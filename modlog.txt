MODAL LOGICCambridge Tracts in Theoretical Computer Science
Editorial Board
S. Abramsky, Computer Laboratory, Oxford University
P. H. Aczel, Department of Computer Science, University of Manchester
J. W. de Bakker, Centrum voor Wiskunde en Informatica, Amsterdam
Y. Gurevich, Microsoft Research
J. V. Tucker, Department of Mathematics and Computer Science, University College of Swansea
Titles in the series
1.
2.
3.
5.
6.
7.
8.
9.
10.
11.
12.
14.
15.
17.
18.
19.
21.
22.
23.
26.
27.
28.
29.
30.
31.
32.
33.
34.
35.
36.
37.
38.
39.
40.
41.
42.
43.
44.
45.
46.
47.
48.
49.
51.
52.
53.
G. Chaitin Algorithmic Information Theory
L. C. Paulson Logic and Computation
M. Spivey Understanding Z
A. Ramsey Formal Methods in ArtiÔ¨Åcial Intelligence
S. Vickers Topology via Logic
J.-Y. Girard, Y. Lafont & P. Taylor Proofs and Types
J. CliÔ¨Äord Formal Semantics & Progmatics for Natural Language Processing
M. Winslett Updating Logical Databases
K. McEvoy & J. V. Tucker (eds) Theoretical Foundations of VLSI Design
T. H. Tse A Unifying Framework for Structured Analysis and Design Models
G. Brewka Nonmonotonic Reasoning
S. G. Hoggar Mathematics for Computer Graphics
S. Dasgupta Design Theory and Computer Science
J. C. M. Baeten (ed) Applications of Process Algebra
J. C. M. Baeten & W. P. Weijland Process Algebra
M. Manzano Extensions of First Order Logic
D. A. Wolfram The Clausal Theory of Types
V. Stoltenberg-Hansen, I. Lindstr√∂m & E. GriÔ¨Äor Mathematical Theory of Domains
E.-R. Olderog Nets, Terms and Formulas
P. D. Mosses Action Semantics
W. H. Hesselink Programs, Recursion and Unbounded Choice
P. Padawitz Deductive and Declarative Programming
P. G√§rdenfors (ed) Belief Revision
M. Anthony & N. Biggs Computational Learning Theory
T. F. Melham Higher Order Logic and Hardware VeriÔ¨Åcation
R. L. Carpenter The Logic of Typed Feature Structures
E. G. Manes Predicate Transformer Semantics
F. Nielson & H. R. Nielson Two Level Functional Languages
L. Feijs & H. Jonkers Formal SpeciÔ¨Åcation and Design
S. Mauw & G. J. Veltink (eds) Algebraic SpeciÔ¨Åcation of Communication Protocols
V. Stavridou Formal Methods in Circuit Design
N. Shankar Metamathematics, Machines and G√∂del‚Äôs Proof
J. B. Paris The Uncertain Reasoner‚Äôs Companion
J. Dessel & J. Esparza Free Choice Petri Nets
J.-J. Ch. Meyer & W. van der Hoek Epistemic Logic for AI and Computer Science
J. R. Hindley Basic Simple Type Theory
A. Troelstra & H. Schwichtenberg Basic Proof Theory
J. Barwise & J. Seligman Information Flow
A. Asperti & S. Guerrini The Optimal Implementation of Functional Programming Languages
R. M. Amadio & P.-L. Curien Domains and Lambda-Calculi
W.-P. de Roever & K. Engelhardt Data ReÔ¨Ånement
H. Kleine B√ºning & T. Lettman Propositional Logic
L. Novak & A. Gibbons Hybrid Graph Theory and Network Analysis
H. Simmons Derivation and Computation
A. S. Troelstra & H. Schwictenberg Basic Proof Theory (Second Edition)
P. Blackburn, M. de Rijke & Y. Venema Modal LogicModal Logic
Patrick Blackburn
LORIA, Nancy
Maarten de Rijke
University of Amsterdam
Yde Venema
University of Amsterdamcambridge university press
Cambridge, New York, Melbourne, Madrid, Cape Town,
Singapore, S√£o Paulo, Delhi, Tokyo, Mexico City
Cambridge University Press
The Edinburgh Building, Cambridge CB2 8RU, UK
Published in the United States of America by
Cambridge University Press, New York
www.cambridge.org
Information on this title: www.cambridge.org/9780521527149
¬© Cambridge University Press 2001
This publication is in copyright. Subject to statutory exception
and to the provisions of relevant collective licensing agreements,
no reproduction of any part may take place without the written
permission of Cambridge University Press.
First published 2001
First paperback edition 2002
Fourth printing with corrections 2010
A catalogue record for this publication is available from the British Library
Library of Congress Cataloguing in Publication data
Blackburn, Patrick, 1959-
Modal logic / Patrick Blackburn, Maarten de Rijke, Yde Venema.
p. cm.
Includes bibliographical references and index.
ISBN 0 521 80200 8
1. Modality (Logic). I. Rijke, Maarten de. II. Venema, Yde, 1963- III. Title.
QA9.46.B58 2001
511.3 21-dc21 00-054667
isbn 978-0-521-80200-0 Hardback
isbn 978-0-521-52714-9 Paperback
Cambridge University Press has no responsibility for the persistence or
accuracy of URLs for external or third-party internet websites referred to in
this publication, and does not guarantee that any content on such websites is,
or will remain, accurate or appropriate. Information regarding prices, travel
timetables, and other factual information given in this work is correct at
the time of first printing but Cambridge University Press does not guarantee
the accuracy of such information thereafter.For JohanContents
Preface
1
1.1
1.2
1.3
1.4
1.5
1.6
1.7
1.8
page xi
1
2
9
16
28
31
33
37
48
Basic Concepts
Relational Structures
Modal Languages
Models and Frames
General Frames
Modal Consequence Relations
Normal Modal Logics
Historical Overview
Summary of Chapter 1
2
Models
2.1 Invariance Results
2.2 Bisimulations
2.3 Finite Models
2.4 The Standard Translation
2.5 Modal Saturation via UltraÔ¨Ålter Extensions
2.6 Characterization and DeÔ¨Ånability
2.7 Simulation and Safety
2.8 Summary of Chapter 2
Notes50
51
64
73
83
91
100
110
117
118
3
3.1
3.2
3.3
3.4
3.5
3.6
3.7123
124
130
138
143
148
156
167
Frames
Frame DeÔ¨Ånability
Frame DeÔ¨Ånability and Second-Order Logic
DeÔ¨Ånable and UndeÔ¨Ånable Properties
Finite Frames
Automatic First-Order Correspondence
Sahlqvist Formulas
More about Sahlqvist Formulas
viiContents
viii
3.8 Advanced Frame Theory
3.9 Summary of Chapter 3
Notes178
183
185
4
Completeness
4.1 Preliminaries
4.2 Canonical Models
4.3 Applications
4.4 Limitative Results
4.5 Transforming the Canonical Model
4.6 Step by Step
4.7 Rules for the UndeÔ¨Ånable
4.8 Finitary Methods I
4.9 Finitary Methods II
4.10 Summary of Chapter 4
Notes188
189
196
201
211
217
223
229
239
247
256
258
5
Algebras and General Frames
5.1 Logic as Algebra
5.2 Algebraizing Modal Logic
5.3 The J√≥nsson-Tarski Theorem
5.4 Duality Theory
5.5 General Frames
5.6 Persistence
5.7 Summary of Chapter 5
Notes261
262
275
283
294
303
318
326
327
6
Computability and Complexity
6.1 Computing SatisÔ¨Åability
6.2 Decidability via Finite Models
6.3 Decidability via Interpretations
6.4 Decidability via Quasi-models and Mosaics
6.5 Undecidability via Tiling
6.6 NP
6.7 PSPACE
6.8 EXPTIME
6.9 Summary of Chapter 6
Notes332
333
338
347
356
364
373
381
393
406
407
7
7.1
7.2
7.3
7.4413
414
426
434
446
Extended Modal Logic
Logical Modalities
Since and Until
Hybrid Logic
The Guarded FragmentContentsix
7.5 Multi-Dimensional Modal Logic
7.6 A Lindstr√∂m Theorem for Modal Logic
7.7 Summary of Chapter 7
Notes458
470
476
477
Appendix AA Logical Toolkit485
Appendix BAn Algebraic Toolkit497
Appendix CA Computational Toolkit504
Appendix DA Guide to the Literature516
Bibliography
List of Notation524
544
Index547Preface
Ask three modal logicians what modal logic is, and you are likely to get at least
three different answers. The authors of this book are no exception, so we will not
try to start off with a neat deÔ¨Ånition. Nonetheless, a number of general ideas guide
our thinking about the subject, and we will present the most important right away
as a series of three slogans. These are meant to be read now, and, perhaps more
importantly, referred back to occasionally; doing so will help you obtain a Ô¨Årm
grasp of the ideas and intuitions that have shaped this book. Following the slogans
we will discuss the aims and content of the book in more detail.
Our Ô¨Årst slogan is the simplest and most fundamental. It sets the basic theme on
which the others elaborate:
Slogan 1: Modal languages are simple yet expressive languages for talk-
ing about relational structures.
In this book we will be examining various propositional modal languages: that is,
the familiar language of propositional logic augmented by a collection of modal
operators. Like the familiar boolean connectives (¬¨, ‚àß, ‚à®, ‚Üí, ‚ä•, and ), modal
operators do not bind variables. Thus, as far as syntax is concerned, we will be
working with the simplest non-trivial languages imaginable.
But in spite of their simplicity, propositional modal languages turn out to be an
excellent way of talking about relational structures, and this book is essentially an
attempt to map out some of the ramiÔ¨Åcations of this. For a start, it goes a long
way towards explaining the recent popularity of modal languages in applied logic.
Moreover, it introduces one of the fundamental themes in the mathematical study
of modal logic: the use of relational structures (that is, relational semantics, or
Kripke semantics) to explicate the logical structure of modal systems.
A relational structure is simply a set together with a collection of relations on
that set. Given the broad nature of this deÔ¨Ånition, it is unsurprising that relational
structures are to be found just about everywhere. Virtually all familiar mathe-
xixii
Preface
matical structures can be thought of as relational structures. Moreover, the enti-
ties commonly used to model the phenomena of interest in various applications
often turn out to be relational structures. For example, theoretical computer sci-
entists use labeled transition systems to model program execution, but a labeled
transition system is just a set (the states) together with a collection of binary re-
lations (the transition relations) that model the behavior of programs. Moreover,
relational structures play a fundamental modeling role in many other disciplines,
including knowledge representation, computational linguistics, formal semantics,
economics, and philosophy. As modal languages are the simplest languages in
which relational structures can be described, constrained, and reasoned about, it is
hardly surprising that applied modal logic has blossomed in recent years.
But relational structures have also played a fundamental role in the development
of the mathematics of modal logic: their use turned modal logic from a rather
esoteric branch of syntax manipulation into a concrete and intuitively compelling
Ô¨Åeld. In fact, it is difÔ¨Åcult to overstate the importance of relational models to modal
logic: their discovery in the 1950s and early 1960s was the biggest single impetus
to the development of the Ô¨Åeld. An early application was completeness theory, the
classiÔ¨Åcation of modal logics in relational terms. More recently, relational seman-
tics has played an important role in mapping out the computational complexity of
modal systems.
Modal languages may be simple ‚Äì but what makes them special? Our next slogan
tries to pin this down:
Slogan 2: Modal languages provide an internal, local perspective on rela-
tional structures.
That is, modal languages talk about relational structures in a special way: ‚Äòfrom
the inside‚Äô and ‚Äòlocally.‚Äô Rather than standing outside a relational structure and
scanning the information it contains from some celestial vantage point, modal for-
mulas are evaluated inside structures, at a particular state. The function of the
modal operators is to permit the information stored at other states to be scanned
‚Äì but, crucially, only the states accessible from the current point via an appropri-
ate transition may be accessed in this way. This idea will be made precise in the
following chapter when we deÔ¨Åne the satisfaction deÔ¨Ånition. In the meantime, the
reader who pictures a modal formula as a little automaton standing at some state in
a relational structure, and only permitted to explore the structure by making jour-
neys to neighboring states, will have grasped one of the key intuitions of modal
model theory.
The internal perspective modal languages offer makes them natural for many
applications. For a start, the decidability of many important modal systems stems
from the step-by-step way that modal formulas are evaluated. Moreover, in a num-Preface
xiii
ber of disciplines, simple languages offering an internal perspective on relational
structures have been devised; sometimes these (independently invented) systems
turn out to be variants of well-known modal systems, and can be analyzed using
modal techniques. For example, Kasper-Rounds logic (used in computational lin-
guistics) is essentially a natural notation for a certain fragment of propositional
dynamic logic with intersection, and many of the description logics used in knowl-
edge representation can be usefully viewed as (fragments of) modal languages.
Finally, it is also the stepwise way in which modal formulas are evaluated which
explains why the notion of bisimulation, a crucial tool in the process theoretic study
of labeled transition systems, unlocks the door to important characterizations of
modal expressivity.
So far there have been only two characters in this discussion: modal languages and
the structures which interpret them. Now it is certainly true that for much of its
history modal logic was studied in isolation, but the true richness of the subject
only becomes apparent when one adopts a broader perspective. Accordingly, the
reader should bear in mind that:
Slogan 3: Modal languages are not isolated formal systems.
One of the key lessons to have emerged since about 1970 is that it is fruitful to
systematically explore the way modal logic is related to other branches of math-
ematical logic. In the pair MODAL LANGUAGES, RELATIONAL STRUCTURES,
there are two obvious variations that should be considered: the relationships with
other languages for describing relational structures, and the use of other kinds of
structures for interpreting modal languages.
As regards the Ô¨Årst option, there are many well-known alternative languages
for talking about relational structure: most obviously, Ô¨Årst- or second-order clas-
sical languages. And indeed, every modal language has corresponding classical
languages that describe the same class of structures. But although both modal
and classical languages talk about relational structures, they do so very differently.
Whereas modal languages take an internal perspective, classical languages, with
their quantiÔ¨Åers and variable binding, are the prime example of how to take an
external perspective on relational structures. In spite of this, there is a standard
translation of any modal language into its corresponding classical language. This
translation provides a bridge between the worlds of modal and classical logic, en-
abling techniques and results to be imported and exported. The resultant study is
called correspondence theory, and it is a cornerstone of modern modal logic.
In the most important example of the second variation, modal logic is linked
up with universal algebra via the apparatus of duality theory. In this framework,
modal formulas are viewed as algebraic terms which have a natural algebraic se-
mantics in terms of boolean algebras with operators, and, from this perspective,xiv
Preface
modal logic is essentially the study of certain varieties of equational logic. Now,
even in isolation, this algebraic perspective is of interest ‚Äì but what makes it a
truly formidable tool is the way it interacts with the perspective provided by re-
lational structures. Roughly speaking, relational structures can be constructed out
of algebras, and algebras can be constructed out of relational structures, and both
constructions preserve essential logical properties. The key technical result that
underlies this duality is the J√≥nsson-Tarski Theorem, a Stone-like representation
theorem for boolean algebras with operators. This opens the door to the world of
universal algebra and, as we will see, the powerful techniques to be found there
lend themselves readily to the analysis of modal logic.
Slogan 3 is fundamental to the way the material in this book is developed: modal
logic will be systematically linked to the wider logical world by both correspon-
dence and duality theory. We do not view modal logic as a ‚Äònon-classical logic‚Äô
that studies ‚Äòintensional phenomena‚Äô via ‚Äòpossible world semantics.‚Äô This is one
interpretation of the machinery we will discuss ‚Äì but the real beauty of the subject
lies deeper.
Let us try and summarize our discussion. Modal languages are syntactically sim-
ple languages that provide an internal perspective on relational structures. Because
of their simplicity, they are becoming increasingly popular in a number of appli-
cations. Moreover, modal logic is surprisingly mathematically rich. This richness
is due to the intricate interplay between modal languages and the relational struc-
tures that interpret them. At its most straightforward, the relational interpretation
gives us a natural semantic perspective from which to attack problems directly.
But the interplay runs deeper. By adopting the perspective of correspondence the-
ory, modal logic can be regarded as a fragment of Ô¨Årst- or second-order classical
logic. Moreover, by adopting an algebraic perspective, we obtain a different (and
no less classical) perspective: modal logic as equational logic. The fascination of
modal logic ultimately stems from the (still not fully understood) links between
these perspectives.
What this book is about
This book is a course in modal logic, intended for both novices and more experi-
enced readers, that presents modal logic as a powerful and Ô¨Çexible tool for working
with relational structures. It provides a thorough grounding in the basic relational
perspective on modal logic, and applies this perspective to issues in completeness,
computability, and complexity. In addition, it introduces and develops in some
detail the perspectives provided by correspondence theory and algebra.
This much is predictable from our earlier discussion. However, three additional
desiderata have helped shape the book. First, we have attempted to emphasize thePreface
xv
Ô¨Çexibility of modal logic as a tool for working with relational structures. One still
encounters with annoying frequency the view that modal logic amounts to rather
simple-minded uses of two operators 3 and . This view has been out of date at
least since the late 1960s (say, since Hans Kamp‚Äôs expressive completeness result
for since/until logic, to give a signiÔ¨Åcant, if arbitrary, example), and in view of such
developments as propositional dynamic logic and arrow logic it is now hopelessly
anachronistic and unhelpful. We strongly advocate a liberal attitude in this book:
we switch freely between various modal languages and in the Ô¨Ånal chapter we
introduce a variety of further ‚Äòupgrades.‚Äô And as far as we are concerned, it is all
just modal logic.
Second, two pedagogic goals have shaped the writing and selection of material:
we want to explicate a range of proof techniques which we feel are signiÔ¨Åcant and
worth mastering, and, where appropriate, we want to draw attention to some impor-
tant general results. These goals are pursued fairly single mindedly: on occasion,
a single result may be proved by a variety of methods, and every chapter (except
the following one) proves at least one very general and (we hope) very interesting
result. The reader looking for a catalogue of facts about his or her favorite modal
system probably will not Ô¨Ånd it here. But such a reader may well Ô¨Ånd the technique
needed to algebraize it, to analyze its expressive power, to prove a completeness
result, or to establish its decidability or undecidability ‚Äì and may even discover
that the relevant results are a special case of something known.
Finally, contemporary modal logic is profoundly inÔ¨Çuenced by its applications,
particularly in theoretical computer science. Indeed, some of the most interesting
advances in the subject (for example, the development of propositional dynamic
logic, and the investigation of modal logic from a complexity-theoretic standpoint)
were largely due to computer scientists, not modal logicians. Such inÔ¨Çuences must
be acknowledged and incorporated, and we attempt to do so.
What this book is not about
Modal logic is a broad Ô¨Åeld, and inevitably we have had to leave out a lot of in-
teresting material, indeed whole areas of active research. There are two principle
omissions: there is no discussion of Ô¨Årst-order modal systems or of non-Hilbert-
style proof theory and automated reasoning techniques.
The Ô¨Årst omission is relatively easy to justify. First-order modal logic is an en-
terprise quite distinct from the study of propositional systems: its principle concern
is how best to graft together classical logic and propositional modal logic. It is an
interesting Ô¨Åeld, and one in which there is much current activity, but its concerns
lie outside the scope of this book.
The omission of proof theory and automated reasoning techniques calls for a
little more explanation. A considerable proportion of this book is devoted to com-xvi
Preface
pleteness theory and its algebraic ramiÔ¨Åcations; however, as is often the case in
modal logic, the proof systems discussed are basically Hilbert-style axiomatic sys-
tems. There is no discussion of natural deduction, sequent calculi, labeled deduc-
tive systems, resolution, or display calculi. A (rather abstract) tableaux system is
used once, but only as a tool to prove a complexity result. In short, there is little
in this book that a proof theorist would regard as real proof theory, and nothing
on implementation. Why is this? Essentially because modal proof theory and au-
tomated reasoning are still relatively youthful enterprises; they are exciting and
active Ô¨Åelds, but as yet there is little consensus about methods and few general re-
sults. Moreover, these Ô¨Åelds are moving fast; much that is currently regarded as
state of the art is likely to go rapidly out of date. For these reasons we have decided
‚Äì rather reluctantly ‚Äì not to discuss these topics.
In addition to these major areas, there are a host of more local omissions. One
is provability and interpretability logic. While these are fascinating examples of
how modal logical ideas can be applied in mathematics, the principle interest of
these Ô¨Åelds is not modal logic itself (which is simply used as a tool) but the formal
study of arithmetic: a typical introduction to these topics (and several excellent
ones exist, for example Boolos [68, 69], and Smory≈Ñski [416]) is typically about
ten percent modal and ninety percent arithmetical. A second omission is a topic
that is a traditional favorite of modal logicians: the Ô¨Åne structure of the lattice of
normal modal logics in the basic 3 and 2 language; we conÔ¨Åne ourselves in this
book to the relatively easy case of logics extending S4.3. The reader interested in
learning more about this type of work should consult Bull and Segerberg [75] or
Chagrov and Zakharyaschev [88]. Other omissions we regret include: a discussion
of meta-logical properties such as interpolation, a detailed examination of local
versus global consequence, and an introduction to the modal Œº-calculus and model
checking. Restrictions of space and time made their inclusion impossible.
Audience and prerequisites
The book is aimed at people who use or study modal logic, and more generally,
at people working with relational structures. We hope that the book will be of use
to two distinct audiences: a less experienced audience, consisting of students of
logic, computer science, artiÔ¨Åcial intelligence, philosophy, linguistics, and other
Ô¨Åelds where modal logic and relational structures are of importance, and a more
experienced audience consisting of colleagues working in one or more of the above
research areas who would like to learn and apply modal logic in their own area.
To this end, there are two distinct tracks through this book: the basic track (this
consists of selected sections from each chapter, and will be described shortly) and
an advanced track (that is, the entire book).
The book starts at the beginning, and does not presuppose prior acquaintancePreface
xvii
with modal logic; but, even on the basic track, prior acquaintance with Ô¨Årst-order
logic and its semantics is essential. Furthermore, the development is essentially
mathematical and assumes that the reader is comfortable with such things as sets,
functions, relations and so on, and can follow mathematical argumentation, such
as proofs by induction. In addition, although we have tried to make the basic track
material as self-contained as possible, two of the later chapters probably require a
little more background knowledge than this. In particular, a reader who has never
encountered boolean (or some other) algebras before is likely to Ô¨Ånd Chapter 5
hard going, and the reader who has never encountered the concept of computable
and uncomputable problems will Ô¨Ånd Chapter 6 demanding. That said, only a
relatively modest background knowledge in these areas is required to follow the
basic track material; certainly the main thrust of the development should be clear.
The requisite background material in logic, algebra and computability can be found
in Appendices A, B, and C.
Needless to say, we have also tried to make the advanced track material as read-
able and understandable as possible. However, largely because of the different
kinds of background knowledge required in different places, advanced track read-
ers may sometimes need to supplement this book with a background reading in
model theory, universal algebra or computational complexity. Again, the required
material is sketched in the appendices.
Contents
The chapter-by-chapter breakdown of the material is as follows.
Chapter 1. Basic Concepts. This chapter introduces a number of key modal lan-
guages (namely the basic modal language, modal languages of arbitrary similarity
type, the basic temporal language, the language of propositional dynamic logic,
and arrow languages), and shows how they are interpreted on various kinds of re-
lational structures (namely models, frames and general frames). It also establishes
notation, discusses some basic concepts such as satisfaction, validity, logical con-
sequence and normal modal logics, and places them in historical perspective. The
entire chapter is essentially introductory; all sections lie on the basic track.
Chapter 2. Models. This chapter examines modal languages as tools for talking
about models. In the Ô¨Årst Ô¨Åve sections we prove some basic invariance results,
introduce bisimulations, discuss the use of Ô¨Ånite models, and, by describing the
standard translation, initiate the study of correspondence theory. All Ô¨Åve sections
are fundamental to later developments ‚Äì indeed the sections on bisimulations and
the standard translation are among the most important in the entire book ‚Äì and to-
gether they constitute the basic track selection. The remaining two sections are on
the advanced track. They probe the expressive power of modal languages usingxviii
Preface
ultraÔ¨Ålter extensions, ultraproducts, and saturated models; establish the fundamen-
tal role of bisimulations in correspondence theory; and introduce the concepts of
simulation and safety.
Chapter 3. Frames. This chapter examines modal languages as tools for talk-
ing about frames; all sections, save the very last, lie on the basic track. The Ô¨Årst
three sections develop the basic theory of frame correspondence: we give exam-
ples of frame deÔ¨Ånability, show that relatively simple modal formulas can deÔ¨Åne
frame conditions beyond the reach of any Ô¨Årst-order formula (and explain why
this happens), and introduce the concepts needed to state the celebrated Goldblatt-
Thomason Theorem. After a short fourth section which discusses Ô¨Ånite frames, we
embark on the study of the Sahlqvist fragment. This is a large class of formulas,
each of which corresponds to a Ô¨Årst-order frame condition, and we devote three
sections to it. In the Ô¨Ånal (advanced) section we introduce some further frame
constructions and prove the Goldblatt-Thomason Theorem model theoretically.
Chapter 4. Completeness. This chapter has two parts; all sections, save the very
last, lie on the basic track. The Ô¨Årst part, consisting of the Ô¨Årst four sections, is an
introduction to basic completeness theory (including canonical models, complete-
ness-via-canonicity proofs, canonicity failure, and incompleteness). The second
part is a survey of methods that can be used to show completeness when canonic-
ity fails. We discuss transformation methods, the step-by-step technique, the use
of rules for the undeÔ¨Ånable, and devote the Ô¨Ånal two sections to a discussion of
Ô¨Ånitary methods. The Ô¨Årst of these sections proves the completeness of Proposi-
tional Dynamic Logic (PDL). The second (the only section on the advanced track)
examines extensions of S4.3, proving (among other things) Bull‚Äôs Theorem.
Chapter 5. Algebras and General Frames. The Ô¨Årst three sections lie on the basic
track: we discuss the role of algebra in logic, show how algebraic ideas can be
applied to modal logic via boolean algebras with operators, and then prove the
fundamental J√≥nsson-Tarski Theorem. With the basics thus laid we turn to duality
theory, which soon leads us to an algebraic proof of the Goldblatt-Thomason The-
orem (which was proved model theoretically in Chapter 3). In the two remaining
sections (which lie on the advanced track) we discuss general frames from an al-
gebraic perspective, introduce the concept of persistence (a generalization of the
idea of canonicity) and use it to prove the Sahlqvist Completeness Theorem, the
completeness-theoretic twin of the correspondence result proved in Chapter 3.
Chapter 6. Computability and Complexity. This chapter has two main parts. The
Ô¨Årst, comprising the Ô¨Årst Ô¨Åve sections, is an introduction to decidability and un-
decidability in modal logic. We introduce the basic ideas involved in computing
modal satisÔ¨Åability and validity problems, and then discuss three ways of proving
decidability results: the use of Ô¨Ånite models, the method of interpretations, andPreface
xix
the use of quasi-models and mosaics. The Ô¨Åfth section gives two simple exam-
ples which illustrate how easily undecidable ‚Äì and indeed, highly undecidable ‚Äì
modal logics can arise. All of the Ô¨Årst part lies on the basic track. The remaining
three sections examine modal logic from the perspective of computational com-
plexity. In particular, the modal relevance of three central complexity classes (NP,
PSPACE, and EXPTIME) is discussed in some detail. We pay particular attention
to PSPACE, proving Ladner‚Äôs general PSPACE-hardness result in detail. These
sections lie on the advanced track, but this is partly because computational com-
plexity is likely to be a new subject for some readers. The material is elegant and
interesting, and we have tried to make these sections as self-contained and acces-
sible as possible.
Chapter 7. Extended Modal Logic. This chapter has a quite different Ô¨Çavor from
the others: it is essentially the party at the end of the book in which we talk about
some of our favorite examples of extended modal systems. We will not offer any
advice about what to read here ‚Äì simply pick and choose and enjoy. The topics
covered are: boosting the expressive power of modal languages with the aid of log-
ical modalities, completeness-via-completeness proofs in since/until logic, naming
states with the help of hybrid logics, and performing evaluation at sequences of
states in multi-dimensional modal logic. We also show how to export modal ideas
back to Ô¨Årst-order logic by deÔ¨Åning the guarded fragment, and conclude by proving
a Lindstr√∂m Theorem for modal logic.
Nearly all sections end with exercises. Each chapter starts with a chapter guide out-
lining the main themes of the sections that follow. Moreover, each chapter Ô¨Ånishes
with a summary, and ‚Äì except the Ô¨Årst ‚Äì with a section entitled Notes. These give
references for results discussed in the text. (In general we do not attribute results
in the text, though where a name has become Ô¨Årmly attached ‚Äì for example, Bull‚Äôs
Theorem or Lindenbaum‚Äôs Lemma ‚Äì we use it.) The Notes also give pointers to
relevant work not covered in the text. The Ô¨Ånal section of Chapter 1 sketches the
history of modal logic, and Appendix D gives a brief guide to textbooks, survey
articles, and other material on modal logic.
Teaching the book
The book can be used as the basis for a number of different courses. Here are some
suggestions.
Modal Logic and Relational Structures. (1 Semester, 2 hours a week)
All of Chapter 1, all the basic track sections in Chapter 2, and all the basic track
sections in Chapter 3. This course introduces modal logic from a semantically ori-
ented perspective. It is not particularly technical (in fact, only Section 2.5 is likely
to cause any difÔ¨Åculties), and the student will come away with an appreciation ofxx
Preface
what modal languages are and the kind of expressivity they offer. It is deliberately
one-sided ‚Äì it is intended as an antidote to traditional introductions.
An Introduction to Modal Logic. (1 Semester, 4 hours a week)
All of Chapter 1, all the basic track material in Chapter 2, the Ô¨Årst six or seven
sections of Chapter 3, the Ô¨Årst six or seven sections of Chapter 4, and the Ô¨Årst four
sections of Chapter 6. In essence, this course adds to the previous one the contents
of a traditional introduction to modal logic (namely completeness-via-canonical
models, and decidability-via-Ô¨Åltrations) and includes extra material on decidability
which we believe should become traditional. This course gives a useful and fairly
balanced picture of many aspects of modern modal logic.
Modal Logic for Computer Scientists. (1 Semester, 4 hours a week)
All of Chapter 1, the Ô¨Årst four sections of Chapter 2, the Ô¨Årst four sections of
Chapter 3, the Ô¨Årst four sections of Chapter 4 plus Section 4.8 (completeness of
PDL), all of Chapter 6, and a selection of topics from Chapter 7. In our opinion,
this course is more valuable than the previous one, and in spite of its title it is not
just for computer science students. This course teaches basic notions of modal
expressivity (bisimulation, the standard translation, and frame deÔ¨Ånability), key
ideas on completeness (including incompleteness), covers both computability and
complexity, and will give the student an impression of the wide variety of options
available in modern modal logic. It comes close to our ideal of what a modern,
well-rounded introduction to modal logic should look like.
Mathematical Aspects of Modal Logic. (1 Semester, 4 hours a week)
Chapters 1, 2, and 3, the Ô¨Årst four sections of Chapter 4, and all of Chapter 5. If
you are teaching logicians, this is probably the course to offer. It is a demanding
course, and requires background knowledge in both model theory and algebra, but
we think that students with this background will like the way the story unfolds.
Modal Logic. (2 Semesters, 4 hours a week)
But of course, there is another option: teach the whole book. Given enough back-
ground knowledge and commitment, this is do-able in 2 semesters. Though we
should confess right away that the course‚Äôs title is highly misleading: once you
get to the end of the book, you will discover that far from having learned every-
thing about modal logic, you have merely arrived at the beginning of an unending
journey.
Hopefully these suggestions will spark further ideas. There is a lot of material
here, and by mixing and matching, perhaps combined with judicious use of other
sources (see Appendix D, the Guide to the Literature, for some suggestions), the
instructor should be able to tailor courses for most needs. The dependency diagram
(see Figure 1) will help your planning.Preface
xxi
1
2.1‚Äì2.5
3.7
2.6
2.7
3.1‚Äì3.6
3.8
4.1‚Äì4.8
5.6
5.5
5.1‚Äì5.4
4.9
6.1‚Äì6.5
6.6
6.7
6.8
7.1‚Äì7.6
Fig. 1. Dependency Diagram
Electronic support
We have set up a home page for this book, where we welcome feedback, and where
we will make selected solutions to the exercises and teaching materials available,
as well as any corrections that may need to be made. The URL is
http://www.mlbook.org
Acknowledgments
We want to thank the following colleagues for their helpful comments and useful
suggestions: Carlos Areces, Johan van Benthem, Giacomo Bonanno, Henry Chi-
naski, Jan van Eijck, Joeri Engelfriet, Paul Gochet, Rob Goldblatt, Val Goranko,
Ramon Jansana, Theo Janssen, Tim Klinger, Johan W. Kl√ºwer, Alexander Kurz,
Holger Schlingloff, Moshe Vardi, and Rineke Verbrugge. Special thanks are due to
Maarten Marx who worked through earlier incarnations of Chapter 6 in great detail;
his comments transformed the chapter. We are grateful for the detailed comments
Ian Hodkinson made on a later version of this chapter. We are extremely grateful
to Costas Koutras for his extensive comments based on his experience of teaching
the book.
We had the good fortune of being able to try out (parts of) the material on stu-
dents in Amsterdam, Barcelona, Braga, Budapest, Cape Town, Chiba, Chia-Yi,
Johannesburg, Lisbon, Saarbr√ºcken, Utrecht and Warwick. We want to thank all
our students, and in particular Maarten Stol, and the students of the University of
Amsterdam classes on modal logic of the years 1999‚Äì2001.xxii
Preface
We would like to thank our editor, David Tranah, for his support and advice, and
the anonymous referees for their valuable feedback. We are also extremely grateful
to our copy editor, who displayed amazing attention to detail in what (as we have
discovered) is a very difÔ¨Åcult task indeed.
We began the book when we were employed by the Netherlands Organization
for ScientiÔ¨Åc Research (NWO), project 102/62-356 ‚ÄòStructural and Semantic Par-
allels in Natural Languages and Programming Languages.‚Äô We are grateful for
the Ô¨Ånancial support by NWO. During the later stages of the writing we received
support from a variety of sources, for which we are extremely grateful. Patrick
Blackburn was based at the Department of Computational Linguistics at the Uni-
versity of Saarland. Maarten de Rijke was supported by the Spinoza project ‚ÄòLogic
in Action‚Äô at ILLC, the University of Amsterdam, and by NWO under project
numbers 612-13-001, 365-20-005, 612.069.006, 612.000.106, 612.000.207, and
612.066.302. And Yde Venema was supported by a fellowship of the Royal Nether-
lands Academy of Arts and Sciences, and later, also by the Spinoza project ‚ÄòLogic
in Action.‚Äô We also want to thank the Department of Mathematics and Computer
Science of the Free University in Amsterdam for the facilities they provided.
Concerning the second paperback printing
We made small corrections throughout the book, and more extensive changes to
Example 3.57 and Section 6.4, but the page numbering is essentially unaltered.
We are grateful to everyone who pointed out typos and errors in the Ô¨Årst print-
ing: Loredana Afanasiev, Fokko van de Bult, Seth Cable, Henry Chinaski, Rajeev
Gor√©, Helle Hansen, Philip H√∂lzenspies, Tanja H√∂tte, Dick de Jongh, Suvi Kar-
vonen, Clemens Kupke, Thomas M√ºller, Joshua Sacks, Thomas Schneider, Jerry
Seligman, Dmitry Shkatov, and Zhou Chunlai. Special thanks are due to Bernhard
Heinemann who went through the book very carefully and sent us long lists of ty-
pos.
Patrick Blackburn
Maarten de Rijke
Yde Venema1
Basic Concepts
Languages of propositional modal logic are propositional languages to which sen-
tential operators (usually called modalities or modal operators) have been added.
In spite of their syntactic simplicity, such languages turn out to be useful tools for
describing and reasoning about relational structures. A relational structure is a
non-empty set on which a number of relations have been deÔ¨Åned; they are wide-
spread in mathematics, computer science, artiÔ¨Åcial intelligence and linguistics, and
are also used to interpret Ô¨Årst-order languages.
Now, when working with relational structures we are often interested in struc-
tures possessing certain properties. Perhaps a certain transitive binary relation is
particularly important. Or perhaps we are interested in applications where ‚Äòdead
ends,‚Äô ‚Äòloops,‚Äô and ‚Äòforkings‚Äô are crucial, or where each relation is a partial func-
tion. Wherever our interests lie, modal languages can be useful, for modal oper-
ators are essentially a simple way of accessing the information contained in rela-
tional structures. As we will see, the local and internal access method that modali-
ties offer is strong enough to describe, constrain, and reason about many interesting
and important aspects of relational structures.
Much of this book is essentially an exploration and elaboration of these remarks.
The present chapter introduces the concepts and terminology we will need, and the
concluding section places them in historical context.
Chapter guide
Section 1.1: Relational Structures. Relational structures are deÔ¨Åned, and a num-
ber of examples are given.
Section 1.2: Modal Languages. We deÔ¨Åne the basic modal language and some of
its extensions.
Section 1.3: Models and Frames. Here we link modal languages and relational
structures. In fact, we introduce two levels at which modal languages can
be used to talk about structures: the level of models (which we explore
12
1 Basic Concepts
in Chapter 2) and the level of frames (which is examined in Chapter 3).
This section contains the fundamental satisfaction deÔ¨Ånition, and deÔ¨Ånes
the key logical notion of validity.
Section 1.4: General Frames. In this section we link modal languages and rela-
tional structures in yet another way: via general frames. Roughly speak-
ing, general frames provide a third level at which modal languages can be
used to talk about relational structures, a level intermediate between those
provided by models and frames. We will make heavy use of general frames
in Chapter 5.
Section 1.5: Modal Consequence Relations. Which conclusions do we wish to
draw from a given set of modal premises? That is, which consequence
relations are appropriate for modal languages? We opt for a local conse-
quence relation, though we note that there is a global alternative.
Section 1.6: Normal Modal Logics. Both validity and local consequence are de-
Ô¨Åned semantically (that is, in terms of relational structures). However, we
want to be able to generate validities and draw conclusions syntactically.
We take our Ô¨Årst steps in modal proof theory and introduce Hilbert-style
axiom systems for modal reasoning. This motivates a concept of central
importance in Chapters 4 and 5: normal modal logics.
Section 1.7: Historical Overview. The ideas introduced in this chapter have a long
and interesting history. Some knowledge of this will make it easier to
understand developments in subsequent chapters, so we conclude with a
historical overview that highlights a number of key themes.
1.1 Relational Structures
DeÔ¨Ånition 1.1 A relational structure is a tuple F whose Ô¨Årst component is a non-
empty set W called the universe (or domain) of F, and whose remaining compo-
nents are relations on W . We assume that every relational structure contains at
least one relation. The elements of W have a variety of names in this book, includ-
ing: points, states, nodes, worlds, times, instants and situations.
An attractive feature of relational structures is that we can often display them as
simple pictures, as the following examples show.
Example 1.2 Strict partial orders (SPOs) are an important type of relational struc-
ture. A strict partial order is a pair (W, R) such that R is irreÔ¨Çexive (‚àÄx ¬¨Rxx) and
transitive (‚àÄxyz (Rxy‚àßRyz ‚Üí Rxz)). A strict partial order R is a linear order (or
a total order) if it also satisÔ¨Åes the trichotomy condition: ‚àÄxy (Rxy‚à®x = y‚à®Ryx).
An example of an SPO is given in Figure 1.1, where W = {1, 2, 3, 4, 6, 8, 12, 24}
and Rxy means ‚Äòx and y are different, and y can be divided by x.‚Äô Obviously this is1.1 Relational Structures
3
24
@
@ 12
8
@
@
@ 6
4@
@
@
@3
2@
@
@
1
Fig. 1.1. A strict partial order
not a linear order. On the other hand, if we deÔ¨Åne Rxy by ‚Äòx is numerically smaller
than y,‚Äô we obtain a linear order over the same universe W . Important examples of
linear orders are (N, <), (Z, <), (Q, <) and (R, <), the natural numbers, integers,
rationals and reals in their usual order. We sometimes use the notation (œâ, <) for
(N, <).
In many applications we want to work not with strict partial orders, but with
plain old partial orders (POs). We can think of a partial order as the reÔ¨Çexive
closure of a strict partial order; that is, if R is a strict partial order on W , then
R ‚à™ {(u, u) | u ‚àà W } is a partial order (for more on reÔ¨Çexive closures, see Exer-
cise 1.1.3). Thus partial orders are transitive, reÔ¨Çexive (‚àÄx Rxx) and antisymmetric
(‚àÄxy (Rxy ‚àß Ryx ‚Üí x = y)). If a partial order is connected (‚àÄxy (Rxy ‚à® Ryx))
it is called a reÔ¨Çexive linear order (or a reÔ¨Çexive total order).
If we interpret the relation in Figure 1.1 reÔ¨Çexively (that is, if we take Rxy to
mean ‚Äòx and y are equal, or y can be divided by x‚Äô) we have a simple example of
a partial order. Obviously, it is not a reÔ¨Çexive linear order. Important examples of
reÔ¨Çexive linear orders include (N, ‚â§) (or (œâ, ‚â§)), (Z, ‚â§), (Q, ‚â§) and (R, ‚â§), the
natural numbers, integers, rationals and reals under their respective ‚Äòless-than-or-
equal-to‚Äô orderings.
Example 1.3 Labeled Transition Systems (LTSs), or more simply, transition sys-
tems, are a simple kind of relational structure widely used in computer science. An
LTS is a pair (W, {Ra | a ‚àà A}) where W is a non-empty set of states, A is a non-
empty set (of labels), and for each a ‚àà A, Ra ‚äÜ W √ó W . Transition systems can
be viewed as an abstract model of computation: the states are the possible states
of a computer, the labels stand for programs, and (u, v) ‚àà Ra means that there is
an execution of the program a that starts in state u and terminates in state v. It is
natural to depict states as nodes and transitions Ra as directed arrows.
In Figure 1.2 a transition system with states w1 , w2 , w3 , w4 and labels a, b, c is
shown. Formally, Ra = {(w1 , w2 ), (w4 , w4 )}, while Rb = {(w2 , w3 )} and Rc =
{(w4 , w3 )}. This transition system is actually rather special, for it is deterministic:
if we are in a state where it is possible to make one of the three possible kinds of1 Basic Concepts
4
s
w1
a
w3
s
I
@
6
b @ c
@
4
@ws
-s
a
w2

Fig. 1.2. A deterministic transition system
transition (for example, an a transition) then it is Ô¨Åxed which state that transition
will take us to. In short, the relations Ra , Rb and Rc are all partial functions.
Deterministic transition systems are important, but in theoretical computer sci-
ence it is more usual to take non-deterministic transition systems as the basic model
of computation. A non-deterministic transition system is one in which the state we
reach by making a particular kind of transition from a given state need not be Ô¨Åxed.
That is, the transition relations do not have to be partial functions, but can be arbi-
trary relations.
s
w1
a
w3
s
I
@
6
b @ c
@
w4
- s a @ s
a
w2

Fig. 1.3. A non-deterministic transition system
In Figure 1.3 a non-deterministic transition system is shown: a is now a non-
deterministic program, for if we execute it in state w4 there are two possibilities:
either we loop back into w4 , or we move to w2 .
Transition systems play an important role in this book. This is not so much be-
cause of their computational interpretation (though that is interesting) but because
of their sheer ubiquity. Sets equipped with collections of binary relations are one
of the simplest types of mathematical structures imaginable, and they crop up just
about everywhere.
Example 1.4 For our next example we turn to the branch of artiÔ¨Åcial intelligence
called knowledge representation. A central concern of knowledge representation
is objects, their properties, their relations to other objects, and the conclusions one
can draw about them. For example, Figure 1.4 represents some of the ways Mike
relates to his surroundings.
One conclusion that can be drawn from this representation is that Sue has chil-
dren. Others are not so clear. For example, does Mike love Sue, and does he1.1 Relational Structures

Sue

son-of 6

BMW

owns


Mike

5

loves
-
Diana


Fig. 1.4. Mike and others
love his BMW? Assuming that absence of a not loves arc (like that connecting
the Mike and the Diana nodes) means that the loves relation holds, this is a safe
conclusion to draw. There are often such ‚Äògaps‚Äô between pictures and relational
structures, and to Ô¨Åll them correctly (that is, to know which relational structure
the picture corresponds to) we have to know which diagrammatic conventions are
being assumed.
Let us take the picture at face value. It gives us a set {BMW, Sue, Mike, Diana}
together with binary relations son-of, owns, and not loves. So we have here
another labeled transition system.
Example 1.5 Finite trees are ubiquitous in linguistics. For example, the tree de-
picted in Figure 1.5 represents some simple facts about phrase-structure, namely
that a sentence (S) can consist of a noun phrase (NP) and a verb phrase (VP); an NP
can consist of a proper noun (PN); and VPs can consist of a transitive verb (TV)
and an NP.
S
NP s
s
PN
s
@
@s VP
@
@s
s
TV
NP
s PN
Fig. 1.5. A Ô¨Ånite decorated tree
Trees play an important role in this book, so we will take this opportunity to deÔ¨Åne
them. We Ô¨Årst introduce the following important concepts.
DeÔ¨Ånition 1.6 Let W be a non-empty set and R a binary relation on W . Then R+ ,
the transitive closure of R, is the smallest transitive relation on W that contains R.
That is,

R+ = {R | R is a transitive binary relation on W & R ‚äÜ R }.
Furthermore, R‚àó , the reÔ¨Çexive transitive closure of R, is the smallest reÔ¨Çexive and
transitive relation on W containing R. That is,1 Basic Concepts
6
R‚àó =

{R | R is a reÔ¨Çexive transitive binary relation on W & R ‚äÜ R }.
Note that R+ uv holds if and only if there is a sequence of elements u = w0 , w1 ,
. . . , wn = v (n > 0) from W such that for each i < n we have Rwi wi+1 . That
is, R+ uv means that v is reachable from u in a Ô¨Ånite number of R-steps. Thus
transitive closure is a natural and useful notion; see Exercise 1.1.3.
With these concepts at our disposal, it is easy to say what a tree is.
DeÔ¨Ånition 1.7 A tree T is a relational structure (T, S) where:
(i) T , the set of nodes, contains a unique r ‚àà T (called the root) such that
‚àÄt ‚àà T S ‚àó rt.
(ii) Every element of T distinct from r has a unique S-predecessor; that is, for
every t = r there is a unique t ‚àà T such that St t.
(iii) S is acyclic; that is, ‚àÄt¬¨S+ tt. (It follows that S is irreÔ¨Çexive.)
Clearly, Figure 1.5 contains enough information to give us a tree (T, S) in the sense
just deÔ¨Åned: the nodes in T are the displayed points, and the relation S is indicated
by means of a straight line segment drawn from a node to a node immediately
below (that is, S is the obvious successor or daughter-of relation). The root of the
tree is the topmost node (the one labeled S).
But the diagram also illustrates something else: often we need to work with
structures consisting of not only a tree (T, S), but a whole lot else besides. For
example, linguists would not be particularly interested in the bare tree (T, S) just
deÔ¨Åned, rather they would be interested in (at least) the structure
(T, S, LEFT- OF , S, NP, VP, PN, TV).
Here S, NP, VP, PN, and TV are unary relations on T (note that S and S are distinct
symbols). These relations record the information attached to each node, namely the
fact that some nodes are noun phrase nodes, while others are proper name nodes,
sentential nodes, and so on. LEFT- OF is a binary relation which captures the left-
to-right aspect of the above picture; the fact that the NP node is to the left of the
VP node might be linguistically crucial.
Similar things happen in mathematical contexts. Sometimes we will need to
work with relational structures which are much richer than the simple trees (T, S)
just deÔ¨Åned, but which, perhaps in an implicit form, contain a relation with all the
properties required of S. It is useful to have a general term for such structures; we
will call them tree-like. A formal deÔ¨Ånition here would do more harm than good,
but in the text we will indicate, whenever we call a structure tree-like, where this
implicit tree (T, S) can be found. That is, unless it is obvious, we will say which
deÔ¨Ånable relation in the structure satisÔ¨Åes the conditions of DeÔ¨Ånition 1.7. One of1.1 Relational Structures
7
the most important examples of tree-like structures is the Rabin structure, which
we will meet in Section 6.3.
One often encounters the notion of a tree deÔ¨Åned in terms of the (reÔ¨Çexive) tran-
sitive closure of the successor relation. Such trees we call (reÔ¨Çexive and) transitive
trees, and they are dealt with in Exercises 1.1.4 and 1.1.5
Example 1.8 We have already seen that labeled transition systems can be regarded
as a simple model of computation. Indeed, they can be thought of as models for
practically any dynamic notion: each transition takes us from an input state to an
output state. But this treatment of states and transitions is rather unbalanced: it
is clear that transitions are second-class citizens. For example, if we talked about
LTSs using a Ô¨Årst-order language, we could not name transitions using constants
(they would be talked about using relation symbols) but we could have constants
for states. But there is a way to treat transitions as Ô¨Årst-class citizens: we can work
with arrow structures.
The objects of an arrow structure are things that can be pictured as arrows. As
concrete examples, the mathematically inclined reader might think of vectors, or
functions or morphisms in some category; the computer scientist of programs; the
linguist of the context changing potential of a grammatically well-formed piece of
text or discourse; the philosopher of some agent‚Äôs cognitive actions; and so on. But
note well: although arrows are the prime citizens of arrow structures, this does not
mean that they should always be thought of as primitive entities. For example, in
a two-dimensional arrow structure, an arrow a is thought of as a pair (a0 , a1 ) of
which a0 represents the starting point of a, and a1 its endpoint.
Having ‚ÄòdeÔ¨Åned‚Äô the elements of arrow structures to be objects graphically rep-
resentable as arrows, we should now ask: what are the basic relations which hold
between arrows? The most obvious candidate is composition: vector spaces have
an additive structure, functions can be composed, language fragments can be con-
catenated, and so on. So the central relation on arrows will be a ternary composi-
tion relation C, where Cabc says that arrow a is the outcome of composing arrow
b with arrow c (or conversely, that a can be decomposed into b and c). Note that
in many concrete examples, C is actually a (partial) function; for example, in the
two-dimensional framework we have
Cabc iff a0 = b0 , a1 = c1 and b1 = c0 .
(1.1)
What next? Well, in all the examples listed, the composition function has a neutral
element; think of the identity function or the SKIP-program. So, arrow structures
will contain degenerate arrows, transitions that do not lead to a different state.
Formally, this means that arrow structures will contain a designated subset I of
identity arrows; in the pair-representation, I will be (a subset of) the diagonal:
Ia iff a0 = a1 .
(1.2)1 Basic Concepts
8
Another natural relation is converse. In linguistics and cognitive science we might
view this as an ‚Äòundo‚Äô action (perhaps we have made a mistake and need to recover)
and in many Ô¨Åelds of mathematics arrow-like objects have converses (vectors) or
inverses (bijective functions). So we will also give arrow structures a binary re-
verse relation R. Again, in many cases this relation will be a partial function. For
example, in the two-dimensional picture, R is given by
Rab iff a0 = b1 and a1 = b0 .
(1.3)
Although there are further natural candidates for arrow relations (notably some
notion of iteration) we will leave it at this. And now for the formal deÔ¨Ånition: an
arrow frame is a quadruple F = (W, C, R, I) such that C, R and I are a ternary,
a binary and a unary relation on W , respectively. Pictorially, we can think of them
as follows:
#
*

 @


b

a
@c
@
R
@
-
a
i
"
b
Cabc
q
Rab
a
?
Ia
The two-dimensional arrow structure, in which the universe consists of all pairs
over the set U (and the relations C, R and I are given by (1.1), (1.3) and (1.2),
respectively) is called the square over U , notation: SU . The square arrow frame
over U can be pictorially represented as a full graph over U : each arrow object
(a0 , a1 ) in SU can be represented as a ‚Äòreal‚Äô arrow from a0 to a1 ; the relations
are as pictured above. Alternatively, square arrow frames can be represented two-
dimensionally; see the pictures in Example 1.27.
Exercises for Section 1.1
1.1.1 Let (W, R) be a quasi-order; that is, assume that R is transitive and reÔ¨Çexive. DeÔ¨Åne
the binary relation ‚àº on W by putting s ‚àº t iff Rst and Rts.
(a) Show that ‚àº is an equivalence relation.
Let [s] denote the equivalence class of s under this relation, and deÔ¨Åne the following rela-
tion on the collection of equivalence classes: [s] ‚â§ [t] iff Rst.
(b) Show that this is well deÔ¨Åned.
(c) Show that ‚â§ is a partial order.
1.1.2 Let R be a transitive relation on a Ô¨Ånite set W . Prove that R is well-founded iff R is
irreÔ¨Çexive. (R is called well-founded if there are no inÔ¨Ånite paths . . . Rs 2 Rs1 Rs0 .)
1.1.3 Let R be a binary relation on W . In Example 1.2 we deÔ¨Åned the reÔ¨Çexive closure
of R to be R ‚à™ {(u, u) | u ‚àà W }. But we can also give a deÔ¨Ånition analogous to those1.2 Modal Languages
9
of R+ and R‚àó in DeÔ¨Ånition 1.6, namely that it is the smallest reÔ¨Çexive relation on W that
contains R:

Rr = {R | R is a reÔ¨Çexive binary relation on W & R ‚äÜ R  }.
Explain why this new deÔ¨Ånition (and the deÔ¨Ånitions of R + and R‚àó ) are well deÔ¨Åned. Show
the equivalence of the two deÔ¨Ånitions of reÔ¨Çexive closure. Finally, show that R + uv if and
only if there is a sequence of elements u = w 0 , w1 , . . . , wn = v from W such that for each
i < n we have Rwi wi+1 , and give an analogous sequence-based deÔ¨Ånition of reÔ¨Çexive
transitive closure.
1.1.4 A transitive tree is an SPO (T, <) such that (i) there is a root r ‚àà T satisfying r < t
for all t ‚àà T such that r = t, and (ii) for each t ‚àà T , the set {s ‚àà T | s < t} of
predecessors of t is Ô¨Ånite and linearly ordered by <.
(a) Prove that if (T, S) is a tree then (T, S + ) is a transitive tree.
(b) Prove that (T, <) is a transitive tree iff (T, S < ) is a tree, where S< is the immediate
successor relation given by sS < t iff s < t and s < v < t for no v ‚àà T .
(c) Under which conditions does the converse of (a) hold?
1.1.5 DeÔ¨Åne the notion of a reÔ¨Çexive and transitive tree, such that if (T, S) is a tree then
(T, S ‚àó ) is a reÔ¨Çexive and transitive tree.
1.1.6 Show that the following formulas hold on square arrow frames:
(a) ‚àÄxy (Rxy ‚Üí Ryx),
(b) ‚àÄxyz ((Cxyz ‚àß Iz) ‚Üî x = y),
(c) ‚àÄxx1 x2 x3 (‚àÉy (Cxx1 y ‚àß Cyx2 x3 ) ‚Üî ‚àÉz (Cxzx3 ‚àß Czx1 x2 )).
1.2 Modal Languages
It is now time to meet the modal languages we will be working with. First, we
introduce the basic modal language. We then deÔ¨Åne modal languages of arbitrary
similarity type. Finally we examine the following extensions of the basic modal
language in more detail: the basic temporal language, the language of proposi-
tional dynamic logic, and a language of arrow logic.
DeÔ¨Ånition 1.9 The basic modal language is deÔ¨Åned using a set of proposition let-
ters (or proposition symbols or propositional variables) Œ¶ whose elements are usu-
ally denoted p, q, r, and so on, and a unary modal operator 3 (‚Äòdiamond‚Äô). The
well-formed formulas œÜ of the basic modal language are given by the rule
œÜ ::= p | ‚ä• | ¬¨œÜ | œà ‚à® œÜ | 3œÜ,
where p ranges over elements of Œ¶. This deÔ¨Ånition means that a formula is either a
proposition letter, the propositional constant falsum (‚Äòbottom‚Äô), a negated formula,
a disjunction of formulas, or a formula preÔ¨Åxed by a diamond.
Just as the familiar Ô¨Årst-order existential and universal quantiÔ¨Åers are duals to
each other (in the sense that ‚àÄx Œ± ‚Üî ¬¨‚àÉx ¬¨Œ±), we have a dual operator 2 (‚Äòbox‚Äô)10
1 Basic Concepts
for our diamond which is deÔ¨Åned by œÜ := ¬¨3¬¨œÜ. We also make use of the classi-
cal abbreviations for conjunction, implication, bi-implication and the constant true
(‚Äòtop‚Äô): œÜ‚àßœà := ¬¨(¬¨œÜ‚à®¬¨œà), œÜ ‚Üí œà := ¬¨œÜ‚à®œà, œÜ ‚Üî œà := (œÜ ‚Üí œà)‚àß(œà ‚Üí œÜ)
and  := ¬¨ ‚ä•.
Although we generally assume that the set Œ¶ of proposition letters is a countably
inÔ¨Ånite set {p0 , p1 , . . .}, occasionally we need to make other assumptions. For
instance, when we are after decidability results, it may be useful to stipulate that
Œ¶ is Ô¨Ånite, while doing model theory or frame theory we may need uncountably
inÔ¨Ånite languages. This is why we take Œ¶ as an explicit parameter when deÔ¨Åning
the set of modal formulas.
Example 1.10 Three readings of diamond and box have been extremely inÔ¨Çuen-
tial. First, 3œÜ can be read as ‚Äòit is possibly the case that œÜ.‚Äô Under this reading,
œÜ means ‚Äòit is not possible that not œÜ,‚Äô that is, ‚Äònecessarily œÜ,‚Äô and examples
of formulas we would probably regard as correct principles include all instances
of 2œÜ ‚Üí 3œÜ (‚Äòwhatever is necessary is possible‚Äô) and all instances of œÜ ‚Üí 3œÜ
(‚Äòwhatever is, is possible‚Äô). The status of other formulas is harder to decide. Should
œÜ ‚Üí 23œÜ (‚Äòwhatever is, is necessarily possible‚Äô) be regarded as a general truth
about necessity and possibility? Should 3œÜ ‚Üí 23œÜ (‚Äòwhatever is possible, is
necessarily possible‚Äô)? Are any of these formulas linked by a modal notion of log-
ical consequence, or are they independent claims about necessity and possibility?
These are difÔ¨Åcult (and historically important) questions. The relational semantics
deÔ¨Åned in the following section offers a simple and intuitively compelling frame-
work in which to discuss them.
Second, in epistemic logic the basic modal language is used to reason about
knowledge, though instead of writing 2œÜ for ‚Äòthe agent knows that œÜ‚Äô it is usual to
write KœÜ. Given that we are talking about knowledge (as opposed to, say, belief
or rumor), it seems natural to view all instances of KœÜ ‚Üí œÜ as true: if the agent
really knows that œÜ, then œÜ must hold. On the other hand (assuming that the agent
is not omniscient) we would regard œÜ ‚Üí KœÜ as false. But the legitimacy of other
principles is harder to judge (if an agent knows that œÜ, does she know that she
knows it?). Again, a precise semantics brings clarity.
Third, in provability logic 2œÜ is read as ‚Äòit is provable (in some arithmetical
theory) that œÜ.‚Äô A central theme in provability logic is the search for a complete
axiomatization of the provability principles that are valid for various arithmetical
theories (such as Peano Arithmetic). The L√∂b formula 2(2p ‚Üí p) ‚Üí 2p plays a
key role here. The arithmetical ramiÔ¨Åcations of this formula lie outside the scope
of the book, but in Chapters 3 and 4 we will explore its modal content.
That is the basic modal language. Let us now generalize it. There are two obvious
ways to do so. First, there seems no good reason to restrict ourselves to languages1.2 Modal Languages
11
with only one diamond. Second, there seems no good reason to restrict ourselves
to modalities that take only a single formula as argument. Thus the general modal
languages we will now deÔ¨Åne may contain many modalities, of arbitrary arities.
DeÔ¨Ånition 1.11 A modal similarity type is a pair œÑ = (O, œÅ) where O is a non-
empty set, and œÅ is a function O ‚Üí N. The elements of O are called modal oper-
ators; we use  (‚Äòtriangle‚Äô), 0 , 1 , . . . , to denote elements of O. The function œÅ
assigns to each operator  ‚àà O a Ô¨Ånite arity, indicating the number of arguments
 can be applied to.
In line with DeÔ¨Ånition 1.9, we often refer to unary triangles as diamonds, and
denote them by 3a or a, where a is taken from some index set. We often assume
that the arity of operators is known, and do not distinguish between œÑ and O.
DeÔ¨Ånition 1.12 A modal language ML(œÑ, Œ¶) is built up using a modal similarity
type œÑ = (O, œÅ) and a set of proposition letters Œ¶. The set Form(œÑ, Œ¶) of modal
formulas over œÑ and Œ¶ is given by the rule
œÜ ::= p | ‚ä• | ¬¨œÜ | œÜ1 ‚à® œÜ2 | (œÜ1 , . . . , œÜœÅ() ),
where p ranges over elements of Œ¶.
The similarity type of the basic modal language is called œÑ0 . In the sequel we
sometimes state results for modal languages of arbitrary similarity types, give the
proof for similarity types with diamonds only, and leave the general case as an ex-
ercise. For binary modal operators, we often use inÔ¨Åx notation; that is, we usually
write œÜœà instead of (œÜ, œà). One other thing: note that our deÔ¨Ånition permits
nullary modalities (or modal constants), triangles that take no arguments at all.
Such modalities can be useful ‚Äì we will see a natural example when we discuss
arrow logic ‚Äì but they play a relatively minor role in this book. Syntactically (and
indeed, semantically) they are rather like propositional variables; in fact, they are
best thought of as propositional constants.
DeÔ¨Ånition 1.13 We now deÔ¨Åne dual operators for non-nullary triangles. For each
 ‚àà O the dual  of  is deÔ¨Åned as (œÜ1 , . . . , œÜn ) := ¬¨(¬¨œÜ1 , . . . , ¬¨œÜn ). The
dual of a triangle of arity at least 2 is called a nabla. As in the basic modal language,
the dual of a diamond is called a box, and is written 2a or [a].
Three extensions of the basic modal language deserve special attention. Two of
these, the basic temporal language and the language of propositional dynamic logic
will be frequently used in subsequent chapters. The third is a simple language of
arrow logic; it will provide us with a natural example of a binary modality.
Example 1.14 (The Basic Temporal Language) The basic temporal language is
built using a set of unary operators O = {F , P }. The intended interpretation12
1 Basic Concepts
of a formula F œÜ is ‚ÄòœÜ will be true at some Future time,‚Äô and the intended inter-
pretation of P œÜ is ‚ÄòœÜ was true at some Past time.‚Äô This language is called the
basic temporal language, and it is the core language underlying a branch of modal
logic called temporal logic. It is traditional to write F  as F and P  as P , and
their duals are written as G and H, respectively. (The mnemonics here are: ‚Äòit is
always Going to be the case‚Äô and ‚Äòit always Has been the case.‚Äô)
We can express many interesting assertions about time with this language. For
example, P œÜ ‚Üí GP œÜ, says ‚Äòwhatever has happened will always have happened,‚Äô
and this seems a plausible candidate for a general truth about time. On the other
hand, if we insist that F œÜ ‚Üí F F œÜ must always be true, it shows that we are
thinking of time as dense: between any two instants there is always a third. And if
we insist that GF p ‚Üí F Gp (the McKinsey formula) is true, for all propositional
symbols p, we are insisting that atomic information true somewhere in the future
eventually settles down to being always true. (We might think of this as reÔ¨Çecting
a ‚Äòthermodynamic‚Äô view of information distribution.)
One Ô¨Ånal remark: computer scientists will have noticed that the binary until
modality is conspicuous by its absence. As we will see in the following chapter,
the basic temporal language is not strong enough to express until. We examine a
language containing the until operator in Section 7.2.
Example 1.15 (Propositional Dynamic Logic) Another important branch of mo-
dal logic, again involving only unary modalities, is propositional dynamic logic.
PDL, the language of propositional dynamic logic, has an inÔ¨Ånite collection of
diamonds. Each of these diamonds has the form œÄ, where œÄ denotes a (non-
deterministic) program. The intended interpretation of œÄœÜ is ‚Äòsome terminating
execution of œÄ from the present state leads to a state bearing the information œÜ.‚Äô
The dual assertion [œÄ]œÜ states that ‚Äòevery execution of œÄ from the present state leads
to a state bearing the information œÜ.‚Äô
So far, there is nothing really new ‚Äì but a simple idea is going to ensure that
PDL is highly expressive: we will make the inductive structure of the programs
explicit in PDL‚Äôs syntax. Complex programs are built out of basic programs using
some repertoire of program constructors. By using diamonds which reÔ¨Çect this
structure, we obtain a powerful and Ô¨Çexible language.
Let us examine the core language of PDL. Suppose we have Ô¨Åxed some set of
basic programs a, b, c, and so on (thus we have basic modalities a, b, c, . . .
at our disposal). Then we are allowed to deÔ¨Åne complex programs œÄ (and hence,
modal operators œÄ) over this base as follows:
(choice) if œÄ1 and œÄ2 are programs, then so is œÄ1 ‚à™ œÄ2 .
The program œÄ1 ‚à™ œÄ2 (non-deterministically) executes œÄ1 or œÄ2 .1.2 Modal Languages
13
(composition) if œÄ1 and œÄ2 are programs, then so is œÄ1 ; œÄ2 .
This program Ô¨Årst executes œÄ1 and then œÄ2 .
(iteration) if œÄ is a program, then so is œÄ‚àó .
œÄ ‚àó is a program that executes œÄ a Ô¨Ånite (possibly zero) number of times.
For the collection of diamonds this means that if œÄ1  and œÄ2  are modal operators,
then so are œÄ1 ‚à™ œÄ2 , œÄ1 ; œÄ2  and œÄ1‚àó . This notation makes it straightforward to
describe properties of program execution. Here is a fairly straightforward example.
The formula œÄ‚àó œÜ ‚Üî œÜ ‚à® œÄ ; œÄ ‚àó œÜ says that a state bearing the information œÜ can
be reached by executing œÄ a Ô¨Ånite number of times if and only if either we already
have the information œÜ in the current state, or we can execute œÄ once and then Ô¨Ånd
a state bearing the information œÜ after Ô¨Ånitely many more iterations of œÄ. Here is a
far more demanding example:
[œÄ ‚àó ](œÜ ‚Üí [œÄ]œÜ) ‚Üí (œÜ ‚Üí [œÄ ‚àó ]œÜ).
This is Segerberg‚Äôs axiom (or the induction axiom) and the reader should try work-
ing out what exactly it is that this formula says. We discuss this formula further in
Chapter 3; see Example 3.10.
If we conÔ¨Åne ourselves to these three constructors (and in this book for the most
part we do) we are working with a version of PDL called regular PDL. (This is
because the three constructors are the ones used in Kleene‚Äôs well-known analysis of
regular programs.) However, a wide range of other constructors have been studied.
Here are two:
(intersection) if œÄ1 and œÄ2 are programs, then so is œÄ1 ‚à© œÄ2 .
The intended meaning of œÄ1 ‚à© œÄ2 is: execute both œÄ1 and œÄ2 , in parallel.
(test) if œÜ is a formula, then œÜ? is a program.
This program tests whether œÜ holds, and if so, continues; if not, it fails.
To Ô¨Çesh this out a little, the intended reading of œÄ1 ‚à© œÄ2 œÜ is that if we execute
both œÄ1 and œÄ2 in the present state, then there is at least one state reachable by both
programs which bears the information œÜ. This is a natural constructor for a variety
of purposes, and we will make use of it in Section 6.5.
The key point to note about the test constructor is its unusual syntax: it allows us
to make a modality out of a formula. Intuitively, this modality accesses the current
state if the current state satisÔ¨Åes œÜ. On its own such a constructor is uninteresting
(œÜ?œà simply means œÜ ‚àß œà). However, when other constructors are present, it can
be used to build interesting programs. For example, (p? ; a) ‚à™ (¬¨p? ; b) is ‚Äòif p
then a else b.‚Äô
Nothing prevents us from viewing the basic programs as deterministic, and we
will discuss a fragment of deterministic PDL (DPDL) in Section 6.5.14
1 Basic Concepts
Example 1.16 (An Arrow Language) The type œÑ‚Üí of arrow logic is a similarity
type with modal operators other than diamonds. The language of arrow logic is
designed to talk about the objects in arrow structures (entities which can be pictured
as arrows). The well-formed formulas œÜ of the arrow language are given by the rule
œÜ ::= p | ‚ä• | ¬¨œÜ | œÜ ‚à® œà | œÜ ‚ó¶ œà | ‚äóœÜ | 1‚Äô.
That is, 1‚Äô (‚Äòidentity‚Äô) is a nullary modality (a modal constant), the ‚Äòconverse‚Äô oper-
ator ‚äó is a diamond, and the ‚Äòcomposition‚Äô operator ‚ó¶ is a dyadic operator. Possible
readings of these operators are:
1‚Äô
identity
‚Äòskip‚Äô,
‚äóœÜ
converse
‚ÄòœÜ conversely‚Äô,
œÜ ‚ó¶ œà composition ‚ÄòÔ¨Årst œÜ, then œà‚Äô.
Example 1.17 (Feature Logic and Description Logic) As we mentioned in the
Preface, researchers developing formalisms for describing graphs have sometimes
(without intending to) come up with notational variants of modal logic. For ex-
ample, computational linguists use Attribute-Value Matrices (AVMs) for describ-
ing feature structures (directed acyclic graphs that encode linguistic information).
Here is a fairly typical AVM:

 ‚é§
‚é°
PERSON
1st
‚é£ AGREEMENT
‚é¶
NUMBER plural
CASE
dative
.
But this is just a two dimensional notation for the following modal formula:
AGREEMENT (PERSON 1st ‚àß NUMBER plural) ‚àß CASE dative.
Similarly, researchers in artiÔ¨Åcial intelligence needing a notation for describing and
reasoning about ontologies developed description logic. For example, the concept
of ‚Äòbeing a hired killer for the mob‚Äô is true of any individual who is a killer and is
employed by a gangster. In description logic we can deÔ¨Åne this concept as follows:
killer  ‚àÉemployer.gangster.
But this is simply the following modal formula lightly disguised:
killer ‚àß employergangster.
It turns out that the links between modal logic on the one hand, and feature and
description logic on the other, are far more interesting than these rather simple ex-
amples might suggest. A modal perspective on feature or description logic capable
of accounting for other important aspects of these systems (such as the ability to
talk about re-entrancy in feature structures, or to perform ABox reasoning in de-
scription logic) must make use of the kinds of extended modal logics discussed in1.2 Modal Languages
15
Chapter 7 (in particular, logics containing the global modality, and hybrid logics).
Furthermore, some versions of feature and description logic make use of ideas
from PDL, and description logic makes heavy use of counting modalities (which
say such things as ‚Äòat most 3 transitions lead to a œÜ state‚Äô).
Substitution
Throughout this book we will be working with the syntactic notion of one formula
being a substitution instance of another. In order to deÔ¨Åne this notion we Ô¨Årst
introduce the concept of a substitution as a function mapping proposition letters to
formulas.
DeÔ¨Ånition 1.18 Suppose we are working a modal similarity type œÑ and a set Œ¶ of
proposition letters. A substitution is a map œÉ : Œ¶ ‚Üí Form(œÑ, Œ¶).
Now such a substitution œÉ induces a map (¬∑)œÉ : Form(œÑ, Œ¶) ‚Üí Form(œÑ, Œ¶)
which we can recursively deÔ¨Åne as follows:
‚ä•œÉ = ‚ä•,
pœÉ = œÉ(p),
(¬¨œà)œÉ = ¬¨œà œÉ ,
(œà ‚à® Œ∏)œÉ = œà œÉ ‚à® Œ∏ œÉ ,
((œà1 , . . . , œàn ))œÉ = (œà1œÉ , . . . , œànœÉ ).
This deÔ¨Ånition spells out exactly what is meant by carrying out uniform substitu-
tion. Finally, we say that œá is a substitution instance of œà if there is some substitu-
tion œÑ such that œàœÑ = œá.
To give an example, if œÉ is the substitution that maps p to p ‚àß 2q, q to 33q ‚à® r
and leaves all other proposition letters untouched, then we have
(p ‚àß q ‚àß r)œÉ = ((p ‚àß 2q) ‚àß (33q ‚à® r) ‚àß r).
Exercises for Section 1.2
1.2.1 Using KœÜ to mean ‚Äòthe agent knows that œÜ‚Äô and M œÜ to mean ‚Äòit is consistent with
what the agent knows that œÜ,‚Äô represent the following statements:
(a) If œÜ is true, then it is consistent with what the agent knows that she knows that œÜ.
(b) If it is consistent with what the agent knows that œÜ, and it is consistent with what
the agent knows that œà, then it is consistent with what the agent knows that œÜ ‚àß œà.
(c) If the agent knows that œÜ, then it is consistent with what the agent knows that œÜ.
(d) If it is consistent with what the agent knows that it is consistent with what the agent
knows that œÜ, then it is consistent with what the agent knows that œÜ.
Which of these seem plausible principles concerning knowledge and consistency?1 Basic Concepts
16
1.2.2 Suppose 3œÜ is interpreted as ‚ÄòœÜ is permissible‚Äô; how should 2œÜ be understood?
List formulas which seem plausible under this interpretation. Should the L√∂b formula
2(2p ‚Üí p) ‚Üí 2p be on your list? Why?
1.2.3 Explain how the program constructs ‚Äòwhile œÜ do œÄ‚Äô and ‚Äòrepeat œÄ until œÜ‚Äô
can be expressed in PDL.
1.2.4 Consider the following arrow formulas. Do you think they should be always true?
1‚Äô ‚ó¶ p ‚Üî p,
‚äó(p ‚ó¶ q) ‚Üî ‚äóq ‚ó¶ ‚äóp,
p ‚ó¶ (q ‚ó¶ r) ‚Üî (p ‚ó¶ q) ‚ó¶ r.
1.2.5 Show that ‚Äòbeing-a-substitution-instance-of‚Äô is a transitive concept. That is, show
that if œá is a substitution instance of œà, and œà is a substitution instance of œÜ, then œá is a
substitution instance of œÜ.
1.3 Models and Frames
Although our discussion has contained many semantically suggestive phrases such
as ‚Äòtrue‚Äô and ‚Äòintended interpretation,‚Äô as yet we have given them no mathematical
content. The purpose of this (key) section is to put that right. We do so by in-
terpreting our modal languages in relational structures. In fact, by the end of the
section we will have done this in two distinct ways: at the level of models and at
the level of frames. Both levels are important, though in different ways. The level
of models is important because this is where the fundamental notion of satisfaction
(or truth) is deÔ¨Åned. The level of frames is important because it supports the key
logical notion of validity.
Models and satisfaction
We start by deÔ¨Åning frames, models, and the satisfaction relation for the basic
modal language.
DeÔ¨Ånition 1.19 A frame for the basic modal language is a pair F = (W, R) such
that
(i) W is a non-empty set.
(ii) R is a binary relation on W .
That is, a frame for the basic modal language is simply a relational structure bearing
a single binary relation. We remind the reader that we refer to the elements of W
by many different names (see DeÔ¨Ånition 1.1).
A model for the basic modal language is a pair M = (F, V ), where F is a frame
for the basic modal language, and V is a function assigning to each proposition1.3 Models and Frames
17
letter p in Œ¶ a subset V (p) of W . Formally, V is a map: Œ¶ ‚Üí P(W ), where
P(W ) denotes the power set of W . Informally we think of V (p) as the set of
points in our model where p is true. The function V is called a valuation. Given a
model M = (F, V ), we say that M is based on the frame F, or that F is the frame
underlying M.
Note that models for the basic modal language can be viewed as relational struc-
tures in a natural way, namely as structures of the form:
(W, R, V (p), V (q), V (r), . . .).
That is, a model is a relational structure consisting of a domain, a single binary
relation R, and the unary relations given to us by V . Thus, viewed from a purely
structural perspective, a frame F and a model M based on F, are simply two re-
lational models based on the same universe; indeed, a model is simply a frame
enriched by a collection of unary relations.
But in spite of their mathematical kinship, frames and models are used very dif-
ferently. Frames are essentially mathematical pictures of ontologies that we Ô¨Ånd
interesting. For example, we may view time as a collection of points ordered by
a strict partial order, or feel that a correct analysis of knowledge requires that we
postulate the existence of situations linked by a relation of ‚Äòbeing an epistemic
alternative to.‚Äô In short, we use the level of frames to make our fundamental as-
sumptions mathematically precise.
The unary relations provided by valuations, on the other hand, are there to dress
our frames with contingent information. Is it raining on Tuesday or not? Is the
system write-enabled at time t6 ? Is a situation where Janet does not love him an
epistemic alternative for John? Such information is important, and we certainly
need to be able to work with it ‚Äì nonetheless, statements only deserve the de-
scription ‚Äòlogical‚Äô if they are invariant under changes of contingent information.
Because we have drawn a distinction between the fundamental information given
by frames, and the additional descriptive content provided by models, it will be
straightforward to deÔ¨Åne a modally reasonable notion of validity.
But this is jumping ahead. First we must learn how to interpret the basic modal
language in models. This we do by means of the following satisfaction deÔ¨Ånition.
DeÔ¨Ånition 1.20 Suppose w is a state in a model M = (W, R, V ). Then we induc-
tively deÔ¨Åne the notion of a formula œÜ being satisÔ¨Åed (or true) in M at state w as
follows:
M, w  p iff w ‚àà V (p), where p ‚àà Œ¶,
M, w ‚ä•
never,
M, w  ¬¨œÜ iff not M, w  œÜ,1 Basic Concepts
18
M, w  œÜ ‚à® œà iff M, w  œÜ or M, w  œà,
M, w  3œÜ iff for some v ‚àà W with Rwv we have M, v  œÜ. (1.4)
It follows from this deÔ¨Ånition that M, w  2œÜ if and only if for all v ‚àà W such
that Rwv, we have M, v  œÜ. Finally, we say that a set Œ£ of formulas is true at a
state w of a model M, notation: M, w  Œ£, if all members of Œ£ are true at w.
Note that this notion of satisfaction is intrinsically internal and local. We evaluate
formulas inside models, at some particular state w (the current state). Moreover,
3 works locally: the Ô¨Ånal clause (1.4) treats 3œÜ as an instruction to scan states
in search of one where œÜ is satisÔ¨Åed. Crucially, only successors of the current
state (that is, states that are accessible from the current one by making one R-step)
can be scanned by our operators. Much of the characteristic Ô¨Çavor of modal logic
springs from the perspective on relational structures embodied in the satisfaction
deÔ¨Ånition.
If M does not satisfy œÜ at w we often write M, w  œÜ, and say that œÜ is false or
refuted at w. When M is clear from the context, we write w  œÜ for M, w  œÜ and
w  œÜ for M, w  œÜ. It is convenient to extend the valuation V from proposition
letters to arbitrary formulas so that V (œÜ) always denotes the set of states at which
œÜ is true:
V (œÜ) := {w | M, w  œÜ}.
DeÔ¨Ånition 1.21 A formula œÜ is globally or universally true in a model M (nota-
tion: M  œÜ) if it is satisÔ¨Åed at all points in M (that is, if M, w  œÜ, for all
w ‚àà W ). A formula œÜ is satisÔ¨Åable in a model M if there is some state in M at
which œÜ is true; a formula is falsiÔ¨Åable or refutable in a model if its negation is
satisÔ¨Åable.
A set Œ£ of formulas is globally true (satisÔ¨Åable, respectively) in a model M if
M, w  Œ£ for all states w in M (some state w in M, respectively).
Example 1.22 (i) Consider the frame F = ({w1 , w2 , w3 , w4 , w5 }, R), where
Rwi wj iff j = i + 1:
s
w1
-s
w2
-s
w3
-s
w4
-s
w5
If we choose a valuation V on F such that V (p) = {w2 , w3 }, V (q) = {w1 , w2 ,
w3 , w4 , w5 }, and V (r) = ‚àÖ, then in the model M = (F, V ) we have that
‚Ä¢ M, w1  3p,
‚Ä¢ M, w1  3p ‚Üí p,
‚Ä¢ M, w2  3(p ‚àß ¬¨r), and
‚Ä¢ M, w1  q ‚àß 3(q ‚àß 3(q ‚àß 3(q ‚àß 3q))).1.3 Models and Frames
19
Furthermore, M  2q. Now, it is clear that 2q is true at w1 , w2 , w3 and w4 , but
why is it true at w5 ? Well, as w5 has no successors at all (we often call such points
‚Äòdead ends‚Äô or ‚Äòblind states‚Äô) it is vacuously true that q is true at all R-successors
of w5 . Indeed, any ‚Äòboxed‚Äô formula 2œÜ is true at any dead end in any model.
(ii) As a second example, let F be the SPO given in Figure 1.1, where W = {1,
2, 3, 4, 6, 8, 12, 24} and Rxy means ‚Äòx and y are different, and y can be divided
by x.‚Äô Choose a valuation V on this frame such that V (p) = {4, 8, 12, 24}, and
V (q) = {6}, and let M = (F, V ). Then we have that
‚Ä¢ M, 4  2p,
‚Ä¢ M, 6  2p,
‚Ä¢ M, 2  2p, and
‚Ä¢ M, 2  3(q ‚àß 2p) ‚àß 3(¬¨q ‚àß 2p).
(iii) Whereas a diamond 3 corresponds to making a single R-step in a model,
stacking diamonds one in front of the other corresponds to making a sequence
of R-steps through the model. The following deÔ¨Åned operators will sometimes
be useful: we write 3n œÜ for œÜ preceded by n occurrences of 3, and 2n œÜ for œÜ
preceded by n occurrences of 2. If we like, we can associate each of these deÔ¨Åned
operators with its own accessibility relation. We do so inductively: R0 xy is deÔ¨Åned
to hold if x = y, and Rn+1 xy is deÔ¨Åned to hold if ‚àÉz (Rxz ‚àß Rn zy). Under this
deÔ¨Ånition, for any model M and state w in M we have M, w  3n œÜ iff there exists
a v such that Rn wv and M, v  œÜ.
(iv) The use of the word ‚Äòworld‚Äô (or ‚Äòpossible world‚Äô) for the entities in W
derives from the reading of the basic modal language in which 3œÜ is taken to mean
‚Äòpossibly œÜ,‚Äô and 2œÜ to mean ‚Äònecessarily œÜ.‚Äô Given this reading, the machinery of
frames, models, and satisfaction which we have deÔ¨Åned is essentially an attempt to
capture mathematically the view (often attributed to Leibniz) that necessity means
truth in all possible worlds, and that possibility means truth in some possible world.
The satisfaction deÔ¨Ånition stipulates that 3 and 2 check for truth not at all possi-
ble worlds (that is, at all elements of W ) but only at R-accessible possible worlds.
At Ô¨Årst sight this may seem a weakness of the satisfaction deÔ¨Ånition ‚Äì but in fact, it
is its greatest source of strength. The point is this: varying R is a mechanism which
gives us a Ô¨Årm mathematical grip on the pre-theoretical notion of access between
possible worlds. For example, by stipulating that R = W √ó W we can allow all
worlds access to each other; this corresponds to the Leibnizian idea in its purest
form. Going to the other extreme, we might stipulate that no world has access to
any other. Between these extremes there is a wide range of options to explore.
Should interworld access be reÔ¨Çexive? Should it be transitive? What impact do
these choices have on the notions of necessity and possibility? For example, if we
demand symmetry, does this justify certain principles, or rule others out?
(v) Recall from Example 1.10 that in epistemic logic 2 is written as K and KœÜ20
1 Basic Concepts
is interpreted as ‚Äòthe agent knows that œÜ.‚Äô Under this interpretation, the intuitive
reading for the semantic clause governing K is: the agent knows œÜ in a situation
w (that is, w  KœÜ) iff œÜ is true in all situations v that are compatible with her
knowledge (that is, if v  œÜ for all v such that Rwv). Thus, under this interpre-
tation, W is to be thought of as a collection of situations, R is a relation which
models the idea of one situation being epistemically accessible from another, and
V governs the distribution of primitive information across situations.
We now deÔ¨Åne frames, models and satisfaction for modal languages of arbitrary
similarity type.
DeÔ¨Ånition 1.23 Let œÑ be a modal similarity type. A œÑ -frame is a tuple F consisting
of the following ingredients:
(i) a non-empty set W ,
(ii) for each n ‚â• 0, and each n-ary modal operator  in the similarity type œÑ ,
an (n + 1)-ary relation R.
So, again, frames are simply relational structures. If œÑ contains just a Ô¨Ånite number
of modal operators 1 , . . . , n , we write F = (W, R1 , . . . , Rn ); otherwise we
write F = (W, R)‚ààœÑ or F = (W, {R |  ‚àà œÑ }). We turn such a frame into a
model in exactly the same way that we did for the basic modal language: by adding
a valuation. That is, a œÑ -model is a pair M = (F, V ) where F is a œÑ -frame, and V
is a valuation with domain Œ¶ and range P(W ), where W is the universe of F.
The notion of a formula œÜ being satisÔ¨Åed (or true) at a state w in a model M =
(W, {R |  ‚àà œÑ }, V ) (notation: M, w  œÜ) is deÔ¨Åned inductively. The clauses
for the atomic and boolean cases are the same as for the basic modal language (see
DeÔ¨Ånition 1.20). As for the modal case, when œÅ() > 0 we deÔ¨Åne
M, w  (œÜ1 , . . . , œÜn ) iff for some v1 , . . . , vn ‚àà W with Rwv1 . . . vn
we have, for each i, M, vi  œÜi .
This is an obvious generalization of the way 3 is handled in the basic modal lan-
guage. Before going any further, the reader should formulate the satisfaction clause
for (œÜ1 , . . . , œÜn ).
On the other hand, when œÅ() = 0 (that is, when  is a nullary modality) then
R is a unary relation and we deÔ¨Åne
M, w   iff w ‚àà R.
That is, unlike other modalities, nullary modalities do not access other states. In
fact, their semantics is identical to that of the propositional variables, save that the
unary relations used to interpret them are not given by the valuation ‚Äì rather, they
are part of the underlying frame.1.3 Models and Frames
21
As before, we often write w  œÜ for M, w  œÜ where M is clear from the
context. The concept of global truth (or universal truth) in a model is deÔ¨Åned
as for the basic modal language: it simply means truth at all states in the model.
And, as before, we sometimes extend the valuation V supplied by M to arbitrary
formulas.
Example 1.24 (i) Let œÑ be a similarity type with three unary operators a, b,
and c. Then a œÑ -frame has three binary relations Ra , Rb , and Rc (that is, it is a
labeled transition system with three labels). To give an example, let W , Ra , Rb
and Rc be as in Figure 1.2, and consider the formula ap ‚Üí bp. Informally,
this formula is true at a state, if it has an Ra -successor satisfying p only if it has
an Rb -successor satisfying p. Let V be a valuation with V (p) = {w2 }. Then the
model M = (W, Ra , Rb , Rc , V ) has M, w1  ap ‚Üí bp.
(ii) Let œÑ be a similarity type with a binary modal operator  and a ternary
operator . Frames for this œÑ contain a ternary relation R and a 4-ary rela-
tion S . As an example, let W = {u, v, w, s}, R = {(u, v, w)}, and S =
{(u, v, w, s)} as in Figure 1.6, and consider a valuation V on this frame with
V (p0 ) = {v}, V (p1 ) = {w} and V (p2 ) = {s}. Now, let œÜ be the formula
v
p0
w
p1
: R uvw
: S uvws
u
s
p2
Fig. 1.6. A simple frame
(p0 , p1 ) ‚Üí (p0 , p1 , p2 ). An informal reading of œÜ is ‚Äòany triangle of which the
evaluation point is a vertex, and which has p0 and p1 true at the other two vertices,
can be expanded to a rectangle with a fourth point at which p2 is true.‚Äô The reader
should be able to verify that œÜ is true at u, and indeed at all other points, and hence
that it is globally true in the model.
Example 1.25 (Bidirectional Frames and Models) Recall from Example 1.14
that the basic temporal language has two unary operators F and P . Thus, according
to DeÔ¨Ånition 1.23, models for this language consist of a set bearing two binary re-
lations, RF (the into-the-future relation) and RP (the into-the-past relation), which
are used to interpret F and P respectively. However, given the intended reading
of the operators, most such models are inappropriate: clearly we ought to insist on1 Basic Concepts
22
working with models based on frames in which RP is the converse of RF (that is,
frames in which ‚àÄxy (RF xy ‚Üî RP yx)).
Let us denote the converse of a relation R by RÀá. We will call a frame of the
form (T, R, RÀá) a bidirectional frame, and a model built over such a frame a bidi-
rectional model. From now on, we will only interpret the basic temporal language
in bidirectional models. That is, if M = (T, R, RÀá, V ) is a bidirectional model
then:
M, t  F œÜ
M, t  P œÜ
iff
iff
‚àÉs (Rts ‚àß M, s  œÜ),
‚àÉs (RÀáts ‚àß M, s  œÜ).
But of course, once we have made this restriction, we do not need to mention RÀá
explicitly any more: once R has been Ô¨Åxed, its converse is Ô¨Åxed too. That is, we
are free to interpret the basic temporal languages on frames (T, R) for the basic
modal language using the clauses
M, t  F œÜ
M, t  P œÜ
iff
iff
‚àÉs (Rts ‚àß M, s  œÜ),
‚àÉs (Rst ‚àß M, s  œÜ).
These clauses clearly capture a crucial part of the intended semantics: F looks
forwards along R, and P looks backwards along R. Of course, our models will
only start looking genuinely temporal when we insist that R has further properties
(notably transitivity, to capture the Ô¨Çow of time), but at least we have pinned down
the fundamental interaction between the two modalities.
Example 1.26 (Regular Frames and Models) As explained in Example 1.15, the
language of PDL has an inÔ¨Ånite collection of diamonds, each indexed by a program
œÄ built from basic programs using the constructors ‚à™, ; and ‚àó . Now, according to
DeÔ¨Ånition 1.23, a model for this language has the form
(W, {RœÄ | œÄ is a program }, V ).
That is, a model is a labeled transition system together with a valuation. However,
given our reading of the PDL operators, most of these models are uninteresting. As
with the basic temporal language, we must insist on working with a class of models
that does justice to our intentions.
Now, there is no problem with the interpretation of the basic programs: any
binary relation can be regarded as a transition relation for a non-deterministic pro-
gram. Of course, if we were particularly interested in deterministic programs we
would insist that each basic program be interpreted by a partial function, but let us
ignore this possibility and turn to the key question: which relations should interpret
the structured modalities? Given our readings of ‚à™, ; and ‚àó , as choice, composition,
and iteration, it is clear that we are only interested in relations constructed using1.3 Models and Frames
23
the following inductive clauses:
RœÄ1 ‚à™œÄ2= R œÄ 1 ‚à™ RœÄ 2 ,
RœÄ1 ;œÄ2= RœÄ1 ‚ó¶ RœÄ2 (= {(x, y) | ‚àÉz (RœÄ1 xz ‚àß RœÄ2 zy)}),
RœÄ1‚àó= (RœÄ1 )‚àó , the reÔ¨Çexive transitive closure of RœÄ1 .
These inductive clauses completely determine how each modality should be inter-
preted. Once the interpretation of the basic programs has been Ô¨Åxed, the relation
corresponding to each complex program is Ô¨Åxed too. This leads to the following
deÔ¨Ånition.
Suppose we have Ô¨Åxed a set of basic programs. Let Œ† be the smallest set of pro-
grams containing the basic programs and all the programs constructed over them
using the regular constructors ‚à™, ; and ‚àó . Then a regular frame for Œ† is a labeled
transition system (W, {RœÄ | œÄ ‚àà Œ†}) such that Ra is an arbitrary binary relation
for each basic program a, and for all complex programs œÄ, RœÄ is the binary relation
inductively constructed in accordance with the previous clauses. A regular model
for Œ† is a model built over a regular frame; that is, a regular model is a regular
frame together with a valuation. When working with the language of PDL over the
programs in Œ†, we will only be interested in regular models for Œ†, for these are
the models that capture the intended interpretation.
What about the ‚à© and ? constructors? Clearly the intended reading of ‚à© demands
that RœÄ1 ‚à©œÄ2 = RœÄ1 ‚à©RœÄ2 . As for ?, it is clear that we want the following deÔ¨Ånition:
RœÜ? = {(x, y) | x = y and y  œÜ}.
This is indeed the clause we want, but note that it is rather different from the others:
it is not a frame condition. Rather, in order to determine the relation RœÜ? , we need
information about the truth of the formula œÜ, and this can only be provided at the
level of models.
Example 1.27 (Arrow Models) Arrow frames were deÔ¨Åned in Example 1.8 and
the arrow language in Example 1.16. Given these deÔ¨Ånitions, it is clear how the
language of arrow logic should be interpreted. First, an arrow model is a structure
M = (F, V ) such that F = (W, C, R, I) is an arrow frame and V is a valuation.
Then:
M, a  1‚Äô iff Ia,
M, a  ‚äóœÜ iff M, b  œÜ for some b with Rab,
M, a  œÜ ‚ó¶ œà iff M, b  œÜ and M, c  œà for some b and c with Cabc.
When F is a square frame SU (as deÔ¨Åned in Example 1.8), this works out as
follows. V now maps propositional variables to sets of pairs over U ; that is, to1 Basic Concepts
24
binary relations. The truth deÔ¨Ånition can be rephrased as follows:
M, (a0 , a1 )  1‚Äô iff a0 = a1 ,
M, (a0 , a1 )  ‚äóœÜ iff M, (a1 , a0 )  œÜ,
M, (a0 , a1 )  œÜ ‚ó¶ œà iff M, (a0 , u)  œÜ and M, (u, a1 )  œà for some u ‚àà U .
Such situations can be represented pictorially in two ways. First, one could draw
the graph-like structures as given in Example 1.8. Alternatively, one could draw
a square model two-dimensionally, as in the picture below. It will be obvious that
the modal constant 1‚Äô holds precisely at the diagonal points and that ‚äóœÜ is true at a
point iff œÜ holds at its mirror image with respect to the diagonal. The formula œÜ ‚ó¶ œà
holds at a point a iff we can draw a rectangle abcd such that: b lies on the vertical
line through a, d lies on the horizontal line through a; and c lies on the diagonal.
q
q
dœà
q
aœÜ‚ó¶œà
œÜ
1‚Äô
q
‚äóœÜ
q
c
q
bœÜ
Frames and validity
It is time to deÔ¨Åne one of the key concepts in modal logic. So far we have been
viewing modal languages as tools for talking about models. But models are com-
posite entities consisting of a frame (our underlying ontology) and contingent in-
formation (the valuation). We often want to ignore the effects of the valuation and
get a grip on the more fundamental level of frames. The concept of validity lets
us do this. A formula is valid on a frame if it is true at every state in every model
that can be built over the frame. In effect, this concept interprets modal formulas
on frames by abstracting away from the effects of particular valuations.
DeÔ¨Ånition 1.28 A formula œÜ is valid at a state w in a frame F (notation: F, w  œÜ)
if œÜ is true at w in every model (F, V ) based on F; œÜ is valid in a frame F (notation:
F  œÜ) if it is valid at every state in F. A formula œÜ is valid on a class of frames
F (notation: F  œÜ) if it is valid on every frame F in F; and it is valid (notation:
 œÜ) if it is valid on the class of all frames. The set of all formulas that are valid in
a class of frames F is called the logic of F (notation: ŒõF ).1.3 Models and Frames
25
Our deÔ¨Ånition of the logic of a frame class F (as the set of ‚Äòall‚Äô formulas that
are valid on F) is underspeciÔ¨Åed: we did not say which collection of proposition
letters Œ¶ should be used to build formulas. But usually the precise form of this
collection is irrelevant for our purposes. On the few occasions in this book where
more precision is required, we will explicitly deal with the issue. (If the reader is
worried about this, he or she may just Ô¨Åx a countable set Œ¶ of proposition letters
and deÔ¨Åne ŒõF to be {œÜ ‚àà Form(œÑ, Œ¶) | F  œÜ}.)
As will become abundantly clear in the course of the book, validity differs from
truth in many ways. Here is a simple example. When a formula œÜ ‚à® œà is true at a
point w, this means that either œÜ or œà is true at w (the satisfaction deÔ¨Ånition tells
us so). On the other hand, if œÜ ‚à® œà is valid on a frame F, this does not mean that
either œÜ or œà is valid on F (p ‚à® ¬¨p is a simple counterexample).
Example 1.29 (i) The formula 3(p ‚à® q) ‚Üí (3p ‚à® 3q) is valid on all frames. To
see this, take any frame F and state w in F, and let V be a valuation on F. We have
to show that if (F, V ), w  3(p ‚à® q), then (F, V ), w  3p ‚à® 3q. So assume that
(F, V ), w  3(p ‚à® q). Then, by deÔ¨Ånition there is a state v such that Rwv and
(F, V ), v  p ‚à® q. But, if v  p ‚à® q then either v  p or v  q. Hence either
w  3p or w  3q. Either way, w  3p ‚à® 3q.
(ii) The formula 33p ‚Üí 3p is not valid on all frames. To see this we need to
Ô¨Ånd a frame F, a state w in F, and a valuation on F that falsiÔ¨Åes the formula at w.
So let F be a three-point frame with universe {0, 1, 2} and relation {(0, 1), (1, 2)}.
Let V be any valuation on F such that V (p) = {2}. Then (F, V ), 0  33p, but
(F, V ), 0  3p since 0 is not related to 2.
(iii) But there is a class of frames on which 33p ‚Üí 3p is valid: the class
of transitive frames. To see this, take any transitive frame F and state w in F,
and let V be a valuation on F. We have to show that if (F, V ), w  33p, then
(F, V ), w  3p. So assume that (F, V ), w  33p. Then by deÔ¨Ånition there are
states u and v such that Rwu and Ruv and (F, V ), v  p. But as R is transitive, it
follows that Rwv, hence (F, V ), w  3p.
(iv) As the previous example suggests, when additional constraints are imposed
on frames, more formulas may become valid. For example, consider the frame
depicted in Figure 1.2. On this frame the formula ap ‚Üí bp is not valid; a coun-
termodel is obtained by putting V (p) = {w2 }. Now, consider a frame satisfying
the condition Ra ‚äÜ Rb ; an example is depicted in Figure 1.7.
w
s
a -
s
-
b
b

Fig. 1.7. A frame satisfying R a ‚äÜ Rb26
1 Basic Concepts
On this frame it is impossible to refute the formula ap ‚Üí bp at w, because a
refutation would require the existence of a point u with Ra wu and p true at u, but
not Rb wu; but such points are forbidden when we insist that Ra ‚äÜ Rb .
This is a completely general point: in every frame F of the appropriate similarity
type, if F satisÔ¨Åes the condition Ra ‚äÜ Rb , then ap ‚Üí bp is valid in F. More-
over, the converse to this statement also holds: whenever ap ‚Üí bp is valid on
a given frame F, then the frame must satisfy the condition Ra ‚äÜ Rb . To use the
terminology we will introduce in Chapter 3, the formula ap ‚Üí bp deÔ¨Ånes the
property that Ra ‚äÜ Rb .
(v) When interpreting the basic temporal language (see Example 1.25) we ob-
served that arbitrary frames of the form (W, RP , RF ) were uninteresting given the
intended interpretation of F and P , and we insisted on interpreting them using a
relation R and its converse. Interestingly, there is a sense in which the basic tempo-
ral language itself is strong enough to enforce the condition that the relation RP is
the converse of the relation RF : such frames are precisely the ones which validate
both the formulas p ‚Üí GP p and p ‚Üí HF p; see Exercise 3.1.1.
(vi) The formula F q ‚Üí F F q is not valid on all frames. To see this we need
to Ô¨Ånd a frame T = (T, R), a state t in T, and a valuation on T that falsiÔ¨Åes
this formula at t. So let T = {0, 1}, and let R be the relation {(0, 1)}. Let
V be a valuation such that V (p) = {1}. Then (T, V ), 0  F p, but obviously
(T, V ), 0  F F p.
(vii) But there is a frame on which F p ‚Üí F F p is valid. As the universe of the
frame take the set of all rational numbers Q, and let the frame relation be the usual
<-ordering on Q. To show that F p ‚Üí F F p is valid on this frame, take any point
t in it, and any valuation V such that (Q, <, V ), t  F p; we have to show that
t  F F p. But this is easy: as t  F p, there exists a t such that t < t and t  p.
Because we are working on the rationals, there must be an s with t < s and s < t
(for example, (t + t )/2). As s  F p, it follows that t  F F p.
(viii) The special conditions demanded of PDL models also give rise to validities.
For example,
œÄ1 ; œÄ2 p ‚Üî œÄ1 œÄ2 p
is valid on any frame such that RœÄ1 ;œÄ2 = RœÄ1 ‚ó¶ RœÄ2 , and in fact the converse is also
true. The reader is asked to prove this in Exercise 3.1.2.
(ix) In our last example we consider arrow logic. We claim that in any square
arrow frame SU , the formula ‚äó(p ‚ó¶ q) ‚Üí ‚äóq ‚ó¶ ‚äóp is valid. For, let V be a
valuation on SU , and suppose that for some pair of points u, v in U , we have
(SU , V ), (u, v)  ‚äó(p ‚ó¶ q). It follows that (SU , V ), (v, u)  p ‚ó¶ q, and hence,
there must be a w ‚àà U for which (SU , V ), (v, w)  p and (SU , V ), (w, u)  q.
But then we have (SU , V ), (w, v)  ‚äóp and (SU , V ), (u, w)  ‚äóq. This in turn
implies that (SU , V ), (u, v)  ‚äóq ‚ó¶ ‚äóp.1.3 Models and Frames
27
Exercises for Section 1.3
1.3.1 Show that when evaluating a formula œÜ in a model, the only relevant information in
the valuation is the assignments it makes to the propositional letters actually occurring in
œÜ. More precisely, let F be a frame, and V and V  be two valuations on F such that V (p) =
V  (p) for all proposition letters p in œÜ. Show that (F, V )  œÜ iff (F, V  )  œÜ. Work in the
basic modal language. Do this exercise by induction on the number of connectives in œÜ (or
as we usually put it, by induction on œÜ). (If you are unsure how to do this, glance ahead to
Proposition 2.3 where such a proof is given in detail.)
1.3.2 Let N = (N, S1 , S2 ) and B = (B, R1 , R2 ) be the following frames for a modal
similarity type with two diamonds 3 1 and 32 . Here N is the set of natural numbers, B is
the set of strings of 0s and 1s, and the relations are deÔ¨Åned by
mS1 n
mS2 n
sR1 t
sR2 t
iff
iff
iff
iff
n = m + 1,
m > n,
t = s0 or t = s1,
t is a proper initial segment of s.
Which of the following formulas are valid on N and B, respectively?
(a) (31 p ‚àß 31 q) ‚Üí 31 (p ‚àß q),
(b) (32 p ‚àß 32 q) ‚Üí 32 (p ‚àß q),
(c) (31 p ‚àß 31 q ‚àß 31 r) ‚Üí (31 (p ‚àß q) ‚à® 31 (p ‚àß r) ‚à® 31 (q ‚àß r)),
(d) p ‚Üí 31 22 p,
(e) p ‚Üí 32 21 p,
(f) p ‚Üí 21 32 p,
(g) p ‚Üí 22 31 p.
1.3.3 Consider the basic temporal language and the frames (Z, <), (Q, <) and (R, <)
(the integer, rational, and real numbers, respectively, all ordered by the usual less-than
relation <). In this exercise we use EœÜ to abbreviate P œÜ ‚à® œÜ ‚à® F œÜ, and AœÜ to abbreviate
HœÜ ‚àß œÜ ‚àß GœÜ. Which of the following formulas are valid on these frames?
(a) GGp ‚Üí p,
(b) (p ‚àß Hp) ‚Üí F Hp,
(c) (Ep ‚àß E¬¨p ‚àß A(p ‚Üí Hp) ‚àß A(¬¨p ‚Üí G¬¨p)) ‚Üí E(Hp ‚àß G¬¨p).
1.3.4 Show that every formula that has the form of a propositional tautology is valid.
Further, show that 2(p ‚Üí q) ‚Üí (2p ‚Üí 2q) is valid.
1.3.5 Show that each of the following formulas is not valid by constructing a frame F =
(W, R) that refutes it.
(a) ‚ä•,
(b) 3p ‚Üí 2p,
(c) p ‚Üí 23p,
(d) 32p ‚Üí 23p.
Find, for each of these formulas, a non-empty class of frames on which it is valid.
1.3.6 Show that the arrow formulas œÜ ‚ó¶ (œà ‚ó¶ œá) ‚Üî (œÜ ‚ó¶ œà) ‚ó¶ œá and 1‚Äô ‚ó¶ œÜ ‚Üî œÜ are valid in
any square.1 Basic Concepts
28
1.4 General Frames
At the level of models the fundamental concept is satisfaction. This is a relatively
simple concept involving only a frame and a single valuation. By ascending to the
level of frames we get a deeper grip on relational structures ‚Äì but there is a price to
pay. Validity lacks the concrete character of satisfaction, for it is deÔ¨Åned in terms of
all valuations on a frame. However, there is an intermediate level: a general frame
(F, A) is a frame F together with a restricted, but suitably well-behaved collection
A of admissible valuations.
General frames are useful for at least two reasons. First, there may be appli-
cation driven motivations to exclude certain valuations. For instance, if we were
using (N, <) to model the temporal distribution of outputs from a computational
device, it would be unreasonable to let valuations assign non-recursively enumer-
able sets to propositional variables. But perhaps the most important reason to work
with general frames is that they support a notion of validity that is mathematically
simpler than the frame-based one, without losing too many of the concrete prop-
erties that make models so easy to work with. This ‚Äòsimpler behavior‚Äô will only
really become apparent when we discuss the algebraic perspective on complete-
ness theory in Chapter 5. It will turn out that there is a fundamental and universal
completeness result for general frame validity, something that the frame semantics
lacks. Moreover, we will discover that general frames are essentially a set-theoretic
representation of boolean algebras with operators. Thus, the A in (W, R, A) stands
not only for Admissible, but also for Algebra.
So what is a ‚Äòsuitably well-behaved collection of valuations‚Äô? It simply means a
collection of valuations closed under the set-theoretic operations corresponding to
our connectives and modal operators. Now, fairly obviously, the boolean connec-
tives correspond to the boolean operations of union, relative complement, and so
on ‚Äì but what operations on sets do modalities correspond to? Here is the answer.
Let us Ô¨Årst consider the basic modal similarity type with one diamond. Given a
frame F = (W, R), let mR be the following operation on the power set of W :
mR (X) = {w ‚àà W | Rwx for some x ‚àà X }.
Think of mR (X) as the set of states that ‚Äòsee‚Äô a state in X. This operation corre-
sponds to the diamond in the sense that for any valuation V and any formula œÜ we
have V (3œÜ) = mR (V (œÜ)).
Moving to the general case, we obtain the following deÔ¨Ånition.
DeÔ¨Ånition 1.30 Given an (n + 1)-ary relation R on a set W , we deÔ¨Åne the follow-
ing n-ary operation mR on the power set P(W ) of W :
mR (X1 , . . . , Xn ) =
{w ‚àà W | Rww1 . . . wn for some w1 ‚àà X1 , . . . , wn ‚àà Xn }.1.4 General Frames
29
Example 1.31 Let ‚äó be the converse operator of arrow logic, and recall that we
use the letter R to denote the accessibility relation for ‚äó. Thus on a square frame
SU , by the rather special nature of R, we have that, for any subset X of U2 :
mR (X) = {(a0 , a1 ) ‚àà U 2 | a0 = x1 and a1 = x0 for some (x0 , x1 ) ‚àà X }
= {(x1 , x0 ) ‚àà U 2 | (x0 , x1 ) ‚àà X}.
In other words, mR (X) is nothing but the converse of the binary relation X.
DeÔ¨Ånition 1.32 (General Frames) Let œÑ be a modal similarity type. A general œÑ -
frame is a pair (F, A) where F = (W, R)‚ààœÑ is a œÑ -frame, and A is a non-empty
collection of admissible subsets of W closed under the following operations:
(i) union: if X, Y ‚àà A, then X ‚à™ Y ‚àà A.
(ii) relative complement: if X ‚àà A, then W \ X ‚àà A.
(iii) modal operations: if X1 , . . . , Xn ‚àà A, then mR (X1 , . . . , Xn ) ‚àà A for all
 ‚àà œÑ.
A model based on a general frame is a triple (F, A, V ) where (F, A) is a general
frame and V is a valuation satisfying the constraint that for each proposition letter
p, V (p) is an element of A. Valuations satisfying this constraint are called admis-
sible for (F, A).
It follows immediately from the Ô¨Årst two clauses of the deÔ¨Ånition that both the
empty set and the universe of a general frame are always admissible. Note that
an ordinary frame F = (W, R)‚ààœÑ can be regarded as a general frame where
A = P(W ) (that is, a general frame in which all valuations are admissible). Also,
note that if a valuation V is admissible for a general frame (F, A), then the closure
conditions listed in DeÔ¨Ånition 1.32 guarantee that V (œÜ) ‚àà A, for all formulas
œÜ. In short, a set of admissible valuations A is a ‚Äòlogically closed‚Äô collection of
information assignments.
DeÔ¨Ånition 1.33 A formula œÜ is valid at a state w in a general frame (F, A) (no-
tation: (F, A), w  œÜ) if œÜ is true at w in every admissible model (F, A, V ) on
(F, A); and œÜ is valid in a general frame (F, A) (notation: (F, A)  œÜ) if œÜ is true
at every state in every admissible model (F, A, V ) on (F, A).
A formula œÜ is valid on a class of general frames G (notation: G  œÜ) if it is
valid on every general frame (F, A) in G. Finally, if œÜ is valid on the class of all
general frames we say that it is g-valid and write g œÜ. We will learn in Chapter 4
(see Exercise 4.1.1) that a formula œÜ is valid if and only if it is g-valid.
Clearly, for any frame F, if F  œÜ then for any collection of admissible assign-
ments A on F, we have (F, A)  œÜ too. The converse does not hold. Here is a
counterexample that will be useful in Chapter 4.1 Basic Concepts
30
Example 1.34 Consider the McKinsey formula, 23p ‚Üí 32p. It is easy to see
that the McKinsey formula is not valid on the frame (N, <), for we obtain a coun-
termodel by choosing a valuation for p that lets the truth value of p alternate in-
Ô¨Ånitely often (for instance, by letting V (p) be the collection of even numbers).
However, there is a general frame based on (N, <) in which the McKinsey for-
mula is valid. First some terminology: a set is co-Ô¨Ånite if its complement is Ô¨Ånite.
Now consider the general frame f = (N, <, A), where A is the collection of all
Ô¨Ånite and co-Ô¨Ånite sets. We leave it as an exercise to show that f satisÔ¨Åes all the
constraints of DeÔ¨Ånition 1.32; see Exercise 1.4.5.
To see that the McKinsey formula is indeed valid on f, let V be an admissible
valuation, and let n ‚àà N. If (f, V ), n  23p, then V (p) must be co-Ô¨Ånite (why?),
hence for some k every state l ‚â• k is in V (p). But this means that (f, V ), n  32p,
as required.
Although we will make an important comment about general frames in Section 3.2,
and use them to help prove an incompleteness result in Section 4.4, we will not re-
ally be in a position to grasp their signiÔ¨Åcance until Chapter 5, when we introduce
boolean algebras with operators. Until then, we will concentrate on modal lan-
guages as tools for talking about models and frames.
Exercises for Section 1.4
1.4.1 DeÔ¨Åne, analogous to m R , an operation l R on the power set of a frame such that for an
arbitrary modal formula œÜ and an arbitrary valuation V we have that l R (V (œÜ)) = V (2œÜ).
Extend this deÔ¨Ånition to the dual of a polyadic modal operator.
1.4.2 Consider the basic modal formula 3p ‚Üí p.
(a) Construct a frame F = (W, R) and a general frame f = (F, A) such that F  3p ‚Üí
p, but f  3p ‚Üí p.
(b) Construct a general frame (F, A) and a valuation V on F such that (F, A)  3p ‚Üí
p, but (F, V )  3p ‚Üí p.
1.4.3 Show that if B is any collection of valuations over some frame F, then there is a
smallest general frame (F, A) such that B ‚äÜ A. (‚ÄòSmallest‚Äô means that for any general
frame (F, A ) such that B ‚äÜ A , A ‚äÜ A .)
1.4.4 Recall that in any arrow frame, we use C and I to denote the relations associated
with the modalities ‚ó¶ and 1‚Äô, respectively. Show that for square arrow frames, the operation
mC is nothing but composition of two binary relations. What is m I ?
1.4.5 Consider the basic modal language, and the general frame f = (N, <, A), where A
is the collection of all Ô¨Ånite and co-Ô¨Ånite sets. Show that f is a general frame.
1.4.6 Consider the structure g = (N, C, A) where A is the collection of Ô¨Ånite and co-Ô¨Ånite
subsets of N, and C is deÔ¨Åned by
Cn1 n2 n3 iff n1 ‚â§ n2 + n3 and n2 ‚â§ n3 + n1 and n3 ‚â§ n1 + n2 .1.5 Modal Consequence Relations
31
If C is the accessibility relation of a dyadic modal operator, show that g is a general frame.
1.4.7 Let M = (F, V ) be some modal model. Prove that the structure
(F, {V (œÜ) | œÜ is a formula })
is a general frame.
1.5 Modal Consequence Relations
While the idea of validity in frames (and indeed, validity in general frames) gives
rise to logically interesting formulas, so far we have said nothing about what logical
consequence might mean for modal languages. That is, we have not explained what
it means for a set of modal formulas Œ£ to logically entail a modal formula œÜ.
This we will now do. In fact, we will introduce two families of consequence
relations: a local one and a global one. Both families will be deÔ¨Åned semantically;
that is, in terms of classes of structures. We will deÔ¨Åne these relations for all three
kinds of structures we have introduced, though in practice we will be primarily
interested in semantic consequence over frames. Before going further, a piece of
terminology. If S is a class of models, then a model from S is simply a model M in
S. On the other hand, if S is a class of frames (or a class of general frames) then a
model from S is a model based on a frame (general frame) in S.
What is a modally reasonable notion of logical consequence? Two things are
fairly clear. First, it seems sensible to hold on to the familiar idea that a relation
of semantic consequence holds when the truth of the premises guarantees the truth
of the conclusion. Second, it should be clear that the inferences we are entitled to
draw will depend on the class of structures we are working with. (For example,
different inferences will be legitimate on transitive and intransitive frames.) Thus
our deÔ¨Ånition of consequence will have to be parametric: it must make reference
to a class of structures S.
Here is the standard way of meeting these requirements. Suppose we are work-
ing with a class of structures S. Then, for a formula œÜ (the conclusion) to be a
logical consequence of Œ£ (the premises) we should insist that whenever Œ£ is true
at some point in some model from S, then œÜ should also be true in that same model
at the same point. In short, this deÔ¨Ånition demands that the maintenance of truth
should be guaranteed point to point or locally.
DeÔ¨Ånition 1.35 (Local Semantic Consequence) Let œÑ be a similarity type, and
let S be a class of structures of type œÑ (that is a class of models, a class of frames,
or a class of general frames of this type). Let Œ£ and œÜ be a set of formulas and
a single formula from a language of type œÑ . We say that œÜ is a local semantic
consequence of Œ£ over S (notation: Œ£ S œÜ) if for all models M from S, and all
points w in M, if M, w  Œ£ then M, w  œÜ.32
1 Basic Concepts
Example 1.36 Suppose that we are working with Tran, the class of transitive
frames. Then:
{33p} Tran 3p.
On the other hand, 3p is not a local semantic consequence of {33p} over the
class of all frames.
Local consequence is the notion of logical entailment explored in this book, but it
is by no means the only possibility. Here is an obvious variant.
DeÔ¨Ånition 1.37 (Global Semantic Consequence) Let œÑ , S, Œ£ and œÜ be as in DeÔ¨Å-
nition 1.35. We say that œÜ is a global semantic consequence of Œ£ over S (notation:
Œ£ gS œÜ) if and only if for all structures S in S, if S  Œ£ then S  œÜ. (Here,
depending on the kind of structures S contains,  denotes either validity in a frame,
validity in a general frame, or global truth in a model.)
Again, this deÔ¨Ånition hinges on the idea that premises guarantee conclusions, but
here the guarantee covers global notions of correctness.
Example 1.38 The local and global consequence relations are different. Consider
the formulas p and 2p. It is easy to see that p does not locally imply 2p ‚Äì indeed,
that this entailment should not hold is pretty much the essence of locality. On the
other hand, suppose that we consider a model M where p is globally true. Then p
certainly holds at all successors of all states, so M  2p, and so p g 2p.
Nonetheless, there is a systematic connection between the two consequence rela-
tions, as the reader is asked to show in Exercise 1.5.3.
Exercises for Section 1.5
1.5.1 Let K be a class of frames for the basic modal similarity type, and let M(K) denote
the class of models based on a frame in K. Prove that 2p  gM(K) p iff K |= ‚àÄx‚àÉy Ryx
(every point has a predecessor).
Does this equivalence hold as well if we work with  gK instead?
1.5.2 Let M denote the class of all models, and F the class of all frames. Show that if
Œ£ gM œÜ then Œ£ gF œÜ, but that the converse is false.
1.5.3 Let Œ£ be a set of formulas in the basic modal language, and let M denote the class
of all models. Show that Œ£  gM œÜ iff {2n œÉ | œÉ ‚àà Œ£, n ‚àà œâ} M œÜ.
1.5.4 Again, let M denote the class of all models. Show that the local consequence relation
does have the deduction theorem: œÜ  M œà iff  œÜ ‚Üí œà, but the global one does not.
However, show that on the class Tran of transitive models we have that œÜ  gTran œà iff
gTran 2œÜ ‚Üí œà.1.6 Normal Modal Logics
33
1.6 Normal Modal Logics
Till now our discussion has been largely semantic; but logic has an important syn-
tactic dimension, and our discussion raises some obvious questions. Suppose we
are interested in a certain class of frames F: are there syntactic mechanisms capable
of generating ŒõF , the formulas valid on F? And are such mechanisms capable of
coping with the associated semantic consequence relation? The modal logician‚Äôs
response to such questions is embodied in the concept of a normal modal logic.
A normal modal logic is simply a set of formulas satisfying certain syntactic clo-
sure conditions. Which conditions? We will work towards the answer by deÔ¨Åning a
Hilbert-style axiom system called K. K is the ‚Äòminimal‚Äô (or ‚Äòweakest‚Äô) system for
reasoning about frames; stronger systems are obtained by adding extra axioms. We
discuss K in some detail, and then, at the end of the section, deÔ¨Åne normal modal
logics. By then, the reader will be in a position to see that the deÔ¨Ånition is a more-
or-less immediate abstraction from what is involved in Hilbert-style approaches to
modal proof theory. We will work in the basic modal language.
DeÔ¨Ånition 1.39 A K-proof is a Ô¨Ånite sequence of formulas, each of which is an
axiom, or follows from one or more earlier items in the sequence by applying a
rule of proof . The axioms of K are all instances of propositional tautologies plus:
(K)
(Dual)
2(p ‚Üí q) ‚Üí (2p ‚Üí 2q)
3p ‚Üî ¬¨2¬¨p.
The rules of proof of K are:
‚Ä¢ Modus ponens: given œÜ and œÜ ‚Üí œà, prove œà.
‚Ä¢ Uniform substitution: given œÜ, prove Œ∏, where Œ∏ is obtained from œÜ by uniformly
replacing proposition letters in œÜ by arbitrary formulas.
‚Ä¢ Generalization: given œÜ, prove 2œÜ.
A formula œÜ is K-provable if it occurs as the last item of some K-proof, and if this
is the case we write K œÜ.
Some comments. Tautologies may contain modalities (for example, 3q ‚à® ¬¨3q is a
tautology, as it has the same form as p ‚à® ¬¨p). As tautologies are valid on all frames
(Exercise 1.3.4), they are a safe starting point for modal reasoning. Our decision
to add all propositional tautologies as axioms is an example of axiomatic overkill;
we could have chosen a small set of tautologies capable of generating the rest via
the rules of proof, but this reÔ¨Ånement is of little interest for our purposes.
Modus ponens is probably familiar to all our readers, but there are two important
points we should make. First, modus ponens preserves validity. That is, if  œÜ and
 œÜ ‚Üí œà then  œà. Given that we want to reason about frames, this property is
crucial. Note, however, that modus ponens also preserves two further properties,34
1 Basic Concepts
namely global truth (if M  œÜ and M  œÜ ‚Üí œà then M  œà) and satisÔ¨Åability
(if M, w  œÜ and M, w  œÜ ‚Üí œà then M, w  œà). That is, modus ponens is not
only a correct rule for reasoning about frames, it is also a correct rule for reasoning
about models, both globally and locally.
Uniform substitution should also be familiar. It mirrors the fact that validity ab-
stracts away from the effects of particular assignments: if a formula is valid, this
cannot be because of the particular value its propositional symbols have, thus we
should be free to uniformly replace these symbols with any other formula what-
soever. And indeed, as the reader should check, uniform substitution preserves
validity. Note, however, that it does not preserve either global truth or satisÔ¨Åabil-
ity. (For example, q is obtainable from p by uniform substitution, but just because
p is globally true in some model, it does not follow that q is too!) In short, uniform
substitution is strictly a tool for generating new validities from old.
That is the classical core of our Hilbert system, so let us turn to the the genuinely
modal axioms and rules of proof. First the axioms. The K axiom is the fundamental
one. It is clearly valid (as the reader who has not done Exercise 1.3.4 should now
check) but why is it a useful addition to our Hilbert system?
K is sometimes called the distribution axiom, and is important because it lets us
transform 2(œÜ ‚Üí œà) (a boxed formula) into 2œÜ ‚Üí 2œà (an implication). This
box-over-arrow distribution enables further purely propositional reasoning to take
place. For example, suppose we are trying to prove 2œà, and have constructed a
proof sequence containing both 2(œÜ ‚Üí œà) and 2œÜ. If we could apply modus
ponens under the scope of the box, we would have proved 2œà. This is what distri-
bution lets us do: as K contains the axiom 2(p ‚Üí q) ‚Üí (2p ‚Üí 2q), by uniform
substitution we can prove 2(œÜ ‚Üí œà) ‚Üí (2œÜ ‚Üí 2œà). But then a Ô¨Årst application
of modus ponens proves 2œÜ ‚Üí 2œà, and a second proves 2œà as desired.
The Dual axiom obviously reÔ¨Çects the duality of 3 and 2; nonetheless, readers
familiar with other discussions of K (many of which have K as the sole modal
axiom) may be surprised at its inclusion. Do we really need it? Yes, we do. In this
book, 3 is primitive and 2 is an abbreviation. Thus our K axiom is really shorthand
for ¬¨3¬¨(p ‚Üí q) ‚Üí (¬¨3¬¨p ‚Üí ¬¨3¬¨q). We need a way to maneuver around
these negations, and this is the syntactic role that Dual plays. (Incidentally had we
chosen 2 as our primitive operator, Dual would not have been required.) We prefer
working with a primitive 3 (apart from anything else, it is more convenient for the
algebraic work of Chapter 5) and do not mind adding Dual as an extra axiom. Dual,
of course, is valid.
It only remains to discuss the modal rule of proof: generalization (another com-
mon name for it is necessitation). Generalization ‚Äòmodalizes‚Äô provable formulas by
stacking boxes in front. Roughly speaking, while the K axiom lets us apply classi-
cal reasoning inside modal contexts, necessitation creates new modal contexts for
us to work with; modal proofs arise from the interplay of these two mechanisms.1.6 Normal Modal Logics
35
Note that generalization preserves validity: if it is impossible to falsify œÜ, then
obviously we will never be able to falsify œÜ at any accessible state! Similarly,
generalization preserves global truth. But it does not preserve satisfaction: just
because p is true in some state, we cannot conclude that p is true at all accessible
states.
K is the minimal modal Hilbert system in the following sense. As we have
seen, its axioms are all valid, and all three rules of inference preserve validity,
hence all K-provable formulas are valid. (To use the terminology introduced in
DeÔ¨Ånition 4.9, K is sound with respect to the class of all frames.) Moreover, as we
will prove in Theorem 4.23, the converse is also true: if a basic modal formula is
valid, then it is K-provable. (That is, K is complete with respect to the class of all
frames.) In short, K generates precisely the valid formulas.
Example 1.40 The formula (2p ‚àß 2q) ‚Üí 2(p ‚àß q) is valid on any frame, so
it should be K-provable. And indeed, it is. To see this, consider the following
sequence of formulas:
1.
2.
3.
4.
5.
6.
7.
8.
 p ‚Üí (q ‚Üí (p ‚àß q))
Tautology
 2(p ‚Üí (q ‚Üí (p ‚àß q)))
Generalization: 1
 2(p ‚Üí q) ‚Üí (2p ‚Üí 2q)
K axiom
 2(p ‚Üí (q ‚Üí (p ‚àß q))) ‚Üí (2p ‚Üí 2(q ‚Üí (p ‚àß q)))
Uniform Substitution: 3
 2p ‚Üí 2(q ‚Üí (p ‚àß q))
Modus Ponens: 2, 4
 2(q ‚Üí (p ‚àß q)) ‚Üí (2q ‚Üí 2(p ‚àß q)) Uniform Substitution: 3
 2p ‚Üí (2q ‚Üí 2(p ‚àß q))
Propositional Logic: 5, 6
 (2p ‚àß 2q) ‚Üí 2(p ‚àß q)
Propositional Logic: 7
Strictly speaking, this sequence is not a K-proof ‚Äì it is a subsequence of the proof
consisting of the most important items. The annotations in the right-hand column
should be self-explanatory; for example ‚ÄòModus Ponens: 2, 4‚Äô labels the formula
obtained from the second and fourth formulas in the sequence by applying modus
ponens. To obtain the full proof, Ô¨Åll in the items that lead from line 6 to 8.
Remark 1.41 Warning: there is a pitfall that is very easy to fall into if you are used
to working with natural deduction systems: we cannot freely make and discharge
assumptions in the Hilbert system K. The following ‚Äòproof‚Äô shows what can go
wrong if we do:
1. p
Assumption
2. 2p
Generalization: 1
3. p ‚Üí 2p Discharge assumption
So we have ‚Äòproved‚Äô p ‚Üí 2p! This is obviously wrong: this formula is not valid,
hence it is not K-provable. And it should be clear where we have gone wrong:36
1 Basic Concepts
we cannot use assumptions as input to generalization, for, as we have already re-
marked, this rule does not preserve satisÔ¨Åability. Generalization is there to enable
us to generate new validities from old. It is not a local rule of inference.
For many purposes, K is too weak. If we are interested in transitive frames, we
would like a proof system which reÔ¨Çects this. For example, we know that 33p ‚Üí
3p is valid on all transitive frames, so we would want a proof system that generates
this formula; K does not do this, for 33p ‚Üí 3p is not valid on all frames.
But we can extend K to cope with many such restrictions by adding extra ax-
ioms. For example, if we enrich K by adding 33p ‚Üí 3p as an axiom, we obtain
the Hilbert system called K4. As we will show in Theorem 4.27, K4 is sound and
complete with respect to the class of all transitive frames (that is, it generates pre-
cisely the formulas valid on transitive frames). More generally, given any set of
modal formulas Œì , we are free to add them as extra axioms to K, thus forming the
axiom system KŒì. As we will learn in Chapter 4, in many important cases it is
possible to characterize such extensions in terms of frame validity.
One Ô¨Ånal issue remains to be discussed: do such axiomatic extensions of K give
us a grip on semantic consequence, and in particular, the local semantic conse-
quence relation over classes of frames (see DeÔ¨Ånition 1.35)?
In many important cases they do. Here is the basic idea. Suppose we are inter-
ested in transitive frames, and are working with K4. We capture the notion of local
consequence over transitive frames in K4 as follows. Let Œ£ be a set of formulas,
and œÜ a formula. Then we say that œÜ is a local syntactic consequence of Œ£ in K4
(notation: Œ£ K4 œÜ) if and only if there is some Ô¨Ånite subset {œÉ1 , . . . , œÉn } of Œ£
such that K4 œÉ1 ‚àß ¬∑ ¬∑ ¬∑ ‚àß œÉn ‚Üí œÜ. In Theorem 4.27 we will show that
Œ£ K4 œÜ iff Œ£ Tran œÜ,
where Tran denotes local semantic consequence over transitive frames. In short,
we have reduced the local semantic consequence relation over transitive frames to
provability in K4.
DeÔ¨Ånition 1.42 (Normal Modal Logics) A normal modal logic Œõ is a set of for-
mulas that contains all tautologies, 2(p ‚Üí q) ‚Üí (2p ‚Üí 2q), and 3p ‚Üî ¬¨2¬¨p,
and that is closed under modus ponens, uniform substitution and generalization.
We call the smallest normal modal logic K.
This deÔ¨Ånition is a direct abstraction from the ideas underlying modal Hilbert sys-
tems. It throws away all talk of proof sequences and concentrates on what is really
essential: the presence of axioms and closure under the rules of proof.
We will rarely mention Hilbert systems again: we prefer to work with the more
abstract notion of normal modal logics. For a start, although the two approaches
are equivalent (see Exercise 1.6.6), it is simpler to work with the set-theoretical1.7 Historical Overview
37
notion of membership than with proof sequences. More importantly, in Chapters 4
and 5 we will prove results that link the semantic and syntactic perspectives on
modal logic. These results will hold for any set of formulas fulÔ¨Ålling the normality
requirements. Such a set might be the formulas generated by a Hilbert-style proof
system ‚Äì but it could just as well be the formulas provable in a natural-deduction
system, a sequent system, a tableaux system, or a display calculus. Finally, the
concept of a normal modal logic makes good semantic sense: for any class of
frames F, we have that ŒõF , the set of formulas valid on F, is a normal modal logic;
see Exercise 1.6.7.
Exercises for Section 1.6
1.6.1 Give K-proofs of (2p ‚àß 3q) ‚Üí 3(p ‚àß q) and 3(p ‚à® q) ‚Üî (3p ‚à® 3q).
1.6.2 Let œÜ‚àí be the ‚Äòdemodalized‚Äô version of a modal formula œÜ; that is, œÜ ‚àí is obtained
from œÜ by simply erasing all diamonds. Prove that œÜ ‚àí is a propositional tautology when-
ever œÜ is K-provable. Conclude that not every modal formula is K-provable.
1.6.3 The axiom system known as S4 is obtained by adding the axiom p ‚Üí 3p to K4.
Show that S4 p ‚Üí 23p; that is, show that S4 does not prove this formula. (Hint: Ô¨Ånd an
appropriate class of frames for which S4 is sound.) If we add this formula as an axiom to
S4 we obtain the system called S5. Give an S5-proof of 32p ‚Üí 2p.
1.6.4 Try adapting K to obtain a minimal Hilbert system for the basic temporal language.
Does your system cope with the fact that we only interpret this language on bidirectional
frames? Then try and deÔ¨Åne a minimal Hilbert system for the language of propositional
dynamic logic.
1.6.5 This exercise is only for readers who like syntactical manipulations and have a lot
of time to spare. KL is the axiomatization obtained by adding the L√∂b formula 2(2p ‚Üí
p) ‚Üí 2p as an extra axiom to K. Try and Ô¨Ånd a KL proof of 2p ‚Üí 22p. That is, show
that KL = KL4.
1.6.6 In Chapter 4 we will use KŒì to denote the smallest normal modal logic containing
Œì ; the point of the present exercise is to relate this notation to our discussion of Hilbert
systems. So (as discussed above) suppose we form the axiom system KŒì by adding as
axioms all the formulas in Œì to K. Show that the Hilbert system KŒì proves precisely the
formulas contained in the normal modal logic KŒì.
1.6.7 Let F be a class of frames. Show that Œõ F is a normal modal logic.
1.7 Historical Overview
The ideas introduced in this chapter have a long history. They evolved as responses
to particular problems and challenges, and knowing something of the context in38
1 Basic Concepts
which they arose will make it easier to appreciate why they are considered im-
portant, and the way they will be developed in subsequent chapters. Some of the
discussion that follows may not be completely accessible at this stage. If so, do not
worry. Just note the main points, and try again once you have explored the chapters
that follow.
We Ô¨Ånd it useful to distinguish three phases in the development of modal logic:
the syntactic era, the classical era, and the modern era. Roughly speaking, most of
the ideas introduced in this chapter stem from the classical era, and the remainder
of the book will explore them from the point of view of the modern era.
The syntactic era (1918‚Äì1959)
We have opted for 1918, the year that C.I. Lewis published his Survey of Symbolic
Logic [299], as the birth of modal logic as a mathematical discipline. Lewis was
certainly not the Ô¨Årst to consider modal reasoning, indeed he was not even the
Ô¨Årst to construct symbolic systems for this purpose: Hugh MacColl, who explored
the consequences of enriching propositional logic with operators  (‚Äòit is certain
that‚Äô) and Œ∑ (‚Äòit is impossible that‚Äô) seems to have been the Ô¨Årst to do that (see
his book Symbolic Logic and its Applications [305], and for an overview of his
work, see [369]). But MacColl‚Äôs work is Ô¨Årmly rooted in the nineteenth century
algebraic tradition of logic (well-known names in this tradition include Boole, De
Morgan, Jevons, Peirce, Schr√∂der, and Venn), and linking MacColl‚Äôs contributions
to contemporary concerns is a non-trivial scholarly task. The link between Lewis‚Äôs
work and contemporary modal logic is more straightforward.
In his 1918 book, Lewis extended propositional calculus with a unary modality
I (‚Äòit is impossible that‚Äô) and deÔ¨Åned the binary modality œÜ ‚â∫ œà (œÜ strictly implies
œà) to be I(œÜ ‚àß ¬¨œà). Strict implication was meant to capture the notion of logical
entailment, and Lewis presented a ‚â∫-based axiom system. Lewis and Langford‚Äôs
joint book Symbolic Logic [300], published in 1932, contains a more detailed de-
velopment of Lewis‚Äôs ideas. Here 3 (‚Äòit is possible that‚Äô) is primitive and œÜ ‚â∫ œà
is deÔ¨Åned to be ¬¨3(œÜ ‚àß ¬¨œà). Five axiom systems of ascending strength, S1‚ÄìS5,
are discussed; S3 is equivalent to Lewis‚Äôs system of 1918, and only S4 and S5 are
normal modal logics. Lewis‚Äôs work sparked interest in the idea of ‚Äòmodalizing‚Äô
propositional logic, and there were many attempts to axiomatize such concepts as
obligation, belief and knowledge. Von Wright‚Äôs monograph An Essay in Modal
Logic [464] is an important example of this type of work.
But in important respects, Lewis‚Äôs work seems strange to modern eyes. For a
start, his axiomatic systems are not modular. Instead of extending a base system of
propositional logic with speciÔ¨Åcally modal axioms (as we did in this chapter when
we deÔ¨Åned K), Lewis deÔ¨Ånes his axioms directly in terms of ‚â∫. The modular
approach to modal Hilbert systems is due to Kurt G√∂del. G√∂del [175] showed1.7 Historical Overview
39
that (propositional) intuitionistic logic could be translated into S4 in a theorem-
preserving way. However instead of using the Lewis and Langford axiomatization,
G√∂del took 2 as primitive and formulated S4 in the way that has become standard:
he enriched a standard system for classical propositional logic with the rule of
generalization, the K axiom, and the additional axioms (2p ‚Üí p and 2p ‚Üí 22p).
But the fundamental difference between current modal logic and the work of
Lewis and his contemporaries is that the latter is essentially syntactic. Propositional
logic is enriched with some new modality. By considering various axioms, the
logician tries to pin down the logic of the intended interpretation. This simple view
of logical modeling has its attractions, but is open to serious objections. First, there
are technical difÔ¨Åculties. Suppose we have several rival axiomatizations of some
concept. Forget for now the problem of judging which is the best, for there is a
more basic difÔ¨Åculty: how can we tell if they are really different? If we only have
access to syntactic ideas, proving that two Hilbert systems generate different sets
of formulas can be extremely difÔ¨Åcult. Indeed, even showing syntactically that two
Hilbert systems generate the same set of formulas can be highly non-trivial (recall
Exercise 1.6.5).
Proving distinctness theorems was standard activity in the syntactic era; for in-
stance, Parry [355] showed that S2 and S3 are distinct, and papers addressing such
problems were common till the late 1950s. Algebraic methods were often used to
prove distinctness. The propositional symbols would be viewed as denoting the
elements of some algebra, and complex formulas would be interpreted using the
algebraic operations. Indeed, algebras were the key tool driving the technical de-
velopment of the period. For example, McKinsey [322] used them to analyze S2
and S4 and show their decidability; McKinsey and Tarski [324, 325] and McKin-
sey [323] extended this work in a variety of directions (giving, among other things,
a topological interpretation of S4); while Dummett and Lemmon [117] built on this
work to isolate and analyze S4.2 and S4.3, two important normal logics between
S4 and S5. But for all their technical utility, algebraic methods seemed of limited
help in providing reliable intuitions about modal languages and their associated
logics. Sometimes algebraic elements were viewed as multiple truth values. But
Dugundji [116] showed that no logic between S1 and S5 could be viewed as an
n-valued logic for Ô¨Ånite n, so the multi-valued perspective on modal logic was not
suited as a reliable source of insight.
The lack of a natural semantics brings up a deeper problem facing the syntac-
tic approach: how do we know we have considered all the relevant possibilities?
Nowadays the normal logic T (that is, K enriched with the axiom p ‚Üí 3p) would
be considered a fundamental logic of possibility; but Lewis overlooked T (it is
intermediate between S2 and S4 and neither contains nor is contained by S3).
Moreover, although Lewis did isolate two logics still considered important (namely
S4 and S5), how could he claim that either system was, in any interesting sense,40
1 Basic Concepts
complete? Perhaps there are important axioms missing from both systems? The
existence of so many competing logics should make us skeptical of claims that it
is easy to Ô¨Ånd all the relevant axioms and rules; and without precise, intuitively
acceptable, criteria of what the reasonable logics are (in short, the type of crite-
ria a decent semantics provides us with) we have no reasonable basis for claiming
success.
For further discussion of the work of this period, the reader should consult the
historical section of Bull and Segerberg [75]). We close our discussion of the syn-
tactic era by noting three lines of work that anticipate later developments: Carnap‚Äôs
state-description semantics, Prior‚Äôs work on temporal logic, and the J√≥nsson and
Tarski Representation Theorem for boolean algebras with operators.
A state description is simply a collection of propositional letters. (Actually,
Carnap used state descriptions in his pioneering work on Ô¨Årst-order modal logic,
so a state for Carnap could be a set of Ô¨Årst-order formulas.) If S is a collection of
state descriptions, and s ‚àà S, then a propositional symbol p is satisÔ¨Åed at s if and
only if p ‚àà s. Boolean operators are interpreted in the obvious way. Finally, 3œÜ is
satisÔ¨Åed at s ‚àà S if and only if there is some s ‚àà S such that s satisÔ¨Åes œÜ. (See,
for example, Carnap [85, 86].)
Carnap‚Äôs interpretation of 3œÜ in state descriptions is strikingly close to the idea
of satisfaction in models. However one crucial idea is missing: the use of an
explicit relation R over state descriptions. In Carnap‚Äôs semantics, satisfaction for
3 is deÔ¨Åned in terms of membership in S (in effect, R is taken to be S √ó S). This
implicit Ô¨Åxing of R reduces the utility of his semantics: it yields a semantics for
one Ô¨Åxed interpretation of 3, but deprives us of the vital parameter needed to map
logical options.
Arthur Prior founded temporal logic (or as he called it, tense logic) in the early
1950s. He invented the basic temporal language and many other temporal lan-
guages, both modal and non-modal. Like most of his contemporaries, Prior viewed
the axiomatic exploration of concepts as one of the logician‚Äôs key tasks. But there
the similarity ends: his writings are packed with an extraordinary number of se-
mantic ideas and insights. By 1955 Prior had interpreted the basic modal lan-
guage in models based on (œâ, <) (see Prior [364], and Chapter 2 of Prior [365]),
and used what would now be called soundness arguments to distinguish logics.
Moreover, the relative expressivity of modal and classical languages (such as the
Prior-Meredith U-calculus [327]) is a constant theme of his writings; indeed, much
of his work anticipates later work in correspondence theory and extended modal
logic. His work is hard to categorize, and impossible to summarize, but one thing
is clear: because of his inÔ¨Çuence temporal logic was an essentially semantically
driven enterprise. The best way into his work is via Prior [365].
With the work of J√≥nsson and Tarski [255, 256] we reach the most important
(and puzzling) might-have-beens in the history of modal logic. BrieÔ¨Çy, J√≥nsson1.7 Historical Overview
41
and Tarski investigated the representation theory of boolean algebras with operators
(that is, modal algebras). As we have remarked, while modal algebras were useful
tools, they seemed of little help in guiding logical intuitions. The representation
theory of J√≥nsson and Tarski should have swept this apparent shortcoming away for
good, for in essence they showed how to represent modal algebras as the structures
we now call models! In fact, they did a lot more than this. Their representation
technique is essentially a model building technique, hence their work gave the
technical tools needed to prove the completeness result that dominated the classical
era (indeed, their approach is an algebraic analog of the canonical model technique
that emerged 15 years later). Moreover, they provided all this for modal languages
of arbitrary similarity type, not simply the basic modal language.
Unfortunately, their work was overlooked for 20 years; not until the start of the
modern era was its signiÔ¨Åcance appreciated. It is unclear to us why this happened.
Certainly it did not help matters that J√≥nsson and Tarski do not mention modal
logic in their classic article; this is curious since Tarski had already published joint
papers with McKinsey on algebraic approaches to modal logic. Maybe Tarski did
not see the connection at all: Copeland [97, page 13] writes that Tarski heard
Kripke speak about relational semantics at a 1962 talk in Finland, a talk in which
Kripke stressed the importance of the work by J√≥nsson and Tarski. According to
Kripke, following the talk Tarski approached him and said he was unable to see
any connection between the two lines of work.
Even if we admit that a connection which now seems obvious may not have
been so at the time, a puzzle remains. Tarski was based in California, which in
the 1960s was the leading center of research in modal logic, yet in all those years,
the connection was never made. For example, in 1966 Lemmon (also based in
California) published a two part paper on algebraic approaches to modal logic [295]
which reinvented (some of) the ideas in J√≥nsson and Tarski (Lemmon attributes
these ideas to Dana Scott), but only cites the earlier Tarski and McKinsey papers.
We present the work by J√≥nsson and Tarski in Chapter 5; their Representation
Theorem underpins the work of the entire chapter.
The classical era (1959‚Äì1972)
‚ÄòRevolutionary‚Äô is an overused word, but no other word adequately describes the
impact relational semantics (that is, the concepts of frames, models, satisfaction,
and validity presented in this chapter) had on the study of modal logic. Problems
which had previously been difÔ¨Åcult (for example, distinguishing Hilbert systems)
suddenly yielded to straightforward semantic arguments. Moreover, like all revolu-
tions worthy of the name, the new world view came bearing an ambitious research
program. Much of this program revolved around the concept of completeness: at
last is was possible to give a precise and natural meaning to claims that a logic gen-42
1 Basic Concepts
erated everything it ought to. (For example, K4 could now be claimed complete
in a genuinely interesting sense: it generated all the formulas valid on transitive
frames.) Such semantic characterizations are both simple and beautiful (especially
when viewed against the complexities of the preceding era) and the hunt for such
results was to dominate technical work for the next 15 years. The two outstanding
monographs of the classical era ‚Äì the existing fragment of Lemmon and Scott‚Äôs An
Introduction to Modal Logic [296], and Segerberg‚Äôs An Essay in Classical Modal
Logic [404] ‚Äì are largely devoted to completeness issues.
Some controversy attaches to the birth of the classical era. BrieÔ¨Çy, relational
semantics is often called Kripke semantics, and Kripke [283] (in which S5-based
modal predicate logic is proved complete with respect to models with an implicit
global relation), Kripke [284] (which introduces an explicit accessibility relation R
and gives semantic characterization of some propositional modal logics in terms of
this relation) and Kripke [285] (in which relational semantics for Ô¨Årst-order modal
languages is deÔ¨Åned) were crucial in establishing the relational approach: they are
clear, precise, and ever alert to the possibilities inherent in the new framework: for
example, Kripke [285] discusses provability interpretations of propositional modal
languages. Nonetheless, Hintikka had already made use of relational semantics to
analyze the concept of belief and distinguish logics, and Hintikka‚Äôs ideas played
an important role in establishing the new paradigm in philosophical circles; see,
for example, [224]. Furthermore, it has since emerged that Kanger, in a series of
papers and monographs published in 1957, had introduced the basic idea of rela-
tional semantics for propositional and Ô¨Årst-order modal logic; see, for example,
Kanger [261, 262]. And a number of other authors (such as Arthur Prior, and
Richard Montague [335]) had either published or spoken about similar ideas ear-
lier. Finally, the fact remains that J√≥nsson and Tarski had already presented and
generalized the mathematical ideas needed to analyze propositional modal logics.
But disputes over priority should not distract the reader from the essential point:
somewhere around 1960 modal logic was reborn as a new Ô¨Åeld, acquiring new
questions, methods, and perspectives. The magnitude of the shift, not who did
what when, is what is important here. (The reader interested in more detail on who
did what when, should consult Goldblatt [182]. Incidentally, Goldblatt concludes
that Kripke‚Äôs contributions were the most signiÔ¨Åcant.)
So by the early 1960s it was clear that relational semantics was an important tool
for classifying modal logics. But how could its potential be unlocked? The key tool
required ‚Äì the canonical models we discuss in Chapter 4 ‚Äì emerged with surpris-
ing speed. They seem to have Ô¨Årst been used in Makinson [307] and in Cress-
well [99] (although Cresswell‚Äôs so-called subordination relation differs slightly
from the canonical relation), and in Lemmon and Scott [296] they appear full-
Ô¨Çedged in the form that has become standard.
Lemmon and Scott [296] is a fragment of an ambitious monograph that was in-1.7 Historical Overview
43
tended to cover all then current branches of modal logic. At the time of Lemmon‚Äôs
death in 1966, however, only the historical introduction and the chapter on the ba-
sic modal languages had been completed. Nonetheless, it is a gem. Although for
the next decade it circulated only in manuscript form (it was not published until
1977) it was enormously inÔ¨Çuential, setting much of the agenda for subsequent
developments. It unequivocally established the power of the canonical model tech-
nique, using it to prove general results of a sort not hitherto seen. It also introduced
Ô¨Åltrations, an important technique for building Ô¨Ånite models we will discuss in
Chapter 2, and used them to prove a number of decidability results.
While Lemmon and Scott showed how to exploit canonical models directly,
many important normal logics (notably, KL and the modal and temporal logic of
structures such as (N, <), (Z, <), (Q, <), and (R, <), and their reÔ¨Çexive counter-
parts) cannot be analyzed in this way. However, as Segerberg [403, 404] showed,
it is possible to use canonical models indirectly: one can transform the canonical
model into the required form and prove these (and a great many other) complete-
ness results. Segerberg-style transformation proofs are discussed in Section 4.5.
But although completeness and canonical models were the dominant issues of
the classical era, there is a small body of work which anticipates more recent
themes. For example, Robert Bull, swimming against the tide of fashion, used
algebraic arguments to prove a striking result: all normal extensions of S4.3 are
characterized by classes of Ô¨Ånite models (see Bull [74]). Although model-theoretic
proofs of Bull‚Äôs Theorem were sought (see, for example, Segerberg [404, page
170]), not until Fine [128] did these efforts succeed. Kit Fine was shortly to play a
key role in the birth of the modern era, and the technical sophistication which was
to characterize his later work is already evident in this paper; we discuss Fine‚Äôs
proof in Theorem 4.96. As a second example, in his 1968 PhD thesis [258], Hans
Kamp proved one of the few (and certainly the most interesting) expressivity results
of the era. He deÔ¨Åned two natural binary modalities, since and until (discussed in
Chapter 7), showed that the standard temporal language was not strong enough to
deÔ¨Åne them, and proved that over Dedekind continuous strict total orders (such as
(R, <)) his new modalities offered full Ô¨Årst-order expressive power.
Summing up, the classical era supplied many of the fundamental concepts and
methods used in contemporary modal logic. Nonetheless, viewed from a modern
perspective, it is striking how differently these ideas were put to work then. For
a start, the classical era took over many of the goals of the syntactic era. Modal
investigations still revolved round much the same group of concepts: necessity,
belief, obligation and time. Moreover, although modal research in the classical era
was certainly not syntactical, it was, by and large, syntactically driven. That is ‚Äì
with the notable exception of the temporal tradition ‚Äì relational semantics seems
to have been largely viewed as a tool for analyzing logics: soundness results could
distinguish logics, and completeness results could give them nice characterizations.44
1 Basic Concepts
Relational structures, in short, were not really there to be described ‚Äì they were
there to fulÔ¨Åll an analytic role. (This goes a long way towards explaining the lack
of expressivity results for the basic modal language; Kamp‚Äôs result, signiÔ¨Åcantly,
was grounded in the Priorean tradition of temporal logic.) Moreover, it was a self-
contained world in a way that modern modal logic is not. Modal languages and
relational semantics: the connection between them seemed clear, adequate, and
well understood. Surely nothing essential was missing from this paradise?
The modern era (1972‚Äìpresent)
Two forces gave rise to the modern era: the discovery of frame incompleteness re-
sults, and the adoption of modal languages in theoretical computer science. These
unleashed a wealth of activity which profoundly changed the course of modal logic
and continues to inÔ¨Çuence it till this day. The incompleteness results forced a fun-
damental reappraisal of what modal languages actually are, while the inÔ¨Çuence of
theoretical computer science radically changed expectations of what they could be
used for, and how they were to be applied.
Frame-based analyses of modal logic were revealing and intoxicatingly success-
ful ‚Äì but was every normal logic complete with respect to some class of frames?
Lemmon and Scott knew that this was a difÔ¨Åcult question; they had shown, for
example, that there were obstacles to adapting the canonical model method to ana-
lyze the logic yielded by the McKinsey axiom. Nonetheless, they conjectured that
the answer was yes:
However, it seems reasonable to conjecture that, if a consistent normal K-
system S is closed with respect to substitution instances . . . then S determines
a class ŒìS of world systems such that S A iff |=ŒìS A. We have no proof of
this conjecture. But to prove it would be to make a considerable difference to
our theoretical understanding of the general situation. [296, page 76]
Other optimistic sentiments can be found in the literature of the period. Segerberg‚Äôs
thesis is more cautious, simply identifying it as ‚Äòprobably the outstanding question
in this area of modal logic at the present time‚Äô [404, page 29].
The question was soon resolved ‚Äì negatively. In 1972, S.K. Thomason [433]
showed that there were incomplete normal logics in the basic temporal language,
and in 1974 Thomason [434] and Fine [129] both published examples of incom-
plete normal logics in the basic modal language. Moreover, in an important series
of papers Thomason showed that these results were ineradicable: as tools for talk-
ing about frames, modal languages were essentially monadic second-order logic in
disguise, and hence were intrinsically highly complex.
These results stimulated what remains some of the most interesting and innova-
tive work in the history of the subject. For a start, it was now clear that it no longer1.7 Historical Overview
45
sufÔ¨Åced to view modal logic as an isolated formal system; on the contrary, it was
evident that a full understanding of what modal languages were, required that their
position in the logical universe be located as accurately as possible. Over the next
few years, modal languages were to be extensively mapped from the perspective of
both universal algebra and classical model theory.
Thomason [433] had already adopted an algebraic perspective on the basic tem-
poral language. Moreover, this paper introduced general frames, showed that
they were equivalent to semantics based on boolean algebras with operators, and
showed that these semantics were complete in a way that the frame-based seman-
tics was not: every normal temporal logic was characterized by some algebra.
Goldblatt introduced the universal algebraic approach towards modal logic and
developed modal duality theory (the categorical study of the relation between rela-
tional structures endowed with topological structure on the one hand, and boolean
algebras with operators on the other). This led to a belated appreciation of the
fundamental contributions made in J√≥nsson and Tarski‚Äôs pioneering work. Gold-
blatt and Thomason showed that the concepts and results of universal algebra could
be applied to yield modally interesting results; the best known example of this is
the Goldblatt-Thomason Theorem, a model theoretic characterization of modally
deÔ¨Ånable frame classes obtained by applying the Birkhoff Variety Theorem to
boolean algebras with operators. We discuss such work in Chapter 5 (and in Chap-
ter 3 we discuss the Goldblatt-Thomason Theorem from the perspective of Ô¨Årst-
order model theory). Work by Blok made deeper use of algebras, and universal
algebra became a key tool in the exploration of completeness theory. The revival
of algebraic semantics ‚Äì together with a genuine appreciation of why it was so
important ‚Äì is one of the most enduring legacies of this period.
But the modern period also Ô¨Årmly linked modal languages with classical model
theory. One line of inquiry that led naturally in this direction was the following:
given that modal logic was essentially second-order in nature, why was it so often
Ô¨Årst-order, and very simple Ô¨Årst-order at that? That is, from the modern perspec-
tive, incomplete normal logics were to be expected ‚Äì it was the elegant results of
the classical period that now seemed in need of explanation. One type of answer
was given in the work of Sahlqvist [396], who isolated a large set of axioms which
guaranteed completeness with respect to Ô¨Årst-order deÔ¨Ånable classes of frames.
(We deÔ¨Åne the Sahlqvist fragment in Section 3.6, where we discuss the Sahlqvist
Correspondence Theorem, an expressivity result. The twin Sahlqvist Complete-
ness Theorem is proved algebraically in Theorem 5.91.) Another type of answer
was developed in Fine [132] and van Benthem [40, 41]; we discuss this work (albeit
from an algebraic perspective) in Chapter 5.
A different line of work also linked modal and classical languages: an investiga-
tion of modal languages viewed purely as description languages. The classical era
largely ignored expressivity in favor of completeness, but the Sahlqvist Correspon-46
1 Basic Concepts
dence Theorem showed the narrowness of this perspective: a beautiful result about
the basic modal language that did not even mention normal modal logics! Ex-
pressivity issues were subsequently studied by van Benthem, who developed the
subject now known as correspondence theory, along two main lines; see [42, 43].
One views modal languages as tools for describing frames (that is, as second-order
description languages) and probes their expressive power. This line of investiga-
tion, together with Sahlqvist‚Äôs work, forms the basis of Chapter 3. The second line
explores modal languages as tools for talking about models, an intrinsically Ô¨Årst-
order perspective. This lead van Benthem to isolate the concept of a bisimulation,
and prove the fundamental Characterization Theorem: viewed as a tool for talk-
ing about models, modal languages are the bisimulation invariant fragment of the
corresponding Ô¨Årst-order language. Bisimulation driven investigations of modal
expressivity are now standard, and much of Chapter 2 is devoted to such issues.
The impact of theoretical computer science was less dramatic than the discov-
ery of the incompleteness results, but its inÔ¨Çuence has been equally profound.
Burstall [82] already suggests using modal logic to reason about programs, but the
birth of this line of work really dates from Pratt [362] (the paper which gave rise
to PDL) and Pnueli [359] (which suggested using temporal logic to reason about
execution-traces of programs). Computer scientists tended to develop powerful
modal languages; PDL in its many variants is an obvious example (see Harel [209]
for a detailed survey). And since the appearance of Gabbay et al. [160] the tempo-
ral languages used by computer scientists typically contain the until operator, and
often additional operators which are evaluated with respect to paths (see Clarke
and Emerson [94]). Gabbay also noted the signiÔ¨Åcance of Rabin‚Äôs Theorem [368]
for modal decidability (we discuss this in Chapter 6), and applied it to a wide range
of languages and logics; see Gabbay [145, 146, 147].
Computer scientists brought a new array of questions to the study of modal logic.
For a start, they initiated the study of the computational complexity of normal log-
ics. Already by 1977 Ladner [292] had showed that every normal logic between K
and S4 had a PSPACE-hard satisÔ¨Åability problem, while the results of Fischer and
Ladner [135] and Pratt [363] together show that PDL has an EXPTIME-complete
satisÔ¨Åability problem. (These results are proved in Chapter 6.) Moreover, the in-
terest of the modal expressivity studies emerging in correspondence theory was
reinforced by several lines of work in computer science. To give one particularly
nice example, computer scientists studying concurrent systems independently iso-
lated the notion of bisimulation (see Park [354]). This paved the way for the work
of Hennessy and Milner [219] who showed that weak modal languages could be
used to classify various notions of process invariance.
But one of the most signiÔ¨Åcant endowments from computer science has actu-
ally been something quite simple: it has helped remove a lingering tendency to see
modal languages as intrinsically ‚Äòintensional‚Äô formalisms, suitable only for ana-1.7 Historical Overview
47
lyzing such concepts as knowledge, obligation and belief. During the 1990s this
point was strongly emphasized when connections were discovered between modal
logic and knowledge representation formalisms. In particular, description logics
are a family of languages that come equipped with effective reasoning methods,
and a special focus on balancing expressive power and computational and algo-
rithmic complexity; see Donini et al. [115]. The discovery of this connection has
lead to a renewed focus on efÔ¨Åcient reasoning methods, dedicated languages that
are Ô¨Åne-tuned for speciÔ¨Åc modeling tasks, and a variety of novel uses of modal
languages; see Schild [400] for the Ô¨Årst paper to make the connection between the
two Ô¨Åelds, and De Giacomo [106], Areces [12], and Areces and de Rijke [15] for
work exploiting the connection.
And this is but one example. Links with computer science and other disciplines
have brought enormous richness and variety to modal logic. Computer science has
seen a shift of emphasis from isolated programs to complex entities collaborating
in heterogeneous environments; this gives rise to new challenges for the use of
modal logic in theoretical computer science. For instance, agent-based theories
require Ô¨Çexible modeling facilities together with efÔ¨Åcient reasoning mechanisms;
see Wooldridge and Jennings [463] for a discussion of the agent paradigm, and
Bennet et al. [34] for the link with modal logic. More generally, complex com-
putational architectures call for a variety of combinations of modal languages; see
the proceedings of the Frontiers of Combining Systems workshop series for refer-
ences [16, 152, 268].
Similar developments took place in foundational research in economics. Game
theory (Osborne and Rubinstein [350]) also shows a nice interplay between the no-
tions of action and knowledge; recent years have witnessed an increasing tendency
to give a formal account of epistemic notions; see Battigalli and Bonanno [31] or
Kaneko and Nagashima [260]. For modal logics that combine dynamic and epis-
temic notions to model games we refer to Baltag [21] and van Ditmarsch [109].
Further examples abound. Database theory continues to be a fruitful source
of questions for logicians, modal or otherwise. For instance, developments in
temporal databases have given rise to new challenges for temporal logicians (see
Finger [134]), while description logicians have found new applications for their
modeling and reasoning methods in the area of semistructured data (see Calvanese
et al. [84]). In the related, but more philosophically oriented area of belief re-
vision, Fuhrmann [144] has given a modal formalization of one of the most in-
Ô¨Çuential approaches in the area, the AGM approach [4]. Authors such as Fried-
man and Halpern [142], Gerbrandy and Groeneveld [170], de Rijke [384], and
Segerberg [410] have discussed various alternative modal formalizations.
Cognitive phenomena have long been of interest to modal logicians. This is clear
from examples such as belief revision, but perhaps even more so from language-
related work in modal logic. The feature logic mentioned in Example 1.17 is but48
1 Basic Concepts
one example; authors such as Blackburn, Gardent, Meyer-Viol, and Spaan [61, 58],
Kasper and Rounds [266, 394], Kracht [280], Kurtonina [287], and Reape [376]
have offered a variety of modal logical perspectives on grammar formalisms. Oth-
ers have analyzed the semantics of natural language by modal means; see Fer-
nando [126] for a sample of modern work along these lines.
During the 1980s and 1990s a number of new themes on the interface of modal
logic and mathematics received considerable attention. One of these themes con-
cerns links between modal logic and non-wellfounded set theory; work that we
should mention here includes Aczel [2], Barwise and Moss [27], and Baltag [20,
22]; see the Notes to Chapter 2 for further discussion. Non-well-founded sets and
many other notions, such as automata and labeled transition systems, have been
brought together under the umbrella of co-algebras (see Jacobs and Rutten [242]),
which form a natural and elegant way to model state-based dynamic systems. Since
it was discovered that modal logic is as closely related to co-algebras as equational
logic is to algebras, there has been a wealth of results reporting on this connection;
we only mention Jacobs [241], Kurz [290] and R√∂√üiger [393] here.
Another 1990s theme on the interface of modal logic and mathematics concerns
an old one: geometry. Work by Balbiani et al. [19], Stebletsova [423] and Ven-
ema [448] indicates that modal logic may have interesting things to say about ge-
ometry, while Aiello and van Benthem [3] and Lemon and Pratt [297] investigate
the potential of modal logic as a tool for reasoning about space.
As should now be clear to all our readers, the simple question posed by the modal
satisfaction deÔ¨Ånition ‚Äì what happens at accessible states? ‚Äì gives us a natural
way of working with any relational structure. This has opened up a host of new
applications for modal logic. Moreover, once the relational perspective has been
fully assimilated, it opens up rich new approaches to traditional subjects: see van
Benthem [45] and Fagin, Halpern, Moses, and Vardi [125] for thoroughly modern
discussions of temporal logic and epistemic logic respectively.
1.8 Summary of Chapter 1
 Relational Structures: A relational structure is a set together with a collection
of relations. Relational structures can be used to model key ideas from a wide
range of disciplines.
 Description Languages: Modal languages are simple languages for describing
relational structures.
 Similarity Types: The basic modal language contains a single primitive unary
operator 3. Modal languages of arbitrary similarity type may contain many
modalities  of arbitrary arity.
 Basic Temporal Language: The basic temporal language has two operators F1.8 Summary of Chapter 1
49
and P whose intended interpretations are ‚Äòat some time in the future‚Äô and ‚Äòat
some time in the past.‚Äô
 Propositional Dynamic Logic: The language of propositional dynamic logic
has an inÔ¨Ånite collection of modal operators indexed by programs œÄ built up
from atomic programs using union ‚à™, composition ; and iteration ‚àó ; additional
constructors such as intersection ‚à© and test ? may also be used. The intended
interpretation of œÄœÜ is ‚Äòsome terminating execution of program œÄ leads to a
state where œÜ holds.‚Äô
 Arrow Logic: The language of arrow logic is designed to talk about any object
that may be represented by arrows; it has a modal constant 1‚Äô (‚Äòskip‚Äô), a unary
operator ‚äó (‚Äòconverse‚Äô), and a dyadic operator ‚ó¶ (‚Äòcomposition‚Äô).
 Satisfaction: The satisfaction deÔ¨Ånition is used to interpret formulas inside mod-
els. This satisfaction deÔ¨Ånition has an obvious local Ô¨Çavor: modalities are inter-
preted as scanning the states accessible from the current state.
 Validity: A formula is valid on a frame when it is globally true, no matter what
valuation is used. This concept allows modal languages to be viewed as lan-
guages for describing frames.
 General Frames: Modal languages can also be viewed as talking about general
frames. A general frame is a frame together with a set of admissible valuations.
General frames offer some of the advantages of both models and frames and are
an important technical tool.
 Semantic Consequence: Semantic consequence relations for modal languages
need to be relativized to classes of structures. The classical idea that the truth
of the premises should guarantee the truth of the conclusion can be interpreted
either locally or globally. In this book we almost exclusively use the local inter-
pretation.
 Normal Modal Logics: Normal modal logics are the unifying concept in modal
proof theory. Normal modal logics contain all tautologies, the K axiom and the
Dual axiom; in addition they should be closed under modus ponens, uniform
substitution and generalization.2
Models
In Section 1.3 we deÔ¨Åned what it means for a formula to be satisÔ¨Åed at a state in
a model ‚Äì but as yet we know virtually nothing about this fundamental semantic
notion. What exactly can we say about models when we use modal languages
to describe them? Which properties of models can modal languages express, and
which lie beyond their reach?
In this chapter we examine such questions in detail. We introduce disjoint
unions, generated submodels, bounded morphisms, and ultraÔ¨Ålter extensions, the
‚Äòbig four‚Äô operations on models that leave modal satisfaction unaffected. We dis-
cuss two ways to obtain Ô¨Ånite models and show that modal languages have the Ô¨Ånite
model property. Moreover, we deÔ¨Åne the standard translation of modal logic into
Ô¨Årst-order logic, thus opening the door to correspondence theory, the systematic
study of the relationship between modal and classical logic. All this material plays
a fundamental role in later work; indeed, the basic track sections in this chapter are
among the most important in the book.
But the central concept of the chapter is that of a bisimulation between two
models. Bisimulations reÔ¨Çect, in a particularly simple and direct way, the locality
of the modal satisfaction deÔ¨Ånition. We introduce them early on, and they gradually
come to dominate our discussion. By the end of the chapter we will have a good
understanding of modal expressivity over models, and the most interesting results
all hinge on bisimulations.
Chapter guide
Section 2.1: Invariance Results (Basic track). We introduce three classic ways of
constructing new models from old ones that do not affect modal satisfac-
tion: disjoint unions, generated submodels, and bounded morphisms. We
also meet isomorphisms and embeddings.
Section 2.2: Bisimulations (Basic track). We introduce bisimulations and show
that modal satisfaction is invariant under bisimulation. We will see that
502.1 Invariance Results
51
the model constructions introduced in the Ô¨Årst section are all special cases
of bisimulation, learn that modal equivalence does not always imply bisim-
ilarity, and examine an important special case in which it does.
Section 2.3: Finite Models (Basic track). Here we show that modal languages en-
joy the Ô¨Ånite model property. We do so in two distinct ways: by the se-
lection method (Ô¨Ånitely approximating a bisimulation), and by Ô¨Åltration
(collapsing a model into a Ô¨Ånite number of equivalence classes).
Section 2.4: The Standard Translation (Basic track). We start our study of cor-
respondence theory. By deÔ¨Åning the standard translation, we link modal
languages to Ô¨Årst-order (and other classical) languages and raise the two
central questions that dominate later sections: What part of Ô¨Årst-order logic
does modal logic correspond to? And which properties of models are de-
Ô¨Ånable by modal means?
Section 2.5: Modal Saturation via UltraÔ¨Ålter Extensions (Basic track). The Ô¨Årst
step towards obtaining some answers is to introduce ultraÔ¨Ålter extensions,
the last of the big four modal model constructions. We then show that al-
though modal equivalence does not imply bisimilarity, it does imply bisim-
ilarity somewhere else, namely in the ultraÔ¨Ålter extensions of the models
concerned.
Section 2.6: Characterization and DeÔ¨Ånability (Advanced track). We prove the
two main results of this chapter. First, we prove van Benthem‚Äôs Theorem
stating that modal languages are the bisimulation invariant fragments of
Ô¨Årst-order languages. Second, we show that modally deÔ¨Ånable classes of
(pointed) models are those that are closed under bisimulations and ultra-
products and whose complements are closed under ultrapowers.
Section 2.7: Simulation and Safety (Advanced track). We prove two results that
give the reader a glimpse of recent work in modal model theory. The Ô¨Årst
describes the properties that are preserved under simulations (a one-way
version of bisimulation), the second characterizes the Ô¨Årst-order deÔ¨Ånable
operations on binary relations which respect bisimilarity.
2.1 Invariance Results
Mathematicians rarely study structures in isolation. They are usually interested in
the relations between different structures, and in operations that build new struc-
tures from old. Questions that naturally arise in such contexts concern the structural
properties that are invariant under, or are preserved by, such relations and opera-
tions. We will not give precise deÔ¨Ånitions of these notions, but roughly speaking, a
property is preserved by a certain relation or operation if, whenever two structures
are linked by the relation or operation, then the second structure has the property2 Models
52
if the Ô¨Årst one has it. We speak of invariance if the property is preserved in both
directions.
Logicians add a descriptive twist to this. For example, modal logicians want to
know when two structures, or perhaps two points in distinct structures, are indis-
tinguishable by modal languages. That is, when do they satisfy exactly the same
modal formulas?
DeÔ¨Ånition 2.1 Let M and M be models of the same modal similarity type œÑ , and
let w and w be states in M and M respectively. The œÑ -theory (or œÑ -type) of w is
the set of all œÑ -formulas satisÔ¨Åed at w: that is, {œÜ | M, w  œÜ}. We say that w and
w are (modally) equivalent (notation: w  w ) if they have the same œÑ -theories.
The œÑ -theory of the model M is the set of all œÑ -formulas satisÔ¨Åed by all states
in M: that is, {œÜ | M  œÜ}. Models M and M are called (modally) equivalent
(notation: M  M ) if their theories are identical.
We now introduce three important ways of constructing new models from old ones
which leave the theories associated with states unchanged: disjoint unions, gen-
erated submodels, and bounded morphisms. These constructions (together with
ultraÔ¨Ålter extensions, which we introduce in Section 2.5) play an important role
throughout the book. For example, in the following chapter we will see that they
lift to the level of frames (where they preserve validity), we will use them repeat-
edly in our work on completeness and complexity, and in Chapter 5 we will see
that they have important algebraic analogs.
Disjoint Unions
Suppose we have the following two models:
'
'
$
w 
vt0
t
M&
v
- t1
$
v
- t2
v
- t3
N
%
%
&
Do not worry that we have not speciÔ¨Åed the valuations ‚Äì they are irrelevant here.
All that matters is that M and N have disjoint domains, for we are now going to
lump them together to form the model M  N:
$
'
w 
t
M  N&
vt0
v
- t1
v
- t2
v
- t3
%
The model M  N is called the disjoint union of M and N. It gathers together all
the information in the two smaller models unchanged: we have not altered the way
the points are related, nor the way atomic information is distributed. Suppose we2.1 Invariance Results
53
are working in the basic modal language, and suppose that a formula œÜ is true at
(say) v1 in N: is œÜ still true at v1 in M  N? More generally, is modal satisfaction
preserved from points in the original models to the points in the disjoint union?
And what about the reverse direction: if a modal formula is true at some state in
M  N, is it also true at that same state in the smaller model it came from?
The answer to these questions is clearly yes: modal satisfaction must be invariant
(that is, preserved in both directions) under the formation of disjoint unions. Modal
satisfaction is intrinsically local: only the points accessible from the current state
are relevant to truth or falsity. If we evaluate a formula œÜ at (say) w, it is completely
irrelevant whether we perform the evaluation in M or M  N; œÜ simply cannot
detect the presence or absence of states in other islands.
DeÔ¨Ånition 2.2 (Disjoint Unions) We Ô¨Årst deÔ¨Åne disjoint unions for the basic
modal language. We say that two models are disjoint if their domains contain
no common elements. For disjoint models Mi = (Wi , Ri , Vi ) (i ‚àà I), their
disjoint union is the structure i Mi = (W, R, V ), where W is the union of
the sets Wi , R is the union of the relations Ri , and for each proposition letter
p, V (p) = i‚ààI Vi (p).
Now for the general case. For disjoint œÑ -structures Mi = (Wi , Ri , Vi )‚ààœÑ
(i ‚àà I) of the same modal similarity type œÑ , their disjoint union is the structure
i Mi = (W, R , V )‚ààœÑ such that W is the union of the sets Wi ; for each  ‚àà œÑ ,
R is the union i‚ààI Ri ; and V is deÔ¨Åned as in the basic modal case.
If we want to put together a collection of models that are not disjoint, we Ô¨Årst
have to make them disjoint (say by indexing the domains of these models). To use
the terminology introduced shortly, we simply take mutually disjoint isomorphic
copies of the models we wish to combine, and combine the copies instead.
Proposition 2.3 Let œÑ be a modal similarity type and, for all i ‚àà I, let Mi be a
œÑ -model. Then, for each modal formula œÜ, for each i ‚àà I, and each element w
of Mi , we have Mi , w  œÜ iff i‚ààI Mi , w  œÜ. In words: modal satisfaction is
invariant under disjoint unions.
Proof. We will prove the result for the basic similarity type. The proof is by in-
duction on œÜ. Let i be some index; we will prove, for each basic modal formula œÜ,
and each element w of Mi , that Mi , w  œÜ iff M, w  œÜ, where M is the disjoint
union i‚ààI Mi .
First suppose that œÜ contains no connectives. Now, if œÜ is a proposition letter
p, then we have Mi , w  œÜ iff w ‚àà Vi (p) iff (by deÔ¨Ånition of V ) w ‚àà V (p)
iff M, w  œÜ. On the other hand, œÜ could be ‚ä• (for the purposes of inductive
proofs it is convenient to regard ‚ä• as a propositional letter rather than as a logical
connective). But trivially ‚ä• is false at w in both models, so we have the desired
equivalence here too.54
2 Models
Our inductive hypothesis is that the desired equivalence holds for all formulas
containing at most n connectives (where n ‚â• 0). We must now show that the
equivalence holds for all formulas œÜ containing n + 1 connectives. Now, if œÜ is
of the form ¬¨œà or œà ‚à® Œ∏ this is easily done ‚Äì we will leave this to the reader ‚Äì so
as we are working with the basic similarity type, it only remains to establish the
equivalence for formulas of the form 3œà. So assume that Mi , w  3œà. Then
there is a state v in Mi with Ri wv and Mi , v  œà. By the inductive hypothesis,
M, v  œà. But by deÔ¨Ånition of M, we have Rwv, so M, w  3œà.
For the other direction, assume that M, w  3œà holds for some w in Mi . Then
there is a v with Rwv and M, v  œà. It follows by the deÔ¨Ånition of R that Rj wv for
some j, and by the disjointness of the universes we must have that j = i. But then
we Ô¨Ånd that v belongs to Mi as well, so we may apply the inductive hypothesis;
this yields Mi , v  œà, so we Ô¨Ånd that Mi , w  3œà.
We will use Proposition 2.3 all through the book ‚Äì here is a simple application
which hints at the ideas we will explore in Chapter 7.
Example 2.4 DeÔ¨Åned modalities are a convenient shorthand for concepts we Ô¨Ånd
useful. We have already seen some examples. In this book 2, the ‚Äòtrue at all
accessible states modality,‚Äô is shorthand for ¬¨3¬¨, and we have inductively deÔ¨Åned
a ‚Äòtrue somewhere n-steps from here‚Äô modality 3n for each natural number n (see
Example 1.22). But while it is usually easy to show that some modality is deÔ¨Ånable
(we need simply write down its deÔ¨Ånition), how do we show that some proposed
operator is not deÔ¨Ånable? Via invariance results! As an example, consider the
global modality. The global diamond E has as its (intended) accessibility relation
the relation W √ó W implicitly present in any model. That is:
M, w  EœÜ iff M, v  œÜ for some state v in M.
Its dual, A, the global box, thus has the following interpretation:
M, w  AœÜ iff M, v  œÜ for all states v in M.
Thus the global modality brings a genuinely global dimension to modal logic. But
is it deÔ¨Ånable in the basic modal language? Intuitively, no: as 3 and 2 work
locally, it seems unlikely that they can deÔ¨Åne a truly global modality over arbitrary
structures. Fine ‚Äì but how do we prove this?
With the help of the previous proposition. Suppose we could deÔ¨Åne A. Then
we could write down an expression Œ±(p) containing only symbols from the basic
modal language such that for every model M, M, w  Œ±(p) iff M  p. We
now derive a contradiction from this supposition. Consider a model M1 where
p holds everywhere, and a model M2 where p holds nowhere. Let w be some
point in M1 . It follows that M1 , w  Œ±(p), so as (by assumption) Œ±(p) contains2.1 Invariance Results
55
only symbols from the basic modal language, by Proposition 2.3 we have that
M1  M2 , w  Œ±(p). But this implies that M1  M2 , v  p for every v in M2 ,
which, again by Proposition 2.3, in turn implies that M2  p: contradiction. We
conclude that the global box (and hence the global diamond) is not deÔ¨Ånable in the
basic modal language.
So, if we want the global modality, then we either have to introduce it as a
primitive (we will do this in Section 7.1), or we have to work with restricted classes
of models on which it is deÔ¨Ånable (in Exercise 1.3.3 we worked with a class of
models in which we could deÔ¨Åne A in the basic temporal language).
Generated submodels
Disjoint unions are a useful way of making bigger models from smaller ones ‚Äì but
we also want methods for doing the reverse. That is, we would like to know when it
is safe to throw points away from a model without affecting satisÔ¨Åability. Disjoint
unions tell us a little about this (if a model is a disjoint union of smaller models,
we are free to work with the component models), but in practice we usually need
something sharper: generated submodels.
Suppose we are using the basic modal language to talk about a model M based
on the frame (Z, <), the integers with their usual order. It does not matter what the
valuation is ‚Äì all that is important is that M looks something like this:


...
- t‚àí3 - ‚àí2
t
- ‚àí1
t
- 0
t
- 1
t
- 2t
- 3t
- ...


First suppose that we form a submodel M‚àí of M by throwing away all the positive
numbers, and restricting the original valuation (whatever it was) to the remaining
numbers. So M‚àí looks something like this:


...

- t‚àí3 - ‚àí2
t
- ‚àí1
t
- 0
t

The basic modal language certainly can see that M and M‚àí are different. For
example, it sees that 0 has successors in M (note that M, 0  3) but is a dead
end in M‚àí (note that M‚àí , 0  3). So there is no invariance result for arbitrary
submodels. But now consider the submodel M+ of M that is formed by omitting
the negative numbers, and restricting the original valuation to the numbers that
remain:

0
- 1
t
t


- 2t
- 3t
- ...
56
2 Models
Suppose a basic modal formula œÜ is satisÔ¨Åed at some point n in M. Is œÜ also
satisÔ¨Åed at the same point n in M+ ? The answer must be yes. The only points that
are relevant to œÜ‚Äôs satisÔ¨Åability are the points greater than n ‚Äì and all such points
belong to M+ . Similarly, it is clear that if M+ satisÔ¨Åes a basic modal formula œÜ at
m, then M must too.
In short, it seems plausible that modal invariance holds for submodels which
are closed under the accessibility relation of the original model. Such models are
called generated submodels, and they do indeed give rise to the invariance result
we are looking for.
DeÔ¨Ånition 2.5 (Generated Submodels) We Ô¨Årst deÔ¨Åne generated submodels for
the basic modal language. Let M = (W, R, V ) and M = (W  , R , V  ) be two
models; we say that M is a submodel of M if W  ‚äÜ W , R is the restriction of R
to W  (that is: R = R ‚à© (W  √ó W  )), and V  is the restriction of V to M (that is:
for each p, V  (p) = V (p) ‚à© W  ). We say that M is a generated submodel of M
(notation: M  M) if M is a submodel of M and for all points w the following
closure condition holds:
if w is in M and Rwv, then v is in M .
 , V )
For the general case, we say that a model M = (W  , R
‚ààœÑ is a generated
submodel of the model M = (W, R, V )‚ààœÑ (notation: M  M) whenever M
is a submodel of M (with respect to R for all  ‚àà œÑ ), and the following closure
condition is fulÔ¨Ålled for all  ‚àà œÑ
if u ‚àà W  and Ruu1 . . . un , then u1 , . . . , un ‚àà W  .
Let M be a model, and X a subset of the domain of M; the submodel generated
by X is the smallest generated submodel of M whose domain contains X (such a
model always exists: why?). Finally, a rooted or point generated model is a model
that is generated by a singleton set, the element of which is called the root of the
frame.
Proposition 2.6 Let œÑ be a modal similarity type and let M and M be œÑ -models
such that M is a generated submodel of M. Then, for each modal formula œÜ and
each element w of M we have that M, w  œÜ iff M , w  œÜ. In words: modal
satisfaction is invariant under generated submodels.
Proof. By induction on œÜ. The reader unused to such proofs should write out the
proof in full. In Proposition 2.19 we provide an alternative proof based on the
observation that generated submodels induce a bisimulation.
Four remarks. First, note that the invariance result for disjoint unions (Proposi-
tion 2.3) is a special case of the result for generated submodels: any component of2.1 Invariance Results
57
a disjoint union is a generated submodel of the disjoint union. Second, using an
argument analogous to that used in Example 2.4 to show that the global box cannot
be deÔ¨Åned in the basic modal language, we can use Proposition 2.6 to show that we
cannot deÔ¨Åne a backward looking modality in terms of 3; see Exercise 2.1.2. Thus
if we want such a modality we have to add it as a primitive ‚Äì which is exactly what
we did, of course, when deÔ¨Åning the basic temporal language. Third, although we
have not explicitly discussed generated submodels for the basic temporal language,
PDL, or arrow logic, the required concepts are all special cases of DeÔ¨Ånition 2.5,
and thus the respective invariance results are special cases of Proposition 2.6. But
it is worth making a brief comment about the basic temporal language. When we
think explicitly in terms of bidirectional frames (see Example 1.25) it is obvious
that we are interested in submodels closed under both RF and RP . But when work-
ing with the basic temporal language we usually leave RP implicit: we work with
ordinary models (W, R, V ), and use RÀá, the converse of R, as RP . Thus a tem-
poral generated submodel of (W, R, V ) is a submodel (W , R , V  ) that is closed
under both R and RÀá. Finally, generated submodels are heavily used throughout
the book: given a model M that satisÔ¨Åes a formula œÜ at a state w, very often the
Ô¨Årst thing we will do is form the submodel of M generated by w, thus trimming
what may be a very unwieldy satisfying model down to a more manageable one.
Morphisms for modalities
In mathematics the idea of morphisms or structure preserving maps is of funda-
mental importance. What notions of morphism are appropriate for modal logic?
That is, what kinds of morphism give rise to invariance results? We will approach
the answer bit by bit, introducing a number of important concepts on the way. We
will start by considering the general notion of homomorphism (this is too weak to
yield invariance, but it is the starting point for better attempts), then we will deÔ¨Åne
strong homomorphisms, embeddings, and isomorphisms (these do give us invari-
ance, but are not particularly modal), and Ô¨Ånally we will zero in on the answer:
bounded morphisms.
DeÔ¨Ånition 2.7 (Homomorphisms) Let œÑ be a modal similarity type and let M and
M be œÑ -models. By a homomorphism f from M to M (notation: f : M ‚Üí M )
we mean a function f from W to W  with the following properties:
(i) For each proposition letter p and each element w from M, if w ‚àà V (p),
then f (w) ‚àà V  (p).
(ii) For each n ‚â• 0 and each n-ary  ‚àà œÑ , and (n + 1)-tuple w from M, if
 (the homomorphic
(w0 , . . . , wn ) ‚àà R then (f (w0 ), . . . , f (wn )) ‚àà R
condition).2 Models
58
We call M the source and M the target of the homomorphism.
Note that for the basic modal language, item (ii) is just this:
if Rwu then R f (w)f (u).
Thus item (ii) simply says that homomorphisms preserve relational links.
Are modal formulas invariant under homomorphisms? No: although homomor-
phisms reÔ¨Çect the structure of the source in the structure of the target, they do
not reÔ¨Çect the structure of the target back in the source. It is easy to turn this
observation into a counterexample, and we will leave this task to the reader as
Exercise 2.1.3.
So let us try and strengthen the deÔ¨Ånition. There is an obvious way of doing
so: turn the conditionals into equivalences. This leads to a number of important
concepts.
DeÔ¨Ånition 2.8 (Strong Homomorphisms, Embeddings and Isomorphisms) Let
œÑ be a modal similarity type and let M and M be œÑ -models. By a strong homo-
morphism of M into M we mean a homomorphism f : M ‚Üí M which satisÔ¨Åes
the following stronger version of the above items (i) and (ii):
(i) For each proposition letter p and element w from M, w ‚àà V (p) iff f (w) ‚àà
V  (p).
(ii) For each n ‚â• 0 and each n-ary  in œÑ and (n + 1)-tuple w from M, (w0 ,
 (the strong homomorphic
. . . , wn ) ‚àà R iff (f (w0 ), . . . , f (wn )) ‚àà R
condition).
An embedding of M into M is a strong homomorphism f : M ‚Üí M which is
injective. An isomorphism is a bijective strong homomorphism. We say that M
is isomorphic to M , in symbols M ‚àº
= M , if there is an isomorphism from M to

M.
Note that for the basic modal language, item (ii) is just:
Rwu iff R f (w)f (u).
That is, item (ii) says that relational links are preserved from the source model to
the target and back again. So it is not particularly surprising that we have a number
of invariance results.
Proposition 2.9 Let œÑ be a modal similarity type and let M and M be œÑ -models.
Then the following holds:
(i) For all elements w and w of M and M , respectively, if there exists a
surjective strong homomorphism f : M ‚Üí M with f (w) = w , then w
and w are modally equivalent.2.1 Invariance Results
59
(ii) If M ‚àº
= M , then M  M .
Proof. The Ô¨Årst item follows by induction on œÜ; the second one is an immediate
consequence.
None of the above results is particularly modal. For a start, as in all branches of
mathematics, ‚Äòisomorphic‚Äô basically means ‚Äòmathematically identical.‚Äô Thus, we
do not want to be able to distinguish isomorphic structures in modal (or indeed,
any other) logic. Quite the contrary: we want to be free to work with structures
‚Äòup to isomorphism‚Äô ‚Äì as we did, for example, in our discussion of disjoint union,
when we talked of taking isomorphic copies. Item (ii) tells us that we can do this,
but it is not a surprising result.
But why is item (i), the invariance result for strong homomorphisms, not ‚Äògen-
uinely modal‚Äô? Quite simply, because there are many morphisms which do give
rise to invariance, but which fail to qualify as strong homomorphisms. To ensure
modal invariance we need to ensure that some target structure is reÔ¨Çected back in
the source, but strong morphisms do this in a much too heavy-handed way. The
crucial concept is more subtle.
DeÔ¨Ånition 2.10 (Bounded Morphisms ‚Äì the Basic Case) We Ô¨Årst deÔ¨Åne bounded
morphisms for the basic modal language. Let M and M be models for the basic
modal language. A mapping f : M = (W, R, V ) ‚Üí M = (W  , R , V  ) is a
bounded morphism if it satisÔ¨Åes the following conditions:
(i) w and f (w) satisfy the same proposition letters.
(ii) f is a homomorphism with respect to the relation R (that is, if Rwv then
R f (w)f (v)).
(iii) If R f (w)v  then there exists v such that Rwv and f (v) = v (the back
condition).
If there is a surjective bounded morphism from M to M , then we say that M is a
bounded morphic image of M, and write M
M .
The idea embodied in the back condition is utterly fundamental to modal logic ‚Äì
in fact, it is the idea that underlies the notion of bisimulation ‚Äì so we need to get a
good grasp of what it involves right away. Here is a useful example.
Example 2.11 Consider the models M = (W , R, V ) and M = (W  , R , V  ),
where
‚Ä¢ W = N (the natural numbers), Rmn iff n = m + 1, and V (p) = {n ‚àà N |
n is even},
‚Ä¢ W  = {e, o}, R = {(e, o), (o, e)}, and V  (p) = {e}.2 Models
60

0
t
- 1
t

- 2
t
- 3
t
- 4
t
- 5t

-
...

?
e t

- t?
o
...



Fig. 2.1. A bounded morphism.
Now, let f : W ‚Üí W  be the following map:
f (n) =
e if n is even
o if n is odd
Figure 2.1 sums this all up in a simple picture.
Now, f is not a strong homomorphism (why not?), but it is a (surjective) bounded
morphism from M to M . Let us see why. Trivially f satisÔ¨Åes item (i) of the
deÔ¨Ånition. As for the homomorphic condition consider an arbitrary pair (n, n + 1)
in R. There are two possibilities: n is either even or odd. Suppose n is even. Then
n + 1 is odd, so f (n) = e and f (n + 1) = o. But then we have R f (n)f (n + 1),
as required. The argument for n odd is analogous.
And now for the interesting part: the back condition. Take an arbitrary element
n of W and assume that R f (n)w . We have to Ô¨Ånd an m ‚àà W such that Rnm
and f (m) = w . Let us assume that n is odd (the case for even n is similar). As
n is odd, f (n) = o, so by deÔ¨Ånition of R , we must have that w = e. But then
f (n + 1) = w since n + 1 is even, and by the deÔ¨Ånition of R we have that n + 1
is a successor of n. Hence, n + 1 is the m that we were looking for.
DeÔ¨Ånition 2.12 (Bounded Morphisms ‚Äì the General Case) The deÔ¨Ånition of
a bounded morphism for general modal languages is obtained from the above by
adapting the homomorphic and back conditions of DeÔ¨Ånition 2.10 as follows:
 f (w)f (v ) . . . f (v ).
(ii) For all  ‚àà œÑ , Rwv1 . . . vn implies R
1
n




(iii) If Rf (w)v1 . . . vn then there exist v1 . . . vn such that Rwv1 . . . vn and
f (vi ) = vi (for 1 ‚â§ i ‚â§ n).
Example 2.13 Suppose we are working in the modal similarity type of arrow
logic; see Example 1.16 and 1.27. Recall that the language has a modal constant
1‚Äô, a unary operator ‚äó and a single dyadic operator ‚ó¶. Semantically, to these oper-
ators correspond a unary relation I, a binary R and a ternary C. We will deÔ¨Åne a2.1 Invariance Results
61
bounded morphism from a square model to a model based on the addition of the
integer numbers. We will use the following notation: if x is an element of Z √ó Z,
then x0 denotes its Ô¨Årst component, and x1 its second component.
Consider the two models M = (W, C, R, I, V ) and M = (W  , C  , R , I  , V  )
where
‚Ä¢ W = Z √ó Z, Cxyz iff x0 = y0 , y1 = z0 and z1 = x1 , Rxy if x0 = y1
and x1 = y0 , Ix iff x0 = x1 , and Ô¨Ånally, the valuation V is given by V (p) =
{(x0 , x1 ) | x1 ‚àí x0 is even },
‚Ä¢ W  = Z, C  stu iff s = t + u, R st iff s = ‚àít, I  s iff s = 0, and the valuation
V  is given by V  (p) = {s ‚àà Z | s is even }.
This example is best understood by looking at Figure 2.2. The left picture shows a
fragment of the model M; the points of Z √ó Z are represented as disks or circles,
depending on whether p is true or not. The diagonal is indicated by the dashed
diagonal line.
..
aqaaqaqa
qaqaq
.
a
aqaqaq
qaqaqa
aqaqaaqa
..
2

1
 0
 -1
 -2

a
..
.
..
.
.
Fig. 2.2. Another bounded morphism.
The right-hand side of Figure 2.2 gives a pictorial representation of the function
f : Z √ó Z ‚Üí Z given by
f (z) = z1 ‚àí z0 .
We claim that f is a bounded morphism for this similarity type. The clause for the
propositional variables is trivial. For the unary relation I we only have to check
that for any z in Z √ó Z, z0 = z1 iff z1 ‚àí z0 = 0. This is obviously true. We leave
the case of the binary relation R to the reader.
So let us turn to the clauses for the ternary relation C. To check item (ii) (the
homomorphic condition), assume that Cxyz holds for x, y and z in W . That is,
we have that x0 = y0 , y1 = z0 and z1 = x1 . But then we Ô¨Ånd that
f (x) = x1 ‚àí x0 = z1 ‚àí y0 = z1 ‚àí z0 + y1 ‚àí y0 = f (z) + f (y),62
2 Models
so by deÔ¨Ånition of C we do indeed Ô¨Ånd that C f (x)f (y)f (z).
For item (iii) (the back condition) assume that we have C f (x)tu for some
x ‚àà Z √ó Z and t, u ‚àà Z. In other words, we have that x1 ‚àí x0 = t + u. Consider
the pairs y := (x0 , x0 + t) and z := (x0 + t, x1 ). It is obvious that Cxyz; we also
Ô¨Ånd that f (y) = t and f (z) = x1 ‚àí (x0 + t) = (x1 ‚àí x0 ) ‚àí t = u. Hence y and z
are the elements of W that we need to satisfy item (iii) .
DeÔ¨Ånition 2.12 covers the basic temporal language, PDL, and arrow logic, as spe-
cial cases ‚Äì but once more it is worth issuing a warning concerning the basic tem-
poral language. Although RP is usually presented implicitly (as the converse of the
relation R in some model (W, R, V )) we certainly cannot ignore it. Thus a tempo-
ral bounded morphism from (W1 , R1 , V1 ) to (W2 , R2 , V2 ) is a bounded morphism
from (W1 , R1 , RÀá1 , V1 ) to (W2 , R2 , RÀá2 , V2 ).
Proposition 2.14 Let œÑ be a modal similarity type and let M and M be œÑ -models
such that f : M ‚Üí M is a bounded morphism. Then, for each modal formula œÜ,
and each element w of M we have M, w  œÜ iff M , f (w)  œÜ. In words: modal
satisfaction is invariant under bounded morphisms.
Proof. Let M, M and f be as in the statement of the proposition. We will prove
that for each formula œÜ and state w, M, w  œÜ iff M , f (w)  œÜ. The proof is
by induction on œÜ. We will assume that œÑ is the basic similarity type, leaving the
general case to the reader.
The base step and the boolean cases are routine, so let us turn to the case where
œÜ is of the form 3œà. Assume Ô¨Årst that M, w  3œà. This means there is a state
v with Rwv and M, v  œà. By the inductive hypothesis, M , f (v)  œà. By the
homomorphic condition, R f (w)f (v), so M , f (w)  3œà.
For the other direction, assume that M , f (w)  3œà. Thus there is a successor
of f (w) in M , say v , such that M , v   œà. Now we use the back condition
(of DeÔ¨Ånition 2.10). This yields a point v in M such that Rwv and f (v) = v .
Applying the inductive hypothesis, we obtain M, v  œà, so M, w  3œà.
Here is a simple application: we will now show that any satisÔ¨Åable formula can be
satisÔ¨Åed in a tree-like model. To put it another way: modal logic has the tree model
property.
Let œÑ be a modal similarity type containing only diamonds (thus if M is a
œÑ -model, it has the form (W, R1 , R2 , . . . , V ), where each Ri is a binary rela-
tion on W ). In this context we will call a œÑ -model M tree-like if the structure
(W, i Ri , V ) is a tree in the sense of DeÔ¨Ånition 1.7.
Proposition 2.15 Assume that œÑ is a modal similarity type containing only dia-
monds. Then, for any rooted œÑ -model M there exists a tree-like œÑ -model M such
that M
M. Hence any satisÔ¨Åable œÑ -formula is satisÔ¨Åable in a tree-like model.2.1 Invariance Results
63
Proof. Let w be the root of M. DeÔ¨Åne the model M as follows. Its domain W 
consists of all Ô¨Ånite sequences (w, u1 , . . . , un ) such that n ‚â• 0 and for some modal
operators a1 , . . . , an  ‚àà œÑ there is a path wRa1 u1 ¬∑ ¬∑ ¬∑ Ran un in M. DeÔ¨Åne
(w, u1 , . . . , un )Ra (w, v1 , . . . , vm ) to hold if m = n + 1, ui = vi for i = 1, . . . , n,
and Ra un vm holds in M. That is, Ra relates two sequences iff the second is an
extension of the Ô¨Årst with a state from M that is a successor of the last element
of the Ô¨Årst sequence. Finally, V  is deÔ¨Åned by putting (w, u1 , . . . , un ) ‚àà V  (p)
iff un ‚àà V (p). As the reader is asked to check in Exercise 2.1.4, the mapping
f : (w, u1 , . . . , un ) ‚Üí un deÔ¨Ånes a surjective bounded morphism from M to M,
thus M and M are equivalent.
But then it follows that any satisÔ¨Åable œÑ -formula is satisÔ¨Åable in a tree-like
model. For suppose œÜ is satisÔ¨Åable in some œÑ -model at a point w. Let M be
the submodel generated by w. By Proposition 2.6, M, w  œÜ, and as M is rooted
we can form an equivalent tree-like model M as just described.
The method used to construct M from M is well known in both modal logic and
computer science: it is called unraveling (or unwinding, or unfolding). In essence,
we built M by treating the paths through M as Ô¨Årst class citizens: this untangles
the (possibly very complex) way information is stored in M, and makes it possible
to present it as a tree. We will make use of unraveling several times in later work; in
the meantime, Exercise 2.1.7 asks the reader to extend the notion of ‚Äòtree-likeness‚Äô
to arbitrary modal similarity types, and generalize Proposition 2.15.
Exercises for Section 2.1
2.1.1 Suppose we wanted an operator D with the following satisfaction deÔ¨Ånition: for any
model M and any formula œÜ, M, w  DœÜ iff there is a u = w such that M, u  œÜ. This
operator is called the difference operator and we will discuss it further in Section 7.1. Is
the difference operator deÔ¨Ånable in the basic modal language?
2.1.2 Use generated submodels to show that the backward looking modality (that is, the P
of the basic temporal language) cannot be deÔ¨Åned in terms of the forward looking operator
3.
2.1.3 Give the simplest possible example which shows that the truth of modal formulas is
not invariant under homomorphisms, even if condition (i) is strengthened to an equivalence.
Is modal truth preserved under homomorphisms?
2.1.4 Show that the mapping f deÔ¨Åned in the proof of Proposition 2.15 is indeed a surjec-
tive bounded morphism.
2.1.5 Let B = (B, R) be the transitive binary tree; that is, B is the set of Ô¨Ånite strings
of 0s and 1s, and RœÉœÑ holds if œÉ is a proper initial segment of œÑ . Let N = (N, <) be the
frame of the natural numbers with the usual ordering.64
2 Models
(a) Let V0 be the valuation on N given by V 0 (p) = {2n | n ‚àà N} for each proposition
letter p. DeÔ¨Åne a valuation U 0 on B and a bounded morphism from (B, U 0 ) to
(N, V0 ).
(b) Let U1 be the valuation on B given by U 1 (p) = {1œÉ | œÉ ‚àà B} for each proposition
letter p. Give a valuation V 1 on N and a homomorphism from (B, U 1 ) to (N, V1 )
(c) Can you also Ô¨Ånd bounded morphisms?
2.1.6 Show that every model is the bounded morphic image of the disjoint union of point-
generated (that is: rooted) models. This exercise may look rather technical, but in fact it is
very straightforward ‚Äì think about it!
2.1.7 This exercise generalizes Proposition 2.15 to arbitrary modal similarity types.
(a) DeÔ¨Åne a suitable notion of tree-like model that works for arbitrary modal similarity
types. (Hint: in case of R  s0 s1 . . . sn , think of s0 as being the parent node and of
s1 , . . . , sn as the children.)
(b) Generalize Proposition 2.15 to arbitrary modal similarity types.
2.2 Bisimulations
What do the invariance results of the previous section have in common? They all
deal with special sorts of relations between two models, namely relations with the
following properties: related states carry identical atomic information, and when-
ever it is possible to make a transition in one model, it is possible to make a match-
ing transition in the other. For example, with generated submodels the inter-model
relation is identity, and every transition in one model is matched by an identical
transition in the other. With bounded morphisms, the inter-model relation is a func-
tion, and the notion of matching involves both the homomorphic link from source
to target, and the back condition which reÔ¨Çects target structure in the source.
This observation leads us to the central concept of the chapter: bisimulations.
Quite simply, a bisimulation is a relation between two models in which related
states have identical atomic information and matching transition possibilities. The
interesting part of the deÔ¨Ånition is the way it makes the notion of ‚Äòmatching transi-
tion possibilities‚Äô precise.
DeÔ¨Ånition 2.16 (Bisimulations ‚Äì the Basic Case) We Ô¨Årst give the deÔ¨Ånition for
the basic modal language. Let M = (W, R, V ) and M = (W  , R , V  ) be two
models.
A non-empty binary relation Z ‚äÜ W √ó W  is called a bisimulation between M
and M (notation: Z : M ‚Üî M ) if the following conditions are satisÔ¨Åed:
(i) If wZw then w and w satisfy the same proposition letters.
(ii) If wZw and Rwv, then there exists v (in M ) such that vZv and R w v 
(the forth condition).2.2 Bisimulations
65
(iii) The converse of (ii): if wZw and R w v  , then there exists v (in M) such
that vZv and Rwv (the back condition).
When Z is a bisimulation linking two states w in M and w in M we say that w
and w are bisimilar, and we write Z : M, w ‚Üî M , w . If there is a bisimulation
Z such that Z : M, w ‚Üî M , w , we sometimes write M, w ‚Üî M , w , or w ‚Üî w
if the models are clear from the context. Finally, if M and M are linked by some
bisimulation, we write M ‚Üî M .
Think of DeÔ¨Ånition 2.16 pictorially. Figure 2.3 shows the content of the forth
clause. Suppose we know that wZw and Rwv (the solid arrow in M and the Z-
link at the bottom of the diagram display this information). Then the forth condition
says that it is always possible to Ô¨Ånd a v that ‚Äòcompletes the square‚Äô (this is shown
by the dashed arrow in M and the dotted Z-link at the top of the diagram). Note
the symmetry between the back and forth clauses: to visualize the back clause,
simply reÔ¨Çect the picture through its vertical axis.
vq
qv
6
Zq
6
w
q

Z
w
M
M
Fig. 2.3. The forth condition.
In effect, bisimulations are a relational generalization of bounded morphisms: we
drop the directionality from source to target (and with it the homomorphic con-
dition) and replace it with a back-and-forth system of matching moves between
models.
Example 2.17 The models M and M shown in Figure 2.4 are bisimilar. To see
this, deÔ¨Åne the following relation Z between their states: Z = {(1, a), (2, b),
(2, c), (3, d), (4, e), (5, e)}. Condition (i) of DeÔ¨Ånition 2.16 is obviously satisÔ¨Åed:
Z-related states make the same propositional letters true. Moreover, the back and
forth conditions are satisÔ¨Åed too: any move in M can be matched by a similar move
in M , and conversely, as the reader should check.
This example also shows that bisimulation is a genuine generalization of the
constructions discussed in the previous section. Although M and M are bisimilar,
neither is a generated submodel nor a bounded morphic image of the other.2 Models
$ '
66
'
4
M
b

s - 2s - 3s
p
q
p@
R sq
@
1
&
5
$
sq
a  @
R ds
@
s
p@
p
Rs
@
q
sq
%
&
c
- es
q
M
%
Fig. 2.4. Bisimilar models.
DeÔ¨Ånition 2.18 (Bisimulations ‚Äì the General Case) Let œÑ be a modal similarity
 , V )
type, and let M = (W, R, V )‚ààœÑ and M = (W  , R
‚ààœÑ be œÑ -models. A

non-empty binary relation Z ‚äÜ W √ó W is called a bisimulation between M and
M (notation: Z : M ‚Üî M ) if the above condition (i) from DeÔ¨Ånition 2.16
is satisÔ¨Åed (that is, Z-related states satisfy the same proposition letters) and in
addition the following conditions (ii) and (iii) are satisÔ¨Åed:
(ii) If wZw and Rwv1 . . . vn then there are v1 , . . . , vn (in W  ) such that
 w v  . . . v  and for all i (1 ‚â§ i ‚â§ n) v Zv  (the forth condition).
R
i
n
1
i
 w v  . . . v  then there are v , . . . , v
(iii) The converse of (ii) : if wZw and R
1
n
n
1
(in W ) such that Rwv1 . . . vn and for all i (1 ‚â§ i ‚â§ n) vi Zvi (the back
condition).
Examples of bisimulations abound ‚Äì indeed, as we have already mentioned, the
constructions of the previous section (disjoint unions, generated submodels, iso-
morphisms, and bounded morphisms), are all bisimulations:
Proposition 2.19 Let œÑ be a modal similarity type, and let M, M and Mi (i ‚àà I)
be œÑ -models.
(i) If M ‚àº
= M , then M ‚Üî M .
(ii) For every i ‚àà I and every w in Mi , Mi , w ‚Üî i Mi , w.
(iii) If M  M, then M , w ‚Üî M, w for all w in M .
(iv) If f : M
M , then M, w ‚Üî M , f (w) for all w in M.
Proof. We only prove the second item, leaving the others as Exercise 2.2.2. As-
sume we are working in the basic modal language. DeÔ¨Åne a relation Z between
Mi and i Mi by putting Z = {(w, w) | w ‚àà Mi }. Then Z is a bisimulation.
To see this, observe that clause (i) of DeÔ¨Ånition 2.16 is trivially fulÔ¨Ålled, and as to
clauses (ii) and (iii), any R-step in Mi is reproduced in i Mi , and by the disjoint-
ness condition every R-step in i Mi that departs from a point that was originally
in Mi , stems from a corresponding R-step in Mi . The reader should extend this
argument to arbitrary similarity types.2.2 Bisimulations
67
We will now show that modal satisÔ¨Åability is invariant under bisimulations (and
hence, by Proposition 2.19, provide an alternative proof that modal satisÔ¨Åability is
invariant under disjoint unions, generated submodels, isomorphisms, and bounded
morphisms). The key thing to note about the following proof is how straightfor-
ward it is ‚Äì the back and forth clauses in the deÔ¨Ånition of bisimulation are precisely
what is needed to push the induction through.
Theorem 2.20 Let œÑ be a modal similarity type, and let M, M be œÑ -models. Then,
for every w ‚àà W and w ‚àà W  , w ‚Üî w implies that w  w . In words, modal
formulas are invariant under bisimulation.
Proof. By induction on œÜ. The case where œÜ is a proposition letter follows from
clause (i) of DeÔ¨Ånition 2.16, and the case where œÜ is ‚ä• is immediate. The boolean
cases are immediate from the induction hypothesis.
As for formulas of the form 3œà, we have M, w  3œà iff there exists a v in M
such that Rwv and M, v  œà. As w ‚Üî w we Ô¨Ånd by clause (ii) of DeÔ¨Ånition
2.16 that there exists a v in M such that R w v  and v ‚Üî v  . By the induction
hypothesis, M , v   œà, hence M , w  3œà. For the converse direction use
clause (iii) of DeÔ¨Ånition 2.16.
The argument for the general modal case, with triangles , is an easy extension
of that just given, as the reader should check.
This Ô¨Ånishes our discussion of the basics of bisimulation ‚Äì so let us now try and
understand the concept more deeply. Some of the remarks that follow are concep-
tual, and some are technical, but they all point to ideas that crop up throughout the
book.
Remark 2.21 (Bisimulation, Locality, and Computation) In the Preface we sug-
gested that the reader think of modal formulas as automata. Evaluating a modal
formula amounts to running an automaton: we place it at some state inside a struc-
ture and let it search for information. The automaton is only permitted to explore
by making transitions to neighboring states; that is, it works locally.
Suppose such an automaton is standing at a state w in a model M, and we pick it
up and place it at a state w in a different model M ; would it notice the switch? If
w and w are bisimilar, no. Our automaton cares only about the information at the
current state and the information accessible by making a transition ‚Äì it is indifferent
to everything else. Thus the deÔ¨Ånition of bisimulation spells out exactly what we
have to do if we want to fool such an automaton as to where it is being evaluated.
Viewed this way, it is clear that the concept of bisimulation is a direct reÔ¨Çection of
the locality of the modal satisfaction deÔ¨Ånition.
But there is a deeper link between bisimulation and computation than our in-
formal talk of automata might suggest. As we discussed in Example 1.3, labeled2 Models
68


s
w


. . .
w
s
Z
~
Z
 Z
~
Z

Z
. . .
~
Z
Z
~.
Z


.

M
N
..
.
Fig. 2.5. Equivalent but not bisimilar.
transition systems (LTSs) are a standard way of thinking about computation: when
we traverse an LTS we build a sequence of state transitions ‚Äì or to put it another
way, we compute. When are two LTSs computationally equivalent? More pre-
cisely, if we ignore practical issues (such as how long it takes to actually perform
a computation) when can two different LTSs be treated as freely exchangeable
(‚Äòobservationally equivalent‚Äô) black boxes? One natural answer is: when they are
bisimilar. Bisimulation turns out to be a very natural notion of equivalence for both
mathematical and computational investigations. For more on the history of bisim-
ulation and the connection with computer science, see the Notes.
Remark 2.22 (Bisimulation and First-Order Logic) According to Theorem 2.20
modal formulas cannot distinguish between bisimilar states or between bisimilar
models, even though these states or models may be quite different. It follows
that modal logic is very different from Ô¨Årst-order logic, for arbitrary Ô¨Årst-order
formulas are certainly not invariant under bisimulations. For example, the model
M of Example 2.17 satisÔ¨Åes the formula
‚àÉy1 y2 y3 (y1 = y2 ‚àß y1 = y3 ‚àß y2 = y3 ‚àß Rxy1 ‚àß Rxy2 ‚àß Ry1 y3 ‚àß Ry2 y3 ),
if we assign the state a to the free variable x. This formula says that there is a
diamond-shaped conÔ¨Åguration of points, which is true of the point a in M , but
not of the state 1 in M. But as far as modal logic is concerned, M and M, being
bisimilar, are indistinguishable. In Section 2.4 we will start examining the links
between modal logic and Ô¨Årst-order logic more systematically.
Now for a fundamental question: is the converse of Theorem 2.20 true? That is, if
two models are modally equivalent, must they be bisimilar? The answer is no.
Example 2.23 Consider the basic modal language. We may just as well work with
an empty set of proposition letters here. DeÔ¨Åne models M and N as in Figure 2.5,
where arrows denote R-transitions. Each of M and N has, for each n > 0, a Ô¨Ånite
branch of length n; the difference between the models is that, in addition, N has an
inÔ¨Ånite branch.2.2 Bisimulations
69
One can show that for all modal formulas œÜ, M, w  œÜ iff N, w  œÜ (this is
easy if one is allowed to use some results that we will prove further on, namely
Proposition 2.31 and Lemma 2.33, but it is not particularly hard to prove from Ô¨Årst
principles, and the reader may like to try this). But even though w and w are
modally equivalent, there is no bisimulation linking them. To see this, suppose
that there was such a bisimulation Z: we will derive a contradiction from this
supposition.
Since w and w are linked by Z, there has to be a successor of w, say v0 , which
is linked to the Ô¨Årst point v0 on the inÔ¨Ånite path from w . Suppose that n is the
length of the (maximal) path leading from w through v0 , and let w, v0 , . . . , vn‚àí1
be the successive points on this path. Using the bisimulation conditions n ‚àí 1

times, we Ô¨Ånd points v1 , . . . , vn‚àí1
on the inÔ¨Ånite path emanating from w , such







that v0 R v1 . . . R vn‚àí1 and vi Zvi for each i. Now vn‚àí1
has a successor, but vn‚àí1
does not; hence, there is no way that these two points can be bisimilar.
Nonetheless, it is possible to prove a restricted converse to Theorem 2.20, namely
the Hennessy-Milner Theorem. Let œÑ be a modal similarity type, and M a œÑ -
model. M is image-Ô¨Ånite if for each state u in M and each relation R in M, the
set { (v1 , . . . , vn ) | Ruv1 . . . vn } is Ô¨Ånite; observe that we are not putting any
restrictions on the total number of different relations R in the model M ‚Äì just that
each of them is image-Ô¨Ånite.
Theorem 2.24 (Hennessy-Milner Theorem) Let œÑ be a modal similarity type,
and let M and M be two image-Ô¨Ånite œÑ -models. Then, for every w ‚àà W and
w ‚àà W  , w ‚Üî w iff w  w .
Proof. Assume that our similarity type œÑ only contains a single diamond (that is,
we will work in the basic modal language). The direction from left to right follows
from Theorem 2.20; for the other direction, we will prove that the relation 
of modal equivalence itself satisÔ¨Åes the conditions of DeÔ¨Ånition 2.16 ‚Äì that is, we
show that the relation of modal equivalence on these models is itself a bisimulation.
(This is an important idea; we will return to it in Section 2.5.)
The Ô¨Årst condition is immediate. For the second one, assume that w  w
and Rwv. We will try to arrive at a contradiction by assuming that there is no v
in M with R w v  and v  v . Let S  = {u | R w u }. Note that S  must
be non-empty, for otherwise M , w  ‚ä•, which would contradict w  w
since M, w  3. Furthermore, as M is image-Ô¨Ånite, S must be Ô¨Ånite, say
S  = {w1 , . . . , wn }. By assumption, for every wi ‚àà S  there exists a formula œài
such that M, v  œài but M , wi  œài . It follows that
M, w  3(œà1 ‚àß ¬∑ ¬∑ ¬∑ ‚àß œàn ) and M , w  3(œà1 ‚àß ¬∑ ¬∑ ¬∑ ‚àß œàn ),
which contradicts our assumption that w  w . The third condition of DeÔ¨Åni-70
2 Models
tion 2.16 may be checked in a similar way. Extending the proof to other similarity
types is routine.
Theorem 2.20 (together with the Hennessy-Milner Theorem) on the one hand, and
Example 2.23 on the other, mark important boundaries. Clearly, bisimulations have
something important to say about modal expressivity over models, but they do not
tell us everything. Two pieces of the jigsaw puzzle are missing. For a start, we are
still considering modal languages in isolation: as yet, we have made no attempt to
systematically link them to Ô¨Årst-order logic. We will remedy this in Section 2.4 and
this will eventually lead us to a beautiful result, the van Benthem Characterization
Theorem (Theorem 2.68): modal logic is the bisimulation invariant fragment of
Ô¨Årst-order logic.
The second missing piece is the notion of an ultraÔ¨Ålter extension. We will intro-
duce this concept in Section 2.5, and this will eventually lead us to Theorem 2.62.
Informally, this theorem says: modal equivalence implies bisimilarity-somewhere-
else. Where is this mysterious ‚Äòsomewhere else‚Äô? In the ultraÔ¨Ålter extension. As
we will see, although modally equivalent models need not be bisimilar, they must
have bisimilar ultraÔ¨Ålter extensions.
Remark 2.25 (Bisimulations for the Basic Temporal Language, PDL, and Ar-
row Logic) Although we have already said the most fundamental things that need
to be said on this topic (DeÔ¨Ånition 2.18 and Theorem 2.20 covers these languages),
a closer look reveals some interesting results for PDL and arrow logic. But let us
Ô¨Årst discuss the basic temporal language.
First we issue our (by now customary) warning. When working with the basic
temporal language, we usually work with models (W, R, V ) and implicitly take RP
to be RÀá. Thus we need a notion of bisimulation which takes RÀá into account, and
so we deÔ¨Åne a temporal bisimulation between models (W, R, V ) and (W , R , V  )
to be a relation Z between the states of the two models that satisÔ¨Åes the clauses
of DeÔ¨Ånition 2.16, and in addition the following two clauses (iv) and (v) requiring
that backward steps in one model should be matched by similar steps in the other
model:
(iv) If wZw and Rvw, then there exists v (in M ) such that vZv and R v  w .
(v) The converse of (iv): if wZw and R v  w , then there exists v (in M) such
that vZv and Rvw.
If we do not do this, we are in trouble. For example, if M is a model whose
underlying frame is the integers, and M is the submodel of M generated by 0
(according to the deÔ¨Ånition for the basic modal language), then these two models
are bisimilar in the sense of DeÔ¨Ånition 2.16, and hence equivalent as far as the
basic modal language is concerned. But they are not equivalent as far as the basic
temporal language is concerned: M, 0  P , but M , 0  P .2.2 Bisimulations
71
Given our previous discussion, this is unsurprising. What is (pleasantly) sur-
prising is that things do not work this way in PDL. Suppose we are given two
regular models. Checking that these models are bisimilar for the language of PDL
means checking that bisimilarity holds for all the (inÔ¨Ånitely many) relations that
exist in regular models (see Example 1.26). But as it turns out, most of this work
is unnecessary. Once we have checked that bisimilarity holds for all the relations
which interpret the basic programs, we do not have to check anything else: the
relations corresponding to complex programs will automatically be bisimilar. In
Section 2.7 we will introduce some special terminology to describe this: the oper-
ations in regular PDL‚Äôs modality building repertoire (‚à™, ; and ‚àó ) will be called safe
for bisimulation. Note that taking the converse of a relation is not an operation that
is safe for bisimulation (in effect, that is what we just noted when discussing the
basic temporal language).
What about arrow logic? The required notion of bisimulation is given by Def-
inition 2.18; note that the clause for 1‚Äô reads that for bisimilar points a and a we
have Ia iff I  a.
Remark 2.26 (The Algebra of Bisimulations) Bisimulations give rise to alge-
braic structure quite naturally. For instance, if Z0 is a bisimulation between M0
and M1 , and Z1 a bisimulation between M1 and M2 , then the composition of Z0
and Z1 is a bisimulation linking M0 and M2 . It is also a rather easy observation
that the set of bisimulations between two models is closed under taking arbitrary
(Ô¨Ånite or inÔ¨Ånite) unions. This shows that if two points are bisimilar, there is al-
ways a maximal bisimulation linking them; see Exercise 2.2.8. Further information
on closure properties of the set of bisimulations between two models can be found
in Section 2.7.
Exercises for Section 2.2
2.2.1 Consider a modal similarity type with two diamonds a and b, and with Œ¶ = {p}.
Show that the following two models are bisimilar:
w s
p
b
a
v
-s p
w0
s
p
a - v0s
p
b - ws1
p
a - v1s . . .
p
2.2.2 This exercise asks the reader to complete in detail the proof of Proposition 2.19,
which links bisimulations and the model constructions discussed in the previous section.
You should prove these results for arbitrary similarity types.
(a) Show that if M ‚àº
= M , then M ‚Üî M .
(b) Show that if i Mi is the disjoint union of the models M i (i ‚àà I), then, for each i,
Mi ‚Üî i Mi .
(c) Show that if M is a generated submodel of M, then M  ‚Üî M.
(d) Show that if M  is a bounded morphic image of M, then M  ‚Üî M.2 Models
72
2.2.3 This exercise is about temporal bisimulations.
(a) Show from Ô¨Årst principles that the truth of basic temporal formulas is invariant
under temporal bisimulations. (That is, do not appeal to any of the results proved
in this section.)
(b) Let M and M be Ô¨Ånite rooted models for basic temporal logic with F and P . Let
w and w  be the roots of M and M  , respectively. Prove that if w and w  satisfy
the same basic temporal formulas with F and P , then there exists a basic temporal
bisimulation that relates w and w  .
2.2.4 Consider the binary until operator U . In a model M = (W, R, V ) its truth deÔ¨Ånition
reads:
M, t  U (œÜ, œà)
iff there is a v such that Rtv and v  œÜ, and
for all u such that Rtu and Ruv: u  œà.
Prove that U is not deÔ¨Ånable in the basic modal language. Hint: think about the following
two models, but with arrows added to make sure that the relations are transitive:
v1
v0
t
t
t0 *
q H
YH u 
*q H
YH t1
t
H t
H t
I
I

p
t s0
t s1
v
t
u
*

YH t
 q H
t
H t
I

p
t s
2.2.5 Consider the following two models, which we are going to use to interpret the basic
temporal language: M 0 = (R, <, V0 ) and M1 = (R, <, V1 ), where V0 makes q true at all
non-zero integers and V 1 in addition makes q true at all points of the form 1/z with z a
non-zero integer number.
(a) Prove that there is a temporal bisimulation between M 0 and M1 , linking 0 (in the
one model) to 0 (in the other model).
(b) Let Œ† be the progressive operator deÔ¨Åned by the following truth table:
M, s  Œ†œÜ
iff
there are t and u such that t < s < u and
M, x  œÜ for all x between t and u.
Prove that this operator is not deÔ¨Ånable in the basic temporal language.
2.2.6 Suppose we have two bisimilar LTSs. Show that bisimilar states in these LTSs satisfy
exactly the same formulas of PDL.
2.2.7 Prove that two square arrow models M = (S U , V ) and M = (SU  , V  ) are bisim-
ilar if and only if there is a relation Z between pairs over U and pairs over U  such that
(i) if (u, v)Z(u , v  ), then (u, v) ‚àà V (p) iff (u , v  ) ‚àà V  (p),
(ii) if (u, v)Z(u , v  ), then u = v iff u = v  ,
(iii) if (u, v)Z(u , v  ), then (v, u)Z(v  , u ),
(iv) if (u, v)Z(u , v  ), then for any w ‚àà U there exists a w  ‚àà U  such that both
(u, w)Z(u , w ) and (w, v)Z(w  , v  ),
(v) the converse of (iv): if (u, v)Z(u  , v  ), then for any w  ‚àà U  there exists a w ‚àà U
such that both (u, w)Z(u  , w ) and (w, v)Z(w  , v  ),2.3 Finite Models
73
Must any two bisimilar square arrow models be isomorphic? (Hint: think of V (p) and
V  (p) as the natural ordering relations of the rational and the real numbers, respectively.)
2.2.8 Suppose that {Z i | i ‚àà I} is a non-empty collection of bisimulations between M and
M . Prove that the relation i‚ààI Zi is also a bisimulation between M and M  . Conclude
that if M and M are bisimilar, then there is a maximal bisimulation between M and M  ;
that is, a bisimulation Z m such that for any bisimulation Z : M ‚Üî M we have Z ‚äÜ Zm .
2.3 Finite Models
Preservation and invariance results can be viewed either positively or negatively.
Viewed negatively, they map the limits of modal expressivity: they tell us, for
example, that modal languages are incapable of distinguishing a model from its
generated submodels. Viewed positively, they are a toolkit for transforming mod-
els into more desirable forms without affecting satisÔ¨Åability. Proposition 2.15 has
already given us a taste of this perspective (we showed that modal languages have
the tree model property) and it will play an important role when we discuss com-
pleteness in Chapter 4.
The results of this section are similarly double-edged. We are going to investi-
gate modal expressivity over Ô¨Ånite models, and the basic result we will prove is that
modal languages have the Ô¨Ånite model property: if a modal formula is satisÔ¨Åable
on an arbitrary model, then it is satisÔ¨Åable on a Ô¨Ånite model.
DeÔ¨Ånition 2.27 (Finite Model Property) Let œÑ be a modal similarity type, and
let M be a class of œÑ -models. We say that œÑ has the Ô¨Ånite model property with
respect to M if the following holds: if œÜ is a formula of similarity type œÑ , and œÜ is
satisÔ¨Åable in some model in M, then œÜ is satisÔ¨Åable in a Ô¨Ånite model in M.
In this section we will mostly be concerned with the special case in which M in
DeÔ¨Ånition 2.27 is the collection of all œÑ -models, so to simplify terminology here
we will use the term ‚ÄòÔ¨Ånite model property‚Äô for this special case. The fact that
modal languages have the Ô¨Ånite model property (in this sense) can be viewed as a
limitative result: modal languages simply lack the expressive strength to force the
existence of inÔ¨Ånite models. (By way of contrast, it is easy to write down Ô¨Årst-
order formulas which can only be satisÔ¨Åed on inÔ¨Ånite models.) On the other hand,
the result is a source of strength: we do not need to bother about (arbitrary) inÔ¨Ånite
models, for we can always Ô¨Ånd an equivalent Ô¨Ånite one. This opens the door to the
decidability results of Chapter 6. (The satisÔ¨Åability problem for Ô¨Årst-order logic,
as the reader probably knows, is undecidable over arbitrary models.)
We will discuss two methods for building Ô¨Ånite models for satisÔ¨Åable modal
formulas. The Ô¨Årst is to (carefully!) select a Ô¨Ånite submodel of the satisfying model,
the second (called the Ô¨Åltration method) is to deÔ¨Åne a suitable quotient structure.2 Models
74
Selecting a Ô¨Ånite submodel
The selection method draws together four observations. Here is the Ô¨Årst. We know
that modal satisfaction is intrinsically local: modalities scan the states accessible
from the current state. How much of the model can a modal formula see from the
current state? That obviously depends on how deeply the modalities it contains are
nested.
DeÔ¨Ånition 2.28 (Degree) We deÔ¨Åne the degree of modal formulas as follows:
deg(p) = 0,
deg(‚ä•) = 0,
deg(¬¨œÜ) = deg(œÜ),
deg(œÜ ‚à® œà) = max{deg(œÜ), deg(œà)},
deg((œÜ1 , . . . , œÜn )) = 1 + max{deg(œÜ1 ), . . . , deg(œÜn )}.
In particular, the degree of a basic modal formula 3œÜ is 1 + deg(œÜ).
Second, we observe the following:
Proposition 2.29 Let œÑ be a Ô¨Ånite modal similarity type, and assume that our col-
lection of proposition letters is Ô¨Ånite as well.
(i) For all n, up to logical equivalence there are only Ô¨Ånitely many formulas of
degree at most n.
(ii) For all n, and every œÑ -model M and state w of M, the set of all œÑ -formulas
of degree at most n that are satisÔ¨Åed by w, is equivalent to a single formula.
Proof. We prove the Ô¨Årst item by induction on n. The case n = 0 is obvious. As
for the case n+1, observe that every formula of degree ‚â§ n+1 is a boolean combi-
nation of proposition letters and formulas of the form 3œà, where deg(œà) ‚â§ n. By
the induction hypothesis there can only be Ô¨Ånitely many non-equivalent such for-
mulas œà. Thus there are only Ô¨Ånitely many non-equivalent boolean combinations
of proposition letters and formulas 3œà, where œà has degree at most n. Hence,
there are only Ô¨Ånitely many non-equivalent formulas of degree at most n + 1.
Item (ii) is immediate from item (i).
Third, we observe that there is a natural way of Ô¨Ånitely approximating a bisimula-
tion. These Ô¨Ånite approximations will prove crucial in our search for Ô¨Ånite models.
DeÔ¨Ånition 2.30 (n-Bisimulations) Here we deÔ¨Åne n-bisimulations for modal
similarity types containing only diamonds, leaving the deÔ¨Ånition of the general
case as part of Exercise 2.3.2. Let M and M be models, and let w and w be
states of M and M , respectively. We say that w and w are n-bisimilar (notation:2.3 Finite Models
75
w ‚Üîn w ) if there exists a sequence of binary relations Zn ‚äÜ ¬∑ ¬∑ ¬∑ ‚äÜ Z0 with the
following properties (for i + 1 ‚â§ n):
(i) wZn w .
(ii) If vZ0 v  then v and v agree on all proposition letters.
(iii) If vZi+1 v  and Rvu, then there exists u with R v  u and uZi u .
(iv) If vZi+1 v  and R v  u , then there exists u with Rvu and uZi u .
The intuition is that if w ‚Üîn w , then w and w bisimulate up to depth n. Clearly,
if w ‚Üî w , then w ‚Üîn w for all n ‚Äì but the converse need not hold; see Exer-
cise 2.3.1.
Fourth, we observe that for languages containing only Ô¨Ånitely many proposition
letters, there is an exact match between modal equivalence and n-bisimilarity for
all n. That is, for such languages not only does n-bisimilarity for all n imply modal
equivalence, but the converse holds as well.
Proposition 2.31 Let œÑ be a Ô¨Ånite modal similarity type, Œ¶ a Ô¨Ånite set of proposi-
tion letters, and let M and M be models for this language. Then for every w in M
and w in M , the following are equivalent:
(i) w ‚Üîn w .
(ii) w and w agree on all modal formulas of degree at most n.
It follows that ‚Äòn-bisimilarity for all n‚Äô and modal equivalence coincide as rela-
tions between states.
Proof. The implication (i) ‚áí (ii) may be proved by induction on n. For the con-
verse implication one can use an argument similar to the one used in the proof of
Theorem 2.24; we leave the proof as part of Exercise 2.3.2.
It is time to draw these observations together. The following deÔ¨Ånition and lemma,
which are about rooted models, give us half of what we need to build Ô¨Ånite models.
DeÔ¨Ånition 2.32 Let œÑ be a modal similarity type containing only diamonds. Let
M = (W, R1 , . . . , Rn , . . . , V ) be a rooted œÑ -model with root w. The notion of
the height of states in M is deÔ¨Åned by induction. The only element of height 0 is
the root of the model; the states of height n + 1 are those immediate successors of
elements of height n that have not yet been assigned a height smaller than n + 1.
The height of a model M is the maximum n such that there is a state of height n in
M, if such a maximum exists; otherwise the height of M is inÔ¨Ånite.
For a natural number k, the restriction of M to k (notation: M k) is deÔ¨Åned
as the submodel containing only states whose height is at most k. More precisely,
(M k) = (Wk , R1k , . . . , Rnk , . . . , Vk ), where Wk = {v | height(v) ‚â§ k},
Rnk = Rn ‚à© (Wk √ó Wk ), and for each p, Vk (p) = V (p) ‚à© Wk .76
2 Models
In words: the restriction of M to k contains all states that can be reached from
the root in at most k steps along the accessibility relations. Typically, this will not
give a generated submodel, so why does it interest us? Because, as we can now
show, given a formula œÜ of degree k that is satisÔ¨Åable in some rooted model M, the
restriction of M to k contains all the states we need to satisfy œÜ. To put it another
way: we are free to simply delete all states that lie beyond the ‚Äòk-horizon.‚Äô
Lemma 2.33 Let œÑ be a modal similarity type that contains only diamonds. Let
M be a rooted œÑ -model, and let k be a natural number. Then, for every state w of
(M k), we have (M k), w ‚Üîl M, w, where l = k ‚àí height(w).
Proof. Take the identity relation on (M k). We leave the reader to work out the
details as Exercise 2.3.3. The following comment may be helpful: in essence this
lemma tells us that if we are only interested in the satisÔ¨Åability of modal formulas
of degree at most k, then generating submodels of height k sufÔ¨Åces to maintain
satisÔ¨Åability.
Putting together Proposition 2.31 and Lemma 2.33, we conclude that every satis-
Ô¨Åable modal formula can be satisÔ¨Åed on a model of Ô¨Ånite height. This is clearly
useful, but we are only halfway to our goal: the resulting model may still be inÔ¨Å-
nite, as it may be inÔ¨Ånitely branching. We obtain the Ô¨Ånite model we are looking
for by a further selection of points; in effect this discards unwanted branches and
leads to the desired Ô¨Ånite model.
Theorem 2.34 (Finite Model Property ‚Äì via Selection) Let œÑ be a modal simi-
larity type containing only diamonds, and let œÜ be a œÑ -formula. If œÜ is satisÔ¨Åable,
then it is satisÔ¨Åable on a Ô¨Ånite model.
Proof. Fix a modal formula œÜ with deg(œÜ) = k. We restrict our modal simi-
larity type œÑ and our collection of proposition letters to the modal operators and
proposition letters actually occurring in œÜ. Let M1 , w1 be such that M1 , w1  œÜ.
By Proposition 2.15, there exists a tree-like model M2 with root w2 such that
M2 , w2  œÜ. Let M3 := (M2 k). By Lemma 2.33 we have M2 , w2 ‚Üîk M3 , w2 ,
and by Proposition 2.31 it follows that M3 , w2  œÜ.
By induction on n ‚â§ k we deÔ¨Åne Ô¨Ånite sets of states S0 , . . . , Sk and a (Ô¨Ånal)
model M4 with domain S0 ‚à™ ¬∑ ¬∑ ¬∑ ‚à™ Sk ; the points in each Sn will have height n.
DeÔ¨Åne S0 to be the singleton {w2 }. Next, assume that S0 , . . . , Sn have already
been deÔ¨Åned. Fix an element v of Sn . By Proposition 2.29 there are only Ô¨Ånitely
many non-equivalent modal formulas whose degree is at most k ‚àí n, say œà1 , . . . ,
œàm . For each such formula that is of the form aœá and holds in M3 at v, select
a state u from M3 such that Ra vu and M3 , u  œá. Add all these us to Sn+1 , and
repeat this selection process for every state in Sn . Sn+1 is deÔ¨Åned as the set of all
points that have been selected in this way.2.3 Finite Models
77
Finally, deÔ¨Åne M4 as follows. Its domain is S0 ‚à™¬∑ ¬∑ ¬∑‚à™Sk ; as each Si is Ô¨Ånite, M4
is Ô¨Ånite. The relations and valuation are obtained by restricting the relations and
valuation of M3 to the domain of M4 . By Exercise 2.3.4 we have that M4 , w2 ‚Üîk
M3 , w2 , and hence M4 , w2  œÜ, as required.
How well does the selection method generalize to other modal languages? For
certain purposes it is Ô¨Åne. For example, to deal with arbitrary modal similarity
types, the notion of a tree-like model needs to be adapted (in fact, we explained
how to do this in Exercise 2.1.7), but once this has been done we can prove a
general version of Proposition 2.15. Next, the notion of n-bisimilarity needs to
be adapted to other similarity types, but that too is straightforward (it is part of
Exercise 2.3.2). Finally, the selection process in the proof of Theorem 2.34 needs
adaptation, but this is unproblematic. In short, we can show that the Ô¨Ånite model
property holds for arbitrary similarity types using the selection method.
The method has a drawback: the input model for our construction may satisfy
important relational properties (such as being symmetric), but the end result is al-
ways a Ô¨Ånite tree-like model, and the desired relational properties may be (and
often are) lost. So if we want to establish the Ô¨Ånite model property with respect
to a class of models satisfying additional properties ‚Äì something that is very im-
portant in practice ‚Äì we may have to do additional work once we have obtained
our Ô¨Ånite tree-like model. In such cases, the selection method tends to be harder
to use than the Ô¨Åltration method (which we discuss next). Nonetheless, the idea
of (intelligently!) selecting points to build submodels is important, and (as we will
see in Section 6.6 when we discuss NP-completeness) the idea really comes into
its own when the model we start with is already Ô¨Ånite.
Finite models via Ô¨Åltrations
We now examine the classic modal method for building Ô¨Ånite models: Ô¨Åltration.
Whereas the selection method builds Ô¨Ånite models by deleting superÔ¨Çuous material
from large, possibly inÔ¨Ånite models, the Ô¨Åltration method produces Ô¨Ånite models
by taking a large, possibly inÔ¨Ånite model and identifying as many states as possible.
We Ô¨Årst present the Ô¨Åltration method for the basic modal language.
DeÔ¨Ånition 2.35 A set of formulas Œ£ is closed under subformulas (or: subformula
closed) if for all formulas œÜ, œÜ : if œÜ ‚à® œÜ ‚àà Œ£ then so are œÜ and œÜ ; if ¬¨œÜ ‚àà Œ£ then
so is œÜ; and if (œÜ1 , . . . , œÜn ) ‚àà Œ£ then so are œÜ1 , . . . , œÜn . (For the basic modal
language, this means that if 3œÜ ‚àà Œ£, then so is œÜ.)
DeÔ¨Ånition 2.36 (Filtrations) We work in the basic modal language. Let M =
(W, R, V ) be a model and Œ£ a subformula closed set of formulas. Let Œ£ be the2 Models
78
'
0
s
&
$
1s
2
3
- s
4
- s. . .
1
qs

|0|

%
s

- s
 |1| 
Fig. 2.6. A model and its Ô¨Åltration.
relation on the states of M deÔ¨Åned by:
w Œ£ v iff for all œÜ in Œ£: (M, w  œÜ iff M, v  œÜ).
Note that Œ£ is an equivalence relation. We denote the equivalence class of a
state w of M with respect to Œ£ by |w|Œ£ , or simply by |w| if no confusion will
arise. The mapping w ‚Üí |w| that sends a state to its equivalence class is called the
natural map.
Let WŒ£ = {|w|Œ£ | w ‚àà W }. Suppose MfŒ£ is any model (W f , Rf , V f ) such
that:
(i) W f = WŒ£ .
(ii) If Rwv then Rf |w||v|.
(iii) If Rf |w||v| then for all 3œÜ ‚àà Œ£, if M, v  œÜ then M, w  3œÜ.
(iv) V f (p) = {|w| | M, w  p}, for all proposition letters p in Œ£.
Then MfŒ£ is called a Ô¨Åltration of M through Œ£; we will often suppress subscripts
and write Mf instead of MfŒ£ .
Because of item (ii), the natural map associated with any Ô¨Åltration is guaranteed to
be a homomorphism (see DeÔ¨Ånition 2.7). And at Ô¨Årst glance it may seem that it
is even guaranteed to be a bounded morphism (see DeÔ¨Ånition 2.10), for item (iii)
seems reminiscent of the back condition. Unfortunately, this is not the case, as the
following example shows.
Example 2.37 Let M be the model (N, R, V ), where R = {(0, 1), (0, 2), (1, 3)}‚à™
{(n, n + 1) | n ‚â• 2}, and V has V (p) = N \ {0} and V (q) = {2}.
Further, assume that Œ£ = {3p, p}. Clearly Œ£ is subformula closed. Then,
the model N = ({|0|, |1|}, {(|0|, |1|), (|1|, |1|)}, V  ), where V  (p) = {|1|}, is a
Ô¨Åltration of M through Œ£. See Figure 2.6.
Clearly, N can not be a bounded morphic image of M: any bounded morphism
would have to preserve the formula q, and the natural map does not preserve q, and
need not, because q is not an element of our subformula closed set Œ£.2.3 Finite Models
79
But in many other respects Ô¨Åltrations are well-behaved. For a start, the method
gives us a bound (albeit an exponential one) on the size of the resulting Ô¨Ånite model:
Proposition 2.38 Let Œ£ be a Ô¨Ånite subformula closed set of basic modal formulas.
For any model M, if Mf is a Ô¨Åltration of M through a subformula closed set Œ£,
then Mf contains at most 2n nodes (where n denotes the size of Œ£).
Proof. The states of Mf are the equivalence classes in WŒ£ . Let g be the function
with domain WŒ£ and range P(Œ£) deÔ¨Åned by g(|w|) = {œÜ ‚àà Œ£ | M, w  œÜ}. It
follows from the deÔ¨Ånition of Œ£ that g is well deÔ¨Åned and injective. Thus the
size of WŒ£ is at most 2n , where n is the size of Œ£.
Moreover ‚Äì crucially ‚Äì Ô¨Åltrations preserve satisfaction in the following sense.
Theorem 2.39 (Filtration Theorem) Consider the basic modal language. Let
Mf (= (WŒ£ , Rf , V f )) be a Ô¨Åltration of M through a subformula closed set Œ£.
Then for all formulas œÜ ‚àà Œ£, and all nodes w in M, we have M, w  œÜ iff
Mf , |w|  œÜ.
Proof. By induction on œÜ. The base case is immediate from the deÔ¨Ånition of V f .
The boolean cases are straightforward; the fact that Œ£ is closed under subformulas
allows us to apply the inductive hypothesis.
So suppose 3œÜ ‚àà Œ£ and M, w  3œÜ. Then there is a v such that Rwv and
M, v  œÜ. As Mf is a Ô¨Åltration, Rf |w||v|. As Œ£ is subformula closed, œÜ ‚àà Œ£,
thus by the inductive hypothesis Mf , |v|  œÜ. Hence Mf , |w|  3œÜ.
Conversely, suppose 3œÜ ‚àà Œ£ and Mf , |w|  3œÜ. Thus there is a state |v| in
Mf such that Rf |w||v| and Mf , |v|  œÜ. As œÜ ‚àà Œ£, by the inductive hypothesis
M, v  œÜ. So the third clause in DeÔ¨Ånition 2.36 is applicable, and we conclude
that M, w  3œÜ.
Observe that clauses (ii) and (iii) of DeÔ¨Ånition 2.36 are designed to make the modal
case of the induction step go through in the proof above.
But we still have not done one vital thing: we have not actually shown that Ô¨Ål-
trations exist! Observe that the clauses (ii) and (iii) in DeÔ¨Ånition 2.36 only impose
conditions on candidate relations Rf ‚Äì but we have not yet shown that a suitable
Rf can always be found. In fact, there are always at least two ways to deÔ¨Åne binary
relations that fulÔ¨Åll the required conditions. DeÔ¨Åne Rs and Rl as follows:
(i) Rs |w||v| iff ‚àÉw ‚àà |w|‚àÉv  ‚àà |v| Rw v  .
(ii) Rl |w||v| iff for all formulas 3œÜ in Œ£: M, v  œÜ implies M, w  3œÜ.
These relations ‚Äì which are not necessarily distinct ‚Äì give rise to the smallest and
largest Ô¨Åltrations respectively.80
2 Models
Lemma 2.40 Consider the basic modal language. Let M be any model, Œ£ any
subformula closed set of formulas, WŒ£ the set of equivalence classes induced
by Œ£ , and V f the standard valuation on WŒ£ . Then both (WŒ£ , Rs , V f ) and
(WŒ£ , Rl , V f ) are Ô¨Åltrations of M through Œ£. Furthermore, if (WŒ£ , Rf , V f ) is
any Ô¨Åltration of M through Œ£ then Rs ‚äÜ Rf ‚äÜ Rl .
Proof. We show that (WŒ£ , Rs , V f ) is a Ô¨Åltration; the rest is left as an exercise.
It sufÔ¨Åces to show that Rs fulÔ¨Ålls clauses (ii) and (iii) of DeÔ¨Ånition 2.36. But
Rs satisÔ¨Åes clause (ii) by deÔ¨Ånition, so it remains to check clause (iii). Suppose
Rs |w||v|, and further suppose that 3œÜ ‚àà Œ£ and M, v  œÜ. As Rs |w||v|, there exist
w ‚àà |w| and v ‚àà |v| such that Rw v  . As œÜ ‚àà Œ£ and M, v  œÜ, then because
v Œ£ v  , we get M, v  œÜ. But Rw v  , so M, w  3œÜ. But 3œÜ ‚àà Œ£, thus as
w Œ£ w it follows that M, w  3œÜ.
Theorem 2.41 (Finite Model Property ‚Äì via Filtrations) Let œÜ be a basic modal
formula. If œÜ is satisÔ¨Åable, then it is satisÔ¨Åable on a Ô¨Ånite model. Indeed, it is
satisÔ¨Åable on a Ô¨Ånite model containing at most 2m nodes, where m is the number
of subformulas of œÜ.
Proof. Assume that œÜ is satisÔ¨Åable on a model M; take any Ô¨Åltration of M through
the set of subformulas of œÜ. That œÜ is satisÔ¨Åed in the Ô¨Åltration is immediate from
Theorem 2.39. The bound on the size of the Ô¨Åltration is immediate from Proposi-
tion 2.38.
There are several points worth making about Ô¨Åltrations. The Ô¨Årst has to do with
the possible loss of properties when moving from a model to one of its Ô¨Åltrations.
As we have already discussed, a drawback of the selection method is that it can be
hard to preserve such properties. Filtrations are far better in this respect ‚Äì but they
certainly are not perfect. Let us consider the matter more closely.
Suppose (WŒ£ , Rf , V f ) is a Ô¨Åltration of (W, R, V ). Now, clause (ii) of DeÔ¨Åni-
tion 2.36 means that the natural map from M to Mf is a surjective homomorphism
with respect to the accessibility relation R. Thus any property of relations which
is preserved under such maps will automatically be inherited by any Ô¨Åltration. Ob-
vious examples include reÔ¨Çexivity and right unboundedness (‚àÄx‚àÉy Rxy).
However, many interesting relational properties are not preserved under homo-
morphisms: transitivity and symmetry are obvious counterexamples. Thus we need
to Ô¨Ånd special Ô¨Åltrations which preserve these properties. Sometimes this is easy;
for example, the smallest Ô¨Åltration preserves symmetry. Sometimes we need new
ideas to Ô¨Ånd a good Ô¨Åltration; the classic example involves transitivity. Let us see
what this involves.
Lemma 2.42 Let M be a model, Œ£ a subformula closed set of formulas, and WŒ£2.3 Finite Models
s
s
s
s
-
s
s
s
s
-
s
s
s
s
81
-
...
-
s
s
s
s
Fig. 2.7. Filtrating a model based on (Q, <).
the set of equivalence classes induced on M by Œ£ . Let Rt be the binary relation
on WŒ£ deÔ¨Åned by:
Rt |w||v| iff for all œÜ, if 3œÜ ‚àà Œ£ and M, v  œÜ ‚à® 3œÜ then M, w  3œÜ.
If R is transitive then (WŒ£ , Rt , V f ) is a Ô¨Åltration and Rt is transitive.
Proof. Left as Exercise 2.3.5.
In short, Ô¨Åltrations are Ô¨Çexible ‚Äì but it is not a matter of ‚Äòplug and play.‚Äô Creativity
is often required to exploit them.
The second point worth making is that Ô¨Åltrations of an inÔ¨Ånite model through a
Ô¨Ånite set manage to represent an inÔ¨Ånite amount of information in a Ô¨Ånitary manner.
It seems obvious, at least from an intuitive point of view, that this can only be
achieved by identifying lots of points. As we have seen in Example 2.37, an inÔ¨Ånite
chain may be collapsed onto a single reÔ¨Çexive point by a Ô¨Åltration. An even more
informative example is provided by models based on the rationals. For instance,
what happens to the density condition in the Ô¨Åltration? Let M = (Q, <, V ); then
any (Ô¨Ånite) Ô¨Åltration of M has the form displayed in Figure 2.7. What is going
on here? Instead of viewing models as structures made up of states and relations
between them, in the case of Ô¨Åltrations it can be useful to view them as sets of
states (namely, the sets of identiÔ¨Åed states) and relations between those sets. The
following deÔ¨Ånition captures this idea.
DeÔ¨Ånition 2.43 Let (W, R, V ) be a transitive frame. A cluster on (W, R, V ) is a
maximal, nonempty equivalence class under R. That is, C ‚äÜ W is a cluster if
the restriction of R to C is an equivalence relation, and this is not the case for any
subset D properly extending C.
A cluster is simple if it consists of a single reÔ¨Çexive point, and proper if it con-
tains more than one point.
As Figure 2.7 shows, a (Ô¨Ånite) Ô¨Åltration of (Q, <) can be thought of as resulting in
a Ô¨Ånite linear sequence of clusters, perhaps interspersed with singleton irreÔ¨Çexive
points, no two of which can be adjacent. (Note: the displayed model is transitive,
even though we haven‚Äôt drawn in the arrows needed to indicate this.) The reader is
asked to check this claim in Exercise 2.3.9. Clusters will play an important role in
Section 4.5.82
2 Models
To conclude this section we brieÔ¨Çy indicate how the Ô¨Åltration method can be
extended to other modal languages. Let us Ô¨Årst consider modal languages based
on arbitrary modal similarity types œÑ . Fix a œÑ -model M = (W , R, V )‚ààœÑ and a
f
subformula closed set Œ£ as in DeÔ¨Ånition 2.36. Suppose MfŒ£ = (WŒ£ , R
, V f )‚ààœÑ
f
is a œÑ -model where WŒ£ and V f are as in DeÔ¨Ånition 2.36, and for  ‚àà œÑ , R
satisfy
(ii) if Rwv1 . . . vn then Rf |w||v1 | . . . |vn |,
(iii) if Rf |w||v1 | . . . |vn |, then for all œÜ1 , . . . , œÜn ‚àà Œ£, if (œÜ1 , . . . , œÜn ) ‚àà Œ£
and M, v1  œÜ1 , . . . , M, vn  œÜn , then M, w  (œÜ1 , . . . , œÜn ).
Then MfŒ£ is a œÑ -Ô¨Åltration of M through Œ£.
With this deÔ¨Ånition at hand, Proposition 2.38 and Theorem 2.39 can be reformu-
lated and proved for œÑ -Ô¨Åltrations, and suitable versions of the smallest and largest
Ô¨Åltrations can also be deÔ¨Åned, resulting in a general modal analog of Theorem 2.41,
the Finite Model Property.
What about basic temporal logic, PDL, and arrow logic? It turns out that the
Ô¨Åltration method works well for all of these. For basic temporal logic we need to
issue the customary warning (we need to be explicit about what the Ô¨Åltration does
to RÀá), but with this observed, matters are straightforward. Exercise 2.3.7 asks the
reader to deÔ¨Åne transitive Ô¨Åltrations for the basic temporal language.
Matters are far more interesting (and difÔ¨Åcult) with PDL ‚Äì but here too, by mak-
ing use of a clever idea called the Fischer-Ladner closure, it is possible to use a
Ô¨Åltration style argument to show that PDL has the Ô¨Ånite model property; we will do
this in Section 4.8 as part of a completeness proof (Theorem 4.91). Exercise 2.3.10
deals with the Ô¨Ånite model property for arrow logic.
Exercises for Section 2.3
2.3.1 Find two models M and M  and states w and w  in these models such that w ‚Üîn w
for all n, but it is not the case that w ‚Üî w are bisimilar. (Hint: we drew a picture of such
a pair of models in the previous section.)
2.3.2 Generalize the deÔ¨Ånition of n-bisimulations (DeÔ¨Ånition 2.30) from diamond-only
to arbitrary modal languages. Then prove Proposition 2.31 (that n-bisimilarity for all n
implies modal equivalence and conversely) for arbitrary modal languages.
2.3.3 Lemma 2.33 tells us that if we are only interested in the satisÔ¨Åability of modal for-
mulas of degree at most k, we can delete all states that lie beyond the k-horizon without
affecting satisÔ¨Åability. Prove this.
2.3.4 The proof of Theorem 2.34 uses a selection-of-points argument to establish the Ô¨Ånite
model property. But no proof details were given for the last (crucial) claim in the proof,
namely that M4 , w2 is k-bisimilar to M3 , w2 . Fill in this gap.2.4 The Standard Translation
83
2.3.5 First show that not every Ô¨Åltration of a transitive model is transitive. Then prove
Lemma 2.42. That is, show that the relation R t deÔ¨Åned there is indeed a Ô¨Åltration, and that
any Ô¨Åltration of a transitive model that makes use of R t is guaranteed to be transitive.
2.3.6 Finish the proof of Lemma 2.40. That is, prove that the Ô¨Åltrations R s and Rl are
indeed the smallest and the largest Ô¨Åltration, respectively. In addition, give an example of
a model and a set of formulas for which R s and Rl coincide.
2.3.7 Show that every transitive model (W, R, V ) has a transitive temporal Ô¨Åltration. (Take
care to specify what the Ô¨Åltration does to R Àá.)
2.3.8 Call a frame or model euclidean if it satisÔ¨Åes ‚àÄxyz ((Rxy ‚àß Rxz) ‚Üí Ryz), and let
E be the class of euclidean models. Fix a formula Œæ, and let Œ£ be the smallest subformula
closed set of formulas containing Œæ that satisÔ¨Åes, for all formulas œà: if 3œà ‚àà Œ£, then
23œà ‚àà Œ£. (Recall that 2 is an abbreviation of ¬¨3¬¨.) Note that in general, Œ£ will be
inÔ¨Ånite.
(a) Prove that E  3œà ‚Üí 23œà.
(b) Prove that every euclidean model can be Ô¨Åltrated through Œ£ to a euclidean model.
(c) Show that every euclidean model satisÔ¨Åes the following modal reduction principles:
333 ‚Üî 33, 332 ‚Üî 32, 323 ‚Üî 33 and 322 ‚Üî 32. That is, prove that
the formulas 333œÜ ‚Üî 33œÜ, . . . are true throughout every euclidean model.
Conclude that Œ£ is Ô¨Ånite modulo equivalence on euclidean models.
(d) Prove that the basic modal similarity type has the Ô¨Ånite model property with respect
to the class of euclidean models. Can you prove this result simply by Ô¨Åltrating
through any subformula closed set of formulas containing Œæ?
2.3.9 Let Mf be a Ô¨Ånite, transitive Ô¨Åltration of a model based on the rationals with their
usual ordering. Describe the possible shape of M f in terms of clusters and sets consisting
of a single, irreÔ¨Çexive point. In particular, show that there is a natural way to impose
a linear order on this collection of subsets of Q. Can M f have two adjacent singleton
clusters? Two adjacent singleton sets each consisting of an irreÔ¨Çexive point?
2.3.10 Consider the similarity type œÑ ‚Üí of arrow logic.
(i) Show that œÑ‚Üí has the Ô¨Ånite model property with respect to the class of all arrow
models.
(ii) Consider the class of arrow models based on arrow frames F = (W, C, R, I) such
that for all s, t and u in W we have (i) Cstu iff Csut iff Ctus and (ii) Cstu and
Iu iff s = t. Prove that arrow formulas have the Ô¨Ånite model property with respect
to this class of arrow models.
(iii) Prove that œÑ‚Üí does not have the Ô¨Ånite model property with respect to the class of all
square models. (Hint: try to express that the extension of the propositional variable
p is a dense, linear ordering.)
2.4 The Standard Translation
In the Preface we warned the reader against viewing modal logic as an isolated
formal system (remember Slogan 3?), yet here we are, halfway through Chapter 2,
and we still have not linked modal logic with the wider logical world. We now put84
2 Models
this right. We deÔ¨Åne a link called the standard translation. This paves the way
for the results on modal expressivity in the sections that follow, for the study of
frames in the following chapter, and for the introduction of the guarded fragment
in Section 7.4.
We Ô¨Årst specify our correspondence languages ‚Äì that is, the languages we will
translate modal formulas into.
DeÔ¨Ånition 2.44 For œÑ a modal similarity type and Œ¶ a collection of proposition
letters, let L1œÑ (Œ¶) be the Ô¨Årst-order language (with equality) which has unary pred-
icates P0 , P1 , P2 , . . . corresponding to the proposition letters p0 , p1 , p2 , . . . in
Œ¶, and an (n + 1)-ary relation symbol R for each (n-ary) modal operator  in
our similarity type. We write Œ±(x) to denote a Ô¨Årst-order formula Œ± with one free
variable, x.
We are now ready to deÔ¨Åne the standard translation.
DeÔ¨Ånition 2.45 (Standard Translation) Let x be a Ô¨Årst-order variable. The stan-
dard translation ST x taking modal formulas to Ô¨Årst-order formulas in L1œÑ (Œ¶) is
deÔ¨Åned as follows:
ST x (p) = P x,
ST x (‚ä•) = x = x,
ST x (¬¨œÜ) = ¬¨ST x (œÜ),
ST x (œÜ ‚à® œà) = ST x (œÜ) ‚à® ST x (œà),
ST x ((œÜ1 , . . . , œÜn )) = ‚àÉy1 . . . ‚àÉyn (Rxy1 . . . yn ‚àß
ST y1 (œÜ1 ) ‚àß ¬∑ ¬∑ ¬∑ ‚àß ST yn (œÜn )),
where y1 , . . . , yn are fresh variables (that is, variables that have not been used so far
in the translation). When working with the basic modal language, the last clause
boils down to:
ST x (3œÜ) = ‚àÉy (Rxy ‚àß ST y (œÜ)).
Note that (to keep notation simple) we prefer to use R rather than R3 , and we
will continue to do this. We leave to the reader the task of working out what
ST x ((œÜ1 , . . . , œÜn )) is, but we will point out that for the basic modal language
the required clause is:
ST x (2œÜ) = ‚àÄy (Rxy ‚Üí ST y (œÜ)).
Example 2.46 Let us see how this works. Consider the formula 3(2p ‚Üí q).
ST x (3(2p ‚Üí q)) = ‚àÉy1 (Rxy1 ‚àß ST y1 (2p ‚Üí q))2.4 The Standard Translation
85
= ‚àÉy1 (Rxy1 ‚àß (ST y1 (2p) ‚Üí ST y1 (q)))
= ‚àÉy1 (Rxy1 ‚àß (‚àÄy2 (Ry1 y2 ‚Üí ST y2 (p)) ‚Üí Qy1 ))
= ‚àÉy1 (Rxy1 ‚àß (‚àÄy2 (Ry1 y2 ‚Üí P y2 ) ‚Üí Qy1 )).
Note that (this version of) the standard translation leaves the choice of fresh vari-
ables unspeciÔ¨Åed. For example, ‚àÉy256 (Rxy256 ‚àß (‚àÄy14 (Ry256 y14 ‚Üí P y14 ) ‚Üí
Qy256 )) is a legitimate translation of 3(2p ‚Üí q), and indeed there are inÔ¨Ånitely
many others, all differing only in the bound variables they contain. Later in the
section we remove this indeterminacy ‚Äì elegantly.
It should be clear that the standard translation makes good sense: it is essentially
a Ô¨Årst-order reformulation of the modal satisfaction deÔ¨Ånition. For any modal for-
mula œÜ, ST x (œÜ) will contain exactly one free variable (namely x); the role of this
free variable is to mark the current state; this use of a free variable makes it pos-
sible for the global notion of Ô¨Årst-order satisfaction to mimic the local notion of
modal satisfaction. Furthermore, observe that modalities are translated as bounded
quantiÔ¨Åers, and in particular, quantiÔ¨Åers bounded to act only on related states; this
is the obvious way of mimicking the local action of the modalities in Ô¨Årst-order
logic. Because of its importance it is worth pinning down just why the standard
translation works.
Models for modal languages based on a modal similarity type œÑ and a collection
of proposition letters Œ¶ can also be viewed as models for L1œÑ (Œ¶). For example,
if œÑ contains just a single diamond 3, then the corresponding Ô¨Årst-order language
L1œÑ (Œ¶) has a binary relation symbol R and a unary predicate symbol corresponding
to each proposition letter in Œ¶ ‚Äì and a Ô¨Årst-order model for this language needs to
provide an interpretation for these symbols. But a (modal) model M = (W, R, V )
supplies precisely what is required: the binary relation R can be used to interpret
the relation symbol R, and the set V (pi ) can be used to interpret the unary predicate
Pi . This should not come as a surprise. As we emphasized in Chapter 1 (especially
Sections 1.1 and 1.3) there is no mathematical distinction between modal and Ô¨Årst-
order models ‚Äì both modal and Ô¨Årst-order models are simply relational structures.
Thus it makes perfect sense to write things like M |= STx (œÜ)[w], which means
that the Ô¨Årst-order formula ST x (œÜ) is satisÔ¨Åed (in the usual sense of Ô¨Årst-order
logic) in the model M when w is assigned to the free variable x.
Proposition 2.47 (Local and Global Correspondence on Models) Fix a modal
similarity type œÑ , and let œÜ be a œÑ -formula. Then:
(i) For all M and all states w of M: M, w  œÜ iff M |= STx (œÜ)[w].
(ii) For all M: M  œÜ iff M |= ‚àÄx ST x (œÜ).
Proof. By induction on œÜ. We leave this to the reader as Exercise 2.4.1.86
2 Models
Summing up: when interpreted on models, modal formulas are equivalent to Ô¨Årst-
order formulas in one free variable. Fine ‚Äì but what does that give us? Lots!
Proposition 2.47 is a bridge between modal and Ô¨Årst-order logic ‚Äì and we can use
this bridge to import results, ideas, and proof techniques from one to the other.
Example 2.48 First-order logic has the compactness property: if Œò is a set of Ô¨Årst-
order formulas, and every Ô¨Ånite subset of Œò is satisÔ¨Åable, then so is Œò itself. It also
has the downward L√∂wenheim-Skolem property: if a set of Ô¨Årst-order formulas has
an inÔ¨Ånite model, then it has a countably inÔ¨Ånite model.
It follows that modal logic must have both these properties (over models) too.
Consider compactness. Suppose Œ£ is a set of modal formulas every Ô¨Ånite subset
of which is satisÔ¨Åable ‚Äì is Œ£ itself satisÔ¨Åable? Yes. Consider the set {STx (œÜ) |
œÜ ‚àà Œ£}. As every Ô¨Ånite subset of Œ£ has a model it follows (reading item (i) of
Proposition 2.47 left to right) that every Ô¨Ånite subset of {STx (œÜ) | œÜ ‚àà Œ£} does
too, and hence (by Ô¨Årst-order compactness) that this whole set is satisÔ¨Åable in some
model, say M. But then it follows (this time reading item (i) of Proposition 2.47
right to left) that Œ£ is satisÔ¨Åable in M, hence modal satisÔ¨Åability over models is
compact.
And there is interesting trafÔ¨Åc from modal logic to Ô¨Årst-order logic too. For
example, a signiÔ¨Åcant difference between modal and Ô¨Årst-order logic is that modal
logic is decidable (over arbitrary models) but Ô¨Årst-order logic is not. By using
our understanding of modal decidability, it is possible to locate novel decidable
fragments of Ô¨Årst-order logic, a theme we will return to in Section 7.4 when we
discuss the guarded fragment.
Just as importantly, the standard translation gives us a new research agenda for
investigating modal expressivity: correspondence theory. The central aim of this
chapter is to explore the expressivity of modal logic over models ‚Äì but how is ex-
pressivity to be measured? Proposition 2.47 suggests an interesting strategy: try to
characterize the fragment of Ô¨Årst-order logic picked out by the standard translation.
It is obvious on purely syntactic grounds that the standard translation is not
surjective (standard translations of modal formulas contain only bounded quan-
tiÔ¨Åers) ‚Äì but could every Ô¨Årst-order formula (in the appropriate correspondence
language) be equivalent to the translation of a modal formula? No. This is very
easy to see: whereas modal formulas are invariant under bisimulations, Ô¨Årst-order
formulas need not be; thus any Ô¨Årst-order formula which is not invariant under
bisimulations cannot be equivalent to the translation of a modal formula. We have
seen such a formula in Section 2.2 (namely ‚àÉy1 y2 y3 (y1 = y2 ‚àß y1 = y3 ‚àß y2 =
y3 ‚àß Rxy1 ‚àß Rxy2 ‚àß Ry1 y3 ‚àß Ry2 y3 )), and it is easy to Ô¨Ånd simpler examples.
Thus the (Ô¨Årst-order formulas equivalent to) standard translations of model for-
mulas are a proper subset of the correspondence language. Which subset? Here2.4 The Standard Translation
87
is a nice observation. The standard translation can be reformulated so that it maps
every modal formula into a very small fragment of L1œÑ (Œ¶), namely a certain Ô¨Ånite-
variable fragment. Suppose the variables of L1œÑ (Œ¶) have been ordered in some way.
Then the n-variable fragment of L1œÑ (Œ¶) is the set of L1œÑ (Œ¶) formulas that contain
only the Ô¨Årst n variables. As we will now see, by judicious reuse of variables, a
modal language with operators of arity at most n can be translated into the (n + 1)-
variable fragment of L1œÑ (Œ¶). (Reuse of variables is the name of the game when
working with Ô¨Ånite variable fragments. For example, we can express the existence
of three different points in a linear ordering using only two variables as follows:
‚àÉxy (x < y ‚àß ‚àÉx (y < x)).)
Proposition 2.49
(i) Let œÑ be a modal similarity type that only contains di-
amonds. Then, every œÑ -formula œÜ is equivalent to a Ô¨Årst-order formula
containing at most two variables.
(ii) More generally, if œÑ does not contain modal operators  whose arity ex-
ceeds n, all œÑ -formulas are equivalent to Ô¨Årst-order formulas containing at
most (n + 1) variables.
Proof. Assume œÑ contains only diamonds a, b, . . . ; proving the general case
is left as Exercise 2.4.2. Fix two distinct individual variables x and y. DeÔ¨Åne two
variants ST x and ST y of the standard translation as follows:
ST x (p) = P x
ST x (‚ä•) = x = x
ST x (¬¨œÜ) = ¬¨ST x (œÜ)
ST x (œÜ ‚à® œà) = ST x (œÜ) ‚à® ST x (œà)
ST x (aœÜ) = ‚àÉy (Ra xy ‚àß ST y (œÜ))
ST y (p) = P y
ST y (‚ä•) = y = y
ST y (¬¨œÜ) = ¬¨ST y (œÜ)
ST y (œÜ ‚à® œà) = ST y (œÜ) ‚à® ST y (œà)
ST y (aœÜ) = ‚àÉx (Ra yx ‚àß ST x (œÜ)).
Then, for any œÑ -formula œÜ, its ST x -translation contains at most the two variables
x and y, and STx (œÜ) is equivalent to the original standard translation of œÜ.
Example 2.50 Let us see how this modiÔ¨Åed standard translation works. Consider
again the formula 3(2p ‚Üí q).
ST x (3(2p ‚Üí q)) = ‚àÉy (Rxy ‚àß ST y (2p ‚Üí q))
= ‚àÉy (Rxy ‚àß (‚àÄx (Ryx ‚Üí ST x (p)) ‚Üí Qy))
= ‚àÉy (Rxy ‚àß (‚àÄx (Ryx ‚Üí P x) ‚Üí Qy)).
That is, we just keep Ô¨Çipping between the two variables x and y. The result is
a translation containing only two variables (instead of the three used in Exam-
ple 2.46). As a side effect, the indeterminacy associated with the original version
of the standard translation has disappeared.88
2 Models
This raises another question: is every Ô¨Årst-order formula Œ±(x) in two variables
equivalent to the translation of a basic modal formula? Again the answer is no.
There is even a Ô¨Årst-order formula in a single variable x which is not equivalent
to any modal formula, namely Rxx. To see this, assume for the sake of a con-
tradiction that œÜ is a modal formula such that STx (œÜ) is equivalent to Rxx. Let
M be a singleton reÔ¨Çexive model and let w be the unique state in M; obviously
(irrespective of the valuation) M |= Rxx[w]. Let N be a model based on the strict
ordering of the integers; obviously (again, irrespective of the valuation), for every
integer v, N |= ¬¨Rxx[v]. Let Z be the relation which links every integer with the
unique state in M, and assume that the valuations in N and M are such that Z is
a bisimulation (for example, make all proposition letters true at all points in both
models). As M |= Rxx[w], it follows by Proposition 2.47 that M, w  œÜ (after all,
by assumption Rxx is equivalent to ST x (œÜ)). But for any integer v, we have that
w ‚Üî v, hence N, v  œÜ. Hence (again by Proposition 2.47 and our assumption
that ST x (œÜ) is equivalent to Rxx) we have that N |= Rxx[v], contradicting the
fact that N |= ¬¨Rxx[v].
We will not discuss correspondence theory any further here, but in Section 2.6
we will prove one of its central results, the van Benthem Characterization Theorem:
a Ô¨Årst-order formula is equivalent to the translation of a modal formula if and only
if it is invariant under bisimulations.
Proposition 2.47 is also going to help us investigate modal expressivity in other
ways, notably via the concept of deÔ¨Ånability.
DeÔ¨Ånition 2.51 Let œÑ be a modal similarity type, C a class of œÑ -models, and Œì a
set of formulas over œÑ . We say that Œì deÔ¨Ånes or characterizes a class K of models
within C if for all models M in C we have that M is in K iff M  Œì . If C is
the class of all œÑ -models, we simply say that Œì deÔ¨Ånes or characterizes K; we omit
brackets whenever Œì is a singleton. We will say that a formula œÜ deÔ¨Ånes a property
whenever œÜ deÔ¨Ånes the class of models satisfying that property.
It is immediate from Proposition 2.47 that if a class of models is deÔ¨Ånable by a set
of modal formulas, then it is also deÔ¨Ånable by a set of Ô¨Årst-order formulas ‚Äì but
this is too obvious to be interesting. The important way in which Proposition 2.47
helps, is by making it possible to exploit standard model construction techniques
from Ô¨Årst-order model theory. For example, in Section 2.6 we will prove Theo-
rem 2.75 which says that a class of (pointed) models is modally deÔ¨Ånable if and
only if it is closed under bisimulations and ultraproducts (an important construc-
tion known from Ô¨Årst-order model theory; see Appendix A), and its complement
is closed under ultrapowers (another standard model theoretic construction). It
would be difÔ¨Åcult to overemphasize the importance of the standard translation; it
is remarkable that such a simple idea can lead to so much.2.4 The Standard Translation
89
To conclude this section, let us see how to adapt these ideas to the basic temporal
language, PDL, and arrow logic. The case of basic temporal logic is easy: all we
have to do is add a clause for translating the backward looking operator P :
ST x (P œÜ) = ‚àÉy (Ryx ‚àß ST y (œÜ)).
Note that we are using the more sophisticated approach introduced in the proof
of Proposition 2.49: Ô¨Çipping between two translations STx and ST y . (Thus we
really need to add a mirror clause which Ô¨Çips the variables back.) So, just like
the basic modal language, the basic temporal language can be mapped into a two
variable fragment of the correspondence language. Moreover (again, as with the
basic modal language) not every Ô¨Årst-order formula in two variables is equivalent
to (the translation of) a basic temporal formula (see Exercise 2.4.3).
Propositional dynamic logic calls for more drastic changes. Let us Ô¨Årst look at
the ‚àó-free fragment ‚Äì that is, at PDL formulas without occurrences of the Kleene
star. In PDL both formulas and modalities are recursively structured, so we are go-
ing to need two interacting translation functions: one to handle the formulas, the
other to handle the modalities. The only interesting clause in the formula transla-
tion is the following:
ST x (œÄœÜ) = ‚àÉy (ST xy (œÄ) ‚àß ST y (œÜ)).
That is, instead of returning a Ô¨Åxed relation symbol (say R), the formula translation
ST x calls on STxy to start recursively decomposing the program œÄ. Why does this
part of the translation require two free variables? Because its task is to deÔ¨Åne a
binary relation.
ST xy (a) = Ra xy (and similarly for other pairs of variables),
ST xy (œÄ1 ‚à™ œÄ2 ) = ST xy (œÄ1 ) ‚à® ST xy (œÄ2 ),
ST xy (œÄ1 ; œÄ2 ) = ‚àÉz (ST xz (œÄ1 ) ‚àß ST zy (œÄ2 )).
It follows that we can translate the ‚àó-free fragment of PDL into a three variable
fragment of the correspondence language. The details are worth checking; see
Exercise 2.4.4.
But the really drastic change comes when we consider the full language of PDL
(that is, with Kleene star). Recall that a program Œ±‚àó is interpreted using the reÔ¨Çex-
ive, transitive closure of RŒ± . But the reÔ¨Çexive, transitive closure of an arbitrary
relation is not a Ô¨Årst-order deÔ¨Ånable relation (see Exercise 2.4.5). So the standard
translation for PDL needs to take us to a richer background logic than Ô¨Årst-order
logic, one that can express this concept. Which one should we use? There are
many options here, but to motivate our actual choice recall the deÔ¨Ånition of the
meaning of a PDL program Œ±‚àó :
RŒ±‚àó =
n
(RŒ± )n ,2 Models
90
where RŒ±n is deÔ¨Åned by
R0 xy iff x = y and Rn+1 xy iff ‚àÉz (Rn xz ‚àß Rzy).
Thus, if we were allowed to write inÔ¨Ånitely long disjunctions, it would be easy to
capture the meaning of an iterated program Œ±‚àó :
(RŒ± )‚àó xy iff (x = y) ‚à® RŒ± xy ‚à®
‚àÉz1 . . . zn (RŒ± xz1 ‚àß ¬∑ ¬∑ ¬∑ ‚àß RŒ± zn y).
n‚â•1
In inÔ¨Ånitary logic we can do this. More precisely, in Lœâ1 œâ we are allowed to form
formulas as in Ô¨Årst-order logic, and, in addition, to build countably inÔ¨Ånite dis-
junctions and conjunctions. We will take Lœâ1 œâ as the target logic for the standard
translation of PDL. We have seen most of the clauses we need: we use the clauses
for the ‚àó-free fragment given above, and in addition the following clause to cater
for the Kleene star:
ST xy (Œ±‚àó ) =
(x = y) ‚à® ST xy (Œ±) ‚à®
‚àÉz1 . . . zn (ST xz1 (Œ±) ‚àß ¬∑ ¬∑ ¬∑ ‚àß ST zn y (Œ±)).
n‚â•1
This example of PDL makes an important point vividly: we cannot always hope
to embed modal logic into Ô¨Årst-order logic. Indeed in the following chapter we
will see that when it comes to analyzing the expressive power of modal logic at
the level of frames, the natural correspondence language (even for the basic modal
language) is second-order logic.
There is nothing particularly interesting concerning the standard translation for
the arrow language of Example 1.16. However, this changes when we turn to
square models: in Exercise 2.4.6 the reader is asked to prove that on this class of
models, the arrow language corresponds to a Ô¨Årst-order language with binary pred-
icate symbols, and that, in fact, it is expressively equivalent to the three variable
fragment of such a language.
Exercises for Section 2.4
2.4.1 Prove Proposition 2.47. That is, check that the standard translation really is correct.
2.4.2 Prove Proposition 2.49 for arbitrary modal languages. That is, show that if œÑ does
not contain modal operators  whose arity exceeds n, all œÑ -formulas are equivalent to
Ô¨Årst-order formulas containing at most (n + 1) variables.
2.4.3 Show that there are Ô¨Årst-order formulas Œ±(x) using at most two variables that are not
equivalent to the standard translation of a basic temporal formula.
2.4.4 In this exercise you should Ô¨Åll in some of the details for the standard translation for
PDL .2.5 Modal Saturation via UltraÔ¨Ålter Extensions
91
(a) Check that the translation for the ‚àó-free fragment of PDL really does map all such
formulas into the three variable fragment of the corresponding Ô¨Årst-order language.
(b) Show that in fact, there is a translation into the two variable fragment of this corre-
sponding Ô¨Årst-order language.
2.4.5 The aim of this exercise is to show that taking the reÔ¨Çexive, transitive closure of a
binary relation is not a Ô¨Årst-order deÔ¨Ånable operation.
(a) Show that the class of connected graphs is not Ô¨Årst-order deÔ¨Ånable:
(i) For l ‚àà N, let Cl be the graph given by a cycle of length l + 1:
Cl = ({0, . . . , l}, {(i, i + 1), (i + 1, i) | 0 ‚â§ i < l} ‚à™ {(0, l), (l, 0)})
Show that for every k ‚àà N and l ‚â• 2 k the graph C l satisÔ¨Åes the same Ô¨Årst-
order sentences of quantiÔ¨Åer rank at most k as the disjoint union C l  Cl .
(ii) Conclude that the class of connected graphs is not Ô¨Årst-order deÔ¨Ånable.
(b) Use item (a) to conclude that the reÔ¨Çexive transitive closure of a relation is not
Ô¨Årst-order deÔ¨Ånable.
2.4.6 Consider the class of square models for arrow logic. Observe that a square model
M = (SU , V ) can be seen as a Ô¨Årst-order model M ‚àó = (U, V (p))p‚ààŒ¶ if we let each
propositional variable p ‚àà Œ¶ correspond to a dyadic relation symbol P .
(a) Work out this observation in the following sense. DeÔ¨Åne a suitable translation (¬∑) ‚àó
mapping an arrow formula œÜ to a formula œÜ ‚àó (x0 , x1 ) in this ‚Äòdyadic correspondence
language.‚Äô Prove that this translation has the property that for all arrow formulas œÜ
and all square models M the following correspondence holds:
M, (a0 , a1 )  œÜ iff M‚àó |= œÜ‚àó (x0 , x1 )[a0 , a1 ].
(b) Show that this translation can be done within the three variable fragment of Ô¨Årst-
order logic.
(c) Prove that conversely, every formula Œ±(x 0 , x1 ) that uses only three variables, in a
Ô¨Årst-order language with binary predicates only, is equivalent to the translation of
an arrow formula on the class of square models.
2.5 Modal Saturation via UltraÔ¨Ålter Extensions
Bisimulations and the standard translation are two of the tools we need to under-
stand modal expressivity over models. This section introduces the third: ultraÔ¨Ålter
extensions. To motivate their introduction, we will Ô¨Årst discuss Hennessy-Milner
model classes and modally saturated models; both generalize ideas met in our ear-
lier discussion of bisimulations. We will then introduce ultraÔ¨Ålter extensions as a
way of building modally saturated models, and this will lead us to an elegant result:
modal equivalence implies bisimilarity-somewhere-else.
M-saturation
Theorem 2.20 tells us that bisimilarity implies modal equivalence, but we have
already seen that the converse does not hold in general (recall Figure 2.5). The92
2 Models
Hennessy-Milner Theorem shows that the converse does hold in the special case of
image-Ô¨Ånite models. Let us try and generalize this theorem.
First, when proving Theorem 2.24, we exploited the fact that, between image-
Ô¨Ånite models, the relation of modal equivalence itself is a bisimulation. Classes of
models for which this holds are evidently worth closer study.
DeÔ¨Ånition 2.52 (Hennessy-Milner Classes) Let œÑ be a modal similarity type, and
K a class of œÑ -models. K is a Hennessy-Milner class, or has the Hennessy-Milner
property, if for every two models M and M in K and any two states w, w of M
and M , respectively, w  w implies M, w ‚Üî M , w .
For example, by Theorem 2.24, the class of image-Ô¨Ånite models has the Hennessy-
Milner property. On the other hand, no class of models containing the two models
in Figure 2.5 has the Hennessy-Milner property.
We generalize the notion of image-Ô¨Åniteness; doing so leads us to the concept of
modally-saturated or (brieÔ¨Çy) m-saturated models. Suppose we are working in the
basic modal language. Let M = (W, R, V ) be a model, let w be a state in W , and
let Œ£ = {œÜ0 , œÜ1 , . . .} be an inÔ¨Ånite set of formulas. Suppose that w has successors
v0 , v1 , v2 , . . . where (respectively) œÜ0 , œÜ0 ‚àß œÜ1 , œÜ0 ‚àß œÜ1 ‚àß œÜ2 , . . . hold. If there is no
successor v of w where all formulas from Œ£ hold at the same time, then the model
is in some sense incomplete. A model is called m-saturated if incompleteness of
this kind does not occur.
To put it another way: suppose that we are looking for a successor of w at
which every formula œÜi of the inÔ¨Ånite set of formulas Œ£ = {œÜ0 , œÜ1 , . . .} holds.
M-saturation is a kind of compactness property, according to which it sufÔ¨Åces to
Ô¨Ånd satisfying successors of w for arbitrary Ô¨Ånite approximations of Œ£.
DeÔ¨Ånition 2.53 (M-saturation) Let M = (W, R, V ) be a model of the basic
modal similarity type, X a subset of W and Œ£ a set of modal formulas. Œ£ is
satisÔ¨Åable in the set X if there is a state x ‚àà X such that M, x  œÜ for all œÜ in Œ£;
Œ£ is Ô¨Ånitely satisÔ¨Åable in X if every Ô¨Ånite subset of Œ£ is satisÔ¨Åable in X.
The model M is called m-saturated if it satisÔ¨Åes the following condition for
every state w ‚àà W and every set Œ£ of modal formulas:
If Œ£ is Ô¨Ånitely satisÔ¨Åable in the set of successors of w,
then Œ£ is satisÔ¨Åable in the set of successors of w.
The deÔ¨Ånition of m-saturation for arbitrary modal similarity types runs as follows.
Let œÑ be a modal similarity type, and let M be a œÑ -model. M is called m-saturated
if, for every state w of M and every (n-ary) modal operator  ‚àà œÑ and sequence
Œ£1 , . . . , Œ£n of sets of modal formulas, we have the following:2.5 Modal Saturation via UltraÔ¨Ålter Extensions
93
If for every sequence of Ô¨Ånite subsets Œî1 ‚äÜ Œ£1 , . . . , Œîn ‚äÜ Œ£n there are
states v1 , . . . , vn such that Rwv1 . . . vn and v1  Œî1 , . . . , vn  Œîn ,
then there are states v1 , . . . , vn in M such that Rwv1 . . . vn and v1  Œ£1 ,
. . . , v n  Œ£n .
Proposition 2.54 Let œÑ be a modal similarity type. Then the class of m-saturated
œÑ -models has the Hennessy-Milner property.
Proof. We only prove the proposition for the basic modal language. Let M =
(W, R, V ) and M = (W  , R , V  ) be two m-saturated models. It sufÔ¨Åces to prove
that the relation  of modal equivalence between states in M and states in M is a
bisimulation. We conÔ¨Åne ourselves to a proof of the forth condition of a bisimula-
tion, since the condition concerning the propositional variables is trivially satisÔ¨Åed,
and the back condition is completely analogous to the case we prove.
So, assume that w, v ‚àà W and w ‚àà W  are such that Rwv and w  w .
Let Œ£ be the set of formulas true at v. It is clear that for every Ô¨Ånite subset Œî of


Œ£ we have M, v  Œî, hence M, w  3 Œî. As w  w , it follows that


M , w  3 Œî, so w has an R -successor vŒî such that M , vŒî  Œî. In
other words, Œ£ is Ô¨Ånitely satisÔ¨Åable in the set of successors of w ; but, then, by
m-saturation, Œ£ itself is satisÔ¨Åable in a successor v of w . Thus v  v .
UltraÔ¨Ålter extensions
So the class of m-saturated models satisÔ¨Åes the Hennessy-Milner property ‚Äì but
how do we actually build m-saturated models? To this end, we will now introduce
the last of the ‚Äòbig four‚Äô model constructions: ultraÔ¨Ålter extensions. The ultraÔ¨Ålter
extension of a structure (model or frame) is a kind of completion of the original
structure. The construction adds states to a model in order to make it m-saturated.
Sometimes the result is a model isomorphic to the original (for example, when
the original model is Ô¨Ånite) but when working with inÔ¨Ånite models, the ultraÔ¨Ålter
extension always adds lots of new points. In the deÔ¨Ånition of ultraÔ¨Ålter extension
we need operations on the power set algebra of a frame; we have already met one
of these operations in Section 1.4 when we introduced general frames.
DeÔ¨Ånition 2.55 Given an (n + 1)-ary relation R on a set W , we deÔ¨Åne the follow-
ing two n-ary operations mR and lR on the power set P(W ) of W :
mR (X1 , . . . , Xn ) := {w ‚àà W | there exist w1 , . . . , wn such that
Rww1 . . . wn and wi ‚àà Xi for all i},
lR (X1 , . . . , Xn ) := {w ‚àà W | for all w1 , . . . , wn : if Rww1 . . . wn ,
then there is an i with wi ‚àà Xi }.2 Models
94
For a binary relation R, mR (X) is the set of points that ‚Äòcan see‚Äô a state in X, and
lR (X) is the set of points that ‚Äòonly see‚Äô states in X. It follows that for any model
M = (W, R, V ) we have
V (3œÜ) = mR (V (œÜ)) and V (2œÜ) = lR (V (œÜ)).
Similar identities hold for modal operators of higher arity. Furthermore, for any
relation R, mR and lR are each other‚Äôs dual, in the following sense:
Proposition 2.56 Let R be a relation of arity n + 1 on the set W . Then, for every
n-tuple X1 , . . . , Xn of subsets of W we have
lR (X1 , . . . , Xn ) = W \ mR (W \ X1 , . . . , W \ Xn ).
Proof. Left to the reader.
We are ready to deÔ¨Åne ultraÔ¨Ålter extensions. As the name is meant to suggest, the
states of the ultraÔ¨Ålter extension of a model M are the ultraÔ¨Ålters over the universe
of M. Filters and ultraÔ¨Ålters are discussed in Appendix A. Readers encountering
this notion for the Ô¨Årst time, are advised to do Exercises 2.5.1‚Äì2.5.4.
DeÔ¨Ånition 2.57 (UltraÔ¨Ålter Extension) Let œÑ be a modal similarity type, and
F = (W , R)‚ààœÑ a œÑ -frame. The ultraÔ¨Ålter extension ue F of F is deÔ¨Åned as
ue )
the frame (Uf (W ), R
‚ààœÑ . Here Uf (W ) is the set of ultraÔ¨Ålters over W and
ue
R u0 u1 . . . un holds for a tuple u0 , . . . , un of ultraÔ¨Ålters over W if we have that
mR (X1 , . . . , Xn ) ‚àà u0 whenever Xi ‚àà ui for all i with 1 ‚â§ i ‚â§ n.
The ultraÔ¨Ålter extension of a œÑ -model M = (F, V ) is the model ue M = (ue F,
V ue ) where V ue (pi ) is the set of ultraÔ¨Ålters of which V (pi ) is a member.
What are the intuitions behind this deÔ¨Ånition? First, note that the main ingredients
have a logical interpretation. Any subset of a frame can, in principle, be viewed as
(the extension or interpretation of) a proposition. A Ô¨Ålter over the universe of the
frame can thus be seen as a theory, in fact as a logically closed theory, since Ô¨Ålters
are both closed under intersection (conjunction) and upward closed (entailment).
Viewed this way, a proper Ô¨Ålter is a consistent theory, for it does not contain the
empty set (falsum). Finally, an ultraÔ¨Ålter is a complete theory, or, as we will call it,
a state of affairs: for each proposition (subset of the universe) an ultraÔ¨Ålter chooses
between it and its negation (between the subset and its complementation).
How does this relate to ultraÔ¨Ålter extensions? In a given frame F not every state
of affairs needs to be ‚Äòrealized‚Äô, in the sense that there is a state satisfying all and
only the propositions belonging to the state of affairs; only the states of affairs that
correspond to the principal ultraÔ¨Ålters are realized, namely, as the points of the
frame. We build ue F by adding every state of affairs for F as a new element of the
domain ‚Äì that is, ue F realizes every proposition in F.2.5 Modal Saturation via UltraÔ¨Ålter Extensions
95
How should we relate these new elements in ue F to each other and to the original
ue u u . . . u if u
elements from F? The obvious choice is to stipulate that R
0 1
n
0
‚Äòsees‚Äô the n-tuple u1 , . . . , un . That is, whenever X1 , . . . , Xn are propositions of
u1 , . . . , un respectively, then u0 ‚Äòsees‚Äô this combination: that is, the proposition
mR (X1 , . . . , Xn ) is a member of u0 . The deÔ¨Ånition of the valuation V ue is self-
explanatory.
One Ô¨Ånal comment: a special role in this section is played by the so-called prin-
cipal ultraÔ¨Ålters over W . Recall that, given an element w ‚àà W , the principal
ultraÔ¨Ålter generated by w is the set œÄw = {X ‚äÜ W | w ‚àà X}. By identifying a
state w of a frame F with the principal ultraÔ¨Ålter œÄw , it is easily seen that any frame
F is (isomorphic to) a submodel (but in general not a generated submodel) of its
ultraÔ¨Ålter extension. For we have the following equivalences, here proved for the
basic modal similarity type:
Rwv
iffw ‚àà mR (X) for all X ‚äÜ W such that v ‚àà X
iffmR (X) ‚àà œÄw for all X ‚äÜ W such that X ‚àà œÄv
(2.1)
ue
R œÄw œÄv .
iff
Let us make our discussion more concrete by considering an example.
Example 2.58 Consider the frame N = (N, <), the natural numbers in their usual
ordering (a transitive model, though we haven‚Äôt drawn in arrows to indicate this):
0
u
1
- u
2
- u
3
- u
4
- u
-
...
What is the ultraÔ¨Ålter extension of N? There are two kinds of ultraÔ¨Ålters over an
inÔ¨Ånite set: the principal ultraÔ¨Ålters that are in one-to-one correspondence with
the points of the set, and the non-principal ones which contain all co-Ô¨Ånite sets,
and only inÔ¨Ånite sets, cf. Exercise 2.5.4. We have just remarked (see (2.1)) that
the principal ultraÔ¨Ålters form an isomorphic copy of the frame N inside ue N. So
where are the non-principal ultraÔ¨Ålters situated? The key fact here is that for any
pair u, u of ultraÔ¨Ålters, if u is non-principal, then Rue uu . To see this, let u be a
non-principal ultraÔ¨Ålter, and let X ‚àà u . As X is inÔ¨Ånite, for any n ‚àà N there is
an m such that n < m and m ‚àà X. This shows that m< (X) = N. But N is an
element of every ultraÔ¨Ålter u.
This shows that the ultraÔ¨Ålter extension of N looks like a gigantic balloon at the
end of an inÔ¨Ånite string: it consists of a copy of N, followed by a large (uncount-
able) cluster consisting of all the non-principal ultraÔ¨Ålters (again, the following
diagram represents a transitive model):
0t
1
- t
2
- t
3
- t
4
- t
-
...


t
t
t
t
t
t
t
t
t
t
t

2 Models
96
We will prove two results concerning ultraÔ¨Ålter extensions. The Ô¨Årst one, Proposi-
tion 2.59, is an invariance result: any state in the original model is modally equiv-
alent to the corresponding principal ultraÔ¨Ålter in the ultraÔ¨Ålter extension. Then, in
Proposition 2.61 we show that ultraÔ¨Ålter extensions are m-saturated. Putting these
two facts together leads us to the main result of this section: two states are modally
equivalent iff their representatives in the ultraÔ¨Ålter extensions are bisimilar.
Proposition 2.59 Let œÑ be a modal similarity type, and M a œÑ -model. Then, for
any formula œÜ and any ultraÔ¨Ålter u over W , V (œÜ) ‚àà u iff ue M, u  œÜ. Hence, for
every state w of M we have w  œÄw .
Proof. The second claim of the proposition is immediate from the Ô¨Årst one by the
observation that w  œÜ iff w ‚àà V (œÜ) iff V (œÜ) ‚àà œÄw .
The proof of the Ô¨Årst claim is by induction on œÜ. The basic case is immediate
from the deÔ¨Ånition of V ue . The proofs of the boolean cases are straightforward
consequences of the deÔ¨Åning properties of ultraÔ¨Ålters. As an example, we treat
negation; suppose that œÜ is of the form ¬¨œà, then
V (¬¨œà) ‚àà u
iff
iff
iff
iff
W \ V (œà) ‚àà u
V (œà) ‚àà u
ue M, u  œà
(induction hypothesis)
ue M, u  ¬¨œà.
Next, consider the case where œÜ is of the form 3œà (we only treat the basic modal
similarity type, leaving the general case as an exercise to the reader). Assume Ô¨Årst
that ue M, u  3œà. Then, there is an ultraÔ¨Ålter u such that Rue uu and ue M, u 
œà. The induction hypothesis implies that V (œà) ‚àà u , so by the deÔ¨Ånition of Rue ,
mR (V (œà)) ‚àà u. Now the result follows immediately from the observation that
mR (V (œà)) = V (3œà).
The left-to-right implication requires a bit more work. Assume that V (3œà) ‚àà u.
We have to Ô¨Ånd an ultraÔ¨Ålter u such that V (œà) ‚àà u and Rue uu . The latter con-
straint reduces to the condition that mR (X) ‚àà u whenever X ‚àà u , or equivalently
(see Exercise 2.5.5):
u0 := {Y | lR (Y ) ‚àà u} ‚äÜ u .
We will Ô¨Årst show that u0 is closed under intersection. Let Y , Z be members
of u0 . By deÔ¨Ånition, lR (Y ) and lR (Z) are in u. But then lR (Y ‚à© Z) ‚àà u, as
lR (Y ‚à© Z) = lR (Y ) ‚à© lR (Z), as a straightforward proof shows. This proves that
Y ‚à© Z ‚àà u0 .
Next we make sure that for any Y ‚àà u0 , Y ‚à©V (œà) = ‚àÖ. Let Y be an arbitrary el-
ement of u0 , then by deÔ¨Ånition of u0 , lR (Y ) ‚àà u. As u is closed under intersection
and does not contain the empty set, there must be an element x in lR (Y ) ‚à© V (3œà).
But then x must have a successor y in V (œà). Finally, x ‚àà lR (Y ) implies y ‚àà Y .2.5 Modal Saturation via UltraÔ¨Ålter Extensions
97
From the fact that u0 is closed under intersection, and the fact that for any Y ‚àà

u0 , Y ‚à© V (œà) = ‚àÖ, it follows that the set u0 ‚à™ {V (œà)} has the Ô¨Ånite intersection
property. So the UltraÔ¨Ålter Theorem (Fact A.14 in the Appendix) provides us with
an ultraÔ¨Ålter u such that u0 ‚à™ {V (œà)} ‚äÜ u . This ultraÔ¨Ålter u has the desired
properties: it is clearly a successor of u, and the fact that ue M, u  œà follows
from V (œà) ‚àà u and the induction hypothesis.
Example 2.60 As with the invariance results of Section 2.1 (disjoint unions, gen-
erated submodels, and bounded morphisms), our new invariance result can be used
to compare the relative expressive power of modal languages. Consider the modal
constant whose truth deÔ¨Ånition in a model for the basic modal language is
M, w 
iff M |= Rxx[v] for some v in M.
Can such a modality be deÔ¨Åned in the basic modal language? No ‚Äì a bisimulation
based argument given at the end of the previous section already establishes this.
Alternatively, we can see this by comparing the pictures of the frame (N, <) and
its ultraÔ¨Ålter extension given in Example 2.58. The former is loop-free (thus in any
model over this frame, M, 0  ), but the latter contains uncountably many loops
(thus ue M, œÄ0  ). So if we want we have to add it as a primitive.
Proposition 2.61 Let œÑ be a modal similarity type, and let M be a œÑ -model. Then
ue M is m-saturated.
Proof. We only prove the proposition for the basic modal similarity type. Let
M = (W, R, V ) be a model; we will show that its ultraÔ¨Ålter extension ue M is m-
saturated. Consider an ultraÔ¨Ålter u over W , and a set Œ£ of modal formulas which
is Ô¨Ånitely satisÔ¨Åable in the set of successors of u. We have to Ô¨Ånd an ultraÔ¨Ålter u
such that Rue uu and ue M, u  Œ£. DeÔ¨Åne
Œî = {V (œÜ) | œÜ ‚àà Œ£  } ‚à™ {Y | lR (Y ) ‚àà u},
where Œ£  is the set of (Ô¨Ånite) conjunctions of formulas in Œ£. We claim that the
set Œî has the Ô¨Ånite intersection property. Since both {V (œÜ) | œÜ ‚àà Œ£ } and {Y |
lR (Y ) ‚àà u} are closed under taking intersections, it sufÔ¨Åces to prove that for an
arbitrary œÜ ‚àà Œ£ and an arbitrary set Y ‚äÜ W for which lR (Y ) ‚àà u, we have
V (œÜ) ‚à© Y = ‚àÖ. But if œÜ ‚àà Œ£  , then by assumption, there is a successor u of u
such that ue M, u  œÜ, or, in other words, V (œÜ) ‚àà u . Then, lR (Y ) ‚àà u implies
Y ‚àà u by Exercise 2.5.5. Hence, V (œÜ) ‚à© Y is an element of the ultraÔ¨Ålter u and,
therefore, cannot be identical to the empty set.
It follows by the UltraÔ¨Ålter Theorem that Œî can be extended to an ultraÔ¨Ålter u .
Clearly, u is the required successor of u in which Œ£ is satisÔ¨Åed.2 Models
98
We have Ô¨Ånally arrived at the main result of this section: a characterization of
modal equivalence as bisimilarity-somewhere-else ‚Äì namely, between ultraÔ¨Ålter
extensions.
Theorem 2.62 Let œÑ be a modal similarity type, and let M and M be œÑ -models,
and w, w two states in M and M , respectively. Then
M, w  M , w iff ue M, œÄw ‚Üî ue M , œÄw .
Proof. Immediate by Propositions 2.59, 2.61 and 2.54.
Three remarks. First, it is easy to deÔ¨Åne ultraÔ¨Ålter extensions and prove an analog
of Theorem 2.62 for the basic temporal logic and arrow logic; see Exercises 2.5.8
and 2.5.9. With PDL the situation is a bit more complex; see Exercise 2.5.11. (The
problem is that the property of one relation being the reÔ¨Çexive transitive closure
of another is not preserved under taking ultraÔ¨Ålter extensions.) Second, we have
not seen the last of ultraÔ¨Ålter extensions. Like disjoint unions, generated submod-
els, and bounded morphisms, ultraÔ¨Ålter extensions are a fundamental modal model
construction technique, and we will make use of them when we discuss frames (in
Chapter 3) and algebras (in Chapter 5). We will shortly see that ultraÔ¨Ålter exten-
sions tie in neatly with ideas from Ô¨Årst-order model theory ‚Äì and we will use this
to prove a second bisimilarity-somewhere-else result, Lemma 2.66. Finally, some
readers may still have the feeling that taking the ultraÔ¨Ålter extension of a model is
a far less natural construction than the other model operations that we have met.
These readers are advised to hold on until (or take a peek ahead towards) Chapter 5,
where we will see that ultraÔ¨Ålter extensions are indeed a very natural byproduct of
modal logic‚Äôs duality theory.
Exercises for Section 2.5
2.5.1 Let E be any subset of P(W ), and let F be the Ô¨Ålter generated by E.
(a) Prove that indeed, F is a Ô¨Ålter over W . (Show that in general, the intersection of a
collection of Ô¨Ålters is again a Ô¨Ålter.)
(b) Show that F is the set of all X ‚àà P(W ) such that either X = W or for some Y 1 ,
. . . , Yn ‚àà E,
Y1 ‚à© ¬∑ ¬∑ ¬∑ ‚à© Yn ‚äÜ X.
(c) Prove that F is proper (that is: it does not coincide with P(W )) iff E has the Ô¨Ånite
intersection property.
2.5.2 Let W be a non-empty set, and let w be an element of W . Show that the principal
ultraÔ¨Ålter generated by w, that is, the set {X ‚àà P(W ) | w ‚àà X}, is indeed an ultraÔ¨Ålter
over W .
2.5.3 Let F be a Ô¨Ålter over W .2.5 Modal Saturation via UltraÔ¨Ålter Extensions
99
(a) Prove that F is an ultraÔ¨Ålter if and only if it is proper and maximal, that is, it has
no proper extensions.
(b) Prove that F is an ultraÔ¨Ålter if and only if it is proper and for each pair of subsets
X, Y of W we have that X ‚à™ Y ‚àà F iff X ‚àà F or Y ‚àà F .
2.5.4 Let W be an inÔ¨Ånite set. Recall that X ‚äÜ W is co-Ô¨Ånite if W \ X is Ô¨Ånite.
(a) Prove that the collection of co-Ô¨Ånite subsets of W has the Ô¨Ånite intersection prop-
erty.
(b) Show that there are ultraÔ¨Ålters over W that do not contain any Ô¨Ånite set.
(c) Prove that an ultraÔ¨Ålter is non-principal if and only if it contains only inÔ¨Ånite sets
if and only if it contains all co-Ô¨Ånite sets.
(d) Prove that any ultraÔ¨Ålter over W has uncountably many elements.
2.5.5 Given a model M = (W, R, V ) and two ultraÔ¨Ålters u and v over W , show that
Rue uv if and only if {Y | l R (Y ) ‚àà u} ‚äÜ v.
2.5.6 Let B = (B, R) be the transitive binary tree; that is, B is the set of Ô¨Ånite strings of
0s and 1s, and RœÉœÑ holds if œÉ is a proper initial segment of œÑ . The aim of this exercise is
to prove that any non-principal ultraÔ¨Ålter over B determines an inÔ¨Ånite string of 0s and 1s.
More precisely, let B œâ be the set of Ô¨Ånite and inÔ¨Ånite strings of 0s and 1s, and R œâ the
relation on B œâ given by R œâ œÉœÑ if either œÉ is Ô¨Ånite and a proper initial segment of œÑ , or else
œÉ = œÑ . DeÔ¨Åne a bounded morphism f : ue B ‚Üí B œâ .
2.5.7 Give an example of a model M which is point-generated while its ultraÔ¨Ålter exten-
sion is not.
2.5.8 Develop a notion of ultraÔ¨Ålter extension for basic temporal logic, and establish an
analog of Theorem 2.62 for basic temporal logic.
2.5.9 Develop a notion of ultraÔ¨Ålter extension for the arrow language introduced in Exam-
ple 1.14, and establish an analog of Theorem 2.62 for this language.
2.5.10 Show that, in general, Ô¨Årst-order formulas are not preserved under ultraÔ¨Ålter ex-
tensions. That is, give a model M, a state w, and a Ô¨Årst-order formula Œ±(x) such that
M |= Œ±(x)[w], but ue M |= Œ±(x)[œÄw ], where œÄw is the principal ultraÔ¨Ålter generated by
w.
2.5.11 Consider a modal similarity type with two diamonds, 3 and ‚àó, and take any
model M = (S, R, R‚àó , V ) with
S
R
R‚àó
= N ‚à™ {‚àû},
= {(n + 1, n), (‚àû, n) | n ‚àà N},
= {(m, n) | m, n ‚àà N, m ‚â• n} ‚à™ ({‚àû} √ó S).
Note that R‚àó is the reÔ¨Çexive transitive closure of R.
(a) Show that M, ‚àû  2‚àó2‚ä•.
(b) Let u be an arbitrary non-principal ultraÔ¨Ålter over S. Prove that R ue œÄ‚àû u.
(c) Let u be an arbitrary non-principal ultraÔ¨Ålter over S. Prove that u has an R ue -
successor in ue M, and that each of its R ue -successors is again a non-principal
ultraÔ¨Ålter.100
2 Models
(d) Now suppose that we add a new diamond  to the language, and that in the
model ue M we take R to be the reÔ¨Çexive transitive closure of R ue . Show that
ue M, œÄ‚àû  3[]3.
(e) Prove that R ‚àóue = R . (Hint: use Proposition 2.59, and conclude that the ultraÔ¨Ålter
extension of a regular PDL-model need not be a regular PDL-model.)
(f) Prove that every non-principal ultraÔ¨Ålter over S has a unique R ue -successor.
2.6 Characterization and DeÔ¨Ånability
In Section 2.3 we posed two important questions about modal expressivity:
(i) What is the modal fragment of Ô¨Årst-order logic? That is, which Ô¨Årst-order
formulas are equivalent to the standard translation of a modal formula?
(ii) Which properties of models are deÔ¨Ånable by means of modal formulas?
In this, the Ô¨Årst advanced track section of the book, we answer both questions. Our
main tool will be a second characterization of modal equivalence as bisimilarity-
somewhere-else, the Detour Lemma. Unlike the characterization just proved (The-
orem 2.62), the Detour Lemma rests on a number of non-modal concepts and re-
sults, all of which are centered on saturated models (a standard concept of Ô¨Årst-
order model theory). We start by introducing saturated models and use them to
describe the modal fragment of Ô¨Årst-order logic. After that we show how to build
saturated models. As corollaries we obtain results on modally deÔ¨Ånable proper-
ties of models. For background information on Ô¨Årst-order model theory, see Ap-
pendix A.
The van Benthem Characterization Theorem
To deÔ¨Åne the notion of saturated models, we need the concept of Œ±-saturation, but
before giving a formal deÔ¨Ånition of the latter, we provide an informal description,
which the reader may want to use as a ‚Äòworking‚Äô deÔ¨Ånition.
Informally, then, the notion of Œ±-saturation can be explained as follows. First of
all, let Œì (x) be a set of Ô¨Årst-order formulas in which a single individual variable
x may occur free ‚Äì such a set of formulas is called a type. A Ô¨Årst-order model M
realizes Œì (x) if there is an element w in M such that for all Œ≥ ‚àà Œì , M |= Œ≥[w].
Next, let M be a model for a given Ô¨Årst-order language L1 with domain W .
For a subset A ‚äÜ W , L1 [A] is the language obtained by extending L1 with new
constants a for all elements a ‚àà A. MA is the expansion of M to a structure for
L1 [A] in which each a is interpreted as a.
Assume that A is of size at most Œ±. For the sake of our informal deÔ¨Ånition
of Œ±-saturation, assume that Œ± = 3 and A = {a1 , a2 }. Let Œì (a1 , a2 , x) be a
type of the language L1 [A]; it is not difÔ¨Åcult to see that Œì (a1, a2 , x) is consistent
with the Ô¨Årst-order theory of MA iff Œì (a1 , a2 , x) is Ô¨Ånitely realizable in MA , (that2.6 Characterization and DeÔ¨Ånability
101
is, MA realizes every Ô¨Ånite subset Œî of Œì (a1, a2 , x)). So, for this particular set
Œì (a1 , a2 , x), 3-saturation of M means that if Œì (a1, a2 , x) is Ô¨Ånitely realizable in
MA , then Œì (a1, a2 , x) is realizable in MA .
Yet another way of looking at 3-saturation for this particular set of formulas is
the following. Consider a formula Œ≥(a1 , a2 , x), and let Œ≥(x1 , x2 , x) be the formula
with the fresh variables x1 and x2 replacing each occurrence in Œ≥ of a1 and a2 ,
respectively. Then we have the following equivalence:
MA realizes {Œ≥(a1 , a2 , x)} iff there is a b such that M |= Œ≥(x1 , x2 , x)[a1 , a2 , b].
So, a model is Œ±-saturated iff the following holds for every n < Œ±, and every set Œì
of formulas of the form Œ≥(x1 , . . . , xn , x).
If (a1 , . . . , an ) is an n-tuple such that for every Ô¨Ånite Œî ‚äÜ Œì there is a bŒî
such that M |= Œ≥(x1 , . . . , xn , x)[a1 , . . . , an , bŒî ] for every Œ≥ ‚àà Œî,
then we have that there is a b such that M |= Œ≥(x1 , . . . , xn , x)[a1 , . . . , an , b]
for every Œ≥ ‚àà Œì .
This way of looking at Œ±-saturation is useful, for it makes the analogy with m-
saturation of the previous section clear. Both m-saturated and countably saturated
models are rich in the number of types Œì (x) they realize, but the latter are far richer
than the former: they realize the maximum number of types.
Now, for the ‚ÄòofÔ¨Åcial‚Äô deÔ¨Ånition of Œ±-saturation.
DeÔ¨Ånition 2.63 Let Œ± be a natural number, or œâ. A model M is Œ±-saturated if for
every subset A ‚äÜ W of size less than Œ±, the expansion MA realizes every set Œì (x)
of L1 [A]-formulas (with only x occurring free) that is consistent with the Ô¨Årst-order
theory of MA . An œâ-saturated model is usually called countably saturated.
Example 2.64 (i) Every Ô¨Ånite model is countably saturated. For, if M is Ô¨Ånite,
and Œì (x) is a set of Ô¨Årst-order formulas consistent with the Ô¨Årst-order theory of
M, there exists a model N that is elementarily equivalent to M and that realizes
Œì (x). But, as M and N are Ô¨Ånite, elementary equivalence implies isomorphism,
and hence Œì (x) is realized in M.
(ii) The ordering of the rational numbers (Q, <) is countably saturated as well.
The relevant Ô¨Årst-order language L1 has < and =. Take a subset A of Q and
let Œì (x) be a set of formulas in the resulting expansion L1 [A] of this Ô¨Årst-order
language that is consistent with the theory of (Q, <, a)a‚ààA . Then there exists a
model N of the theory of (Q, <, a)a‚ààA that realizes Œì (x). Now take a countable
elementary submodel N of N that contains at least one object realizing Œì (x). Then
N is a countable dense linear ordering without endpoints, and hence the ordering
of N is isomorphic to (Q, <). The interpretations (in N) of the constants a for102
2 Models
elements a in A may be copied across to N . Hence, as N realizes Œì (x), so does
N , and hence, so does (Q, <), as required.
(iii) The ordering of the natural numbers (N, <) is not countably saturated. To
see this, consider the following set of formulas:
Œì (x) := {‚àÉy1 (y1 < x), . . . , ‚àÉy1 . . . yn (y1 < ¬∑ ¬∑ ¬∑ < yn < x), . . .}.
Œì (x) is clearly consistent with the theory of (N, <) as each of its Ô¨Ånite subsets is
realizable in (N, <). Yet Œì (x) is clearly not realizable in (N, <).
The following result explains why countably saturated models matter to us.
Theorem 2.65 Let œÑ be a modal similarity type. Any countably saturated œÑ -model
is m-saturated. It follows that the class of countably saturated œÑ -models has the
Hennessy-Milner property.
Proof. We only consider the basic modal language. Assume that M = (W, R, V ),
viewed as a Ô¨Årst-order model, is countably saturated. Let a be a state in W , and
consider a set Œ£ of modal formulas which is Ô¨Ånitely satisÔ¨Åable in the successor set
of a. DeÔ¨Åne Œ£  to be the set
Œ£  = {Rax} ‚à™ ST x (Œ£),
where ST x (Œ£) is the set {ST x (œÜ) | œÜ ‚àà Œ£} of standard translations of formulas
in Œ£. Clearly, Œ£  is consistent with the Ô¨Årst-order theory of Ma : Ma realizes every
Ô¨Ånite subset of Œ£ , namely in some successor of a. So, by the countable saturation
of M, Œ£  itself is realized in some state b. By Ma |= Rax[b] it follows that b is a
successor of a. Then, by Proposition 2.47 and the fact that Ma |= STx (œÜ)[b] for
all œÜ ‚àà Œ£, it follows that M, b  Œ£. Thus Œ£ is satisÔ¨Åable in a successor of a.
In fact, we only need 2-saturation for the proof of Theorem 2.65 to go through.
This is because we restricted ourselves to the basic modal similarity type. We
leave it to the reader to check to which extent the ‚Äòamount of saturation‚Äô needed to
make the proof of Theorem 2.65 go through depends on the rank of the operators
of the similarity type.
We have yet to show that countably saturated models actually exist; this issue
will be addressed below (see Theorem 2.74). For now, we merely want to record the
following important use of saturated models; you may want to recall the deÔ¨Ånition
of an elementary embedding before reading the result (see Appendix A).
Lemma 2.66 (Detour Lemma) Let œÑ be a modal similarity type, and let M and
N be œÑ -models, and w and v states in M and N, respectively. Then the following
are equivalent:
(i) For all modal formulas œÜ: M, w  œÜ iff N, v  œÜ.2.6 Characterization and DeÔ¨Ånability
103
(ii) There exists a bisimulation Z : ue M, œÄw ‚Üî ue N, œÄv .
(iii) There exist countably saturated models M‚àó , w‚àó and N‚àó , v ‚àó and elementary
embeddings f : M M‚àó and g : N N‚àó such that
(a) f (w) = w‚àó and g(v) = v‚àó ,
(b) M‚àó , w‚àó ‚Üî N‚àó , v ‚àó .
What does the Detour Lemma say in words? Obviously (i) ‚áí (ii) is just our old
bisimulation-somewhere-else result (Theorem 2.62). The key new part is the im-
plication (i) ‚áí (iii). This says that if M, w and N, v are modally equivalent, then
both can be extended ‚Äì more accurately: elementarily extended ‚Äì to countably sat-
urated models M‚àó , w‚àó and N‚àó , v ‚àó . As M, w and N, v were modally equivalent,
so are M‚àó , w‚àó and N‚àó , v ‚àó ; it follows by Theorem 2.65 that the latter two models
are bisimilar. In short, this is a second ‚Äòbisimilarity-somewhere-else‚Äô result, this
time the ‚Äòsomewhere else‚Äô being ‚Äòin some suitable ultrapower‚Äô. Notice that in or-
der to prove the Detour Lemma all we need to establish is that every model can be
elementarily embedded in a countably saturated model. There are standard Ô¨Årst-
order techniques for doing this, and we will introduce one in the second half of this
section.
With the help of the Detour Lemma, we can now precisely characterize the
relation between Ô¨Årst-order logic, modal logic, and bisimulations. To prove the
theorem we need to explicitly deÔ¨Åne a concept which we have already invoked
informally on several occasions.
DeÔ¨Ånition 2.67 A Ô¨Årst-order formula Œ±(x) in L1œÑ is invariant for bisimulations if
for all models M and N, and all states w in M, v in N, and all bisimulations Z
between M and N such that wZv, we have M |= Œ±(x)[w] iff N |= Œ±(x)[v].
Theorem 2.68 (van Benthem Characterization Theorem) Let Œ±(x) be a Ô¨Årst-
order formula in L1œÑ . Then Œ±(x) is invariant for bisimulations iff it is equivalent to
the standard translation of a modal œÑ -formula.
Proof. The direction from right to left is a consequence of Theorem 2.20. To prove
the direction from left to right, assume that Œ±(x) is invariant for bisimulations and
consider the set of modal consequences of Œ±:
MOC(Œ±) = {ST x (œÜ) | œÜ is a modal formula, and Œ±(x) |= ST x (œÜ)}.
Our Ô¨Årst claim is that if MOC(Œ±) |= Œ±(x), then Œ±(x) is equivalent to the translation
of a modal formula. To see why this is so, assume that MOC(Œ±) |= Œ±(x); then,
by the Compactness Theorem for Ô¨Årst-order logic, for some Ô¨Ånite subset X ‚äÜ


MOC(Œ±) we have X |= Œ±(x). So |= X ‚Üí Œ±(x). Trivially |= Œ±(x) ‚Üí X,

thus |= Œ±(x) ‚Üî X. And as every Œ≤ ‚àà X is the translation of a modal formula,

so is X. This proves our claim.2 Models
104
So it sufÔ¨Åces to show that MOC(Œ±) |= Œ±(x). Assume M |= MOC(Œ±)[w]; we
need to show that M |= Œ±(x)[w]. Let
T (x) = {ST x (œÜ) | M |= ST x (œÜ)[w]}.
We claim that T (x) ‚à™ {Œ±(x)} is consistent. Why? Assume, for the sake of con-
tradiction, that T (x) ‚à™ {Œ±(x)} is inconsistent. Then, by compactness, for some


Ô¨Ånite subset T0 (x) ‚äÜ T (x) we have |= Œ±(x) ‚Üí ¬¨ T0 (x). Hence ¬¨ T0 (x) ‚àà

MOC(Œ±). But this implies M |= ¬¨ T0 (x)[w], which contradicts T0 (x) ‚äÜ T (x)
and M |= T (x)[w].
So, let N, v be such that N |= T (x) ‚à™ {Œ±(x)}[v]. Observe that w and v are
modally equivalent: M, w  œÜ implies ST x (œÜ) ‚àà T (x), which implies N, v  œÜ;
and likewise, if M, w  œÜ then M, w  ¬¨œÜ, and N, v  ¬¨œÜ. If modal equivalence
implied bisimilarity we would be done, because then M, w and N, v would be
bisimilar, and from this we would be able to deduce the desired conclusion M |=
Œ±(x)[w] by invariance under bisimulation. But, in general, modal equivalence does
not imply bisimilarity, so this is not a sound argument.
However, we can use the Detour Lemma and make a detour through a Hennessy-
Milner class where modal equivalence and bisimilarity do coincide! More pre-
cisely, the Detour Lemma yields two countably saturated models M‚àó , w‚àó M, w
and N‚àó , v ‚àó N, v such that M‚àó , w‚àó ‚Üî N‚àó , v ‚àó :
M, w



N, v



M‚àó , w‚àó ‚Üî N‚àó , v ‚àó .
This is where we really need the new characterization of modal equivalence in
terms of bisimulation-somewhere-else that Theorem 2.74 gives us. We need to
‚Äòlift‚Äô the Ô¨Årst-order formula Œ±(x) from the model N, v to the model N‚àó , v ‚àó . By
deÔ¨Ånition, the truth of Ô¨Årst-order formulas is preserved under elementary embed-
dings, so that this can indeed be done. However, Ô¨Årst-order formulas need not be
preserved under ultraÔ¨Ålter extensions (see Exercise 2.5.10), and for that reason we
cannot use the ultraÔ¨Ålter extension ue N, œÄv instead of N‚àó , v ‚àó .
Returning to the main argument, N |= Œ±(x)[v] implies N‚àó |= Œ±(x)[v ‚àó ]. As
Œ±(x) is invariant for bisimulations, we get M‚àó |= Œ±(x)[w‚àó ]. By invariance under
elementary embeddings, we have M |= Œ±(x)[w]. This proves the theorem.
Ultraproducts
The preceding discussion left us with an important technical question: how do
we get countably saturated models? Our next aim is to answer this question and
thereby prove the Detour Lemma.2.6 Characterization and DeÔ¨Ånability
105
The fundamental construction underlying our proof is that of an ultraproduct.
Here we brieÔ¨Çy recall the basic ideas; further details may be found in Appendix A.
We Ô¨Årst apply the construction to sets, and then to models. Suppose I = ‚àÖ, U is

an ultraÔ¨Ålter over I, and for each i ‚àà I, Wi is a non-empty set. Let C = i‚ààI Wi
be the cartesian product of those sets. That is: C is the set of all functions f with
domain I such that for each i ‚àà I, f (i) ‚àà Wi . For two functions f , g ‚àà C we say
that f and g are U -equivalent (notation f ‚àºU g) if {i ‚àà I | f (i) = g(i)} ‚àà U .
The result is that ‚àºU is an equivalence relation on the set C.
DeÔ¨Ånition 2.69 (Ultraproduct of Sets) Let fU be the equivalence class of f mod-
ulo ‚àºU , that is: fU = {g ‚àà C | g ‚àºU f }. The ultraproduct of Wi modulo U ,

denoted as U Wi , is the set of all equivalence classes of ‚àºU . So


U Wi = {fU | f ‚àà
i‚ààI Wi }.
In the case where all the sets are the same, say Wi = W for all i, the ultraproduct

is called the ultrapower of W modulo U , and written U W .
Following the general deÔ¨Ånition of the ultraproduct of Ô¨Årst-order models (DeÔ¨Åni-
tion A.17), we now deÔ¨Åne the ultraproduct of modal models.
DeÔ¨Ånition 2.70 (Ultraproduct of Models) Fix a modal similarity type œÑ , and let

Mi (i ‚àà I) be œÑ -models. The ultraproduct U Mi of Mi modulo U is the model
described as follows:


(i) The universe WU of U Mi is the set U Wi , where Wi is the universe of
Mi .

(ii) Let Vi be the valuation of Mi . Then the valuation VU of U Mi is deÔ¨Åned
by
fU ‚àà VU (p) iff {i ‚àà I | f (i) ‚àà Vi (p)} ‚àà U.
(iii) Let  be a modal operator in œÑ , and Ri its associated relation in the model

Mi . The relation RU in U Mi is given by
RU fU1 . . . fUn+1 iff {i ‚àà I | Ri f 1 (i) . . . f n+1 (i)} ‚àà U.
In particular, for a diamond, item (iii) boils down to
R3U fU gU iff {i ‚àà I | R3i f (i)g(i)} ‚àà U.
To show that the above deÔ¨Ånition is consistent, we should check that VU and RU
depend only on the equivalence classes fU1 , . . . , fUn+1 .

Proposition 2.71 Let U M be an ultrapower of M. Then, for all modal formulas

œÜ we have M, w  œÜ iff U M, (fw )U  œÜ, where fw is the constant function such
that fw (i) = w, for all i ‚àà I.106
2 Models
Proof. This is left as Exercise 2.6.1.
To build countably saturated models, we use ultraproducts based on a special kind
of ultraÔ¨Ålter. An ultraÔ¨Ålter is countably incomplete if it is not closed under count-
able intersections (of course, it will be closed under Ô¨Ånite intersections).
Example 2.72 Consider the set of natural numbers N. Let U be an ultraÔ¨Ålter over
N that does not contain any singletons {n}. (The reader is asked to prove that such
ultraÔ¨Ålters exist in Exercise 2.5.4.) Then, for all n, (N \ {n}) ‚àà U . But

‚àÖ = n‚ààN (N \ {n}) ‚àà
/ U.
So U is countably incomplete.
Lemma 2.73 Let L be a countable Ô¨Årst-order language, U a countably incomplete

ultraÔ¨Ålter over a non-empty set I, and M an L-model. The ultrapower U M is
countably saturated.
Proof. A standard result. See Appendix A for a proof reference.
We are now ready to prove the Detour Lemma. In Theorem 2.62 we showed that
‚Äòbisimulation-somewhere-else‚Äô can mean ‚Äòin the ultraÔ¨Ålter extension.‚Äô Now we will
show that it can also mean: ‚Äòin a suitable ultrapower of the original models.‚Äô
Theorem 2.74 Let œÑ be a modal similarity type, and let M and N be œÑ -models,
and w and v states in M and N, respectively. Then the following are equivalent:
(i) For all modal formulas œÜ: M, w  œÜ iff N, v  œÜ.


(ii) There exist ultrapowers U M and U N as well as a bisimulation Z :


‚Üî U N, (fv )U linking (fw )U and (fv )U , where fw (fv ) is
U M, (fw )U
the constant function mapping every index to w (v).
Proof. It is easy to see that (ii) implies (i). By Proposition 2.71 M, w  œÜ iff


U M, (fw )U  œÜ. By assumption this is equivalent to
U N, (fv )U  œÜ, and
the latter is equivalent to N, v  œÜ.
To prove the implication from (i) to (ii) we have to do some more work. Assume
that for all modal formulas œÜ we have M, w  œÜ iff N, v  œÜ. We need to create
bisimilar ultrapowers of M and N.
Take the set of natural numbers N as our index set, and let U be a countably
incomplete ultraÔ¨Ålter over N (cf. Example 2.72). By Lemma 2.73 the ultrapowers


Now (fw )U and (fv )U are modally
U M and
U N are countably saturated.


equivalent: for all modal formulas œÜ, U M, (fw )U  œÜ iff U N, (fv )U  œÜ.
This claim follows from the assumption that w and v are modally equivalent to-
gether with Proposition 2.71. Next, apply Theorem 2.65: as (fw )U and (fv )U are2.6 Characterization and DeÔ¨Ånability
107


modally equivalent and U M and U N are countably saturated, there exists a


bisimulation Z : U M, (fw )U ‚Üî U N, (fv )U . This proves the theorem.
We obtain the Detour Lemma as an immediate corollary of Theorem 2.74 and
Theorem 2.62.
DeÔ¨Ånability
Our next aim is to answer the second of the two questions posed at the start of this
section: which properties of models are deÔ¨Ånable by means of modal formulas?
Like the Detour Lemma, the answer is a corollary of Theorem 2.74. We formulate
the result in terms of pointed models. Given a modal similarity type œÑ , a pointed
model is a pair (M, w) where M is a œÑ -model and w is a state of M. Although
the results below can also be given for models, the use of pointed models allows
for a smoother formulation, mainly because pointed models reÔ¨Çect the local way
in which modal formulas are evaluated.
We need some further deÔ¨Ånitions. A class of pointed models K is said to be
closed under bisimulations if (M, w) in K and M, w ‚Üî N, v implies (N, v) in

K. K is closed under ultraproducts if any ultraproduct U (Mi , wi ) of a family of
pointed models (Mi , wi ) in K belongs to K. If K is a class of pointed œÑ -models, K
denotes the complement of K within the class of all pointed œÑ -models. Finally, K is
deÔ¨Ånable by a set of modal formulas if there is a set of modal formulas Œì such that
for any pointed model (M, w) we have (M, w) in K iff for all Œ≥ ‚àà Œì , M, w  Œ≥;
K is deÔ¨Ånable by a single modal formula iff it is deÔ¨Ånable by a singleton set.
By Theorem 2.20 deÔ¨Ånable classes of pointed models must be closed under
bisimulations, and by Proposition 2.47 and Corollary A.20 they must be closed
under ultraproducts as well. Theorems 2.75 and 2.76 below show that these two
closure conditions sufÔ¨Åce to completely describe the classes of pointed models that
are deÔ¨Ånable by means of modal formulas.
Theorem 2.75 Let œÑ be a modal similarity type, and K a class of pointed œÑ -models.
Then the following are equivalent:
(i) K is deÔ¨Ånable by a set of modal formulas.
(ii) K is closed under bisimulations and ultraproducts, and K is closed under
ultrapowers.
Proof. The implication from (i) to (ii) is easy. For the converse, assume K and K
satisfy the stated closure conditions. Observe that K is closed under bisimulations,
as K is. DeÔ¨Åne T as the set of modal formulas holding in K:
T = {œÜ | for all (M, w) in K: M, w  œÜ}.
We will show that T deÔ¨Ånes the class K. First of all, by deÔ¨Ånition every pointed108
2 Models
model (M, w) in K is a model satisfying T in the sense that M, w  T . Second,
assume that M, w  T ; to complete the proof of the theorem we show that (M, w)
must be in K.
DeÔ¨Åne Œ£ to be the modal theory of w; that is, Œ£ = {œÜ | M, w  œÜ}. It is
obvious that Œ£ is Ô¨Ånitely satisÔ¨Åable in K; for suppose that the set {œÉ1 , . . . , œÉn } ‚äÜ
Œ£ is not satisÔ¨Åable in K. Then the formula ¬¨(œÉ1 ‚àß ¬∑ ¬∑ ¬∑ ‚àß œÉn ) would be true on all
pointed models in K, so it would belong to T , yet be false in M, w. But then the
following claim shows that Œ£ is satisÔ¨Åable in the ultraproduct of pointed models
in K.
Claim 1 Let Œ£ be a set of modal formulas, and K a class of pointed models in
which Œ£ is Ô¨Ånitely satisÔ¨Åable. Then Œ£ is satisÔ¨Åable in some ultraproduct of models
in K.
Proof of Claim. DeÔ¨Åne an index set I as the collection of all Ô¨Ånite subsets of Œ£:
I = {Œ£0 ‚äÜ Œ£ | Œ£0 is Ô¨Ånite}.
By assumption, for each i ‚àà I there is a pointed model (Ni , vi ) in K such that
N , v  i. We now construct an ultraÔ¨Ålter U over I such that the ultraproduct
i i

U Ni has a state fU with
U Ni , fU  Œ£.
For each œÉ ‚àà Œ£, let œÉ
 be the set of all i ‚àà I such that œÉ ‚àà i. Then the set
E = {
œÉ | œÉ ‚àà Œ£} has the Ô¨Ånite intersection property because
{œÉ1 , . . . , œÉn } ‚àà œÉ
1 ‚à© ¬∑ ¬∑ ¬∑ ‚à© œÉ
n .

So, by Fact A.14, E can be extended to an ultraÔ¨Ålter U over I. This deÔ¨Ånes U Ni ;
for the deÔ¨Ånition of fU , let Wi denote the universe of the model Ni and consider

the function f ‚àà i‚ààI Wi such that f (i) = vi .
It is left to prove that

(2.2)
U Ni , fU  Œ£.
To prove (2.2), observe that for i ‚àà œÉ
 we have œÉ ‚àà i, and so Ni , vi  œÉ. Therefore,
for each œÉ ‚àà Œ£
{i ‚àà I | Ni , vi  œÉ} ‚äá œÉ
 and œÉ
 ‚àà U.
It follows that {i ‚àà I | Ni , vi  œÉ} ‚àà U , so by Theorem A.19,
This proves (2.2), and, hence, Claim 1.

U Ni , fU  œÉ.
It follows from Claim 1 and the closure of K under taking ultraproducts that Œ£ is
satisÔ¨Åable in some pointed model (N, v) in K. But N, v  Œ£ implies that v and
the state w from our original pointed model (M, w) are modally equivalent. So by
Theorem 2.74 there exists an ultraÔ¨Ålter U such that


‚Üî U  (M, w), (fw )U .
U  (N, v), (fv )U2.6 Characterization and DeÔ¨Ånability
109

By closure under ultraproducts, the pointed model ( U  (N, v), (fv )U ) belongs to

K. Hence by closure under bisimulations, ( U  (M, w), (fw )U ) is in K as well. By
closure of K under ultrapowers it follows that (M, w) is in K. This completes the
proof.
Theorem 2.76 Let œÑ be a modal similarity type, and K a class of pointed œÑ -models.
Then the following are equivalent:
(i) K is deÔ¨Ånable by means of a single modal formula.
(ii) Both K and K are closed under bisimulations and ultraproducts.
Proof. The direction from (i) to (ii) is easy. For the converse we assume that K,
K satisfy the stated closure conditions. Then both are closed under ultraproducts,
hence by Theorem 2.75 there are sets of modal formulas T1 , T2 deÔ¨Åning K and
K, respectively. Obviously their union is inconsistent in the sense that there is no
pointed model (M, w) such that (M, w)  T1 ‚à™ T2 . So then, by compactness,
there exist œÜ1 , . . . , œÜn ‚àà T1 and œà1 , . . . , œàm ‚àà T2 such that for all pointed models
(M, w)
M, w  œÜ1 ‚àß ¬∑ ¬∑ ¬∑ ‚àß œÜn ‚Üí ¬¨œà1 ‚à® ¬∑ ¬∑ ¬∑ ‚à® ¬¨œàm .
(2.3)
To complete the proof we show that K is in fact deÔ¨Åned by the conjunction œÜ1 ‚àß
¬∑ ¬∑ ¬∑ ‚àß œÜn . By deÔ¨Ånition, for any (M, w) in K we have M, w  œÜ1 ‚àß ¬∑ ¬∑ ¬∑ ‚àß œÜn .
Conversely, if M, w  œÜ1 ‚àß ¬∑ ¬∑ ¬∑ ‚àß œÜn , then, by (2.3), M, w  ¬¨œà1 ‚à® ¬∑ ¬∑ ¬∑ ‚à® ¬¨œàm .
Hence, M, w  T2 . Therefore, (M, w) does not belong to K, whence (M, w)
belongs to K.
Theorems 2.75 and 2.76 correspond to analogous deÔ¨Ånability results in Ô¨Årst-order
logic: to get the analogous Ô¨Årst-order results, simply replace closure under bisim-
ulations in 2.75 and 2.76 by closure under isomorphisms; see the Notes at the end
of the chapter for further details. This close connection to Ô¨Årst-order logic may
explain why the results of this section seem to generalize to any modal logic that
has a standard translation into Ô¨Årst-order logic. For example, all of the results of
this section can also be obtained for basic temporal logic.
Exercises for Section 2.6

2.6.1 Prove Proposition 2.71: Let  U M be an ultrapower of M. Then, for all modal
formulas œÜ we have M, w  œÜ iff U M, (fw )U  œÜ, where fw is the constant function
such that fw (i) = w, for all i ‚àà I.
2.6.2 Give simple proofs of Theorem 2.75 and Theorem 2.76 using the analogous proof
for Ô¨Årst-order logic (see Theorem A.23).110
2 Models
2.6.3 Let I be an index set, and let {M i }i‚ààI and {Ni }i‚ààI be two collections of models
such that for each i ‚àà I, M i ‚Üî Ni . Show
 that forany ultraÔ¨Ålter U over I, the ultraproducts
of the two collections are bisimilar: U Mi ‚Üî U Ni .
(a) Show that the ultraproduct of point-generated models need not be point-
generated.
(b) How is this for transitive models?
2.6.4
2.7 Simulation and Safety
Theorem 2.68 provided a result characterizing the modal fragment of Ô¨Årst-order
logic as the class of formulas invariant for bisimulations. In this section we present
two further results in the same spirit; we focus on these results not just because they
are interesting and typical of current work in modal model theory, but also because
they provide instructive examples of how to apply the tools and proof strategies we
have discussed. We Ô¨Årst look at a notion of simulation that has been introduced
in various settings, and characterize the modal formulas preserved by simulations.
We then examine a question that arises in the setting of dynamic logic and process
algebra: which operations on models preserve bisimulation? That is, if we have
the back and forth clauses holding for R, and we apply an operation O to R which
returns a new relation O(R), then under which conditions do we also have the back
and forth clauses for O(R)?
Simulations
A simulation is simply a bisimulation from which half of the atomic clause and the
back clause have been omitted.
DeÔ¨Ånition 2.77 (Simulations) Let œÑ be a modal similarity type. Let M = (W ,
 , V )
R, V )‚ààœÑ and M = (W  , R
‚ààœÑ be œÑ -models. A non-empty binary relation

Z ‚äÜ W √ó W is called a œÑ -simulation from M to M if the following conditions
are satisÔ¨Åed:
(i) If wZw and w ‚àà V (p), then w ‚àà V  (p).
(ii) If wZw and Rwv1 . . . vn then there are v1 , . . . , vn (in W  ) such that
 w v  . . . v  and for all i (1 ‚â§ i ‚â§ n) v Zv  .
R
i
n
1
i
Thus, simulations only require that atomic information is preserved and that the
forth condition holds.
If Z is a simulation from w in M to w in M , we write Z : M, w ‚Üí M , w ;
if there is a simulation Z such that Z : M, w ‚Üí M , w , we sometimes write
M, w ‚Üí M , w .2.7 Simulation and Safety
111
A modal formula œÜ is preserved under simulations if for all models M and M ,
and all states w and w in M and M , respectively, M, w  œÜ implies M , w  œÜ,
whenever it is the case that M, w ‚Üí M , w .
In various forms and under various names simulations have been considered in the-
oretical computer science. In the study of reÔ¨Ånement, ‚Üí is interpreted as follows:
if M, w ‚Üí M , w then (the system modeled by) M , w reÔ¨Ånes or implements (the
system modeled by) M, w. And in the database world one looks at simulations the
other way around: if M, w ‚Üí M , w , then M , w constrains the structure of M, w
by only allowing those relational patterns that are present in M , w itself. Note that
if M, w ‚Üí M , w then M , w cannot enforce the presence of patterns. (See the
Notes for references.) The following question naturally arises: which formulas
are preserved when passing from M, w to M , w along a simulation? Or, dually,
which constraints on M, w can be expressed by requiring that M, w ‚Üí M , w ?
Clearly simulations do not preserve the truth of all modal formulas. In particular,
let M be a one-point model with domain {w} and empty relation; then, there is a
simulation from M, w to any state with the same valuation, no matter which model
it lives in. Using this observation it is easy to show that universal modal formulas of
the form 2(¬∑ ¬∑ ¬∑) or (¬∑ ¬∑ ¬∑) are not preserved under simulations. On the other hand,
by clause (ii) of DeÔ¨Ånition 2.77 existential modal formulas of the form 3(¬∑ ¬∑ ¬∑) or
(¬∑ ¬∑ ¬∑) are preserved under simulations. This leads to the conjecture that a modal
formula is preserved under simulations if and only if it is equivalent to a formula
that has been built from proposition letters, using only ‚àß, ‚à® and existential modal
operators, that is, diamonds or triangles. Below we will prove this conjecture; our
proof follows the proof of Theorem 2.68 to a large extent but there is an important
difference. Since we are working within a modal language, and not in Ô¨Årst-order
logic, we can make do with a detour via (m-saturated) ultraÔ¨Ålter extensions rather
than the (countably saturated) ultrapowers needed in the proof of Theorem 2.68.
Call a modal formula positive existential if it has been built up from proposition
letters, using only ‚àß, ‚à® and existential modal operators 3 and !.
Theorem 2.78 Let œÑ be a modal similarity type, and let œÜ be a œÑ -formula. Then œÜ
is preserved under simulations iff it is equivalent to a positive existential formula.
Proof. The easy inductive proof that positive existential formulas are preserved
under simulations is left to the reader. For the converse, assume that œÜ is preserved
under simulations, and consider the set of positive existential consequences of œÜ:
PEC(œÜ) = {œà | œà is positive existential and œÜ |= œà}.
We will show that PEC(œÜ) |= œÜ; then, by compactness, œÜ is equivalent to a positive
existential modal formula. Assume that M, w  PEC(œÜ); we need to show that
M, w  œÜ. Let Œì = {¬¨œà | œà is positive existential and M, w  œà}.2 Models
112
Our Ô¨Årst claim is that the set {œÜ}‚à™Œì is consistent. For, suppose otherwise. Then
there are formulas ¬¨œà1 , . . . , ¬¨œàn ‚àà Œì such that œÜ |= œà1 ‚à® ¬∑ ¬∑ ¬∑ ‚à® œàn . By deÔ¨Ånition
each formula œài is a positive existential formula, hence, so is œà1 ‚à® ¬∑ ¬∑ ¬∑ ‚à® œàn . But
then M, w  œà1 ‚à® ¬∑ ¬∑ ¬∑ ‚à® œàn , by assumption; from this it follows that M, w  œài
for some i (1 ‚â§ i ‚â§ n). This contradicts ¬¨œài ‚àà Œì .

As a corollary we Ô¨Ånd a model N and a state v of N such that N, v  œÜ ‚àß Œì .
Clearly, for every positive existential formula œà, if N, v  œà, then M, w  œà.
It follows from Proposition 2.59 that for the ultraÔ¨Ålter extensions ue M and ue N
we have the same relation: for every positive existential formula œà, if ue N, œÄv 
œà, then ue M, œÄw  œà. By exploiting the fact that ultraÔ¨Ålter extensions are m-
saturated (Proposition 2.61), it can be shown that this relation is in fact a simulation
from ue N, œÄv to ue M, œÄw ; see Exercise 2.7.1.
In a diagram we have now the following situation.
N, v



M, w



ue N, œÄv ‚Üí ue M, œÄw .
We can carry œÜ around the diagram from N, v to M, w as follows. N, v  œÜ
implies ue N, œÄv  œÜ by Proposition 2.59. Since œÜ is preserved under simulations,
we get ue M, œÄw  œÜ. By Proposition 2.59 again we conclude M, w  œÜ.
Using Theorem 2.78 we can also answer the second of the two questions raised
above. Call a constraint œÜ expressible if whenever M, w satisÔ¨Åes œÜ and N, v ‚Üí
M, w, then N, v also satisÔ¨Åes œÜ. By Theorem 2.78 the expressible constraints
(in Ô¨Årst-order logic) are precisely the ones that are (equivalent to) the standard
translations of negative universal modal formulas, that is, translations of modal
formulas built up from negated proposition letters using only ‚à®, ‚àß and universal
modal operators 2 and .
Safety
Recall from Exercise 2.2.6 that bisimulations preserve the truth of formulas from
propositional dynamic logic. This result hinges on the fact that bisimulations not
only preserve the relations Ra corresponding to atomic programs, but also rela-
tions that are deÔ¨Ånable from these using PDL‚Äôs relational repertoire ‚à™, ; and ‚àó . Put
differently, if the back and forth conditions in the deÔ¨Ånition of a bisimulation hold
for each relation Ra then they also hold for any relation that is deÔ¨Ånable from the
basic ones using ‚à™, ; and ‚àó ; these operations are ‚Äòsafe‚Äô for bisimulation.
In this part of the section we work with a modal similarity type œÑ having dia-
monds only.2.7 Simulation and Safety
113
DeÔ¨Ånition 2.79 Let œÑ be a modal similarity type having diamonds only, and let
Œ±(x, y) denote an L1œÑ (Œ¶)-formula with at most two free variables. Then Œ±(x, y) is
called safe for bisimulations if the following holds, for any bisimulation Z : M ‚Üî
M :
if wZw and M |= Œ±(x, y)[wv] for some state v of M,
then there is a state v of M such that M |= Œ±(x, y)[w v  ] and vZv .
In words, Œ±(x, y) is safe if the back and forth clauses hold for Œ±(x, y) whenever
they hold for the atomic relations.
Example 2.80 (i) All PDL program constructors (‚à™, ; and ‚àó ) are safe for bisim-
ulations (where we stretch the deÔ¨Ånition of safety to program constructors in an
obvious way). For instance, assume that wZw , where Z is a bisimulation, and
(w, v) ‚àà (R ; S) in M. Then, there exists u with Rwu and Suv in M; hence by
the back and forth conditions for R and S, we Ô¨Ånd u with uZu and R w u in M ,
and a state v with vZv and S  u v  in M . Then v is the required (R ;S)-successor
of w in M .
(ii) Atomic tests P ?, deÔ¨Åned by P ? := {(x, y) | x = y ‚àß P y}, are safe. For,
assume that wZw , where Z is a bisimulation, and (w, v) ‚àà P ?. Then w = v and
M |= P x[w]. By the atomic clause in the deÔ¨Ånition of bisimulation, this implies
M |= P x[w ]. Hence, (w , w ) ‚àà P ?, as required.
(iii) Dynamic negation ‚àºR, deÔ¨Åned by ‚àºR = {(x, y) | x = y ‚àß ¬¨‚àÉz Rxz}, is
safe. For, assume that wZw , where Z is a bisimulation, and (w, v) ‚àà ‚àºR in M.
Then, w = v and w has no R-successors in M. Now, suppose that w did have an
R -successor in M ; then, by the back and forth conditions, w would have to have
an R-successor in M ‚Äì a contradiction.
(iv) Intersection of relations is not safe; see Exercise 2.7.2.
Which operations are safe for bisimulations? Below, we give a complete answer for
the restricted case where we consider Ô¨Årst-order deÔ¨Ånable operations and languages
with diamonds only. We need some preparations before we can prove this result.
First, in the remainder of this section we will use the term labeled tree models
for œÑ -models of the form (W, Ra , V )a‚ààœÑ such that (W, a Ra , V ) is a tree in the
sense of DeÔ¨Ånition 1.7.
Second, let p be a Ô¨Åxed proposition letter. We write ‚Üî ‚àí to denote the existence
of a bisimulation for the modal language without the proposition letter p (exactly
which proposition letter is meant will always be clear from the context).
Third, we deÔ¨Åne a modal formula œÜ to be completely additive in the proposition
letter p if it satisÔ¨Åes the following:
For every family of non-empty sets {Xi }i‚ààI such that V (p) =
i Xi we2 Models
114
have (W, Ra , V )a‚ààœÑ , w  œÜ iff, for some i, (W, Ra , Vi )a‚ààœÑ , w  œÜ, where
Vi (p) = Xi and Vi (q) = V (q) for q = p.
Completely additive formulas have a nice syntactic characterization.
Lemma 2.81 A modal formula is completely additive in p iff it is equivalent to a
disjunction of path formulas, that is, formulas of the form
œà0 ‚àß a1 (œà1 ‚àß ¬∑ ¬∑ ¬∑ ‚àß an (œàn ‚àß p) ¬∑ ¬∑ ¬∑),
(2.4)
where p occurs in none of the formulas œài .
Proof. We only prove the hard direction. Assume that œÜ is completely additive in
p. DeÔ¨Åne
COC(œÜ) :=
{œà | œà is of the form (2.4) and œà  œÜ},
that is, COC(œÜ) is an inÔ¨Ånite disjunction of modal formulas. We will show that
œÜ  COC(œÜ); then, by compactness, œÜ is equivalent to a Ô¨Ånite disjunction of
formulas of the form speciÔ¨Åed in (2.4), and this proves the lemma.
So, assume that M, w0  œÜ; we need to show that M, w0  COC(œÜ). As
the reader may verify by doing Exercise 2.7.3, we may assume that M is an m-
saturated, labeled tree model with root w0 . As œÜ is completely additive in p, we
may also assume that V (p) is just a singleton wn ; note that still, we may assume
M to be m-saturated with respect to the p free language. Since M is a labeled tree
with root w0 , there is a path w0 Ra1 ¬∑ ¬∑ ¬∑ Ran wn from w0 to wn , see Figure 2.8.
B
B
p B
S
a
aaS
a
S
S

S
a
aa
S
a
S

S
a
aa
S
a
w0


B
 wn
Fig. 2.8. True at only one state
For 0 ‚â§ i ‚â§ n, let Œ®i be the set of formulas in the p free language that hold at wi ,
and consider the following description of the above path leading up to wn :
Œ®
= {œà | œà is of the form (2.4), with for all i: œài ‚àà Œ®i and Rai wi wi+1 }.
The remainder of the proof is devoted to showing that Œ®  œÜ, and this will do2.7 Simulation and Safety
115
to prove the lemma. For if Œ®  œÜ, then, for some Ô¨Ånite subset Œ® ‚äÜ Œ® we have
 
Œ®  œÜ, by compactness. It is not difÔ¨Åcult to show that Œ® is closed (modulo

equivalence) under taking Ô¨Ånite conjunctions, so Œ®  is equivalent to a formula
œà ‚àà Œ® . Hence, we have found our path formula satisfying M, w0  œà and œà  œÜ.
To show that Œ®  œÜ we proceed as follows. Take a model N with N, v0  Œ® ;
we need to show that N, v0  œÜ. Again, we may assume that N is an m-saturated,
labeled tree with root v0 . By m-saturation, there are points v1 , . . . , vn such that for
each 0 ‚â§ i ‚â§ n ‚àí 1 we have Rai vi vi+1 and N, vi  Œ®i .
It follows from the deÔ¨Ånition of the Œ®i that each wi and vi agree on all p free
modal formulas. So by m-saturation, there is a bisimulation Z : M, w0 ‚Üî ‚àí N, v0 .
It follows from Exercise 2.7.4 that there are extensions M and N of M and N
respectively, such that (M, w0 ) ‚Üî (M , w0 ) and (N, v0 ) ‚Üî (N , v0 ); we may also
conclude from this exercise that there is a bisimulation Z between M and N such
that for all i, the points wi and vi are only related to each other; see Figure 2.9.
'
$'
B
B
S
X
XXS
X
S
S

S
X
XX S
X
S
 w1
S
X
XXX
S
w0
&


T
T
B
B
 wn
$



T
]

vn J
J
 
J
 
J
]
J

J 


 
JJ
v1 ]J 
7



:

J
%&
v0
%
Fig. 2.9. Linking w i only to vi (1 ‚â§ i ‚â§ n)
Now we amend the models M and N as follows: We shrink the interpretations
of p so that p only holds at wn and vn , respectively. Then Z is a bisimulation
between the resulting models M and N with respect to the full language, and
further relations between the models are as indicated in (2.5) below:
(M, w0 )

‚Üî Z : ‚Üî‚àí(N, v0 )

‚Üî

(M , w0 )


shrink V (p)Z : ‚Üî ‚àí(N , v0 )

shrink V (p)

(M , w0 ) Z  :‚Üî
(N , v0 ),
(2.5)116
2 Models
We can chase œÜ around this diagram, from (M, w0 ) to (N, v0 ); see Exercise 2.7.5.
This proves the lemma.
Lemma 2.82 For any program a and any formulas œÜ and œà, the following identi-
ties hold in any model:
(i) (¬¨œÜ)? = ‚àº(œÜ?),
(ii) (œÜ ‚àß œà)? = (œÜ)? ; (œà)?,
(iii) (aœÜ)? = ‚àº‚àº(a ; œÜ?).
The proof of this lemma is left as Exercise 2.7.6.
Theorem 2.83 (Safety Theorem) Let œÑ be a modal similarity type containing only
diamonds, and let Œ±(x, y) be a Ô¨Årst-order formula in L1œÑ (Œ¶). Then Œ±(x, y) is safe
for bisimulations iff it can be deÔ¨Åned from atomic formulas Ra xy and atomic tests
P ? using only ‚à™, ; and ‚àº.
Proof. To see that the constructions mentioned are indeed safe, consult Exam-
ple 2.80. Now, to prove the converse, let Œ±(x, y) be a safe Ô¨Årst-order operation, and
choose a new proposition letter p. Our Ô¨Årst observation is that ‚àÉy (Œ±(x, y) ‚àß P y) is
preserved under bisimulations. So by Theorem 2.68, the formula ‚àÉy (Œ±(x, y)‚àßP y)
is equivalent to a modal formula œÜ.
Next we exploit special properties of œÜ to arrive at our conclusion. First, because
of its special form, ‚àÉy (Œ±(x, y) ‚àß P y) is completely additive in P , in the obvious
sense, and hence, œÜ is completely additive in p. Therefore, by Lemma 2.81 it is
(equivalent to) a disjunction of the form speciÔ¨Åed in (2.4). Then, Œ±(x, y) must be
deÔ¨Ånable using the corresponding union of relations (œà0 )?;a1 ;(œà1 )?;¬∑ ¬∑ ¬∑;an ;(œàn )?.
Finally, by using Lemma 2.82 all complex tests can be pushed inside until we get
a formula of the required form, involving only ‚à™, ;, ‚àº and ?.
Exercises for Section 2.7
2.7.1 Assume that M and M  are m-saturated models and suppose that for every positive
existential formula œÜ it holds that M, w  œÜ only if M  , w  œÜ for some w and w  . Prove
that M, w ‚Üí M , w .
2.7.2 Prove that intersection of relations is not an operation that is safe for bisimulations
(see Example 2.80).
(a) Suppose that Z is a bisimulation linking the models M and M  . Suppose
further that M is m-saturated and that Z is surjective (that is, every point in M  is
linked by Z to some point in M). Prove that M  is m-saturated as well.
(b) Let Œ£ be a set of formulas, and œÜ a formula. Prove that œÜ is a consequence of Œ£
if and only if for every m-saturated, labeled tree model M with root w it holds that
M, w  Œ£ only if M, w  œÜ.
2.7.32.8 Summary of Chapter 2
117
2.7.4 Assume that Z : M, w0 ‚Üî ‚àí N, v0 , where M and N are labeled tree models with
roots w0 and v0 , respectively. Assume further that in M we have w 0 Ra1 ¬∑ ¬∑ ¬∑ Ran wn and in
N, v0 Ra1 ¬∑ ¬∑ ¬∑ Ran vn , while Z links wi (in M) to vi (in N) for each i (1 ‚â§ i ‚â§ n).
In this exercise the reader is asked to show that there are extensions (M  , w0 ) of (M, w0 )
and (N , v0 ) of (N, v0 ) (i.e., the universe of M is a subset of the universe of M  , and
likewise for N and N  ) such that
Z : ‚Üî‚àí(N, v0 )

‚Üî

(M , w0 ) Z  : ‚Üî ‚àí(N , v0 ),
(M, w0 )

‚Üî
where Z  is such that for any i (1 ‚â§ i ‚â§ n) we have that w i and vi are only related to each
other.
(a) Explain why we may assume that all bisimulation links (between M and N) occur
between states at the same height in the trees. (Hint: remove all links between
points of different heights and prove that the remaining links still form a bisimula-
tion.)
(b) Next, work your way up along the branch w 0 Ra1 ¬∑ ¬∑ ¬∑ Ran wn and remove any dou-
ble bisimulation links involving the w i . More precisely, and starting at height 1, do
the following for each double link w 1 Zv. Add a copy of the submodel generated
by w1 to M, connect w0 to the copy w1v of w1 by Ra1 , and ‚Äòdivert‚Äô the bisimulation
link w1 Zv to w1v Zv. Show that the resulting model M v satisÔ¨Åes M ‚Üî Mv and
Mv ‚Üî ‚àí N. Proceed in a similar way with points of larger height.
(c) Similar to the previous item, but now working up the branch v 0 Ra1 ¬∑ ¬∑ ¬∑ Rn van in N
to eliminate any double bisimulation links ending in one of the v i s (1 ‚â§ i ‚â§ n).
(d) Prove the existence of the desired M  , N and Z  by putting together the previous
items.
2.7.5 Explain why we can chase œÜ around the diagram displayed in (2.5) to infer N, v 0  œÜ
from M, w0  œÜ.
2.7.6 Prove Lemma 2.82.
2.8 Summary of Chapter 2
 New Models from Old Ones: Taking disjoint unions, generated submodels, and
bounded morphic images are three important ways of building new models from
old that leave the truth values of modal formulas invariant.
 Bisimulations: Bisimulations offer a unifying perspective on model invariance,
and each of the constructions just mentioned is a kind of bisimulation. Bisimi-
larity implies modal equivalence, but the converse does not hold in general. On
image-Ô¨Ånite models, however, bisimilarity and modal equivalence coincide.
 Using Bisimulations: Bisimulations can be used to establish non-deÔ¨Ånability
results (for example, to show that the global modality is not deÔ¨Ånable in the ba-
sic modal language), or to create models satisfying special relational properties
(for example, to show that every satisÔ¨Åable formula is satisÔ¨Åable in a tree-like
model).118
2 Models
 Finite Model Property: Modal languages have the Ô¨Ånite model property (f.m.p.).
One technique for establishing the f.m.p. is by a selection-of-states argument
involving Ô¨Ånite approximations to bisimulations. Another, the Ô¨Åltration method,
works by collapsing as many states as possible.
 Standard Translation: The standard translation maps modal languages into clas-
sical languages (such as the language of Ô¨Årst-order logic) in a way that reÔ¨Çects
the satisfaction deÔ¨Ånition. Every modal formula is equivalent to a Ô¨Årst-order
formula in one free variable; if the similarity type is Ô¨Ånite, Ô¨Ånitely many vari-
ables sufÔ¨Åce to translate all modal formulas. Propositional dynamic logic has to
be mapped into a richer classical logic capable of expressing transitive closure.
 UltraÔ¨Ålter Extensions: UltraÔ¨Ålter extensions are built by using the ultraÔ¨Ålters
over a given model as the states of a new model, and deÔ¨Åning an appropriate re-
lation between them. This leads to the Ô¨Årst bisimilarity-somewhere-else result:
two states in two models are modally equivalent if and only if (their counterparts
in) the ultraÔ¨Ålter extensions of the two models are bisimilar.
 van Benthem Characterization Theorem: The Detour Lemma ‚Äì a bisimilarity-
somewhere-else result in terms of ultrapowers ‚Äì can be used to prove the van
Benthem Characterization Theorem: the modal fragment of Ô¨Årst-order logic is
the set of formulas in one free variable that are invariant for bisimulations.
 DeÔ¨Ånability: The Detour Lemma also leads to the following result: the modally
deÔ¨Ånable classes of (pointed) models are those that are closed under bisimula-
tions and ultraproducts, while their complements are closed under ultrapowers.
 Simulation: The modal formulas preserved under simulations are precisely the
positive existential ones.
 Safety: An operation on relations is safe for bisimulations if whenever the back
and forth conditions hold for the base relations, they also hold for the result
of applying the operation to the relations. The Ô¨Årst-order operations safe for
bisimulations are the ones that can be deÔ¨Åned from atoms and atomic tests,
using only composition, union, and dynamic negation.
Notes
Kripke, Kanger, Hintikka, and others introduced models to modal logic in the late
1950s and early 1960s, and relational semantics (or Kripke semantics as it was
usually called) swiftly became the standard way of thinking about modal logic.
In spite of this, much of the material discussed in this chapter dates not from the
1960s, or even the 1970s, but from the late 1980s and 1990s. Why? Because re-
lational semantics was not initially regarded as of independent interest, rather it
was thought of as a tool that lead to interesting modal completeness theory and
decidability results. Only in the early 1970s (with the discovery of the frame in-
completeness results) did modal expressivity become an active topic of researchNotes to Chapter 2
119
‚Äì and even then, such investigations were initially conÔ¨Åned to expressivity at the
level of frames rather than at the level of models. Thus the most fundamental level
of modal semantics was actually the last to be explored mathematically.
Generated submodels and bounded morphisms arose as tools for manipulating
the canonical models used in modal completeness theory (we discuss canonical
models in Chapter 4). Point-generated submodels, however, were already men-
tioned, under the name of connected model structures, in Kripke [284]. Bounded
morphisms go back to at least Segerberg [404] (a very similar, earlier, notion can be
found in de Jongh and Troelstra [249]) where they are called pseudo epimorphisms;
this soon got shortened down to p-morphism, which remains the most widely used
terminology. The name bounded morphism stems from Goldblatt [186]. Disjoint
unions and ultraÔ¨Ålter extensions seem to have Ô¨Årst been isolated when modal lo-
gicians started investigating modal expressivity over frames in the 1970s (along
with generated submodels and bounded morphisms they are the four constructions
needed in the Goldblatt-Thomason Theorem, which we discuss in the following
chapter). Neither construction is as useful as generated submodels and bounded
morphisms when it comes to proving completeness results, which is probably why
they were not noted earlier. However, both arise naturally in the context of modal
duality theory; see Goldblatt [184, 185]. UltraÔ¨Ålter extensions independently came
about in the model-theoretic analysis of modal logic, see Fine [132]; the name
seems to be due to van Benthem. The unraveling construction (that is, unwind-
ing arbitrary models into trees; see Proposition 2.15) is helpful in many situations.
Surprisingly, it was Ô¨Årst used as early as in 1959, by Dummett and Lemmon [117],
but the method seems to have become widely known because of Sahlqvist‚Äôs use of
it in his classic 1975 paper [396].
Vardi [441] has stressed the importance of the tree model property of modal
logic: the property that a formula is satisÔ¨Åable iff it is satisÔ¨Åable at the root of a
tree-like model. The tree model property paves the way for the use of automata-
theoretic tools and tableaux-based proof methods. Moreover, it is essential for
explaining the so-called robust decidability of modal logic ‚Äì the phenomenon that
the basic modal logic is decidable itself, and of reasonably low complexity, and that
these features are preserved when the basic modal logic is extended by a variety
of additional constructions, including counting, transitive closure, and least Ô¨Åxed
points.
We discussed two ways of building Ô¨Ånite models: the selection method and
Ô¨Åltration. However, the use of Ô¨Ånite algebras predates the use of Ô¨Ånite models: they
were Ô¨Årst used in 1941 by McKinsey [322]; Lemmon [295] used and extended this
method in 1966. The use of model-theoretic Ô¨Åltration dates back to Lemmon and
Scott‚Äôs long unpublished monograph An Introduction to Modal Logic [296] (which
began circulating in the mid 1960s); it was further developed in Segerberg‚Äôs An
Essay in Classical Modal Logic [404], which also seems to have given the method120
2 Models
its name (see also Segerberg [402]). We introduced the selection method via the
notion of Ô¨Ånitely approximating a bisimulation, an idea which seems to have Ô¨Årst
appeared in 1985 in Hennessy and Milner [219].
The standard translation, in various forms, can be found in the work of a number
of writers on modal and tense logic in the 1960s ‚Äì but its importance only became
fully apparent when the Ô¨Årst frame incompleteness results were proved. Thoma-
son [433], the paper in which frame incompleteness results was Ô¨Årst established,
uses the standard translation ‚Äì and shows why the move to frames and validities
requires a second-order perspective (something we will discuss in the following
chapter). Thus the need became clear for a thorough investigation of the relation
between modal and classical logic, and correspondence theory was born. But al-
though other authors (notably Sahlqvist [396]) helped pioneer correspondence the-
ory, it was the work of van Benthem [36] which made clear the importance of sys-
tematic use of the standard translation to access results and techniques from classi-
cal modal theory. The observation that at most two variables are needed to translate
basic modal formulas into Ô¨Årst-order logic is due to Gabbay [149]. The earliest
systematic study of Ô¨Ånite variable fragments seems to be due to Henkin [216] in
the setting of algebraic logic, and Immerman and Kozen [240] study the link with
complexity and database theory. Consult Otto [351] for more on Ô¨Ånite variable
logics. Keisler [267] is still a valuable reference for inÔ¨Ånitary logic. A variety of
other translations from modal to classical logic have been studied, and for a wide
variety of purposes. For example, simply standardly translating modal logics into
Ô¨Årst-order logic and then feeding the result to a theorem prover is not an efÔ¨Åcient
way of automating modal theorem proving. But the idea of automating modal rea-
soning via translation is interesting, and a variety of translations more suitable for
this purpose have been devised; see Ohlbach et al. [345] for a survey.
Under the name of p-relations, bisimulations were introduced by Johan van Ben-
them in the course of his work on correspondence theory. Key references here are
van Benthem‚Äôs 1976 PhD thesis [36]; his 1983 book based on the thesis [36]; and
[43], his 1984 survey article on correspondence theory. In keeping with the spirit
of the times, most of van Benthem‚Äôs early work on correspondence theory dealt
with frame deÔ¨Ånability (in fact he devotes only 6 of the 227 pages in his book
to expressivity over models). Nonetheless, much of this chapter has its roots in
this early work, for in his thesis van Benthem introduced the concept of a bisim-
ulation (he used the name p-relation in [36, 42], and the name zigzag relation in
[43]) and proved the Characterization Theorem. His original proof differs from
the one given in the text: instead of appealing to saturated models, he employs an
elementary chains argument. Explicitly isolating the Detour Lemma (which brings
out the importance of ultrapowers) opens the way to Theorems 2.75 and 2.76 on
deÔ¨Ånability and makes explicit the interesting analogies with Ô¨Årst-order model the-
ory discussed below. On the other hand, the original proof is more concrete. BothNotes to Chapter 2
121
are worth knowing. The Ô¨Årst published proof using saturated models seems to be
due to Rodenburg [390], who used it to characterize the Ô¨Årst-order fragment corre-
sponding to intuitionistic logic.
The back and forth clauses of a bisimulation can be adapted to analyze the ex-
pressivity of a wide range of extended modal logics (such as those studied in Chap-
ter 7), and such analyses are now commonplace. Bisimulation based characteriza-
tions have been given for the modal mu-calculus by Janin and Walukiewicz [243],
for temporal logics with since and until by Kurtonina and de Rijke [288], for
subboolean fragments of knowledge representation languages by Kurtonina and
de Rijke [289], and for CTL‚àó by Moller and Rabinovich [333]. Related model-
theoretic characterizations can be found in Immerman and Kozen [240] (for Ô¨Ånite
variable logics) and Toman and Niwi≈Ñski [438] (for temporal query languages).
Rosen [392] presents a version of the Characterization Theorem that also works
for the case of Ô¨Ånite models; the proof given in the text breaks down in the Ô¨Ånite
case as it relies on compactness and saturated models.
But bisimulations did not just arise in modal logic ‚Äì they were independently
invented in computer science as an equivalence relation on process graphs. Park
[354] seems to have been the Ô¨Årst author to have used bisimulations in this way.
The classic paper on the subject is Hennessy and Milner [219], the key reference for
the Hennessy-Milner Theorem. The reader should be warned, however, that just as
the notion of bisimulation can be adapted to cover many different modal systems,
the notion of bisimulation can be adapted to cover many different concepts of pro-
cess ‚Äì in fact, a survey of bisimulation in process algebra in the early 1990s lists
over 155 variants of the notion [173]! Our deÔ¨Ånitions do not exclude bisimulations
between a model and itself (auto-bisimulations); the quotient of a model with re-
spect to its largest auto-bisimulation can be regarded as a minimal representation
of this model. The standard method for computing the largest auto-bisimulation is
the so-called Paige-Tarjan algorithm; see the contributions to Ponse, de Rijke and
Venema [360] for relevant pointers and surveys.
More recently, bisimulations have become fundamental in a third area, non-well-
founded set theory. In such theories, the axiom of foundation is dropped, and sets
are allowed to be members of themselves. Sets are thought of as graphs, and two
sets are considered identical if and only if they are bisimilar. The classic source for
this approach is Aczel [2], who explicitly draws on ideas from process theory. A
recent text on the subject is Barwise and Moss [27], who link their work with the
modal tradition. For recent work on modal logic and non-well-founded set theory,
see Baltag [20].
The name ‚Äòm-saturation‚Äô stems from Visser [450], but the notion is older: its Ô¨Årst
occurrence in the literature seems to be in Fine [132] (under the name ‚Äòmodally
saturated2 ‚Äô). The concept of a Hennessy-Milner class is from Goldblatt [179] and
Hollenberg [233]. Theorem 2.62, that equivalence of models implies bisimilar-122
2 Models
ity between their ultraÔ¨Ålter extensions, is due to [233]. Chang and Keisler [91,
Chapters 4 and 6] is the classic reference for the ultraproduct construction; their
Chapters 2 and 5 also contain valuable material on saturated models. Doets and
van Benthem [112] give an intuitive explanation of the ultraproduct construction.
The results proved in this chapter are often analogs of standard results in Ô¨Årst-
order model theory, with bisimulations replacing partial isomorphisms. The Keis-
ler-Shelah Theorem (see Chang and Keisler [91, Theorem 6.1.15]) states that two
models are elementarily equivalent iff they have isomorphic ultrapowers; a weak-
ened form, due to Doets and van Benthem [112], replaces ‚Äòisomorphic‚Äô with ‚Äòpar-
tially isomorphic‚Äô. Theorem 2.74, which is due to de Rijke [380], is a modal analog
of this weakened characterization theorem. Proposition 2.31 is similar to charac-
terizations of logical equivalence for Ô¨Årst-order logic due to Ehrenfeucht [119] and
Fraƒ±Ãàss√© [141]; in fact, bisimulations can be regarded as the modal cousins of the
model theoretic Ehrenfeucht-Fraƒ±Ãàss√© games. We will return to the theme of analo-
gies between Ô¨Årst-order and modal model theory in Section 7.6 when we prove a
Lindstr√∂m theorem for modal logic. See de Rijke [380] and Sturm [426] for further
work on modal model theory; de Rijke and Sturm [386] provide global counterparts
for the local deÔ¨Ånability results presented in Section 2.6. One can also characterize
modal deÔ¨Ånability of model classes using ‚Äòmodal‚Äô structural operations only, that
is, bisimulations, disjoint unions and ultraÔ¨Ålter extensions; see Venema [447].
Sources for the use of simulations in reÔ¨Ånement are Henzinger et al. [221] and
He Jifeng [246], and for their use in a database setting, consult Buneman et al. [76];
see de Rijke [380] for Theorem 2.78. The Safety Theorem 2.83 is due to van
Benthem [48]. The text follows the original proof fairly closely; an alternative
proof has been given by Hollenberg [232], who also proves generalizations.
One Ô¨Ånal remark. Given the importance of Ô¨Ånite model theory, the reader may
be surprised to Ô¨Ånd so little in this chapter on the topic. But we do not neglect
Ô¨Ånite model theory in this book: virtually all the results proved in Chapter 6 re-
volve around Ô¨Ånite models and the way they are structured. That said, the topic
of Ô¨Ånite modal model theory has received less attention from modal logicians than
it deserves. In spite of Rosen‚Äôs [392] proof of the van Benthem characterization
theorem for Ô¨Ånite models, and in spite of work on modal 0-1 laws (Halpern and
Kapron [204], Goranko and Kapron [191], and Grove et al. [200, 199]), Ô¨Ånite
modal model theory is an area where many interesting questions remain.3
Frames
As we saw in Section 1.3, the concept of validity, which abstracts away from the
effects of particular valuations, allows modal languages to get to grips with frame
structure. As we will now see, this makes it possible for modal languages to deÔ¨Åne
classes of frames, and most of the chapter is devoted to exploring this idea.
The following picture will emerge. Viewed as tools for deÔ¨Åning frames, every
modal formula corresponds to a second-order formula. Although this second-order
formula sometimes has a Ô¨Årst-order equivalent, even quite simple modal formulas
can deÔ¨Åne classes of frames that no Ô¨Årst-order formula can. In spite of this, there
are extremely simple Ô¨Årst-order deÔ¨Ånable frame classes which no modal formula
can deÔ¨Åne. In short, viewed as frame description languages, modal languages ex-
hibit an unusual blend of Ô¨Årst- and second-order expressive powers.
The chapter has three main parts. The Ô¨Årst, consisting of the Ô¨Årst four sections,
introduces frame deÔ¨Ånability, explains why it is intrinsically second-order, presents
the four fundamental frame constructions and states the Goldblatt-Thomason The-
orem, and discusses Ô¨Ånite frames. The second part, consisting of the next three
sections, is essentially a detailed exposition of the Sahlqvist Correspondence The-
orem, which identiÔ¨Åes a large class of modal formulas which correspond to Ô¨Årst-
order formulas. The Ô¨Ånal part, consisting of the last section, studies further frame
constructions and gives a model-theoretic proof of the Goldblatt-Thomason Theo-
rem. With the exception of the last two sections, all the material in this chapter lies
on the basic track.
Chapter guide
Section 3.1: Frame DeÔ¨Ånability (Basic track). This section introduces frame de-
Ô¨Ånability, and gives several examples of modally deÔ¨Ånable frame classes.
Section 3.2: Frame DeÔ¨Ånability and Second-Order Logic (Basic Track). We ex-
plain why frame deÔ¨Ånability is intrinsically second-order, and give exam-
123124
3 Frames
ples of frame classes that are modally deÔ¨Ånable but not Ô¨Årst-order deÔ¨Ån-
able.
Section 3.3: DeÔ¨Ånable and UndeÔ¨Ånable Properties (Basic track). We Ô¨Årst show
that validity is preserved under the formation of disjoint unions, generated
subframes and bounded morphic images, and anti-preserved under ultraÔ¨Ål-
ter extensions. We then use these constructions to give examples of frame
classes that are not modally deÔ¨Ånable, and state the Goldblatt-Thomason
Theorem.
Section 3.4: Finite Frames (Basic track). Finite frames enjoy a number of pleas-
ant properties. We Ô¨Årst prove a simple analog of the Goldblatt-Thomason
Theorem for Ô¨Ånite transitive frames. We then introduce the Ô¨Ånite frame
property, and show that a normal modal logic has the Ô¨Ånite frame property
if and only if it has the Ô¨Ånite model property.
Section 3.5: Automatic First-Order Correspondence (Basic track). Here we pre-
pare for the proof of the Sahlqvist Correspondence Theorem in the follow-
ing section. We introduce positive and negative formulas, and show that
their monotonicity properties can help eliminate second-order quantiÔ¨Åers.
Section 3.6: Sahlqvist Formulas (Basic track). In this section we prove the Sahl-
qvist Correspondence Theorem. Our approach is incremental. We Ô¨Årst
explore the key ideas in the setting of two smaller fragments, and then
state and prove the main result.
Section 3.7: More About Sahlqvist Formulas (Advanced track). We Ô¨Årst discuss
the limitations of the Sahlqvist Correspondence Theorem. We then prove
Kracht‚Äôs Theorem, which provides a syntactic description of the Ô¨Årst-order
formulas that can be obtained as translations of Sahlqvist formulas.
Section 3.8: Advanced Frame Theory (Advanced track). We Ô¨Ånish off the chap-
ter with some advanced material on frame constructions, and prove the
Goldblatt-Thomason Theorem model-theoretically.
3.1 Frame DeÔ¨Ånability
This chapter is mostly about using modal formulas to deÔ¨Åne classes of frames. In
this section we introduce the basic ideas (deÔ¨Ånability, and Ô¨Årst- and second-order
frame languages), and give a number of examples of modally deÔ¨Ånable frames
classes. Most of these examples ‚Äì and, indeed, most of the examples given in this
chapter ‚Äì are important in their own right and will be used in later chapters.
Frame deÔ¨Ånability rests on the notion of a formula being valid on a frame, a
concept which was discussed in Section 1.3 (see in particular DeÔ¨Ånition 1.28). We
Ô¨Årst recall and extend this deÔ¨Ånition.
DeÔ¨Ånition 3.1 (Validity) Let œÑ be a modal similarity type. A formula œÜ (of this3.1 Frame DeÔ¨Ånability
125
similarity type) is valid at a state w in a frame F (notation: F, w  œÜ; here, of
course, F is a frame of type œÑ ) if œÜ is true at w in every model (F, V ) based on F; œÜ
is valid on a frame F (notation: F  œÜ) if it is valid at every state in F. A formula
œÜ is valid on a class of frames K (notation: K  œÜ) if it is valid on every frame F
in K. We denote the class of frames where œÜ is valid by FrœÜ .
These concepts can be extended to sets of formulas in the obvious way. In par-
ticular, a set Œì of modal formulas (of type œÑ ) is valid on a frame F (also of type
œÑ ) if every formula in Œì is valid on F; and Œì is valid on a class K of frames if Œì
is valid on every member of K. We denote the class of frames where Œì is valid by
FrŒì .
Now for the concept underlying most of our work in this chapter:
DeÔ¨Ånition 3.2 (DeÔ¨Ånability) Let œÑ be a modal similarity type, œÜ a modal formula
of this type, and K a class of œÑ -frames. We say that œÜ deÔ¨Ånes (or characterizes) K
if for all frames F, F is in K if and only if F  œÜ. Similarly, if Œì is a set of modal
formulas of this type, we say that Œì deÔ¨Ånes K if F is in K if and only if F  Œì .
A class of frames is (modally) deÔ¨Ånable if there is some set of modal formulas
that deÔ¨Ånes it.
In short, a modal formula deÔ¨Ånes a class of frames if the formula pins down pre-
cisely the frames that are in that class via the concept of validity. The following
generalization of this concept is sometimes useful:
DeÔ¨Ånition 3.3 (Relative DeÔ¨Ånability) Let œÑ be a modal similarity type, œÜ a modal
formula of this type, and C a class of œÑ -frames. We say that œÜ deÔ¨Ånes (or charac-
terizes) a class K of frames within C (or relative to C) if for all frames F in C we
have that F is in K if and only if F  œÜ.
Similarly, if Œì is a set of modal formulas of this type, we say that Œì deÔ¨Ånes a
class K of frames within C (or relative to C) if for all frames F in C we have that F
is in K if and only if F  Œì .
Note that when C is the class of all œÑ -frames, deÔ¨Ånability within C is our original
notion of deÔ¨Ånability. In Section 3.4 we will investigate which frames are deÔ¨Ånable
within the class of Ô¨Ånite transitive frames, but for the most part we will work with
the ‚Äòabsolute‚Äô notion of deÔ¨Ånability given in DeÔ¨Ånition 3.2.
We often say that a formula œÜ (or a set of formulas Œì ) deÔ¨Ånes a property (for
example, reÔ¨Çexivity) if it deÔ¨Ånes the class of frames satisfying that property. For
example, we will shortly see that p ‚Üí 3p deÔ¨Ånes the class of reÔ¨Çexive frames; in
practice, we would often simply say that p ‚Üí 3p deÔ¨Ånes reÔ¨Çexivity.
Up till now our discussion has been purely modal ‚Äì but, of course, as frames are
just relational structures, we are free to deÔ¨Åne frame classes using a wide variety of126
3 Frames
non-modal languages. For example, the class of reÔ¨Çexive frames is simply the class
of all frames that make ‚àÄx Rxx true. In this chapter, we are interested in comparing
modal languages with the following classical languages as tools for deÔ¨Åning frame
classes:
DeÔ¨Ånition 3.4 (Frame Languages) For any modal similarity type œÑ , the Ô¨Årst-
order frame language of œÑ is the Ô¨Årst-order language that has the identity symbol =
together with an (n+1)-ary relation symbol R for each n-ary modal operator  in
œÑ . We denote this language by L1œÑ . We often call it the Ô¨Årst-order correspondence
language (for œÑ ).
Let Œ¶ be any set of proposition letters. The monadic second-order frame lan-
guage of œÑ over Œ¶ is the monadic second-order language obtained by augmenting
L1œÑ with a Œ¶-indexed collection of monadic predicate variables. (That is, this lan-
guage has all the resources of L1œÑ , and in addition is capable of quantifying over
subsets of frames.) We denote this language by L2œÑ (Œ¶), though sometimes we sup-
press reference to Œ¶ and write L2œÑ . Moreover, we often simply call it the second-
order frame language or the second-order correspondence language (for œÑ ), taking
it for granted that only monadic second-order quantiÔ¨Åcation is permitted.
Note that the second-order frame language is extremely powerful, even for the
basic modal similarity type. For example, if R is interpreted as the relation of set
membership, second-order Zermelo-Fraenkel (ZF) set theory can be axiomatized
by a single sentence of this language.
DeÔ¨Ånition 3.5 (Frame Correspondence) If a class of frames (or more informally,
a property) can be deÔ¨Åned by a modal formula œÜ and by a formula Œ± from one of
these frame languages, then we say that œÜ and Œ± are each others (global) frame
correspondents.
For example, the basic modal formula p ‚Üí 3p and the Ô¨Årst-order sentence ‚àÄxRxx
are correspondents, for we will shortly see that p ‚Üí 3p deÔ¨Ånes reÔ¨Çexivity. Later
in this chapter we will show how to systematically Ô¨Ånd correspondents of modal
formulas by adopting a slightly different perspective on the standard translation
introduced in Section 2.4.
In DeÔ¨Ånition 3.5 we did not mention the possibility that modal formulas corre-
spond to a set of Ô¨Årst-order formulas. Why not? The reason is that this situation
simply cannot occur, as we ask the reader to show in Exercise 3.8.3.
There are a number of practical reasons for being interested in frame deÔ¨Ånabil-
ity. First, some applications of modal logic are essentially syntactically driven;
their starting point is some collection of modal formulas expressing axioms, laws,
or principles which for some reason we Ô¨Ånd interesting or signiÔ¨Åcant. Frame de-
Ô¨Ånability can be an invaluable tool in such work, for by determining which frame3.1 Frame DeÔ¨Ånability
127
classes these formulas deÔ¨Åne we obtain a mathematical perspective on their con-
tent. On the other hand, some applications of modal logic are essentially seman-
tically driven; their starting point is some class of frames of interest. But here too
deÔ¨Ånability is a useful concept. For a start, can the modal language distinguish the
‚Äògood‚Äô frames from the ‚Äòbad‚Äô ones? And which properties can the modal language
express within the class of ‚Äògood‚Äô frames? Finally, many applied modal languages
contain several modalities, whose intended meanings are interrelated. Sometimes
it is clear that these relationships should validate certain formulas, and we want
to extract the frame-theoretic property they correspond to. On the other hand it
may be clear what the relevant frame-theoretic property is (for example, in the
basic temporal language we want the P and F operators to scan backwards and
forwards along the same relation) and we want to see whether there is a modal
formula that deÔ¨Ånes this property. In short, thinking in terms of frame deÔ¨Ånability
can be useful for a variety of reasons ‚Äì and as the following examples will make
clear, modal languages can deÔ¨Åne some very interesting frame classes indeed.
Example 3.6 In Example 1.10 in Section 1.2 we mentioned the following reading
of the modalities: read 3œÜ as ‚Äòit is possibly the case that œÜ‚Äô and 2œÜ as ‚Äònecessarily
œÜ.‚Äô We also mentioned that a number of interesting looking principles concerning
necessity and possibility could be stated in the basic modal language. Here are
three important examples, together with their traditional names:
(T) p ‚Üí 3p
(4) 33p ‚Üí 3p
(5) 3p ‚Üí 23p
But now the problems start. While the status of T seems secure (if p holds here-
and-now, p must be possible) but what about 4 and 5? When we have to deal with
embedded modalities, our intuitions tend to fade, even for such simple formulas as
4 and 5; it is not easy to say whether they should be accepted, and if we only have
our everyday understanding of the words ‚Äònecessarily‚Äô and ‚Äòpossibly‚Äô to guide us, it
is difÔ¨Åcult to determine whether these principles are interrelated. What we need is
a mathematical perspective on their content, and that is what the frame deÔ¨Ånability
offers. So let us see what frame conditions these principles deÔ¨Åne.
Our Ô¨Årst claim is that for any frame F = (W, R), the axiom T corresponds to
reÔ¨Çexivity of the relation R:
F  T iff F |= ‚àÄx Rxx.
(3.1)
The proof of the right to left direction of (3.1) is easy: let F be a reÔ¨Çexive frame,
and take an arbitrary valuation V on F, and a state w in F such that (F, V ), w  p.
We need to show that 3p holds at some state that is accessible from w ‚Äì but as R
is reÔ¨Çexive, w is accessible from itself, and w  3p.3 Frames
128
For the other direction, we use contraposition: suppose that R is not reÔ¨Çexive,
that is, there exists a state w which is not accessible from itself. To falsify T in
F, it sufÔ¨Åces to Ô¨Ånd a valuation V and a state v such that p holds at v, but 3p
does not. It is pretty obvious that we should choose v to be our irreÔ¨Çexive state
w. Now the valuation V has to satisfy two conditions: (1) w ‚àà V (p) and (2)
{x ‚àà W | Rwx} ‚à© V (p) = ‚àÖ. Consider the minimal valuation V satisfying
condition (1), that is, take
V (p) = {w}.
Then it is immediate that (F, V ), w  p. Now let v be an R-successor of w. As
Rww does not hold in F, v must be distinct from w, so v  p. As v was arbitrary,
w  3p. This proves (3.1).
Likewise, one can prove that for any frame F = (W, R)
F4iffR is transitive, and(3.2)
F5iffR is euclidean,(3.3)
where a relation is euclidean if it satisÔ¨Åes ‚àÄxyz ((Rxy ‚àß Rxz) ‚Üí Ryz). We leave
the proofs of (3.2) and the easy (right to left) direction of (3.3) to the reader. For
the left to right direction of (3.3), we again argue by contraposition. Assume that
F is a non-euclidean frame; then there must be states u, v and w such that Ruv,
Ruw, but not Rvw:
1




u u
PP
uv
H


H
PP
PP
P
q ?
P
u
w
We will try to falsify 5 in u; for this purpose we have to Ô¨Ånd a valuation V such
that (F, V ), u  3p and (F, V ), u  23p. In other words, we have to make p true
at some R-successor x of u, and false at all R-successors of some R-successor y
of u. Some reÔ¨Çection shows that appropriate candidates for x and y are w and v,
respectively. Note that again the constraints on V are twofold: (1) w ‚àà V (p) and
(2) {z | Rvz} ‚à© V (p) = ‚àÖ.
Let us take a maximal V satisfying condition (2), that is, deÔ¨Åne
V (p) = {z ‚àà W | it is not the case that Rvz}.
Now clearly v  3p, so u  23p. On the other hand we have w  p, since w
is in the set {z ‚àà W | it is not the case that Rvz}. So u  3p. In other words,
we have indeed found a valuation V and a state u such that 5 does not hold in u.
Therefore, 5 is not valid in F. This proves (3.3).3.1 Frame DeÔ¨Ånability
129
Example 3.7 Suppose that we are working with the basic temporal language (see
Section 1.3 and in particular Example 1.25) and that we are interested in dense
bidirectional frames (that is, structures in which between every two points there is a
third). This property can be deÔ¨Åned using a Ô¨Årst-order sentence (namely ‚àÄxy (x <
y ‚Üí ‚àÉz (x < z ‚àß z < y)) but can the basic temporal language deÔ¨Åne it too?
It can. The following simple formula sufÔ¨Åces: F p ‚Üí F F p. To see this, let
T = (T, <) be a frame such that T  F p ‚Üí F F p. Suppose that a point t ‚àà T has
a <-successor t . To show that t and t satisfy the density condition, consider the
following minimal valuation Vm guaranteeing that (T, Vm ), t  F p:
Vm (p) = {t }.
Now, under this valuation t  F p, and by assumption T  F p ‚Üí F F p, hence
t  F F p. This means there is a point s such that t < s and s  F p. But as t is
the only state where p holds, this implies that s < t , so s is the intermediate point
we were looking for.
Conversely, let T = (T, <) be a dense frame, and assume that under some
valuation V , F p holds at some t ‚àà T . Then there is a point t such that t < t and
t  p. But as T is dense, there is a point s such that t < s < t , hence s  F p and
hence t  F F p.
Note that nothing in the previous argument depended on the fact that we were
working with the basic temporal language; the previous argument also shows that
density is deÔ¨Ånable in the basic modal language using the formula 3p ‚Üí 33p.
Note that this is the converse of the 4 axiom that deÔ¨Ånes transitivity.
Example 3.8 Here is a more abstract example. Suppose we are working with a
similarity type with three binary operators 1 , 2 and 3 , and that we are in-
terested in the class of frames in which the three ternary accessibility relations
(denoted by R1 , R2 and R3 , respectively), offer, so to speak, three ‚Äòperspectives‚Äô
on the same relation. To put this precisely, suppose we want the condition
R1 stu iff R2 tus iff R3 ust
to hold for all s, t and u in such frames. Can we deÔ¨Åne this class of frames?
We can. We will show that for all frames F = (W, R1 , R2 , R3 ) we have
F  p ‚àß (q1 r) ‚Üí (q ‚àß r2 p)1 r iff F |= ‚àÄxyz (R1 xyz ‚Üí R2 yzx).
(3.4)
(Recall that we use inÔ¨Åx notation for dyadic operation symbols.) The easy direction
is from right to left. Let F be a frame satisfying ‚àÄxyz (R1 xyz ‚Üí R2 yzx). Con-
sider an arbitrary valuation V on F and an arbitrary state s such that (F, V ), s 
p ‚àß (q1 r). Then, s  p and there are states t and u with R1 stu, t  q and
u  r. From R1 stu we derive R2 tus. But then t  q ‚àß r2 p, so by R1 stu we
have s  (q ‚àß r2 p)1 r.3 Frames
130
For the other direction, suppose that the modal formula p ‚àß (q1 r) ‚Üí (q ‚àß
r2 p)1 r is valid in F, and consider states s, t and u in F with R1 stu. We will
show that R2 tus. Consider a valuation V with V (p) = {s}, V (q) = {t} and
V (r) = {u}. Then (F, V ), s  p‚àßq1 r, so by our assumption, s  (q‚àßr2 p)1 r.
Hence, there must be states t , u with R1 st u , t  q ‚àß r2 p and u  r. From
t  q it follows that t = t , so we have t  r2 p. Again, using the truth deÔ¨Ånition
we Ô¨Ånd states s , u with R2 tu s , u  r and s  p. The latter two facts imply
that u = u and s = s. But then we have R2 tus, as required.
From these examples the reader could easily get the impression that modal for-
mulas always correspond to frame properties that are deÔ¨Ånable in Ô¨Årst-order logic.
This impression is wrong, and in the next section we will see why.
Exercises for Section 3.1
3.1.1 Consider a language with two diamonds 1 and 2. Show that p ‚Üí [2]1p is valid
on precisely those frames for the language that satisfy the condition ‚àÄxy (R 2 xy ‚Üí R1 yx).
What sort of frames does p ‚Üí [1]1p deÔ¨Åne?
3.1.2 Consider a language with three diamonds 1, 2, and 3. Show that the modal
formula 3p ‚Üî 12p is valid on a frame for this language if and only if the frame
satisÔ¨Åes the condition ‚àÄxy (R3 xy ‚Üî ‚àÉz (R1 xz ‚àß R2 zy)).
3.2 Frame DeÔ¨Ånability and Second-Order Logic
In this section we show that modal languages can get to grips with notions that
exceed the expressive power of Ô¨Årst-order logic, and explain why. We start by pre-
senting three well-known examples of modal formulas that deÔ¨Åne frame properties
which cannot be expressed in Ô¨Årst-order logic. Then, drawing on our discussion of
the standard translation in Section 2.4, we show that such results are to be expected:
as we will see, modal formulas standardly correspond to second-order frame con-
ditions. Indeed, the real mystery is not why they do so (this turns out to be rather
obvious), but why they sometimes correspond to simple Ô¨Årst-order conditions such
as reÔ¨Çexivity or transitivity (we discuss this more difÔ¨Åcult issue in Sections 3.5‚Äì
3.7).
Example 3.9 Consider the L√∂b formula 2(2p ‚Üí p) ‚Üí 2p, which we will call
L for brevity. This formula plays an essential role in provability logic, a branch of
modal logic where 2œÜ is read as ‚Äòit is provable (in some formal system) that œÜ‚Äô.
The formula L is named after L√∂b, who proved L as a theorem of the provability
logic of Peano Arithmetic. We will Ô¨Årst show that L deÔ¨Ånes the class of frames
(W, R) such that R is transitive and R‚Äôs converse is well-founded. (A relation
R is well-founded if there is no inÔ¨Ånite sequence . . . Rw2 Rw1 Rw0 ; hence, R‚Äôs3.2 Frame DeÔ¨Ånability and Second-Order Logic
131
converse is well-founded if there is no inÔ¨Ånite R-path emanating from any state. In
particular, this excludes cycles and loops.)
We will then show that this is a class of frames that Ô¨Årst-order frame languages
cannot deÔ¨Åne; that is, we will show that this class is not elementary.
To see that L deÔ¨Ånes the stated property, assume that F = (W, R) is a frame
with a transitive and conversely well-founded relation R, and then suppose for the
sake of a contradiction that L is not valid in F. This means that there is a valuation
V and a state w such that (F, V ), w  2(2p ‚Üí p) ‚Üí 2p. In other words, w 
2(2p ‚Üí p), but w  2p. Then w must have a successor w1 such that w1  p, and
as 2p ‚Üí p holds at all successors of w, we have that w1  2p. This in turn implies
that w1 must have a successor w2 where p is false; note that by the transitivity of R,
w2 is also a successor of w. But now, simply by repeating our argument, we see that
w2 must have a p-falsifying successor w3 (which by transitivity must be a successor
of w1 ), that w3 has a successor w4 (which by transitivity must be a successor of
w1 ), and so on. In short, we have found an inÔ¨Ånite path wRw1 Rw2 Rw3 R . . .,
contradicting the converse well-foundedness of R. (Note that the points w1 , w2 ,
. . . need not all be distinct.)
u- u
ww1
- u
w2
- u
-
...
w3
For the other direction, we use contraposition. That is, we assume that either R
is not transitive or its converse is not well-founded; in both cases we have to Ô¨Ånd
a valuation V and a state w such that (F, V ), w  L. We leave the case where
R is not transitive to the reader (hint: instead of L, consider the frame equivalent
formula 3p ‚Üí 3(p ‚àß ¬¨3p)) and only consider the second case. So assume that R
is transitive, but not conversely well-founded. In other words, suppose we have a
transitive frame containing an inÔ¨Ånite sequence w0 Rw1 Rw2 R . . .. We exploit the
presence of this sequence by deÔ¨Åning the following valuation V :
V (p) = W \ {x ‚àà W | there is an inÔ¨Ånite path starting from x}.
We leave it to the reader to verify that under this valuation, 2p ‚Üí p is true every-
where in the model, whence, certainly, (F, V ), w0  2(2p ‚Üí p). The claim then
follows from the fact that (F, V ), w0  2p.
Finally, to show that the class of frames deÔ¨Åned by L is not elementary, an easy
compactness argument sufÔ¨Åces. Suppose for the sake of a contradiction that there
is a Ô¨Årst-order formula equivalent to L; call this formula Œª. As Œª is equivalent to L,
any model making Œª true must be transitive. Let œÉn (x0 , . . . , xn ) be the Ô¨Årst-order
formula stating that there is an R-path of length n through x0 , . . . , xn :

Rxi xi+1 .
œÉn (x0 , . . . , xn ) =
0‚â§i<n3 Frames
132
Obviously, every Ô¨Ånite subset of
Œ£ = {Œª} ‚à™ {‚àÄxyz ((Rxy ‚àß Ryz) ‚Üí Rxz)} ‚à™ {œÉn | n ‚àà œâ}
is satisÔ¨Åable in a Ô¨Ånite linear order, and hence in the class of transitive, conversely
well-founded frames. Thus by the Compactness Theorem, Œ£ itself must have a
model. But it is clear that Œ£ is not satisÔ¨Åable in any conversely well-founded
frame ‚Äì and Œª, being equivalent to L, is supposed to deÔ¨Åne the class of transi-
tive, conversely well-founded frames. From this contradiction we conclude that L
cannot be equivalent to any Ô¨Årst-order formula.
Could L then perhaps be equivalent to an (inÔ¨Ånite) set of Ô¨Årst-order formulas?
No ‚Äì we already mentioned (right after DeÔ¨Ånition 3.5) that this kind of correspon-
dence never occurs.
Our next example concerns propositional dynamic logic (PDL). Recall that this
language contains a family of diamonds {œÄ | œÄ ‚àà Œ†} (where Œ† is a collection of
programs) and the program constructors ‚à™, ; and ‚àó . In the intended frames for this
language (that is, the regular frames; see Example 1.26) we want the accessibility
relations for diamonds built using these constructors to reÔ¨Çect choice, composition,
and iteration of programs, respectively. Now, to reÔ¨Çect iteration we demanded that
the relation RœÄ‚àó used for the program œÄ‚àó be the reÔ¨Çexive, transitive closure of
the relation RœÄ used for œÄ. But it is well known that this constraint cannot be
expressed in Ô¨Årst-order logic (as with the L√∂b example, this can be shown using
a compactness argument, and the reader was asked to do this in Exercise 2.4.5).
Because of this, when we discussed PDL at the level of models in Section 2.4 we
used the inÔ¨Ånitary language Lœâ1 œâ as the correspondence language for PDL; using
inÔ¨Ånite disjunctions enabled us to capture the ‚Äòkeep looking!‚Äô force of ‚àó that eludes
Ô¨Årst-order logic. But although Ô¨Årst-order logic cannot get to grips with ‚àó, PDL itself
can ‚Äì via the concept of frame deÔ¨Ånability.
Example 3.10 PDL can be interpreted on any transition system of the form F =
(W, RœÄ )œÄ‚ààŒ† . Let us call such a frame ‚àó-proper if the transition relation RœÄ‚àó of
each program œÄ‚àó is the reÔ¨Çexive and transitive closure of the transition relation RœÄ
of œÄ. Can we single out, by modal means, the ‚àó-proper frames within the class of
all transition systems of the form (W, RœÄ )œÄ‚ààŒ† ? And can we then go on to single
out the class of all regular frames?
The answer to both questions is yes. Consider the following set of formulas
Œî = {[œÄ ‚àó ](p ‚Üí [œÄ]p) ‚Üí (p ‚Üí [œÄ ‚àó ]p), œÄ ‚àó p ‚Üî (p ‚à® œÄœÄ ‚àó p) | œÄ ‚àà Œ†}.
As we mentioned in Example 1.15, [œÄ‚àó ](p ‚Üí [œÄ]p) ‚Üí (p ‚Üí [œÄ ‚àó ]p) is called
Segerberg‚Äôs axiom, or the induction axiom. We claim that for any PDL-frame F:
F  Œî iff F is ‚àó-proper.
(3.5)3.2 Frame DeÔ¨Ånability and Second-Order Logic
133
The reader is asked to supply a proof of this in Exercise 3.2.1.
A straightforward consequence is that PDL is strong enough to deÔ¨Åne the class
of regular frames. The constraints on the relations interpreting ‚à™ and ; are simple
Ô¨Årst-order conditions, and
Œì = {œÄ1 ; œÄ2 p ‚Üî œÄ1 œÄ2 p, œÄ1 ‚à™ œÄ2 p ‚Üî œÄ1 p ‚à® œÄ2 p | œÄ ‚àà Œ†}.
pins down down what is required. So Œî ‚à™ Œì deÔ¨Ånes the regular frames.
In the previous two examples we encountered modal formulas that expressed frame
properties that were, although not elementary, still relatively easy to understand.
(Note however that in order to formally express (converse) well-foundedness in a
classical language, one needs heavy machinery ‚Äì the inÔ¨Ånitary language Lœâ1 œâ does
not sufÔ¨Åce!) The next example shows that extremely simple modal formulas can
deÔ¨Åne second-order frame conditions that are not easy to understand at all.
Example 3.11 We will show that the McKinsey formula (M) 23p ‚Üí 32p does
not correspond to a Ô¨Årst-order condition by showing that it violates the L√∂wenheim-
Skolem Theorem.
Consider the frame F = (W, R), where
W = {w} ‚à™ {vn , v(n,i) | n ‚àà N, i ‚àà {0, 1}} ‚à™ {zf | f : N ‚Üí {0, 1}},
and
R = {(w, vn ), (vn , v(n,i) ), (v(n,i) , v(n,i) ) | n ‚àà N, i ‚àà {0, 1}} ‚à™
{(w, zf ), (zf , v(n,f (n)) ) | n ‚àà N, f : N ‚Üí {0, 1}}.
In a picture:
3

?
?

v
v

(n,0)
(n,1)
- u
u
iP
P
1


PP 

u



6vn





u
z
u f
w
Note that W contains uncountably many points, for the set of functions indexing
the z points is uncountable.
Our Ô¨Årst observation is that F  23p ‚Üí 32p. We leave it to the reader to
verify that for all u different from w, F, u  23p ‚Üí 32p. As to showing that134
3 Frames
F, w  23p ‚Üí 32p, suppose that (F, V ), w  23p. Then, for each n ‚àà N,
(F, V ), vn  3p. From this we get either (F, V ), v(n,0)  p or (F, V ), v(n,1)  p.
Choose f : N ‚Üí {0, 1} such that (F, V ), v(n,f (n))  p, for each n ‚àà N. Then
clearly, (F, V ), zf  2p, and so (F, V ), w  32p.
In order to show that 23p ‚Üí 32p does not deÔ¨Åne a Ô¨Årst-order frame condition,
let us view the frame F as a Ô¨Årst-order model with domain W . By the downward
L√∂wenheim-Skolem Theorem (here we need the strong version of Theorem A.11)
there must be a countable elementary submodel F of F whose domain W  contains
w, and each vn , v(n,0) and v(n,1) . As W is uncountable and W  countable, there
must be a mapping f : N ‚Üí {0, 1} such that zf does not belong to W  . Now,
if the McKinsey formula was equivalent to a Ô¨Årst-order formula it would be valid
on F (the L√∂wenheim-Skolem Theorem tells us that F and F are elementarily
equivalent). But we will show that the McKinsey formula is not valid on F , hence
it cannot be equivalent to a Ô¨Årst-order formula.
Let V  be a valuation on F such that V  (p) = {v(n,f (n)) | n ‚àà N}; here f is a
mapping such that zf does not belong to W  . We will show that under V  , 23p is
true at w, but 32p is not.
It is easy to see that (F , V  ), w  32p. For a start, since p holds at exactly one
of v(n,0) and v(n,1) , 2p is false at each vn . Now consider an arbitrary element zg
in W  . Then g is distinct from f , so there must be an element n ‚àà N such that
g(n) = f (n). So p is true at v(n,f (n)) and false at v(n,g(n)) ; this means that zg has
a successor where p is false, so (F , V  ), zg  2p. Hence, we have not been able
to Ô¨Ånd a successor for w where 2p holds, so (F , V  ), w  32p.
In order to show that (F , V  ), w  23p we reason as follows. Note Ô¨Årst that
(F , V  ), vn  3p, for each state vn . Now consider an arbitrary element zg of W  .
Call two states zh and zk of F complementary if for all n, h(n) = 1 ‚àí k(n); the
reader should verify that this relation can be expressed in Ô¨Årst-order logic. Now
suppose that zg is complementary to zf ; since complementary states are unique,
the fact that F is an elementary submodel of F would imply that zf exists in F as
well. Clearly then, we may conclude that zg is not complementary to zf . Hence,
there exists some n ‚àà N such that g(n) = f (n). Therefore, (F , V  ), zg  3p. But
then 3p holds at every successor of w.
Clearly then, modal languages can express many highly complex properties via the
notion of frame validity. In fact, as was shown by S.K. Thomason for the basic
modal similarity type, the consequence relation for the entire second-order lan-
guage L2œÑ can be reduced in a certain sense to the (global) consequence relation
over frames. More precisely, Thomason showed that there is a computable trans-
lation f taking L2 sentences Œ± to modal formulas f (Œ±), and a special Ô¨Åxed modal
formula Œ¥, such that for all sets of L2 sentences Œ£, we have that
Œ£ |= Œ± iff {Œ¥} ‚à™ {f (œÉ) | œÉ ‚àà Œ£} g f (Œ±).3.2 Frame DeÔ¨Ånability and Second-Order Logic
135
On the frame level, propositional modal logic must be understood as a rather strong
fragment of classical monadic second-order logic. We now face the question: why?
The answer turns out to be surprisingly simple. Recall from DeÔ¨Ånition 3.1 that
validity is deÔ¨Åned by quantifying over all states of the universe and all possible
valuations. But a valuation assigns a subset of a frame to each proposition let-
ter, and this means that when we quantify across all valuations we are implicitly
quantifying across all subsets of the frame. In short, monadic second-order quan-
tiÔ¨Åcation is hard-wired into the very deÔ¨Ånition of validity; it is hardly surprising
that frame-deÔ¨Ånability is such a powerful concept.
Let us make this answer more precise. In the previous chapter, we saw that at
the level of models, the modal language ML(œÑ, Œ¶) can be translated in a truth-
preserving way into the Ô¨Årst-order language L1œÑ (Œ¶) (see Proposition 2.47). Let us
adopt a slightly different perspective:
View the predicate symbol P that corresponds to the proposition letter p as a
monadic second-order variable that we can quantify over.
If we do this, we are in effect viewing the standard translation as a way of translat-
ing into the second-order frame language L2œÑ (Œ¶) introduced in DeÔ¨Ånition 3.4. And
if we view the standard translation this way we are led, virtually immediately, to
the following result:
Proposition 3.12 Let œÑ be a modal similarity type, and œÜ a œÑ -formula. Then for
any œÑ -frame F and any state w in F:
F, w  œÜiffF |= ‚àÄP1 . . . ‚àÄPn ST x (œÜ)[w],
FœÜiffF |= ‚àÄP1 . . . ‚àÄPn ‚àÄx ST x (œÜ).
Here, the second-order quantiÔ¨Åers bind second-order variables Pi corresponding
to the proposition letters pi occurring in œÜ.
Proof. Let M = (F, V ) be any model based on F, and let w be any state in F.
Then we have that
(F, V ), w  œÜ iff F |= ST x (œÜ)[w, P1 , . . . , Pn ],
where the notation [w, P1 , . . . , Pn ] means ‚Äòassign w to the free Ô¨Årst-order variable
x in ST x (œÜ), and V (p1 ), . . . , V (pn ) to the free monadic second-order variables.‚Äô
Note that this equivalence is nothing new; it is simply a restatement of Proposi-
tion 2.47 in second-order terms. But then we obtain the Ô¨Årst part of the theorem
simply by universally quantifying over the free variables P1 ,. . . ,Pn. The second
part follows from the Ô¨Årst by universally quantifying over the states of the frame
(as in Proposition 3.30).136
3 Frames
It is fairly common to refer to the L2œÑ (Œ¶) formula ‚àÄP1 . . . ‚àÄPn ‚àÄx ST x (œÜ) as the
standard translation of œÜ, since it is usually clear whether we are working at the
level of models or the level of frames. Nonetheless, we will try and reserve the
term standard translation to mean the L1œÑ (Œ¶) formula produced by the translation
process, and refer to ‚àÄP1 . . . ‚àÄPn ‚àÄx ST x (œÜ) as the second-order translation of œÜ.
Let us sum up what we have learned. That modal formulas can deÔ¨Åne second-
order properties of frames is neither mysterious nor surprising: because modal
validity is deÔ¨Åned in terms of quantiÔ¨Åcation over subsets of frames, it is intrinsi-
cally second-order, hence so is the notion of frame deÔ¨Ånability. Indeed, the real
mystery lies not with such honest, hard-working, formulas as L√∂b and McKinsey,
but with such lazy formulas as T, 4 and 5 discussed in the previous section. For
example, if we apply the second-order translation to T (that is, p ‚Üí 3p) we obtain
‚àÄP ‚àÄx (P x ‚Üí ‚àÉy(Rxy ‚àß P y)).
We already know that T deÔ¨Ånes reÔ¨Çexivity, so this must be a (somewhat baroque)
second-order way of expressing reÔ¨Çexivity ‚Äì and it is fairly easy to see that this
is so. But this sort of thing happens a lot: 4 and 5 give rise to (fairly complex)
second-order expressions, yet the complexity melts away leaving a simple Ô¨Årst-
order equivalent behind. The contrast with the McKinsey formula is striking: what
is going on? This is an interesting question, and we discuss it in detail in Sec-
tions 3.5‚Äì3.7.
Another point is worth making: our discussion throws light on the somewhat
mysterious general frames introduced in Section 1.4. Recall that a general frame is
a frame together with a collection of valuations A satisfying certain modally natural
closure conditions. We claimed that general frames combined the key advantage
of frames (namely, that they support the key logical notion of validity) with the
advantage of models (namely, that they are concrete and easy to work with). The
work of this section helps explain why.
The key point is this. A general frame can be viewed as a generalized model
for (monadic) second-order logic. A generalized model for second-order logic is
a model in which the second-order quantiÔ¨Åers are viewed as ranging not over all
subsets, but only over a pre-selected sub-collection of subsets. And of course, the
collection of valuations A in a general frame is essentially such a sub-collection of
subsets. This means that the following equivalence holds:
(F, A)  œÜ iff (F, A) |= ‚àÄP1 . . . ‚àÄPn ‚àÄx ST x (œÜ).
Here the block of quantiÔ¨Åers ‚àÄP1 . . . ‚àÄPn denotes not genuine second-order quan-
tiÔ¨Åcation, but generalized second-order quantiÔ¨Åcation (that is, quantiÔ¨Åcation over
the subsets in A). Generalized second-order quantiÔ¨Åcation is essentially a Ô¨Årst-
order ‚Äòapproximation‚Äô of second-order quantiÔ¨Åcation that possesses many proper-
ties that genuine second-order quantiÔ¨Åcation lacks (such as Completeness, Com-3.2 Frame DeÔ¨Ånability and Second-Order Logic
137
pactness, and L√∂wenheim-Skolem). In short, one of the reasons general frames
are so useful is that they offer a Ô¨Årst-order perspective (via generalized models) on
what is essentially a second-order phenomenon (frame validity). This is not the
full story ‚Äì the algebraic perspective on general frames is vital to modal logic ‚Äì but
it should make clear that these unusual looking structures Ô¨Åll an important logical
niche.
Exercises for Section 3.2
(a) Consider a modal language with two diamonds 1 and 2. Prove that the
class of frames in which R 1 is the reÔ¨Çexive transitive closure of R 2 is deÔ¨Åned by the
conjunction of the formulas 1p ‚Üí (p ‚à® 1(¬¨p ‚àß 2p) and 1p ‚Üî (p ‚à® 21p).
(b) Conclude that in the similarity type of PDL, the set Œî as deÔ¨Åned in Example 3.10
deÔ¨Ånes the class of ‚àó-proper frames.
(c) Consider the example of multi-agent epistemic logic; let {1, . . . , n} be the set of
agents. Suppose that one is interested in the operators E (EœÜ stands for ‚Äòeverybody
knows œÜ‚Äô) and C (CœÜ meaning that ‚Äòit is common knowledge that œÜ‚Äô). The intended
relations modeling E and C are given by:

RE uv iff
1‚â§i‚â§n Ri uv,
RC uv iff there is a path u = x0 RE x1 RE . . . xn‚àí1 RE xn = v.
3.2.1
Write down a set of (epistemic) formulas that characterizes the class of epistemic
frames where these conditions are met.
3.2.2 Show that Grzegorczyk‚Äôs formula, 2(2(p ‚Üí 2p) ‚Üí p) ‚Üí p, characterizes the
class of frames F = (W, R) satisfying (i) R is reÔ¨Çexive, (ii) R is transitive and (iii) there
are no inÔ¨Ånite paths x 0 Rx1 Rx2 R . . . such that for all i, xi = xi+1 .
3.2.3 Consider the basic temporal language (see Example 1.25). Recall that a frame F =
(W, RF , RP ) for this language is called bidirectional if R P is the converse of R F .
(a) Prove that among the Ô¨Ånite bidirectional frames, the formula G(Gp ‚Üí p) ‚Üí Gp
together with its converse, H(Hp ‚Üí p) ‚Üí Hp deÔ¨Ånes the transitive and irreÔ¨Çexive
frames.
(b) Prove that among the bidirectional frames that are transitive, irreÔ¨Çexive, and satisfy
‚àÄxy (RF xy ‚à® x = y ‚à® RP xy), this same set deÔ¨Ånes the Ô¨Ånite frames.
(c) Is there a Ô¨Ånite set of formulas in the basic modal language that has these same
deÔ¨Ånability properties?
3.2.4 Consider the following formula in the basic similarity type:
œà := 32p ‚Üí 3(2(p ‚àß q) ‚à® 2(p ‚àß ¬¨q)).
The aim of this exercise is to show that œà does not deÔ¨Åne a Ô¨Årst-order condition on frames.
(a) To obtain some intuitions about the meaning of œà, let us Ô¨Årst give a relatively simple
Ô¨Årst-order condition implying the validity of œà:
Œ± := ‚àÄxy (Rxy ‚Üí ‚àÉz (Rxz ‚àß ‚àÄuv ((Rzu ‚àß Rzv) ‚Üí (u = v ‚àß Ryu)))),
stating (in words) that for every pair (x, y) in R, x has a successor z which itself
has at most one successor, this point being also a successor of y.138
3 Frames
Show that œà is valid in any frame satisfying Œ±.
(b) Consider the frame F = (W, R) which we deÔ¨Åne as follows. Let u be a non-
principal ultraÔ¨Ålter over the set N of the natural numbers. Then W := {u} ‚à™ u ‚à™ N,
that is, the states of W are u itself, each subset of N that is a member of u and each
natural number. The relation R is the converse of the membership relation, that is,
Rst iff t ‚àà s. Show that F  Œ± and F  œà.
(c) Prove that œà does not have a Ô¨Årst-order correspondent by showing that œà is in-
valid on all countable structures that are elementarily equivalent to F (that is, all
countable structures satisfying the same Ô¨Årst-order formulas as F).
3.3 DeÔ¨Ånable and UndeÔ¨Ånable Properties
We have seen that modal languages are a powerful tool for deÔ¨Åning frames: we
have seen examples of modally deÔ¨Ånable frame classes that are not Ô¨Årst-order de-
Ô¨Ånable, and it is clear that validity is an inherently second-order concept. But what
are the limits of modal deÔ¨Ånability? For example, can modal languages deÔ¨Åne all
Ô¨Årst-order frame classes (the answer is no, as we will shortly see)? And anyway,
how should we go about showing that a class of frames is not modally deÔ¨Ånable?
After all, we cannot try out all possible formulas; something more sophisticated is
needed.
In this section we will answer these question by introducing four fundamental
frame constructions: disjoint unions, generated subframes, bounded morphic im-
ages, and ultraÔ¨Ålter extensions. The names should be familiar: these are the frame
theoretic analogs of the model-theoretic constructions studied in the previous chap-
ter, and they are going to do a lot of work for us, both here and in later chapters.
For a start, it is a more-or-less immediate consequence of the previous chapter‚Äôs
work that the Ô¨Årst three constructions preserve modal validity, while the fourth
anti-preserves it. But this means that these constructions provide powerful tests for
modal deÔ¨Ånability: by showing that some class of frames is not closed under one
of these constructions, we will be able to show that it cannot be modally deÔ¨Ånable.
DeÔ¨Ånition 3.13 The deÔ¨Ånitions of the disjoint union of a family of frames, a gen-
erated subframe of a frame, and a bounded morphism from one frame to another,
are obtained by deleting the clauses concerning valuations from DeÔ¨Ånitions 2.2,
2.5 and 2.10.
That is, for disjoint œÑ -frames Fi = (Wi , Ri )‚ààœÑ (i ‚àà I), their disjoint union is
the structure i Fi = (W, R)‚ààœÑ such that W is the union of the sets Wi and for
each  ‚àà œÑ , R is the union i‚ààI Ri . With frames that are not disjoint, proceed
as in DeÔ¨Ånition 2.2.
 )
We say that a œÑ -frame F = (W  , R
‚ààœÑ is a generated subframe of the frame

F = (W, R)‚ààœÑ (notation: F  F) whenever F is a subframe of F (with respect
to R for all  ‚àà œÑ ), and the following heredity condition is fulÔ¨Ålled for all  ‚àà œÑ3.3 DeÔ¨Ånable and UndeÔ¨Ånable Properties
139
if u ‚àà W  and Ruu1 . . . un , then u1 , . . . , un ‚àà W  .
Let X be a subset of the universe of a frame F; we denote by FX the subframe gen-
erated by X, that is, the generated subframe of F that is based on the smallest set
W  that contains X and satisÔ¨Åes the above heredity condition. If X is a singleton
{w}, we write Fw for the subframe generated by w; if a frame F is generated by a
singleton subset of its universe, we call it rooted or point-generated.
And Ô¨Ånally, a bounded morphism from a œÑ -frame F = (W, R)‚ààœÑ to a œÑ -
 )

frame F = (W  , R
‚ààœÑ is a function from W to W satisfying the following two
conditions:
 f (w)f (v ) . . . f (v ).
(forth) For all  ‚àà œÑ , Rwv1 . . . vn implies R
1
n
 f (w)v  . . . v  then there exist v . . . v such that R wv . . . v and
(back) If R
1
n

1
n
n
1
f (vi ) = vi (for 1 ‚â§ i ‚â§ n).
We say that F is a bounded morphic image of F, notation: F
surjective bounded morphism from F onto F .
F , if there is a
It is an essential characteristic of modal formulas that their validity is preserved
under the structural operations just deÔ¨Åned:
Theorem 3.14 Let œÑ be a modal similarity type, and œÜ a œÑ -formula.
(i) Let {Fi | i ‚àà I} be a family of frames. Then
in I.
(ii) Assume that F  F. Then F  œÜ if F  œÜ.
(iii) Assume that F
F . Then F  œÜ if F  œÜ.
Fi  œÜ if Fi  œÜ for every i
Proof. We only prove (iii), the preservation result for taking bounded morphic
images, and leave the other cases to the reader as Exercise 3.3.1. So, assume that f
is a surjective bounded morphism from F onto F , and that F  œÜ. We have to show
that F  œÜ. So suppose that œÜ is not valid in F . Then there must be a valuation V 
and a state w such that (F , V  ), w  œÜ. DeÔ¨Åne the following valuation V on F:
V (pi ) = {x ‚àà W | f (x) ‚àà V  (pi )}.
This deÔ¨Ånition is tailored to make f a bounded morphism between the models
(F, V ) and (F , V  ) ‚Äì the reader is asked to verify the details. Now we use the
fact that f is surjective to Ô¨Ånd a w such that f (w) = w . It follows from Proposi-
tion 2.14 that (F, V ), w  œÜ. In other words, we have falsiÔ¨Åed œÜ in the frame F,
and shown the contrapositive of the desired result.
Think of these frame constructions as test criteria for the deÔ¨Ånability of frame
properties: if a property is not preserved under one (or more) of these frame con-
structions, then it cannot be modally deÔ¨Ånable. Let us consider some examples of
such testing.3 Frames
140
Example 3.15 The class of Ô¨Ånite frames is not modally deÔ¨Ånable. For suppose
there was a set of formulas Œî (in the basic modal similarity type) characteriz-
ing the Ô¨Ånite frames. Then Œî would be valid in every one-point frame Fi =
({wi }, {(wi , wi )}) (i < œâ). By Theorem 3.14(i) this would imply that Œî was
also valid in the disjoint union i Fi :
'
w0  w1  w2  w3  
u
u
u
u
   
&
$
...
%
But clearly this cannot be the case, for i Fi is inÔ¨Ånite.
The class of frames having a reÔ¨Çexive point (‚àÉx Rxx) does not have a modal
characterization either (again we work with the basic modal similarity type). For
suppose that the set Œî characterized this class. Consider the following frame F:

w u




v u
u
- u

As w is a reÔ¨Çexive state, F  Œî. Now consider the generated subframe Fv of F.
Clearly, Œî cannot be valid in Fv , since neither v nor u is reÔ¨Çexive. But this contra-
dicts the fact that validity of modal formulas is preserved under taking generated
subframes (Theorem 3.14(ii)).
The two Ô¨Ånal examples involve the use of bounded morphisms. First, irreÔ¨Çexiv-
ity is not deÔ¨Ånable. To see this, simply note that the function which collapses the
set of natural numbers in their usual order to a single reÔ¨Çexive point is a surjec-
tive bounded morphism. As the former frame is irreÔ¨Çexive, while the latter is not,
irreÔ¨Çexivity cannot be modally deÔ¨Ånable.
Actually, a more sophisticated variant of this example lets us prove even more.
Consider the following two frames: F = (œâ, S), the natural numbers with the
successor relation (Smn iff n = m + 1), and G = ({e, o}, {(e, o), (o, e)}) as
depicted below.
'
0
1
u
- u
$
2
- u
3
- u
4
- u
5
- u
&
-
...
'
?
e u
&
$
- ?
uo
%
...
%3.3 DeÔ¨Ånable and UndeÔ¨Ånable Properties
141
In Example 2.11 we saw that the map f sending even numbers to e and odd num-
bers to o is a surjective bounded morphism. By the same style of reasoning as in
the earlier examples, it follows that no property P is modally deÔ¨Ånable if F has P
and G lacks it. This shows, for example, that there is no set of formulas character-
izing the asymmetric frames (‚àÄxy (Rxy ‚Üí ¬¨Ryx)).
Now for the fourth frame construction. Recall that in Section 2.5 we introduced
the idea of ultraÔ¨Ålter extensions; see DeÔ¨Ånition 2.57 and Proposition 2.59. Once
again, simply by ignoring the parts of the deÔ¨Ånition that deal with valuations, we
can lift this concept to the level of frames, and this immediately provides us with
the following anti-preservation result:
Corollary 3.16 Let œÑ be a modal similarity type, F a œÑ -frame, and œÜ a œÑ -formula.
Then F  œÜ if ue F  œÜ.
Proof. Assume that œÜ is not valid in F. That is, there is a valuation V and a state
w such that (F, V ), w  ¬¨œÜ. By Proposition 2.59, ¬¨œÜ is true at uw in the ultraÔ¨Ålter
extension of M. But then we have refuted œÜ in ue F.
Once again, we can use this result to show that some frame properties are not
modally deÔ¨Ånable. For example, working in the basic modal similarity type, con-
sider the property that every state has a reÔ¨Çexive successor: ‚àÄx‚àÉy (Rxy ‚àß Ryy).
We claim that this property is not modally deÔ¨Ånable, even though it is preserved
under taking disjoint unions, generated subframes and bounded morphic images.
To verify our claim, the reader is asked to consider the frame in Example 2.58.
It is easy to see that every state of ue F has a reÔ¨Çexive successor ‚Äì take any non-
principal ultraÔ¨Ålter. But F itself clearly does not satisfy the property, as F has no
reÔ¨Çexive states. Now suppose that the property were modally deÔ¨Ånable, say by the
set of formulas Œî. Then we would have ue F  Œî, but F  Œî ‚Äì a clear violation
of Corollary 3.16.
Note the direction of the preservation result in Corollary 3.16. It states that
modal validity is anti-preserved under taking ultraÔ¨Ålter extensions. This naturally
raises the question whether the other direction holds as well, that is, whether F  œÜ
implies ue F  œÜ. For a partial answer to this question, we need the following
theorem:
Theorem 3.17 Let œÑ be a modal similarity type, and F a œÑ -frame. Then F has an


ultrapower U F such that U F
ue F. In a diagram:

UF
Z
Z
F
Z
~
Z
~
ue F142
3 Frames
Proof. Advanced track readers will be asked to supply a proof of this theorem in
Exercise 3.8.1 below.
And now we have the following partial converse to Corollary 3.16:
Corollary 3.18 Let œÑ be a modal similarity type, and œÜ a œÑ -formula. If œÜ deÔ¨Ånes
a Ô¨Årst-order property of frames, then frame validity of œÜ is preserved under taking
ultraÔ¨Ålter extensions.
Proof. Let œÜ be a modal formula which deÔ¨Ånes a Ô¨Årst-order property of frames, and
let F be a frame such that F  œÜ. By the previous theorem, there is an ultrapower


ue F. As Ô¨Årst-order properties are preserved under
U F of F such that U F
taking ultrapowers, U F  œÜ. But then ue F  œÜ by Theorem 3.14.
We are on the verge of one of the best-known results in modal logic: the Goldblatt-
Thomason Theorem. This result tells us that ‚Äì at least as far as Ô¨Årst-order deÔ¨Ån-
able frame classes are concerned ‚Äì the four frame constructions we have discussed
constitute necessary and sufÔ¨Åcient conditions for a class of frames to be modally
deÔ¨Ånable. We are not going to prove this important result right away, but we will
take this opportunity to state it precisely. We use the following terminology: a class
of frames K reÔ¨Çects ultraÔ¨Ålter extensions if ue F ‚àà K implies F ‚àà K.
Theorem 3.19 (Goldblatt-Thomason Theorem) Let œÑ be a modal similarity type.
A Ô¨Årst-order deÔ¨Ånable class K of œÑ -frames is modally deÔ¨Ånable if and only if it
is closed under taking bounded morphic images, generated subframes, disjoint
unions and reÔ¨Çects ultraÔ¨Ålter extensions.
Proof. A model-theoretic proof will be given in Section 3.8 below; this proof lies
on the advanced track. An algebraic proof will be given in Chapter 5; this proof
lies on the basic track. In addition, a simple special case which holds for Ô¨Ånite
transitive frames is proved in the following section.
In fact, we can weaken the condition of Ô¨Årst-order deÔ¨Ånability to closure under
ultrapowers, cf. Exercise 3.8.4 or Theorem 5.54.
Exercises for Section 3.3
(a) Prove that frame validity is preserved under taking generated subframes and
disjoint unions.
(b) Which of the implications in Theorem 3.14 can be replaced with an equivalence?
(c) Is frame validity preserved under taking ultraproducts?
3.3.1
3.3.2 Consider the basic modal language. Show that the following properties of frames
are not modally deÔ¨Ånable:
(a) antisymmetry (‚àÄxy(Rxy ‚àß Ryx ‚Üí x = y)),3.4 Finite Frames
143
(b) |W | > 23,
(c) |W | < 23,
(d) acyclicity (there is no path from any x to itself),
(e) every state has at most one predecessor,
(f) every state has at least two successors.
3.3.3 Consider a language with three diamonds, 3 1 , 32 and 33 . For each of the frame
conditions on the corresponding accessibility relations below, Ô¨Ånd out whether it is modally
deÔ¨Ånable or not:
(a) R1 is the union of R 2 and R3 ,
(b) R1 is the intersection of R 2 and R3 ,
(c) R1 is the complement of R 2 ,
(d) R1 is the composition of R 2 and R3 ,
(e) R1 is the identity relation,
(f) R1 is the complement of the identity relation.
3.3.4 Show that any frame is a bounded morphic image of the disjoint union of its rooted
generated subframes.
3.4 Finite Frames
In this section we prove two simple results about Ô¨Ånite frames. First we state and
prove a version of the Goldblatt-Thomason Theorem for Ô¨Ånite transitive frames.
Next we introduce the Ô¨Ånite frame property, and show that a normal modal logic
has the Ô¨Ånite frame property if and only if it has the Ô¨Ånite model property.
Finite transitive frames
An elegant analog of the Goldblatt-Thomason Theorem holds for Ô¨Ånite transitive
frames: within this class, closure under the three structural operations of (Ô¨Ånite)
disjoint unions, generated subframes, and bounded morphisms is a necessary and
sufÔ¨Åcient condition for a class of frames to be modally deÔ¨Ånable. The proof is
straightforward and makes use of Jankov-Fine formulas.
Let F = (W, R) be a point-generated Ô¨Ånite transitive frame for the basic modal
similarity type, and let w be a root of F. The Jankov-Fine formula œÜF,w is essen-
tially a description of F that has the following property: it is satisÔ¨Åable on a frame
G if and only if F is a bounded morphic image of a generated subframe of G.
We build Jankov-Fine formulas as follows. Enumerate the states of F as w0 , . . . ,
wn , where w = w0 . Associate each state wi with a distinct proposition letter pi .
Let œÜF,w be the conjunction of the following formulas:
(i) p0
(ii) 2(p0 ‚à® ¬∑ ¬∑ ¬∑ ‚à® pn )
(iii) (pi ‚Üí ¬¨pj ) ‚àß 2(pi ‚Üí ¬¨pj ), for each i, j with i = j ‚â§ n
(iv) (pi ‚Üí 3pj ) ‚àß 2(pi ‚Üí 3pj ), for each i, j with Rwi wj144
3 Frames
(v) (pi ‚Üí ¬¨3pj ) ‚àß 2(pi ‚Üí ¬¨3pj ), for each i, j with ¬¨Rwi wj
Note that as R is transitive, each node in F is accessible in one step from w. It fol-
lows that when formulas of the form œà ‚àß 2œà are satisÔ¨Åed at w, œà is true throughout
F. With this observed, the content of Jankov-Fine formulas should be clear: the
Ô¨Årst three conjuncts state that each node in F is uniquely labeled by some pi (with
p0 labelling w0 ) while the last two conjuncts use this labeling to describe the frame
structure.
Lemma 3.20 Let F be a transitive, Ô¨Ånite, point-generated frame, let w be a root
of F, and let œÜF,w be the Jankov-Fine formula for F and w. Then for any transitive
frame G we have the following equivalence: there is a valuation V and a node v
such that (G, V ), v  œÜF,w if and only if there exists a bounded morphism from Gv
onto F.
Proof. Left to the reader as Exercise 3.4.1.
With the help of this lemma, it is easy to prove the following Goldblatt-Thomason
analog:
Theorem 3.21 Recall that œÑ0 denotes the basic modal similarity type. Let K be a
class of Ô¨Ånite, transitive œÑ0 -frames. Then K is deÔ¨Ånable within the class of Ô¨Ånite,
transitive œÑ0 -frames if and only if it is closed under taking (Ô¨Ånite) disjoint unions,
generated subframes, and bounded morphic images.
Proof. The right to left direction is immediate: we know from the previous section
that any modally deÔ¨Ånable frame class is closed under these operations. So let us
consider the more interesting converse.
Assume that K is a class of Ô¨Ånite, transitive œÑ0 -frames and satisÔ¨Åes the stated
closure conditions. Let ŒõK be the logic of K; that is, ŒõK = {œÜ | F  œÜ, for all
F ‚àà K}. We will show that ŒõK deÔ¨Ånes K. Clearly ŒõK is valid on every frame in
K, so to complete the proof we need to show that if F  ŒõK , where F is Ô¨Ånite and
transitive, then F ‚àà K. We split the proof into two cases.
First suppose that F is point-generated with root w. Consider the Jankov-Fine
formula œÜF,w for F and w. Clearly œÜF,w is satisÔ¨Åable in F at w, so ¬¨œÜF,w ‚àà
/ ŒõK .
Hence there is some G ‚àà K such that G  ¬¨œÜF,w ; in other words, for some
valuation V and state v we have (G, V ), v  œÜF,w . Thus by the previous lemma,
F is a bounded morphic image of the point-generated subframe Gv of G. By the
closure conditions on K, it follows that F ‚àà K.
So suppose that F is not point-generated. But then as F  ŒõK , so does each
point-generated subframe of F, hence by the work of the previous paragraph all
these subframes belong to K. But by Exercise 3.3.4, F is a bounded morphic image
of the disjoint union of its rooted generated subframes, so F belongs to K too.3.4 Finite Frames
145
The Ô¨Ånite frame property
Our next result deals not with frame deÔ¨Ånability, but with the relationship between
normal modal logics and Ô¨Ånite frames. Normal modal logics were introduced in
Section 1.6 (see in particular DeÔ¨Ånition 1.42). Recall that normal modal logics
are sets of formulas (containing certain axioms) that are closed under three simple
conditions (modus ponens, uniform substitution, and generalization). They are the
standard tool for capturing the notion of validity syntactically.
Now, in Section 2.3 we introduced the Ô¨Ånite model property. We did not apply
the concept to normal modal logics ‚Äì but as a normal logic is simply a set of
formulas, we can easily extend the deÔ¨Ånition to permit this:
DeÔ¨Ånition 3.22 A normal modal logic Œõ has the Ô¨Ånite model property with respect
to some class of models M if M  Œõ and every formula not in Œõ is refuted in a Ô¨Ånite
model M in M. Œõ has the Ô¨Ånite model property if it has the Ô¨Ånite model property
with respect to some class of models.
Informally, if a normal modal logic has the Ô¨Ånite model property, it has a Ô¨Ånite
semantic characterization: it is precisely the set of formulas that some collection of
Ô¨Ånite models makes globally true. This is an attractive property, and as we will see
in Chapter 6 when we discuss the decidability of normal logics, a useful one too.
But something seems wrong. It is the level of frames, rather than the level of
models, which supports the key logical concept of validity. It certainly seems sen-
sible to try and semantically characterize normal logics in terms of Ô¨Ånite structures
‚Äì but it seems we should do so using Ô¨Ånite frames, not Ô¨Ånite models. That is, the
following property seems more appropriate:
DeÔ¨Ånition 3.23 (Finite Frame Property) Let Œõ be a normal modal logic and F a
class of Ô¨Ånite frames. We say Œõ has the Ô¨Ånite frame property with respect to F if
and only if F  Œõ, and for every formula œÜ such that œÜ ‚àà Œõ there is some F ‚àà F
such that œÜ is falsiÔ¨Åable on F. We say Œõ has the Ô¨Ånite frame property if and only if
it has the Ô¨Ånite frame property with respect to some class of Ô¨Ånite frames.
Note that to establish the Ô¨Ånite frame property of a normal modal logic Œõ, it is not
sufÔ¨Åcient to prove that any formula œÜ ‚àà Œõ can be refuted on a model where Œõ is
globally true: in addition one has to ensure that the underlying frame of the model
validates Œõ. If a logic has the Ô¨Ånite frame property (and many important ones do,
as we will learn in Chapter 6) then clearly there is no room for argument: it really
can be characterized semantically in terms of Ô¨Ånite structures.
But now for a surprising result. The Ô¨Ånite frame property is not stronger than the
Ô¨Ånite model property: we will show that a normal modal logic has the Ô¨Ånite frame
property if and only if it has the Ô¨Ånite model property. This result will prove useful
at a number of places in Chapters 4 and 6. Moreover, while proving it we will meet146
3 Frames
some other concepts, notably deÔ¨Ånable variants and distinguishing models, which
will be useful when proving Bull‚Äôs Theorem in Section 4.9.
DeÔ¨Ånition 3.24 (DeÔ¨Ånable Variant) Let M = (W, R, V ) be a model and U ‚äÜ W .
We say U is deÔ¨Ånable in M if and only if there is a formula œÜU such that for all
states w ‚àà W , M, w  œÜU iff w ‚àà U .
Any model M based on the frame (W, R) is called a variant of M. A variant
(W, R, V  ) of M is deÔ¨Ånable in M if and only if for all proposition symbols p,
V  (p) is deÔ¨Ånable in M. If M is a variant of M that is deÔ¨Ånable in M, we call M
a deÔ¨Ånable variant of M.
Recall that normal modal logics are closed under uniform substitution, the process
of uniformly replacing propositional symbols with arbitrary formulas (see Sec-
tion 1.6), and that a formula obtained from œÜ by uniform substitution is called a
substitution instance of œÜ. Our intuitive understanding of uniform substitution suf-
Ô¨Åces for most purposes, but in order to prove the following lemma we need to refer
to the precise concepts of DeÔ¨Ånition 1.18.
Lemma 3.25 Let M = (F, V ) be a model and M = (F, V  ) be a deÔ¨Ånable vari-
ant of M. For any formula œÜ, let œÜ be the result of uniformly replacing each atomic
symbol p in œÜ by œÜV  (p) , where œÜV  (p) deÔ¨Ånes V  (p) in M. Then for all formulas
œÜ, and all normal modal logics Œõ:
(i) M , w  œÜ iff M, w  œÜ .
(ii) If every substitution instance of œÜ is true in M, then every substitution in-
stance of œÜ is true in M .
(iii) If M  Œõ then M  Œõ.
Proof. Item (i) follows by induction on œÜ. For the base case we have M , w 
p iff M, w  œÜV  (p) . As (¬¨œÜ) = ¬¨œÜ , (œÜ ‚à® œà) = œÜ ‚à® œà  , and (3œÜ) = 3œÜ
(cf. DeÔ¨Ånition 1.18) the inductive steps are immediate.
For item (ii), we show the contrapositive. Let œà be a substitution instance of œÜ
and suppose that M  œà. Thus there is some w in M such that M , w  œà. By
item (i), M, w  œà , which means that M  œà . But as œà is a substitution instance
of œà, and œà is a substitution instance of œÜ, we have that œà is a substitution instance
of œÜ (see Exercise 1.2.5) and the result follows.
Item (iii) is an immediate consequence of item (ii), for normal modal logics are
closed under uniform substitution.
We now isolate a type of model capable of deÔ¨Åning all its variants:
DeÔ¨Ånition 3.26 (Distinguishing Model) A model M is distinguishing if the rela-
tion  of modal equivalence between states of M is the identity relation.3.4 Finite Frames
147
In other words, a model M is distinguishing if and only if for all states w and u
in M, if w = u, then there is a formula œÜ such that M, w  œÜ and M, u  œÜ.
Many important models are distinguishing. For example, all Ô¨Åltrations (see DeÔ¨Å-
nition 2.36) are distinguishing. Moreover, the canonical models introduced in Sec-
tion 4.2 are distinguishing too. And, and as we will now see, when a distinguishing
model is Ô¨Ånite, it can deÔ¨Åne all its variants.
Lemma 3.27 Let M = (F, V ) be a Ô¨Ånite distinguishing model. Then:
(i) For every state w in M there is a formula œÜw that is true at, and only at, w.
(ii) M can deÔ¨Åne any subset of F. Hence M can deÔ¨Åne all its variants.
(iii) If M  œÜ then F  œÜ.
Proof. For item (i), suppose that F = (W, R), and enumerate the states in W as
w1 ,. . . ,wn. For all pairs (i, j) such that 1 ‚â§ i, j ‚â§ n and i = j, choose œÜi,j to be a
formula such that M, wi  œÜi,j and M, wj  œÜi,j (such a formula exists, for M is
distinguishing) and deÔ¨Åne œÜwi to be œÜi,1 ‚àß ¬∑ ¬∑ ¬∑ ‚àß œÜi,n . Clearly œÜwi is true at wi and
false everywhere else.

Item (ii) is an easy consequence. For let U be any subset of W . Then w‚ààU œÜw
deÔ¨Ånes U . Hence as M can deÔ¨Åne all subsets of W , it can deÔ¨Åne V  (p), for any
valuation V  on F and propositional symbol p.
As for item (iii), suppose M  œÜ. By item (iii) of the previous lemma we have
that M  œÜ, where M is any deÔ¨Ånable variant of M. But we have just seen that
M can deÔ¨Åne all its variants, hence F  œÜ.
Lemmas 3.25 and 3.27 will be important in their own right when we prove Bull‚Äôs
Theorem in Section 4.9. And with the help of a neat Ô¨Åltration argument, they yield
the main result:
Theorem 3.28 A normal modal logic has the Ô¨Ånite frame property iff it has the
Ô¨Ånite model property.
Proof. The left to right direction is immediate. For the converse, suppose that Œõ
is a normal modal logic with the Ô¨Ånite model property. Since we will need to take
a Ô¨Åltration through Œõ, we have to be explicit about the set of proposition letters of
the formulas in Œõ, so assume that Œõ ‚äÜ Form(œÑ, Œ¶).
Take a formula in the language ML(œÑ, Œ¶) that does not belong to Œõ. We will
show that œÜ can be refuted on a Ô¨Ånite frame F such that F  Œõ.
As Œõ has the Ô¨Ånite model property, there is a Ô¨Ånite model M such that M  Œõ
and M, w  œÜ for some state w in M. Let Œ£ be the set of all subformulas of
formulas in {œÜ} ‚à™ Œõ, and let Mf be any Ô¨Åltration of M through Œ£. As M is Ô¨Ånite,
so is Mf . As Mf is a Ô¨Åltration, it is a distinguishing model. By the Filtration
Theorem (Theorem 2.39), Mf , |w|  œÜ. Moreover Mf  Œõ, for as every state3 Frames
148
in M satisÔ¨Åes all formulas in Œõ, so does every state in Mf (again, this follows
from the Filtration Theorem). Let F be the (Ô¨Ånite) frame underlying Mf . By
Lemma 3.27 item (iii), F  Œõ, and we have proved the theorem.
Note the somewhat unusual use of Ô¨Åltrations in this proof. Normally we Ô¨Åltrate
inÔ¨Ånite models through Ô¨Ånite sets of formulas. Here we Ô¨Åltrated a Ô¨Ånite model
through an inÔ¨Ånite sets of formulas to guarantee that an entire logic remained true.
This result shows that the concepts of normal modal logics and frame validity
Ô¨Åt together well in the Ô¨Ånite domain: if a normal logic has a Ô¨Ånite semantic char-
acterization in terms of models, then it is guaranteed to have a Ô¨Ånite frame-based
semantic characterization as well. But be warned: one of the most striking re-
sults of the following chapter is that logics and frame validity do not always Ô¨Åt
together so neatly. In fact, the frame incompleteness results will eventually lead
us (in Chapter 5) to the use of new semantic structures, namely modal algebras, to
analyze normal modal logics. But this is jumping ahead. It is time to revert to our
discussion of frame deÔ¨Ånability ‚Äì but from a rather different perspective. So far,
our approach has been Ô¨Årmly semantical. This has taught us a lot: in particular, the
Goldblatt-Thomason Theorem has given us a model-theoretic characterization of
the elementary frame classes that are modally deÔ¨Ånable. Moreover, we will see in
Chapter 5 that the semantic approach has an important algebraic dimension. But it
is also possible to approach frame deÔ¨Ånability from a more syntactic perspective,
and that is what we are going to do now. This will lead us to the other main result
of the chapter: the Sahlqvist Correspondence Theorem.
Exercises for Section 3.4
3.4.1 Prove Lemma 3.20. That is, suppose that œÜ F,w is the Jankov-Fine formula for a
transitive Ô¨Ånite frame F with root w. Show that for any frame G, œÜ F,w is satisÔ¨Åable on G
at a node v iff F is a bounded morphic image of G v .
3.4.2 Let M be a model, let M f be any Ô¨Åltration of M through some Ô¨Ånite set of formulas
Œ£, and let f be the natural map associated with the Ô¨Åltration. If u is a point in the Ô¨Åltration,
show that f ‚àí1 [u] is deÔ¨Ånable in M.
3.5 Automatic First-Order Correspondence
We have learned a lot about frame deÔ¨Ånability in the previous sections. In partic-
ular, we have learned that frame deÔ¨Ånability is a second-order notion, and that the
second-order correspondent of any modal formula can be straightforwardly com-
puted using the second-order translation. Moreover, we know that many modal
formulas have Ô¨Årst-order correspondents, and that the Goldblatt-Thomason Theo-
rem gives us a model-theoretic characterization of the frame classes they deÔ¨Åne.
Nonetheless, there remains a gap in our understanding: although many modal3.5 Automatic First-Order Correspondence
149
formulas deÔ¨Åne Ô¨Årst-order conditions on frames, it is not really clear why they do
so. To put it another way, in many cases the (often difÔ¨Åcult to decipher) second-
order condition yielded by the second-order translation is equivalent to a much
simpler Ô¨Årst-order condition. Is there any system to this? Better, are there algo-
rithms that enable us to compute Ô¨Årst-order correspondents automatically, and if so,
how general are these algorithms? This section, and the two that follow, develop
some answers.
A large part of this work centers on a beautiful positive result: there is a large
class of formulas, the Sahlqvist formulas, each of which deÔ¨Ånes a Ô¨Årst-order con-
dition on frames which is effectively calculable using the Sahlqvist-van Benthem
algorithm; this is the celebrated Sahlqvist Correspondence Theorem, which we
will state and prove in the following section. The proof of this theorem sheds light
on why so many second-order correspondents turn out to be equivalent to a Ô¨Årst-
order condition. Moreover each Sahlqvist formula is complete with respect to the
class of Ô¨Årst-order frames it deÔ¨Ånes; this is the Sahlqvist Completeness Theorem,
which we will formulate more precisely in Theorem 4.42 and prove in Section 5.6.
All in all, the Sahlqvist fragment is interesting from both theoretical and practical
perspectives, and we devote a lot of attention to it.
In this section we lay the groundwork for the proof of the Sahlqvist Correspon-
dence Theorem. We are going to introduce two simple classes of modal formulas,
the closed formulas and the uniform formulas, and show that they deÔ¨Åne Ô¨Årst-order
conditions on frames. Along the way we are going to learn about positive and
negative formulas, what they have to do with monotonicity, and how they can help
us get rid of second-order quantiÔ¨Åers. These ideas will be put to work, in a more
sophisticated way, in the following section.
One other thing: in what follows we are going to work with a stronger notion of
correspondence. The concept of correspondence given in DeÔ¨Ånition 3.5 is global:
a modal and a (Ô¨Årst- or second-order) frame formula are called correspondents if
they are valid on precisely the same frames. But it is natural to demand that validity
matches locally:
DeÔ¨Ånition 3.29 (Local Frame Correspondence) Let œÜ be a modal formula in
some similarity type, and Œ±(x) a formula in the corresponding Ô¨Årst- or second-
order frame language (x is supposed to be the only free variable of Œ±). Then we
say that œÜ and Œ±(x) are local frame correspondents of each other if the following
holds, for any frame F and any state w of F:
F, w  œÜ iff F |= Œ±[w].
In fact, we have been implicitly using local correspondence all along. In Exam-
ple 3.6 we showed that p ‚Üí 3p corresponds to ‚àÄxRxx ‚Äì but inspection of the
proof reveals we did so by showing that p ‚Üí 3p locally corresponds to Rxx.3 Frames
150
Similarly, in Example 3.7 we showed that 3p ‚Üí 33p corresponds to density by
showing that 3p ‚Üí 33p locally corresponds to ‚àÄy (Rxy ‚Üí ‚àÉz (Rxz ‚àß Rzy)).
It should be clear from these examples that the local notion of correspondence is
fundamental, and that the following connection holds between the local and global
notions:
Proposition 3.30 If Œ±(x) is a local correspondent of the modal formula œÜ, then
‚àÄx Œ±(x) is a global correspondent of œÜ. So if œÜ has a Ô¨Årst-order local correspon-
dent, then it also has a Ô¨Årst-order global correspondent.
Proof. Trivial.
What about the converse? In particular, suppose that the modal formula œÜ has a
Ô¨Årst order global correspondent; will it also have a Ô¨Årst-order local correspondent?
Intriguingly, the answer to this question is negative, as we will see in Example 3.57.
But until we come to this result, we will not mention global correspondence
much: it is simpler to state and prove results in terms of local correspondence,
relying on the previous lemma to guarantee correspondence in the global sense.
With this point settled, it is time to start thinking about correspondence theory
systematically.
Closed formulas
There is one obvious class of modal formulas guaranteed to correspond to Ô¨Årst-
order frame conditions: formulas which contain no proposition letters.
Example 3.31 Consider the basic temporal language. The formula P  deÔ¨Ånes
the property that there is no Ô¨Årst point of time. More precisely, P  is valid on
precisely those frames such that every point has a predecessor.
Now, obviously it is easy to prove this directly, but for present purposes the
following argument is more interesting. By Proposition 3.12, for any bidirectional
frame F and any point w in F we have that:
F, w  P  iff F |= ‚àÄP1 . . . ‚àÄPn ST x (P )[w],
where P1 , . . . , Pn are the unary predicate variables corresponding to the proposi-
tion letters p1 , . . . , pn occurring in P . But P  contains no propositional vari-
ables, hence there are no second-order quantiÔ¨Åers, and hence:
F, w  P  iff F |= ST x (P )[w].
But ST x (P ) is ‚àÉy (Ryx‚àßy = y), which is equivalent to ‚àÉy Ryx. So P  locally
corresponds to ‚àÉy Ryx (and thus globally corresponds to ‚àÄx‚àÉy Ryx).3.5 Automatic First-Order Correspondence
151
The argument used in this example is extremely simple, and obviously generalizes.
We will state and prove the required generalization, and then move on to richer
pastures.
DeÔ¨Ånition 3.32 A modal formula œÜ is closed if and only if it contains no proposi-
tion letters. Thus closed formulas are built up from , ‚ä•, and any nullary modali-
ties (or modal constants) the signature may contain.
Proposition 3.33 Let œÜ be a closed formula. Then œÜ locally corresponds to a Ô¨Årst-
order formula cœÜ (x) which is effectively computable from œÜ.
Proof. By Proposition 3.12 and the fact that œÜ contains no propositional variables
we have:
F, w  œÜ iff F |= ST x (œÜ)[w].
As it is easy to write a program that computes STx (œÜ), the claim follows immedi-
ately.
Closed formulas arise naturally in some applications (a noteworthy example is
provability logic), thus the preceding result is quite useful in practice.
Uniform formulas
Although the previous proposition was extremely simple, it does point the way to
the strategy followed in our approach to the Sahlqvist Correspondence Theorem:
we are going to look for ways of stripping off the initial block of monadic second-
order universal quantiÔ¨Åers in ‚àÄP1 . . . ‚àÄPn ST x (œÜ), thus reducing the translation to
ST x (œÜ). The obvious way of getting rid of universal quantiÔ¨Åers is to perform
universal instantiation, and this is exactly what we will do. Both here, and in the
work of the next section, we will look for simple instantiations for the P1 , . . . , Pn ,
which result in Ô¨Årst-order formulas equivalent to the original. We will be able to
make this strategy work because of the syntactic restrictions placed on œÜ.
One of the restrictions imposed on Sahlqvist formulas invokes the idea of pos-
itive and negative occurrences of proposition letters. We now introduce this idea,
study its semantic signiÔ¨Åcance, and then, as an introduction to the techniques of
the following section, use a simple instantiation argument to show that the second-
order translations of uniform formulas are effectively reducible to Ô¨Årst-order con-
ditions on frames.
DeÔ¨Ånition 3.34 An occurrence of a proposition letter p is a positive occurrence if
it is in the scope of an even number of negation signs; it is a negative occurrence if
it is in the scope of an odd number of negation signs. (This is one of the few places
in the book where it is important to think in terms of the primitive connectives.3 Frames
152
For example, the occurrence of p in 3(p ‚Üí q) is negative, for this formula is
shorthand for 3(¬¨p ‚à® q).) A modal formula œÜ is positive in p (negative in p) if all
occurrences of p in œÜ are positive (negative). A formula is called positive (negative)
if it is positive (negative) in all proposition letters occurring in it.
Analogous concepts are deÔ¨Åned for the corresponding second-order language.
That is, an occurrence of a unary predicate variable P in a second-order formula is
positive (negative) if it is in the scope of an even (odd) number of negation signs. A
second-order formula œÜ is positive in P (negative in P ) if all occurrences of P in œÜ
are positive (negative), and it is called positive (negative) if it is positive (negative)
in all unary predicate variables occurring in it.
Lemma 3.35 Let œÜ be a modal formula.
(i) œÜ is positive in p iff ST x (œÜ) is positive in the corresponding unary predicate
P.
(ii) If œÜ is positive (negative) in p, then ¬¨œÜ is negative (positive) in p.
Proof. Virtually immediate.
Positive and negative formulas are important because of their special semantic
properties. In particular, they exhibit a useful form of monotonicity.
DeÔ¨Ånition 3.36 Fix a modal language ML(œÑ, Œ¶), and let p ‚àà Œ¶. A modal for-
mula œÜ is upward monotone in p if its truth is preserved under extensions of
the interpretation of p. More precisely, œÜ is upward monotone in p if for ev-
ery model (W, R, V )‚ààœÑ , every state w ‚àà W , and every valuation V  such that
V (p) ‚äÜ V  (p) and for all q = p, V (q) = V  (q), the following holds:
if (W, R, V )‚ààœÑ , w  œÜ, then (W, R, V  )‚ààœÑ , w  œÜ.
In short, extending V (p) (while leaving the interpretation of other proposition let-
ters unchanged) has the effect of extending V (œÜ) (or keeping it the same).
Likewise, a formula œÜ is downward monotone in p if its truth is preserved under
shrinkings of the interpretation of p. That is, for every model (W, R, V )‚ààœÑ ,
every state w ‚àà W , and every valuation V  such that V  (p) ‚äÜ V (p) and for all
q = p, V (q) = V  (q), the following holds:
if (W, R, V )‚ààœÑ , w  œÜ, then (W, R, V  )‚ààœÑ , w  œÜ.
The notions of a second-order formula being upward and downward monotone in
a unary predicate variable P are deÔ¨Åned analogously; we leave this task to the
reader.
Lemma 3.37 Let œÜ be a modal formula.
(i) If œÜ is positive in p, then it is upward monotone in p.3.5 Automatic First-Order Correspondence
153
(ii) If œÜ is negative in p, then it is downward monotone in p.
Proof. Prove both parts simultaneously by induction on œÜ; see Exercise 3.5.3.
But what do upward and downward monotonicity have to do with frame deÔ¨Ånabil-
ity? The following example is instructive:
Example 3.38 The formula 32p locally corresponds to a Ô¨Årst-order formula. For
suppose F, w  32p. Regardless of the valuation, the formula 32p holds at w.
So consider a minimal valuation (for p) on F; that is, choose any Vm such that
Vm (p) = ‚àÖ. Then as w  32p, there must be a successor v of w such that 2p
holds at v. However, there are no p-states, so v must be blind (that is, without
successors). In other words, we have shown that
(F, Vm ), w  32p only if F |= ‚àÉy (Rxy ‚àß ¬¨‚àÉz Ryz)[w].
Now for the interesting direction: assume that the state w in the frame F has a
blind successor. It follows immediately that (F, Vm ), w  32p, where Vm is any
minimal valuation (for p). We claim that the formula 32p is valid at w. To see this,
consider an arbitrary valuation V and a point w of F. By item (i) of Lemma 3.37,
32p is upward monotone in p. Hence it follows from the fact that Vm (p) ‚äÜ V (p)
that (F, V ), w  32p. As V was arbitrary, 32p is valid on F at w.
The key point is the last part of the argument: the use of a minimal valuation fol-
lowed by an appeal to monotonicity to establish a result about all valuations. But
now think about this argument from the perspective of the second-order correspon-
dence language: in effect, we instantiated the predicate variable corresponding to
p with the smallest subset of the frame possible, and then used a monotonicity
argument to establish a result about all assignments to P .
This simple idea lies behind much of our work on the Sahlqvist fragment. To
illustrate the style of argumentation it leads to, we will now use an instantiation
argument to show that all uniform modal formulas deÔ¨Åne Ô¨Årst-order conditions on
frames.
DeÔ¨Ånition 3.39 A proposition letter p occurs uniformly in a modal formula if it
occurs only positively, or only negatively. A predicate variable P occurs uniformly
in a second-order formula if it occurs only positively, or only negatively. A modal
formula is uniform if all the proposition letters it contains occur uniformly. A
second-order formula is uniform if all the unary predicate variables it contains
occur uniformly.
Theorem 3.40 If œÜ is a uniform modal formula, then œÜ locally corresponds to a
Ô¨Årst-order formula cœÜ (x) on frames. Moreover, cœÜ is effectively computable from
œÜ.3 Frames
154
Proof. Consider the universally quantiÔ¨Åed second-order equivalent of œÜ:
‚àÄP1 . . . ‚àÄPn ST x (œÜ),
(3.6)
where P1 , . . . , Pn are second-order variables corresponding to the proposition let-
ters in œÜ. Our aim is to show that (3.6) is equivalent to a Ô¨Årst-order formula by per-
forming appropriate instantiations for the universally quantiÔ¨Åed monadic second-
order variables P1 , . . . , Pn .
As œÜ is uniform, by Lemma 3.35 so is ST x (œÜ). We will instantiate the unary
predicates that occur positively with a predicate denoting as small a set as possi-
ble (that is, the empty set), and the unary predicates that occur negatively with a
predicate denoting as large a set as possible (that is, all the states in the frame). We
will use Church‚Äôs Œª-notation for the required substitution instance providing the
formulas that deÔ¨Åne these predicates. For every P occurring in STx (œÜ), deÔ¨Åne
Œªu. u = u, if ST x (œÜ) is positive in P ,
Œªu. u = u, if ST x (œÜ) is negative in P .
œÉ(P ) ‚â°
Of course, the idea is that instantiating a universal second-order formula according
to this substitution œÉ simply means (i) removing the second-order quantiÔ¨Åers and
(ii) replacing every atomic subformula P y with the formula œÉ(P )(y), that is, with
either y = y or y = y (as given by the deÔ¨Ånition).1
Now consider the following instance of (3.6) in which every unary predicate P
has been replaced by œÉ(P ):
[œÉ(P1 )/P1 , . . . , œÉ(Pn )/Pn ] ST x (œÜ).
(3.7)
We will show that (3.7) is equivalent to (3.6). It is immediate that (3.6) implies
(3.7), for the latter is an instantiation of the former. For the converse implication
we assume that
M |= [œÉ(P1 )/P1 , . . . , œÉ(Pn )/Pn ] ST x (œÜ)[w],
(3.8)
and we have to show that
M |= ‚àÄP1 . . . ‚àÄPn ST x (œÜ)[w].
By the choice of œÉ(P ), for predicates P that occur only positively in STx (œÜ) we
have that M |= ‚àÄy (œÉ(P )(y) ‚Üí P (y)), and for predicates P that occur only neg-
atively in ST x (œÜ), we have that M |= ‚àÄy (P (y) ‚Üí œÉ(P )(y)). (Readers familiar
with Œª-notation will realize that we have implicitly appealed to Œ≤-conversion here.
Readers unfamiliar with Œª-notation should simply note that when œÉ(P ) is a predi-
cate denoting the empty set, then œÉ(P )(y) is false no matter what y denotes, while
1
If you are unfamiliar with Œª-notation, all you really need to know to follow the proof is that Œªu. u = u and
Œªu. u = u are predicates denoting the empty set and the set of all states respectively. Some explanatory
remarks on Œª-notation are given following the proof.3.5 Automatic First-Order Correspondence
155
if œÉ(P ) denotes the set of all states, œÉ(P )(y) is guaranteed to be true.) Hence,
as ST x (œÜ) is positive or negative in all unary predicates P occurring in it, (3.8)
together with Lemma 3.37 imply that for any choice of P1 , . . . , Pn ,
(M, P1 , . . . , Pn ) |= ST x (œÜ)[w],
which means that M |= ‚àÄP1 . . . ‚àÄPn ST x (œÜ) as required. Finally, in any program-
ming language with decent symbol manipulation facilities it is straightforward to
write a program which, when given a uniform formula œÜ, produces STx (œÜ) and
carries out the required instantiations. Hence the Ô¨Årst-order correspondents of uni-
form formulas are computable.
On Œª-notation
Although it is not essential to use Œª-notation, it is convenient and we will apply it
in the following section. For readers unfamiliar with it, here is a quick introduction
to the fundamental ideas.
We have used Church‚Äôs Œª-notation as a way of writing predicates, that is, enti-
ties which denote subsets. But lambda expressions do not denote subsets directly;
rather they denote their characteristic functions. Suppose we are working with a
frame (W, R). Let S ‚äÜ W . Then the characteristic function of S (with respect
to W ) is the function œáS with domain W and range {0, 1} such that œáS (s) = 1 if
s ‚àà S and œáS (s) = 0 otherwise. Reading 1 as true and 0 as false, œáS is simply the
function that says truthfully of each element of W whether it belongs to S or not.
Lambda expressions pick out characteristic functions in the obvious way. For
example, when working with a frame (W, R), Œªu. u = u denotes the function
from W to {0, 1} that assigns 1 to every element w ‚àà W that satisÔ¨Åes u = u and
0 to everything else. But for no choice of w is it the case that w = w; hence, as
we stated in the previous proof, Œªu. u = u denotes the characteristic function of
the empty set. Similarly, Œªu. u = u denotes the characteristic function of W , for
w = w for every w ‚àà W .
Lambda expressions take the drudgery out of dealing with substitutions. Con-
sider the second-order formula P x. This is satisÔ¨Åed in a model if and only if the
element assigned to x belongs to the subset assigned to P . For example, if P is as-
signed the empty set, P x will be false no matter what x is assigned. Now suppose
we substitute (Œªu. u = u) for P in P x. This yields the expression (Œªu. u = u)x.
Read this as ‚Äòapply the function denoted by Œªu. u = u to the state denoted by x.‚Äô
Clearly this yields the value 0 (that is, false). The process of Œ≤-conversion men-
tioned in the proof is essentially a way of rewriting such functional applications
to simpler but equivalent forms; for more details, consult one of the introductions
cited in the Notes. Newcomers to Œª-notation should try Exercise 3.5.1 right away.3 Frames
156
Exercises for Section 3.5
3.5.1 Explain why we could have used the following predicate deÔ¨Ånitions in the proof of
Example 3.38: for every P occurring in ST x (œÜ), deÔ¨Åne
œÉ(P ) ‚â°
Œªu. ‚ä•, if ST x (œÜ) is positive in P ,
Œªu. , if ST x (œÜ) is negative in P .
If you have difÔ¨Åculties with this, consult one of the introductions to Œª-calculus cited in the
notes before proceeding further.
3.5.2 Let œÜ be a modal formula which is positive in all proposition letters. Prove that œÜ
can be rewritten into a normal form which is built up from proposition letters, using ‚àß, ‚à®,
3 and 2 only.
3.5.3 Prove Lemma 3.37. That is, show that if a modal formula œÜ is positive in p, then it
is upward monotone in p, and that if it is negative in p, then it is downward monotone in p.
3.6 Sahlqvist Formulas
In the proof of Theorem 3.40 we showed that uniform formulas correspond to Ô¨Årst-
order conditions by Ô¨Ånding a suitable instantiation for the universally quantiÔ¨Åed
monadic second-order variables in their second-order translation and appealing to
monotonicity. This is an important idea, and the rest of this section is devoted to
extending it: the Sahlqvist fragment is essentially a large class of formulas to which
this style of argument can be applied.
Very simple Sahlqvist formulas
Roughly speaking, Sahlqvist formulas are built up from implications œÜ ‚Üí œà,
where œà is positive and œÜ is of a restricted form (to be speciÔ¨Åed below) from which
the required instantiations can be read off. We now deÔ¨Åne a limited version of the
Sahlqvist fragment for the basic modal language; generalizations and extensions
will be discussed shortly.
DeÔ¨Ånition 3.41 We will work in the basic modal language. A very simple Sahl-
qvist antecedent over this language is a formula built up from , ‚ä• and proposi-
tion letters, using only ‚àß and 3. A very simple Sahlqvist formula is an implication
œÜ ‚Üí œà in which œà is positive and œÜ is a very simple Sahlqvist antecedent.
Examples of very simple Sahlqvist formulas include p ‚Üí 3p and (p ‚àß 33q) ‚Üí
23(p ‚àß q).
The following theorem is central for understanding what Sahlqvist correspon-
dence is all about. Its proof describes and justiÔ¨Åes an algorithm for converting very
simple Sahlqvist formulas into Ô¨Årst-order formulas; the algorithms given later for3.6 Sahlqvist Formulas
157
richer Sahlqvist fragments elaborate on ideas introduced here. Examples of the al-
gorithm in action are given below; it is a good idea to refer to these while studying
the proof.
Theorem 3.42 Let œá = œÜ ‚Üí œà be a very simple Sahlqvist formula in the basic
modal language ML(œÑ0 , Œ¶). Then œá locally corresponds to a Ô¨Årst-order formula
cœá (x) on frames. Moreover, cœá is effectively computable from œá.
Proof. Our starting point is the formula ‚àÄP1 . . . ‚àÄPn (ST x (œÜ) ‚Üí ST x (œà)), which
is the local second-order translation of œá. We assume that this translation has
undergone a pre-processing step to ensure that no two quantiÔ¨Åers bind the same
variable, and no quantiÔ¨Åer binds x. Let us denote STx (œà) by POS; that is, we
have a translation of the form:
‚àÄP1 . . . ‚àÄPn (ST x (œÜ) ‚Üí POS).
(3.9)
We will now rewrite (3.9) to a form from which we can read off the instantiations
that will yield its Ô¨Årst-order equivalent.
Step 1. Pull out diamonds.
Use equivalences of the form
(‚àÉxi Œ±(xi ) ‚àß Œ≤) ‚Üî ‚àÉxi (Œ±(xi ) ‚àß Œ≤),
and
(‚àÉxi Œ±(xi ) ‚Üí Œ≤) ‚Üî ‚àÄxi (Œ±(xi ) ‚Üí Œ≤),
(in that order) to move all existential quantiÔ¨Åers in the antecedent STx (œÜ) of (3.9)
to the front of the implication. Note that by our deÔ¨Ånition of Sahlqvist antecedents,
the existential quantiÔ¨Åers only have to cross conjunctions before they reach the
main implication. Of course, the above equivalences are not valid if the variable
xi occurs freely in Œ≤, but by our assumption on the pre-processing of the formula,
this problem does not arise.
Step 1 results in a formula of the form
‚àÄP1 . . . ‚àÄPn ‚àÄx1 . . . ‚àÄxm (REL ‚àß AT ‚Üí POS),
(3.10)
where REL is a conjunction of atomic Ô¨Årst-order statements of the form Rxi xj cor-
responding to occurrences of diamonds, and AT is a conjunction of (translations of)
proposition letters. It may be helpful at this point to look at the concrete examples
given below.
Step 2. Read off instances.
We can assume that every unary predicate P that occurs in the consequent of the
matrix of (3.10), also occurs in the antecedent of the matrix of (3.10): otherwise
(3.10) is positive in P and we can substitute Œªu. u = u for P (that is, make use of158
3 Frames
the substitution used in the proof of Theorem 3.40) to obtain an equivalent formula
without occurrences of P .
Let Pi be a unary predicate occurring in (3.10), and let Pi xi1 , . . . , Pi xik be all
the occurrences of the predicate Pi in the antecedent of (3.10). DeÔ¨Åne
œÉ(Pi ) ‚â° Œªu. (u = xi1 ‚à® ¬∑ ¬∑ ¬∑ ‚à® u = xik ).
Note that œÉ(Pi ) is the minimal instance making the antecedent REL ‚àß AT true; this
lambda expression says that if a node u has property Pi , then u must be one of the
nodes xi1 , xi2 , . . . , xik explicitly stated to have property Pi in the antecedent. But
this is nothing else than saying that if some model M makes the formula AT true
under some assignment, then the interpretation of the predicate P must extend the
set of points where œÉ(P ) holds:
M |= AT[ww1 . . . wm ] implies M |= ‚àÄy (œÉ(Pi )(y) ‚Üí Pi y)[ww1 . . . wm ] (3.11)
This observation, in combination with the positivity of the consequent of the Sahl-
qvist formula, forms the key to understanding why Sahlqvist formulas have Ô¨Årst-
order correspondents.
Step 3. Instantiating.
We now use the formulas of the form œÉ(Pi ) found in Step 2 as instantiations; we
substitute œÉ(Pi ) for each occurrence of Pi in the Ô¨Årst-order matrix of (3.10). This
results in a formula of the form
[œÉ(P1 )/P1 , . . . , œÉ(Pn )/Pn ]‚àÄx1 . . . ‚àÄxm (REL ‚àß AT ‚Üí POS).
Now, there are no occurrences of monadic second-order variables in REL. Further-
more, observe that by our choice of the substitution instances œÉ(P ), the formula
[œÉ(P1 )/P1 , . . . , œÉ(Pn )/Pn ]AT will be trivially true. So after carrying out these
substitutions we end up with a formula that is equivalent to one of the form
‚àÄx1 . . . ‚àÄxm (REL ‚Üí [œÉ(P1 )/P1 , . . . , œÉ(Pn )/Pn ]POS).
(3.12)
As we assumed that every unary predicate occurring in the consequent of (3.10)
also occurs in its antecedent, (3.12) must be a Ô¨Årst-order formula involving only =
and the relation symbol R. So, to complete the proof of the theorem it sufÔ¨Åces to
show that (3.12) is equivalent to (3.10). The implication from (3.10) to (3.12) is
simply an instantiation. To prove the other implication, assume that (3.12) and the
antecedent of (3.10) are true. That is, assume that
M |= ‚àÄx1 . . . ‚àÄxm (REL ‚Üí [œÉ(P1 )/P1 , . . . , œÉ(Pn )/Pn ]POS)
and
M |= REL ‚àß AT[ww1 . . . wm ].3.6 Sahlqvist Formulas
159
We need to show that M |= POS[ww1 . . . wm ]. First of all, it follows from the
above assumptions that
M |= [œÉ(P1 )/P1 , . . . , œÉ(Pn )/Pn ]POS[ww1 . . . wm ].
As POS is positive, it is upwards monotone in all unary predicates occurring in
it, so it sufÔ¨Åces to show that M |= ‚àÄy (œÉ(Pi )(y) ‚Üí Pi y)[ww1 . . . wm ]. But, by
the essential observation (3.11) in Step 2, this is precisely what the assumption
M |= AT[ww1 . . . wm ] amounts to.
Example 3.43 First consider the formula p ‚Üí 3p. Its second-order translation is
the formula
‚àÄP (
P x ‚Üí ‚àÉz (Rxz ‚àß P z)).
AT
There are no diamonds to be pulled out here, so we can read off the minimal in-
stance œÉ(P ) ‚â° Œªu. u = x immediately. Instantiation gives
(Œªu. u = x)x ‚Üí ‚àÉz (Rxz ‚àß (Œªu. u = x)z),
which (either by Œ≤-conversion or semantic reasoning) yields the following Ô¨Årst-
order formula.
x = x ‚Üí ‚àÉz (Rxz ‚àß z = x).
Note that this is equivalent to Rxx.
Our second example is the density formula 3p ‚Üí 33p, which has
‚àÄP (‚àÉx1 (Rxx1 ‚àß P x1 ) ‚Üí ‚àÉz0 (Rxz0 ‚àß ‚àÉz1 (Rz0 z1 ‚àß P z1 ))).
as its second-order translation. Here we can pull out the diamond ‚àÉx1 :
‚àÄP ‚àÄx1 (Rxx1 ‚àß P x1 ‚Üí ‚àÉz0 (Rxz0 ‚àß ‚àÉz1 (Rz0 z1 ‚àß P z1 ))).
   
REL
AT
Instantiating with œÉ(P ) ‚â° Œªu. u = x1 gives
‚àÄx1 (Rxx1 ‚àß x1 = x1 ‚Üí ‚àÉz0 (Rxz0 ‚àß ‚àÉz1 (Rz0 z1 ‚àß z1 = x1 ))),
which can be simpliÔ¨Åed to ‚àÄx1 (Rxx1 ‚Üí ‚àÉz0 (Rxz0 ‚àß Rz0 x1 )).
Our last example of a very simple Sahlqvist formula is (p ‚àß 33p) ‚Üí 3p. Its
second-order translation is
‚àÄP (P x ‚àß ‚àÉx1 (Rxx1 ‚àß ‚àÉx2 (Rx1 x2 ‚àß P x2 )) ‚Üí ‚àÉz0 (Rxz0 ‚àß P z0 )).
Pulling out the diamonds ‚àÉx1 and ‚àÉx2 results in
‚àÄP ‚àÄx1 ‚àÄx2 (Rxx1 ‚àß Rx1 x2 ‚àß P x ‚àß P x2 ‚Üí ‚àÉz0 (Rxz0 ‚àß P z0 )).


   
REL
AT3 Frames
160
Our minimal instantiation here is: œÉ(P ) ‚â° Œªu. (u = x ‚à® u = x2 ). After instanti-
ating we obtain
‚àÄx1 ‚àÄx2 (Rxx1 ‚àß Rx1 x2 ‚àß (x = x ‚à® x = x2 ) ‚àß (x2 = x ‚à® x2 = x2 ) ‚Üí
‚àÉz0 (Rxz0 ‚àß (z0 = x ‚à® z0 = x2 ))).
This formula simpliÔ¨Åes to ‚àÄx1 ‚àÄx2 (Rxx1 ‚àß Rx1 x2 ‚Üí (Rxx ‚à® Rxx2 )).
Simple Sahlqvist formulas
What is the crucial observation we need to make about the preceding proof? Sim-
ply this: the algorithm for very simple Sahlqvist formulas worked because we were
able to Ô¨Ånd a minimal instantiation for their antecedents. We now show that min-
imal instantiations can be found for more complex Sahlqvist antecedents. First a
motivating example.
Example 3.44 Consider the formula 31 22 p ‚Üí 22 31 p; we will show that this
formula locally corresponds to a kind of local conÔ¨Çuence (or Church-Rosser) prop-
erty of R1 and R2 :
‚àÄx1 z0 (R1 xx1 ‚àß R2 xz0 ‚Üí ‚àÉz1 (R2 x1 z1 ‚àß R1 z0 z1 )).
The reason for the apparently unnatural choice of variable names will soon become
clear, as will the somewhat roundabout approach to the proof that we take. The
name ‚ÄòconÔ¨Çuence‚Äô is explained by the following picture:
ux1
*

1 

H

x u
HH
H2
H

H
1
2 H

j u
H
H uz1
j
*

z0
Let F = (W, R1 , R2 ) be a frame and w a state in F such that F, w  31 22 p ‚Üí
22 31 p, and let v be a state in F such that R1 wv. A sufÔ¨Åcient condition for a
valuation to make 31 22 p true at w would be that p holds at all R2 -successors of
v. So a minimal such valuation can be deÔ¨Åned as
Vm (p) = {x ‚àà W | R2 vx}.
That is, Vm makes p true at precisely the R2 -successors of v. As F, w  31 22 p ‚Üí
22 31 p, we have (F, Vm ), w  22 31 p, but what does this tell us about the (Ô¨Årst-
order) properties of F? The crucial observation is that by the choice of Vm :
(F, Vm ), w  22 31 p iff
(F, Vm ) |= ‚àÄz0 (R2 xz0 ‚Üí ‚àÉz1 (R2 x1 z1 ‚àß R1 z0 z1 ))[wv],
(3.13)3.6 Sahlqvist Formulas
161
which yields that F |= ‚àÄx1 z0 (R1 xx1 ‚àß R2 xz0 ‚Üí ‚àÉz1 (R2 x1 z1 ‚àß R1 z0 z1 ))[w].
Conversely, assume that F has the conÔ¨Çuence property at w. In order to show that
F, w  31 22 p ‚Üí 22 31 p, let V be a valuation on F such that (F, V ), w  31 22 p.
We have to prove that w  22 31 p. By the truth deÔ¨Ånition of 31 , w has an R1 -
successor v satisfying v  22 p. Now we use the minimal valuation Vm again; Ô¨Årst
note that by the deÔ¨Ånition of Vm , we have Vm (p) ‚äÜ V (p). Therefore, Lemma 3.37
ensures that it sufÔ¨Åces to show that 22 31 p holds at w under the valuation Vm . But
this is immediate by the assumption that F is conÔ¨Çuent and (3.13).
This example inspires the following deÔ¨Ånitions:
DeÔ¨Ånition 3.45 Let œÑ be a modal similarity type. A boxed atom is a formula of the
form 2i1 ¬∑ ¬∑ ¬∑ 2ik p (k ‚â• 0), where 2i1 , . . . , 2ik are (not necessarily distinct) boxes
of the language. In the case where k = 0, the boxed atom 2i1 ¬∑ ¬∑ ¬∑ 2ik p is just the
proposition letter p.
Convention 3.46 In the sequel, it will be convenient to treat sequences of boxes
as single boxes. We will therefore denote the formula 2i1 ¬∑ ¬∑ ¬∑ 2ik p by 2Œ≤ p, where
Œ≤ is the sequence i1 . . . ik of indices. Analogously, we will pretend to have a
corresponding binary relation symbol RŒ≤ in the frame language L1œÑ . Thus the
expression RŒ≤ xy abbreviates the formula
‚àÉy1 (Ri1 xy1 ‚àß ‚àÉy2 (Ri2 y1 y2 ‚àß ¬∑ ¬∑ ¬∑ ‚àß ‚àÉyk‚àí1 (Rik‚àí1 yk‚àí2 yk‚àí1 ‚àß Rik yk‚àí1 y) . . .)).
Note that this convention allows us to write the second-order translation of the
boxed atom 2Œ≤ p as ‚àÄy (RŒ≤ xy ‚Üí P y).
If k = 0, Œ≤ is the empty sequence ; in this case the formula R xy should be read
as x = y. Note that the second-order translation of 2 p (that is, of the proposition
letter p) can indeed be written as ‚àÄy (R xy ‚Üí P y).
DeÔ¨Ånition 3.47 Let œÑ be a modal similarity type. A simple Sahlqvist antecedent
over this similarity type is a formula built up from , ‚ä• and boxed atoms, using
only ‚àß and existential modal operators (3 and ). A simple Sahlqvist formula is
an implication œÜ ‚Üí œà in which œà is positive (as before) and œÜ is a simple Sahlqvist
antecedent.
Example 3.48 Typical examples of simple Sahlqvist formulas are 3p ‚Üí 33p,
2p ‚Üí 22p, 21 22 p ‚Üí 23 p, 31 22 p ‚Üí 22 31 p and (21 22 p)(33 p‚àß22 21 q) ‚Üí
33 (qp).
Typically forbidden in a simple Sahlqvist antecedent are:
(i) boxes over disjunctions, as in H(r ‚à® F q) ‚Üí G(P r ‚àß P q),
(ii) boxes over diamonds, as in 23p ‚Üí 32p,3 Frames
162
(iii) dual-triangled atoms, as in p  p ‚Üí p.
Theorem 3.49 Let œÑ be a modal similarity type, and let œá = œÜ ‚Üí œà be a simple
Sahlqvist formula over œÑ . Then œá locally corresponds to a Ô¨Årst-order formula cœá (x)
on frames. Moreover, cœá is effectively computable from œá.
Proof. The proof of this theorem is an adaptation of the proof of Theorem 3.42.
Consider the universally quantiÔ¨Åed second-order transcription of œá:
‚àÄP1 . . . ‚àÄPn (ST x (œÜ) ‚Üí ST x (œà)).
(3.14)
Again, we Ô¨Årst make sure that no two quantiÔ¨Åers bind the same variable, and that
no quantiÔ¨Åer binds x. As before, the idea of the algorithm is to rewrite (3.14) to a
formula from which we can easily read off instantiations which yield a Ô¨Årst-order
equivalent of (3.14).
Step 1. Pull out diamonds.
This is the same as before. This process results in a formula of the form
‚àÄP1 . . . ‚àÄPn ‚àÄx1 . . . ‚àÄxm (REL ‚àß BOX-AT ‚Üí ST x (œà)),
(3.15)
where REL is a conjunction of atomic Ô¨Årst-order statements of the form Rxi xj cor-
responding to occurrences of diamonds, and BOX-AT is a conjunction of (transla-
tions of) boxed atoms, that is, formulas of the form ‚àÄy (RŒ≤ xi y ‚Üí P y).
Step 2. Read off instances.
Let P be a unary predicate occurring in (3.15), and let œÄ1 (xi1 ), . . . , œÄk (xik ) be
all the (translations of the) boxed atoms in the antecedent of (3.10) in which the
predicate P occurs. Observe that every œÄj is of the form ‚àÄy (RŒ≤j xij y ‚Üí P y),
where Œ≤j is a sequence of diamond indices (recall Convention 3.46). DeÔ¨Åne
œÉ(P ) ‚â° Œªu. (RŒ≤1 xi1 u ‚à® ¬∑ ¬∑ ¬∑ ‚à® RŒ≤k xik u).
Again, œÉ(P1 ), . . . , œÉ(Pn ) form the minimal instances making the antecedent REL‚àß
BOX-AT true.
The remainder of the proof is the same as the proof of Theorem 3.42, with the
proviso that all occurrences of ‚ÄòAT‚Äô should be replaced by ‚ÄòBOX-AT‚Äô.
As in the case of very simple Sahlqvist formulas, the algorithm is best understood
by inspecting some examples:
Example 3.50 Let us investigate some of the formulas given in Example 3.48. The
simple Sahlqvist formula 21 22 p ‚Üí 23 p has the following second-order transla-
tion:
‚àÄP (‚àÄy (R12 xy ‚Üí P y) ‚Üí ‚àÄz (R3 xz ‚Üí P z)).



BOX-AT3.6 Sahlqvist Formulas
163
There are no diamonds to be pulled out here, so we can read off the required sub-
stitution instance œÉ(P ) ‚â° Œªu. R12 xu immediately. Carrying out the substitution
we obtain
‚àÄy (R12 xy ‚Üí R12 xy) ‚Üí ‚àÄz (R3 xz ‚Üí R12 xz),
which is equivalent to ‚àÄz (R3 xz ‚Üí R12 xz).
Next we consider the conÔ¨Çuence formula 31 22 p ‚Üí 22 31 p, whose second-
order translation is
‚àÄP (‚àÉx1 (R1 xx1 ‚àß ‚àÄy (R2 x1 y ‚Üí P y)) ‚Üí ‚àÄz0 (R2 xz0 ‚Üí ‚àÉz1 (R1 z0 z1 ‚àß P z1 ))).
Pulling out the existential quantiÔ¨Åcation ‚àÉx1 yields
‚àÄP ‚àÄx1 (R1 xx1 ‚àß ‚àÄy (R2 x1 y ‚Üí P y) ‚Üí ‚àÄz0 (R2 xz0 ‚Üí ‚àÉz1 (R1 z0 z1 ‚àß P z1 ))).
   


REL
BOX-AT
The minimal instance making BOX-AT true is œÉ(P ) ‚â° Œªu. R2 x1 u. After instanti-
ating we obtain
‚àÄx1 (R1 xx1 ‚àß‚àÄy (R2 x1 y ‚Üí R2 x1 y) ‚Üí ‚àÄz0 (R2 xz0 ‚Üí ‚àÉz1 (R1 z0 z1 ‚àßR2 x1 z1 ))),
which can be simpliÔ¨Åed to
‚àÄx1 ‚àÄz0 (R1 xx1 ‚àß R2 xz0 ‚Üí ‚àÉz1 (R1 z0 z1 ‚àß R2 x1 z1 )).
As our Ô¨Ånal example, let us treat a formula using a dyadic modality :
(21 22 p)(33 p ‚àß 22 21 q) ‚Üí 33 (qp).
We use a ternary relation symbol T for the triangle . Its second-order translation
is the rather formidable looking
‚àÄP ‚àÄQ (‚àÉx1 x2 (T xx1 x2 ‚àß ‚àÄy (R12 x1 y ‚Üí P y) ‚àß
‚àÉx3 (R3 x2 x3 ‚àß P x3 ) ‚àß ‚àÄy (R21 x2 y ‚Üí Qy))
‚Üí ‚àÉz (R3 xz ‚àß ‚àÉz1 z2 (T zz1 z2 ‚àß Qz1 ‚àß P z2 ))),
from which we can pull out the diamonds ‚àÉx1 , ‚àÉx2 and ‚àÉx3 . This leads to
REL



‚àÄP ‚àÄQ‚àÄx1 x2 ‚àÄx3 (T xx1 x2 ‚àß R3 x2 x3 ‚àß
BOX‚àíAT



‚àÄy (R12 x1 y ‚Üí P y) ‚àß P x3 ‚àß ‚àÄy (R21 x2 y ‚Üí Qy) ‚Üí
‚àÉz (R3 xz ‚àß ‚àÉz1 z2 (T zz1 z2 ‚àß Qz1 ‚àß P z2 ))).
Now we can easily read off the required instantiations:
œÉ(P ) ‚â° Œªu. (R12 x1 u ‚à® u = x3 ),
œÉ(Q) ‚â° Œªu. (R21 x2 u).3 Frames
164
Performing the substitution [œÉ(P )/P, œÉ(Q)/Q] and deleting the tautological parts
from the antecedent gives
‚àÄx1 x2 ‚àÄx3 (T xx1 x2 ‚àß R3 x2 x3 ‚Üí
‚àÉz (R3 xz ‚àß ‚àÉz1 z2 (T zz1 z2 ‚àß R21 x2 z1 ‚àß (R12 x1 z2 ‚à® z2 = x3 ))).
Sahlqvist formulas
We are now ready to introduce the full Sahlqvist fragment and the full version of
the Sahlqvist-van Benthem algorithm.
DeÔ¨Ånition 3.51 Let œÑ be a modal similarity type. A Sahlqvist antecedent over œÑ is
a formula built up from , ‚ä•, boxed atoms, and negative formulas, using ‚àß, ‚à® and
existential modal operators (3 and ). A Sahlqvist implication is an implication
œÜ ‚Üí œà in which œà is positive and œÜ is a Sahlqvist antecedent.
A Sahlqvist formula is a formula that is built up from Sahlqvist implications by
freely applying boxes and conjunctions, and by applying disjunctions only between
formulas that do not share any proposition letters.
Example 3.52 Both simple and very simple Sahlqvist formulas are examples of
Sahlqvist formulas, as are (p ‚Üí 3p), p ‚àß 3¬¨p ‚Üí 3p, and (31 2 p ‚Üí
2 31 p) ‚àß 1 (p ‚Üí 32 p). As with simple Sahlqvist formulas, typically forbidden
combinations in Sahlqvist antecedent are ‚Äòboxes over disjunctions,‚Äô ‚Äòboxes over di-
amonds,‚Äô and ‚Äòdual-triangled atoms‚Äô as in p  p ‚Üí p (see Example 3.48).
The following lemma is instrumental in reducing the correspondence problem for
arbitrary Sahlqvist formulas, Ô¨Årst to that of Sahlqvist implications, and then to that
of simple Sahlqvist formulas.
Lemma 3.53 Let œÑ be a modal similarity type, and let œÜ and œà be œÑ -formulas.
(i) If œÜ and Œ±(x) are local correspondents, then so are Œ≤ œÜ and ‚àÄy (RŒ≤ xy ‚Üí
[y/x]Œ±).
(ii) If œÜ (locally) corresponds to Œ±, and œà (locally) corresponds to Œ≤, then œÜ‚àßœà
(locally) corresponds to Œ± ‚àß Œ≤.
(iii) If œÜ locally corresponds to Œ±, œà locally corresponds to Œ≤, and œÜ and œà have
no proposition letters in common, then œÜ ‚à® œà locally corresponds to Œ± ‚à® Œ≤.
Proof. Left as Exercise 3.6.3.
The local perspective in parts one and three of the lemma is essential. For instance,
one can Ô¨Ånd a modal formula œÜ that globally corresponds to a Ô¨Årst-order condition
‚àÄx Œ±(x) without 2œÜ globally corresponding to the formula ‚àÄx‚àÄy (Rxy ‚Üí Œ±(y));
see Exercise 3.6.3.3.6 Sahlqvist Formulas
165
Theorem 3.54 Let œÑ be a modal similarity type, and let œá be a Sahlqvist formula
over œÑ . Then œá locally corresponds to a Ô¨Årst-order formula cœá (x) on frames. More-
over, cœá is effectively computable from œá.
Proof. The proof of the theorem is virtually the same as the proof of Theorem 3.49,
with the exception of the use of Lemma 3.53 and of the fact that we have to do some
pre-processing of the formula œá.
By Lemma 3.53 it sufÔ¨Åces to show that the theorem holds for all Sahlqvist im-
plications. So assume that œá has the form œÜ ‚Üí œà where œÜ is a Sahlqvist antecedent
and œà a positive formula. Proceed as follows.
Step 1. Pull out diamonds and pre-process.
Using the same strategy as in the proof of Theorem 3.49 together with equivalences
of the form
((Œ± ‚à® Œ≤) ‚Üí Œ≥) ‚Üî ( (Œ± ‚Üí Œ≥) ‚àß (Œ≤ ‚Üí Œ≥) )
and
‚àÄ . . . (Œ± ‚àß Œ≤) ‚Üî ( ‚àÄ . . . Œ± ‚àß ‚àÄ . . . Œ≤ ),
we can rewrite the second-order translation of œÜ ‚Üí œà into a conjunction of formu-
las of the form
‚àÄP1 . . . ‚àÄPn ‚àÄx1 . . . ‚àÄxm (REL ‚àß BOX-AT ‚àß NEG ‚Üí ST x (œà)),
(3.16)
where REL is a conjunction of atomic Ô¨Årst-order statements of the form Rx cor-
responding to occurrences of diamonds and triangles, BOX-AT is a conjunction of
(translations of) boxed atoms, and NEG is a conjunction of (translations of) neg-
ative formulas. By Lemma 3.53(ii) it sufÔ¨Åces to show that each formula of the
form displayed in (3.16) has a Ô¨Årst-order equivalent. This is done by using the
equivalence
(Œ± ‚àß NEG ‚Üí Œ≤) ‚Üî (Œ± ‚Üí Œ≤ ‚à® ¬¨NEG),
where ¬¨NEG is the positive formula that arises by negating the negative formula
NEG. Using this equivalence we can rewrite (3.16) to obtain a formula of the form
‚àÄP1 . . . ‚àÄPn ‚àÄx1 . . . ‚àÄxm (REL ‚àß BOX-AT ‚Üí POS),
and from here on we can proceed as in Step 2 of the proof of Theorem 3.49.
Example 3.55 By way of example we determine the local Ô¨Årst-order correspon-
dents of two of the modal formulas given in Example 3.52. To determine the
Ô¨Årst-order correspondent of the Sahlqvist formula (p ‚Üí 3p) we Ô¨Årst recall that
the local Ô¨Årst-order correspondent of p ‚Üí 3p is Rxx. So, by Lemma 3.53(i)
(p ‚Üí 3p) locally corresponds to ‚àÄy (Rxy ‚Üí Ryy).3 Frames
166
Next we consider the Sahlqvist formula (p ‚àß 3¬¨p) ‚Üí 3p. Its translation is
‚àÄP (P x ‚àß ‚àÉy (Rxy ‚àß ¬¨P y) ‚Üí ‚àÉz (Rxz ‚àß P z)).
Pulling out the diamond produces
‚àÄP ‚àÄy ( P x ‚àß Rxy ‚àß ¬¨P y ‚Üí ‚àÉz (Rxz ‚àß P z)),
  



BOX-AT
REL
NEG
POS
and moving the negative part ¬¨P y to the consequent we get
‚àÄP ‚àÄy ( P x ‚àß Rxy ‚Üí P y ‚à® ‚àÉz (Rxz ‚àß P z)).
 



BOX-AT
REL
POS
The minimal instantiation to make P x true is Œªu. u = x. After instantiation we
obtain
‚àÄy (Rxy ‚Üí y = x ‚à® ‚àÉz (Rxz ‚àß z = x)),
which can be simpliÔ¨Åed to ‚àÄy (Rxy ‚àß x = y ‚Üí Rxx).
Exercises for Section 3.6
3.6.1 Compute the Ô¨Årst-order formulas locally corresponding to the following Sahlqvist
formulas:
(a) 31 32 p ‚Üí 32 31 p,
(b) (p ‚àß 2p ‚àß 22p) ‚Üí 3p,
(c) 3k 2l p ‚Üí 2m 3n p, for arbitrary natural numbers k, l, m and n,
(d) (2p)(2p) ‚Üí pp,
(e) 3(¬¨p ‚àß 3(p ‚àß q)) ‚Üí 3(p ‚àß q),
(f) 2((p ‚àß 2¬¨p ‚àß q) ‚Üí 3q)).
(a) Show that the formula 2(p ‚à® q) ‚Üí 3(2p ‚à® 2q) does not locally correspond
to a Ô¨Årst-order formula on frames. (Hint: modify the frame of Example 3.11.)
(b) Use this example to show that dual-triangled atoms cannot be allowed in Sahlqvist
antecedents.
3.6.2
3.6.3 Prove Lemma 3.53:
(a) Show that if œÜ and Œ±(x) locally correspond, so do  Œ≤ œÜ and ‚àÄy (RŒ≤ xy ‚Üí Œ±(y)).
(b) Prove that if œÜ (locally) corresponds to Œ±(x), and œà (locally) corresponds to Œ≤(x),
then œÜ ‚àß œà (locally) corresponds to Œ±(x) ‚àß Œ≤(x).
(c) Show that if œÜ locally corresponds to Œ±(x), œà locally corresponds to Œ≤(x), and œÜ
and œà have no proposition letters in common, then œÜ ‚à® œà locally corresponds to
Œ±(x) ‚à® Œ≤(x).
(d) Prove that (a) and (c) do not hold for global correspondence, and that the condition
on the proposition letters in (c) is necessary as well. (Hint: for (a), think of the
modal formula 33p ‚Üí 3p and the Ô¨Årst-order formula ‚àÄxyz (Ryz ‚àß Rzx ‚Üí
Ryx).)3.7 More about Sahlqvist Formulas
167
3.7 More about Sahlqvist Formulas
It is time to step back and think more systematically about the Sahlqvist fragment,
for a number of questions need addressing. For a start, does this fragment con-
tain all modal formulas with Ô¨Årst-order correspondents? And why did we forbid
disjunctions in the scope of boxes, and occurrences of nested duals of triangles
in Sahlqvist antecedents, while we allowed boxed atoms? Most interesting of all,
which Ô¨Årst-order conditions are expressible by means of Sahlqvist formulas? That
is, is it possible to prove some sort of converse to the Sahlqvist Correspondence
Theorem?
Limitative results
To set the stage for our discussion, we Ô¨Årst state (without proof) the principal limi-
tative result in this area: Chagrova‚Äôs Theorem. Good presentations of the proof are
available in the literature; see the Notes for references.
Theorem 3.56 (Chagrova‚Äôs Theorem) It is undecidable whether an arbitrary ba-
sic modal formula has a Ô¨Årst-order correspondent.
This implies that, even for the basic modal language, it is not possible to write
a computer program which, when presented with an arbitrary modal formula as
input, will terminate after Ô¨Ånitely many steps, returning the required Ô¨Årst-order
correspondent (if there is one) or saying ‚ÄòNo!‚Äô (if there is not).
Quite apart from its intrinsic interest, this result immediately tells us that the
Sahlqvist fragment cannot possibly contain all modal formulas with Ô¨Årst-order cor-
respondents. For it is straightforward to decide whether a modal formula is a Sahl-
qvist formula, and to compute the Ô¨Årst-order correspondents of Sahlqvist formulas.
Hence if all modal formulas with Ô¨Årst-order correspondents were Sahlqvist, this
would contradict Chagrova‚Äôs Theorem.
But a further question immediately presents itself: is every modal formula with
a Ô¨Årst-order correspondent equivalent to a Sahlqvist formula? (The preceding ar-
gument does not rule this out.) The answer is no: there are modal formulas corre-
sponding to Ô¨Årst-order frame conditions which are not equivalent to any Sahlqvist
formula.
Example 3.57 Consider the conjunction of the following two formulas:
(M)
(4)
3p ‚Üí 3p,
33q ‚Üí 3q.
(M) is the McKinsey formula we discussed in Example 3.11, and (4) is the transitiv-
ity axiom. It is obvious that M itself is not a Sahlqvist axiom, and by Example 3.11
it does not express a Ô¨Årst-order condition.168
3 Frames
It requires a little argument to show that the conjunction M ‚àß 4 is not equivalent
to a Sahlqvist formula. One way to do so is by proving that M ‚àß 4 does not have a
local Ô¨Årst-order correspondent (cf. Exercise 3.7.1).
Nevertheless, the conjunction M‚àß4 does have a global Ô¨Årst-order correspondent,
as we can prove the following equivalence for all transitive frames F:
F  M iff F |= ‚àÄx‚àÉy (Rxy ‚àß ‚àÄz (Ryz ‚Üí z = y)).
(3.17)
We leave the right to left direction as an exercise to the reader. To prove the other
direction, assume for contradiction that there is a transitive frame F = (W, R) on
which the McKinsey formula is valid, but which does not satisfy the Ô¨Årst-order
formula given in (3.17). Let r be a state witnessing that the Ô¨Årst-order formula
in (3.17) does not hold in F. That is, assume that each successor s of r has a
successor distinct from it. We may assume that the frame is generated from r, so
that F |= ‚àÄy‚àÉz (Ryz ‚àß y = z).
In order to derive a contradiction from this, we need to introduce some terminol-
ogy. Call a subset X of W coÔ¨Ånal in W if for all w ‚àà W there is an x ‚àà X such
that Rwx. We now claim that
W has a subset X such that both X and W \ X are coÔ¨Ånal in W .
(3.18)
From (3.18) we can immediately derive a contradiction by considering the valua-
tion V given by V (p) = X. For, coÔ¨Ånality of X implies that (F, V ), r  23p,
while coÔ¨Ånality of W \ X likewise gives (F, V ), r  23¬¨p. But then (F, V ), r 
M.
To prove (3.18), consider the collection C of all pairs of disjoint non-empty
subsets Y , Z ‚äÇ W satisfying ‚àÄy ‚àà Y ‚àÉz ‚àà Z Ryz and ‚àÄz ‚àà Z‚àÉy ‚àà Y Rzy.
We Ô¨Årst prove that this collection is non-empty. From F |= ‚àÄy‚àÉz (Ryz ‚àß y = z)
it follows that there is a path w0 Rw1 Rw2 R . . . such that wi = wi+1 for all i.
Let n be the Ô¨Årst index such that wn ‚àà {w0 , . . . , wn‚àí1 }, or n = œâ if there is
no such index. It is then an easy exercise to verify that the pair consisting of
Y0 := {w2i | 2i < n} and Y1 := {w2i+1 | 2i + 1 < n} belongs to C.
Order C under coordinate-wise inclusion. It is obvious that every chain in this
partial ordering is bounded above; hence, we may apply Zorn‚Äôs Lemma and obtain
a maximal such pair Z0 , Z1 . We claim that
Z0 ‚à™ Z1 = W.
(3.19)
Since Z0 and Z1 are disjoint, this implies that Z1 = W \ Z0 and thus proves (3.18).
Suppose that (3.19) does not hold. Then there is an element w ‚àà W which
belongs neither to Z0 nor to Z1 . If w has successor in Z0 ‚à™ Z1 then (by transitivity
of R) the pair (Z0 ‚à™ {w}, Z1 ) would belong to C, contradicting the maximality
of (Z0 , Z1 ) in the ordering of C. But if w has no successor in Z0 ‚à™ Z1 then by
transitivity of R, the subframe Fw of F is disjoint from Z0 ‚à™ Z1 . With the argument3.7 More about Sahlqvist Formulas
169
used above to show that C = ‚àÖ we can construct a pair (Y0 , Y1 ) ‚àà C such that Y0
and Y1 fall entirely within Fw , and thus satisfy (Y0 ‚à™ Y1 ) ‚à© (Z0 ‚à™ Z1 ) = ‚àÖ. It is
then straightforward to check that the pair (Y0 ‚à™ Y1 , Z0 ‚à™ Z1 ) belongs to C; but this
membership would contradict the maximality of (Z0 , Z1 ). This proves (3.19).
Of course, this example begs the question whether there is a modal formula that
locally corresponds to a Ô¨Årst-order formula without being equivalent to a Sahlqvist
formula. However, the answer to this is also afÔ¨Årmative: the formula 2M ‚àß 4 is an
example. In Exercise 3.7.1 the reader is asked to show that it has a local Ô¨Årst-order
correspondent; in Chapter 5 we will develop the techniques needed to prove that
the formula is not equivalent to a Sahlqvist formula, see Exercise 5.6.2.
Thus the Sahlqvist fragment does not contain all modal formulas with Ô¨Årst-order
correspondents. So the next question is: can the Sahlqvist fragment be further
extended? The answer is yes ‚Äì but we should reÔ¨Çect a little on what we hope
to achieve through such extensions. The Sahlqvist fragment is essentially a good
compromise between the demands of generality and simplicity. By adding further
restrictions it is possible to extend it further, but it is not obvious that the resulting
loss of simplicity is really worth it. Moreover, the Sahlqvist fragment also gives
rise to a matching completeness theorem; we would like proposed extensions to do
so as well. We do not know of simple generalizations of the Sahlqvist fragment
which manage to do this. In short, while there is certainly room for experiment
here, it is unclear whether anything interesting is likely to emerge.
However, one point is worth stressing once more: the Sahlqvist fragment cannot
be further extended simply by dropping some of the restrictions in the deÔ¨Ånition
of a Sahlqvist formula. We forbid disjunctions in the scope of boxes and nested
duals of triangles in Sahlqvist antecedents for a very good reason: these forbidden
combinations easily lead to modal formulas that have no Ô¨Årst-order correspondent,
as we have seen in Example 3.11 and Exercise 3.6.2.
Kracht‚Äôs Theorem
Let us turn to a nice positive result. As has already been mentioned, not only
does each Sahlqvist formula deÔ¨Åne a Ô¨Årst-order class of frames, but when we use
one as an axiom in a normal modal logic, that logic is guaranteed to be complete
with respect to the elementary class of frames the axiom deÔ¨Ånes. (This is the
content of the Sahlqvist Completeness Theorem; see Theorem 4.42 for a precise
statement.) So it would be very pleasant to know which Ô¨Årst-order conditions are
the correspondents of Sahlqvist formulas. Kracht‚Äôs Theorem is a sort of converse
to the Sahlqvist Correspondence Theorem which gives us this information.
Before we can deÔ¨Åne the fragment of Ô¨Årst-order logic corresponding to Sahl-
qvist formulas we need some auxiliary deÔ¨Ånitions; we also introduce some helpful170
3 Frames
notation. For reasons of notational simplicity, we work in the basic modal similar-
ity type. First of all, we will abbreviate the Ô¨Årst-order formula ‚àÄy (Rxy ‚Üí Œ±(y))
to (‚àÄyx)Œ±(y), speaking of restricted quantiÔ¨Åcation and calling x the restrictor
of y. Likewise ‚àÉy (Rxy ‚àß Œ±(y)) is abbreviated to (‚àÉyx)Œ±(y). We will call the
constructs (‚àÄyx) and (‚àÉyx) restricted quantiÔ¨Åers. If we wish not to specify
the restrictor of a restricted quantiÔ¨Åer we will write ‚àÄr y or ‚àÉr y. Moreover, if we
do not wish to specify whether a quantiÔ¨Åer is existential or universal we denote it
by Q (Qr in the restricted case). Second, for the duration of this subsection it will
be convenient for us to consider formulas of the form u = u as atomic. Third, in
this subsection we will work exclusively with formulas in which no variable occurs
both free and bound, and in which no two distinct (occurrences of) quantiÔ¨Åers bind
the same variable; we will call such formulas clean.
Now we call a formula restrictedly positive if it is built up from atomic formu-
las, using ‚àß, ‚à® and restricted quantiÔ¨Åers only; observe that monadic predicates oc-
cur positively in restrictedly positive formulas. Finally, we assume that the reader
knows how to rewrite an arbitrary positive propositional formula to a disjunctive
normal form or DNF (that is, to an equivalent disjunction of conjunctions of atomic
formulas) and to a conjunctive normal form or CNF (that is, to an equivalent con-
junction of disjunctions of atomic formulas).
The crucial notion in this subsection is that of a variable occurring inherently
universally in a Ô¨Årst-order formula.
DeÔ¨Ånition 3.58 We say that an occurrence of the variable y in the (clean!) formula
Œ± is inherently universal if either y is free, or else y is bound by a restricted quan-
tiÔ¨Åer of the form (‚àÄyx)Œ≤ which is not in the scope of an existential quantiÔ¨Åer.
A formula Œ±(x) in the basic Ô¨Årst-order frame language is called a Kracht formula
if Œ± is clean, restrictedly positive and, furthermore, every atomic formula is either
of the form u = u or u = u, or else it contains at least one inherently universal
variable.
Restricted quantiÔ¨Åcation is obviously the modal face of quantiÔ¨Åcation in Ô¨Årst-order
logic; indeed, we could have deÔ¨Åned the standard translation of a modal formula
using this notion. As for Kracht formulas, Ô¨Årst observe that every universal re-
stricted Ô¨Årst-order formula satisÔ¨Åes the deÔ¨Ånition. A second example of a Kracht
formula is (‚àÄwv)(‚àÄxv)(‚àÉyw)Rxy: note that it does not matter that the ‚Äòx‚Äô
in Rxy falls within the scope of an existential quantiÔ¨Åer; what matters is that the
universal quantiÔ¨Åer that binds x does not occur within the scope of any existen-
tial quantiÔ¨Åcation. On the other hand, the formula (‚àÉwv)(‚àÄxv)w = x is not
a Kracht formula since the occurrence of neither w nor x in w = x is inherently
universal: w is disqualiÔ¨Åed because it is bound by an existential quantiÔ¨Åer and x
because it is bound within the scope of the existential quantiÔ¨Åer (‚àÉwv).3.7 More about Sahlqvist Formulas
171
The following result states that Kracht formulas are the Ô¨Årst-order counterparts
of Sahlqvist formulas ‚Äì but not only that. As will become apparent from its proof,
from a given Kracht formula we can compute a Sahlqvist formula locally corre-
sponding to it. The reader is advised to glance at the examples provided below
while reading the proof.
Theorem 3.59 Any Sahlqvist formula locally corresponds to a Kracht formula;
and conversely, every Kracht formula is a local Ô¨Årst-order correspondent of some
Sahlqvist formula which can be effectively obtained from the Kracht formula.
Proof. For the left to right direction, we leave it as an exercise to the reader to show
that the algorithm discussed in the sections 3.5 and 3.6 in fact produces, given a
Sahlqvist formula, a Ô¨Årst-order correspondent within the Kracht fragment. We will
give the proof of the other direction: we will show how rewrite a given Kracht
formula to an equivalent Sahlqvist formula.
Our Ô¨Årst step is to provide special prenex formulas as normal forms for Kracht
formulas. DeÔ¨Åne a type 1 formula to be of the form
‚àÄr x1 . . . ‚àÄr xn Qr1 y1 . . . Qrm ym Œ≤(x0 , . . . , xn , y1 , . . . , ym )
such that n, m ‚â• 0 and each variable is restricted by an earlier variable (that is, the
restrictor of any xi is some xj with j < i and the restrictor of any yi is either some
xk or some yj with j < i. Furthermore we require that Œ≤ is a DNF of formulas
u = u, u = u, Rux, u = x and Rxu (that is, we allow all atomic formulas that are
not of the form Ryy or y = y  ). Here and in the remainder of this proof we use
the convention that u and z denote arbitrary variables in {x0 , . . . , xn , y1 , . . . , ym }
and x an arbitrary variable in {x0 , . . . , xn }.
Clearly then, type 1 formulas form a special class of Kracht formulas. This
inclusion is not proper (modulo equivalence), since we can prove the following
claim.
Claim 1 Every Kracht formula can be effectively rewritten into an equivalent type
1 formula.
Proof of Claim. Let Œ±(x0 ) be a Kracht formula. By deÔ¨Ånition it is built up from
atomic formulas using ‚àß, ‚à® and restricted quantiÔ¨Åers. Furthermore, since Œ±(x0 ) is
clean, in a subformula of the form Qr v Œ≤ the variable v may not occur outside of
Œ≤. Hence, we may use the equivalences
(Qr v Œ≤) ‚ô• Œ≥ ‚Üî Qr v (Œ≤ ‚ô• Œ≥)
(3.20)
(where ‚ô• uniformly denotes either ‚àß or ‚à®) to pull out quantiÔ¨Åers to the front.
However, if we want to remain within the Kracht fragment we have to take care
about the order in which we pull out quantiÔ¨Åers.172
3 Frames
Without loss of generality we may assume that each inherently universal variable
is named xi for some i, while each of the remaining variables is named yj for some
j. This ensures that no atomic subformula of Œ±(x0 ) is of the form Ryy or y = y 
(with distinct variables y and y ).
Observe also that in every subformula of the form ((‚àÄxu)Œ≤)‚ô•Œ≥, the variable
u occurs free. If this u is not the variable x0 then it is a bound variable of Œ±; hence,
the mentioned subformula must occur in the scope of a quantiÔ¨Åer (Qr u  x ). This
quantiÔ¨Åcation must have been universal, for, otherwise, the variable x could not
have been among the inherently universal ones. But this means that the variable
u itself must be inherently universal as well, so u is some xi . This shows that
by successively pulling out restricted universal quantiÔ¨Åers ‚àÄr x we end up with a
Kracht formula of the form
‚àÄr x1 . . . ‚àÄr xn Œ± (x0 , . . . , xn , y1 , . . . , ym ),
such that each atomic formula of Œ± is of the form u = u or u = u, or else it
contains some occurrence of a variable xi . Furthermore, the restrictor of each xi is
some xj with j < i.
It remains to pull out the other restricted quantiÔ¨Åers from Œ± . But this can easily
be done using the equivalences of (3.20), since we do not have to worry anymore
about the order in which we pull out the quantiÔ¨Åers. In the end, we arrive at a
formula of the form
‚àÄr x1 . . . ‚àÄr xn Qr1 y1 . . . Qrm ym Œ± (x0 , . . . , xn , y1 , . . . , ym )
such that the atomic subformulas of Œ± satisfy the same condition of those in Œ±
(in fact, they are the very same formulas), while in addition, Œ± is quantiÔ¨Åer free.
Hence, if we rewrite Œ± into disjunctive normal form, we are Ô¨Ånished.
Enter diamonds and boxes. A type 2 formula is a formula in the second-order frame
language of the form
‚éõ
‚éû

Àú 0 . . . ‚àÄP
Àú 0 . . . ‚àÄQ
Àú n ‚àÄQ
Àú n ‚àÄ r x1 . . . ‚àÄ r xn ‚éù
‚àÄP
ST xi (œÉi ) ‚Üí Œ≤ ‚é†
0‚â§i‚â§n
such that each œÉi is a conjunction of boxed atoms in pi and qi , whereas Œ≤ is a DNF
of formulas ST x (œà), with œà some modal formula which is positive in each pi , qj .
Claim 2 Every type 1 formula can be effectively rewritten into an equivalent type
2 formula.
Proof of Claim. Now the prominent role of the inherently universal formulas will
come out: they determine the proposition letters of the Sahlqvist formula and the3.7 More about Sahlqvist Formulas
173
‚ÄòBOX-AT‚Äô part of its antecedent. Consider the type 1 formula
‚àÄr x1 . . . ‚àÄr xn Qr1 y1 . . . Qrm ym Œ≤(x0 , . . . , xn , y1 , . . . , ym ).
We abbreviate the sequence ‚àÄr x1 . . . ‚àÄr xn by ‚àÄr xÃÑ, and use similar abbreviations for
other sequences of quantiÔ¨Åers. Recall that Œ≤ is a DNF of formulas u = u, u = u,
u = xi , Ruxi and Rxi u. Our Ô¨Årst move is to replace such subformulas with the
formulas ST u (), ST u (‚ä•), ST u (pi ), ST u (3pi ) and ST u (qi ), respectively; call
the resulting formula Œ≤ .
Our Ô¨Årst claim is that
‚àÄr xÃÑ Qr »≥ Œ≤ is equivalent to
‚éû
‚éõ

ÀúPÃÑ QÃÑ ‚àÄr xÃÑ ‚éù
‚àÄ
ST xi (pi ‚àß 2qi ) ‚Üí Qr »≥ Œ≤  ‚é† .
(3.21)
0‚â§i‚â§n
Forbidding as (3.21) may look, its proof is completely analogous to proofs in Sec-
tions 3.5 and 3.6: the direction from right to left is immediate by instantiation,
while the other direction simply follows from the fact that Œ≤ is monotone in each
predicate symbol Pi and Qi .
Two remarks are in order here. First, since Œ≤ may contain atomic formulas of the
form Rxi xj and xi = xj (that is, with both variables being inherently universal),
there is some choice here. For instance, the formula Rxi xj may be replaced with
either ST xi (3pj ) or with ST xj (qj ). Having this choice can sometimes be of use if
one wants to Ô¨Ånd Sahlqvist correspondents satisfying some additional constraints.
Related to this is our second remark: we do not need to introduce both proposi-
tion letters pi and qi for each xi . We can do with any supply of proposition letters
that is sufÔ¨Åcient to replace all atomic formulas of Œ≤ with the standard translation of
either ST u (pi ), ST u (3pi ) or ST u (qi ). A glance at the examples below will make
this point clear.
We are now halfway through the proof of Claim 2: observe that Œ≤ is already a
DNF of formulas ST u (œà) with œà positive in each pi , qj . It remains to eliminate
the quantiÔ¨Åer sequence Qr »≥. This will be done step by step, using the following
procedure:
Consider the formula
‚éõ
‚éû

(‚àÉyi+1 z) ‚éù
ST ukl (œàkl )‚é† ,
(3.22)
k‚â§K l‚â§Lk
where each modal formula œàkl is positive in all variables pi , qj ; z is either an x or
a yj with j ‚â§ i; and each u is either an x or a yj with j ‚â§ i + 1. We Ô¨Årst distribute3 Frames
174
the existential quantiÔ¨Åer over the disjunction, yielding a disjunction of formulas

(‚àÉyi+1 z)
ST ukl (œàkl ).
(3.23)
l‚â§Lk
We may assume all these variables u to be distinct (otherwise, replace STu (œà  ) ‚àß
ST u (œà  ) with ST u (œà  ‚àß œà  )); we may also assume that yi+1 is the variable ulLk
(if yi+1 does not occur among the us, add a conjunct STyi+1 ()). But then (3.23)
is equivalent to the formula

ST z (3œàkLk ) ‚àß
ST ukl (œàkl ),
l<Lk
whence (3.22) is equivalent to a disjunction of such formulas. Observe further that
yi+1 does not occur in these formulas.
This shows how to get rid of an existential innermost restricted quantiÔ¨Åer of the
prenex K r »≥. A universal innermost restricted quantiÔ¨Åer can be removed dually, by
Ô¨Årst converting the matrix Œ≤ into a conjunctive normal form; details are left to the
reader. In any case, it will be clear that by this procedure we can rewrite any type
1 formula into an equivalent type 2 formula.
We are now almost through with the proof of Theorem 3.59. All we have to do
now is show how to massage arbitrary type 2 formulas into Sahlqvist shape.
Claim 3 Any type 2 formula can be effectively rewritten into an equivalent Sahl-
qvist formula.
Proof of Claim. Let
‚éõ
ÀúPÃÑ QÃÑ ‚àÄr xÃÑ ‚éù
‚àÄ

‚éû
ST xi (œÉi ) ‚Üí Œ≤ ‚é†
(3.24)
0‚â§i‚â§n
be an arbitrary type 2 formula.
First we rewrite Œ≤ into conjunctive normal form, and we distribute the implica-
tion and the prenex of universal quantiÔ¨Åers over the conjunctions. Thus we obtain
a conjunction of formulas of the form
‚éû
‚éõ

ÀúPÃÑ QÃÑ‚àÄr xÃÑ ‚éù
‚àÄ
(3.25)
ST xi (œÉi ) ‚Üí Œ≤  ‚é† ,
0‚â§i‚â§n
where Œ≤  is a disjunction of formulas of the form STx (œà) with each œà positive in
all pi and qj . As before, we may assume that each xi occurs in exactly one disjunct3.7 More about Sahlqvist Formulas
of Œ≤  , so (3.25) is equivalent to a formula
‚éõ

ÀúPÃÑ QÃÑ ‚àÄr xÃÑ ‚éù
‚àÄ
ST xi (œÉi ) ‚Üí
0‚â§i‚â§n
175
‚éû
ST xi (œài )‚é† ,
0‚â§i‚â§n
where each œÉi is a Sahlqvist antecedent and each œài is positive. But clearly then,
(3.25) is equivalent to the formula

ÀúPÃÑ QÃÑ¬¨‚àÉr xÃÑ
‚àÄ
ST xi (œÉi ‚àß ¬¨œài ).
0‚â§i‚â§n
Observe that each modal formula œÉi ‚àß ¬¨œài is a Sahlqvist antecedent.
But now, as before, working inside out we may eliminate all remaining restricted
quantiÔ¨Åers, step by step. For, observe that the formula

‚àÉr x1 . . . ‚àÉr xk‚àí1 (‚àÉxk xj )
ST xi (œái )
0‚â§i‚â§k
is equivalent to
‚éõ
‚àÉr x1 . . . ‚àÉr xk‚àí1 ‚éùST xj (œáj ‚àß 3œák ) ‚àß

‚éû
ST xi (œái )‚é† .
0‚â§i<k,i=j
Note that œáj ‚àß 3œák+1 is a Sahlqvist antecedent if œáj and œák+1 are.
It turns out that for some Sahlqvist antecedent œÜ, (3.25) is equivalent to the
second-order formula
ÀúPÃÑ QÃÑ ¬¨ST x (œÜ).
‚àÄ
0
But then (3.24) is equivalent to a conjunction of such formulas, and thus equivalent
to a formula


ÀúPÃÑ QÃÑ ST x
‚àÄ
0
œÜl ‚Üí ‚ä• ,
l
which is the local second-order frame correspondent of the formula
which is obviously in Sahlqvist form.

l œÜl ‚Üí ‚ä•,
This completes the proof of the third claim, and hence of the theorem.
Example 3.60 Consider the formula
Œ±(x0 ) ‚â° (‚àÄx1 x0 )(‚àÉy1 x0 )(‚àÉy2 y1 ) Rx1 y2 .
This is already a type 1 Kracht formula, so we proceed by the procedure described
in the proof of Claim 2 in the proof of Theorem 3.59. According to (3.21), Œ±(x0 )
is equivalent to the second order formula
Àú 1 (‚àÄx1 x0 ) (ST x (2q1 ) ‚Üí (‚àÉy1 x0 )(‚àÉy2 y1 )ST y (q1 )).
‚àÄQ
1
23 Frames
176
Then, using the equivalences described further on in the proof of Claim 2 we obtain
the following sequences of formulas that are equivalent to Œ±(x0 ):
Àú 1 (‚àÄx1 x0 ) (ST x (2q1 ) ‚Üí (‚àÉy1 x0 )(‚àÉy2 y1 )ST y (q1 ))
‚àÄQ
1
2
Àú 1 (‚àÄx1 x0 ) (ST x (2q1 ) ‚Üí (‚àÉy1 x0 )ST y (3q1 ))
‚áî ‚àÄQ
1
1
Àú 1 (‚àÄx1 x0 ) (ST x (2q1 ) ‚Üí ST x (33q1 )).
‚áî ‚àÄQ
1
0
The last formula is a type 2 formula. Hence, the only thing left to do is to rewrite
it to an equivalent Sahlqvist formula; this we do via the sequence of equivalent
formulas below, following the pattern of the proof of Claim 3:
Àú 1 ( (‚àÄx1 x0 ) (ST x (2q1 ) ‚Üí ST x (33q1 )) )
‚àÄQ
1
0
Àú
‚áî ‚àÄQ1 ( (‚àÄx1 x0 ) ¬¨(ST x (2q1 ) ‚àß ¬¨ST x (33q1 )) )
1
0
Àú 1 ( (‚àÄx1 x0 ) ¬¨(ST x (2q1 ) ‚àß ST x (¬¨33q1 )) )
‚áî ‚àÄQ
1
0
Àú
‚áî ‚àÄQ1 ( ¬¨(‚àÉx1 x0 ) (ST x1 (2q1 ) ‚àß ST x0 (¬¨33q1 )) )
Àú 1 ( ¬¨((‚àÉx1 x0 )ST x (2q1 ) ‚àß ST x (¬¨33q1 )) )
‚áî ‚àÄQ
1
0
Àú 1 ( ¬¨(ST x (32q1 ) ‚àß ST x (¬¨33q1 )) )
‚áî ‚àÄQ
0
0
Àú
‚áî ‚àÄQ1 ( ¬¨ST x (32q1 ‚àß ¬¨33q1 ) )
0
Àú 1 ( ST x ((32q1 ‚àß ¬¨33q1 ) ‚Üí ‚ä•) ).
‚áî ‚àÄQ
0
This means that Œ±(x0 ) locally corresponds to the Sahlqvist formula (32q1 ‚àß
¬¨33q1 ) ‚Üí ‚ä•, or to the equivalent formula 32q1 ‚Üí 33q1 .
Example 3.61 Consider the Kracht formula
Œ±(x0 ) ‚â° (‚àÄx1 x0 )(‚àÄx2 x0 ) (Rx1 x2 ‚à® Rx2 x1 ‚à® x1 = x2 ).
According to (3.21), Œ±(x0 ) is equivalent to
Àú 1 ‚àÄQ
Àú 1 (‚àÄx1 x0 )(‚àÄx2 x0 ) (ST x (p1 ‚àß 2q1 )
‚àÄP
1
‚Üí (ST x2 (q1 ) ‚à® ST x2 (3p1 ) ‚à® ST x2 (p1 )))
and to
Àú 1 ‚àÄQ
Àú 1 (‚àÄx1 x0 )(‚àÄx2 x0 ) (ST x (p1 ‚àß 2q1 ) ‚Üí ST x (q1 ‚à® 3p1 ‚à® p1 )).
‚àÄP
1
2
The latter is a type 2 formula; in order to Ô¨Ånd a Sahlqvist equivalent for it, we
proceed as follows:
Àú 1 ‚àÄQ
Àú 1 (‚àÄx1 x0 )(‚àÄx2 x0 ) (ST x (p1 ‚àß 2q1 ) ‚Üí ST x (q1 ‚à® 3p1 ‚à® p1 ))
‚àÄP
1
2
Àú
Àú
‚áî ‚àÄP1 ‚àÄQ1 (‚àÄx1 x0 )(‚àÄx2 x0 ) ¬¨(ST x (p1 ‚àß 2q1 ) ‚àß
1
¬¨ST x2 (q1 ‚à® 3p1 ‚à® p1 ))
Àú 1 ‚àÄQ
Àú 1 (‚àÄx1 x0 )(‚àÄx2 x0 ) ¬¨(ST x (p1 ‚àß 2q1 ) ‚àß
‚áî ‚àÄP
13.7 More about Sahlqvist Formulas
177
ST x2 (¬¨(q1 ‚à® 3p1 ‚à® p1 )))
Àú 1 ‚àÄQ
Àú 1 ¬¨(‚àÉx1 x0 )(‚àÉx2 x0 ) (ST x (p1 ‚àß 2q1 ) ‚àß
‚áî ‚àÄP
1
ST x2 (¬¨(q1 ‚à® 3p1 ‚à® p1 )))
Àú
Àú
‚áî ‚àÄP1 ‚àÄQ1 ¬¨(‚àÉx1 x0 ) (ST x1 (p1 ‚àß 2q1 ) ‚àß
(‚àÉx2 x0 )ST x2 (¬¨(q1 ‚à® 3p1 ‚à® p1 )))
Àú 1 ‚àÄQ
Àú 1 ¬¨(‚àÉx1 x0 ) (ST x (p1 ‚àß 2q1 ) ‚àß ST x (3¬¨(q1 ‚à® 3p1 ‚à® p1 )))
‚áî ‚àÄP
1
0
Àú
Àú
‚áî ‚àÄP1 ‚àÄQ1 ¬¨((‚àÉx1 x0 )ST x (p1 ‚àß 2q1 ) ‚àß ST x (3¬¨(q1 ‚à® 3p1 ‚à® p1 )))
1
0
Àú 1 ‚àÄQ
Àú 1 ¬¨(ST x (3(p1 ‚àß 2q1 )) ‚àß ST x (3¬¨(q1 ‚à® 3p1 ‚à® p1 )))
‚áî ‚àÄP
0
0
Àú 1 ‚àÄQ
Àú 1 ¬¨(ST x (3(p1 ‚àß 2q1 ) ‚àß 3¬¨(q1 ‚à® 3p1 ‚à® p1 ))).
‚áî ‚àÄP
0
From this, the fastest way to proceed is by observing that the last formula is equiv-
alent to
Àú 1 ‚àÄQ
Àú 1 (ST x (3(p1 ‚àß 2q1 ) ‚Üí ¬¨3¬¨(q1 ‚à® 3p1 ‚à® p1 ))),
‚àÄP
0
and hence, to the Sahlqvist formula
3(p1 ‚àß 2q1 ) ‚Üí 2(q1 ‚à® 3p1 ‚à® p1 ).
Example 3.62 Consider the type 1 Kracht formula
Œ±(x0 ) ‚â° (‚àÄx1 x0 )(‚àÉy1 x1 ) y1 = y1 .
According to (3.21), we can rewrite Œ±(x0 ) into the equivalent
Àú 0 (‚àÄx1 x0 ) (ST x (p0 ) ‚Üí (‚àÉy1 x1 )ST y (‚ä•))
‚àÄP
0
1
and, hence, to
Àú 0 (‚àÄx1 x0 ) (ST x (p0 ) ‚Üí ST x (3‚ä•)).
‚àÄP
0
1
This is a type 2 formula for which we can Ô¨Ånd a Sahlqvist equivalent as follows:
Àú 0 (‚àÄx1 x0 ) (ST x (p0 ) ‚Üí ST x (3‚ä•))
‚àÄP
0
1
Àú
‚áî ‚àÄP0 (‚àÄx1 x0 ) ¬¨(ST x (p0 ) ‚àß ¬¨ST x (3‚ä•))
0
1
Àú 0 ¬¨(‚àÉx1 x0 ) (ST x (p0 ) ‚àß ST x (¬¨3‚ä•))
‚áî ‚àÄP
0
1
Àú 0 ¬¨ (ST x (p0 ) ‚àß (‚àÉx1 x0 )ST x (¬¨3‚ä•))
‚áî ‚àÄP
0
1
Àú 0 ¬¨ (ST x (p0 ) ‚àß ST x (3¬¨3‚ä•))
‚áî ‚àÄP
0
0
Àú 0 (ST x (¬¨(p0 ‚àß 3¬¨3‚ä•)).
‚áî ‚àÄP
0
The latter formula is equivalent to the Sahlqvist formula p0 ‚Üí 23‚ä•. (Obviously,
the latter formula is equivalent to 23‚ä• and, hence, to 2‚ä•. Our algorithm will not
always provide the simplest correspondents!)3 Frames
178
This Ô¨Ånishes our discussion of Sahlqvist correspondence. In the next chapter we
will see that Sahlqvist formulas also have very nice completeness properties, in
that any modal logic axiomatized by Sahlqvist formulas is complete with respect
to the class of frames deÔ¨Åned by (the global Ô¨Årst-order correspondents of) the for-
mulas. Here Kracht‚Äôs Theorem can be useful: if we want to axiomatize a class of
frames deÔ¨Åned by formulas of the form ‚àÄx Œ±(x) with Œ±(x) a Kracht formula, then
it sufÔ¨Åces to compute the Sahlqvist correspondents of these formulas and add these
as axioms to the basic modal logic.
Exercises for Section 3.7
(a) Prove that the conjunction M ‚àß 4 of McKinsey‚Äôs formula 23p ‚Üí 32p and
the transitivity formula 3p ‚Üí 33p does not have a local Ô¨Årst-order correspondent.
Conclude that this conjunction is not equivalent to a Sahlqvist formula.
(b) Show that on the other hand, the formula 2M ‚àß 4 does have a local Ô¨Årst-order
correspondent.
3.7.1
3.7.2 Prove that the local correspondent of a Sahlqvist formula is a Kracht formula.
3.7.3 Find Sahlqvist formulas that locally correspond to the following formulas:
(a) (‚àÄyx) Ryy,
(b) (‚àÄy1 x)(‚àÄy2 x)(‚àÄy3 x) (y1 = y2 ‚à® y1 = y3 ‚à® y2 = y3 ),
(c) (‚àÄy1 x)(‚àÄy2 y1 ) (y1 = y2 ‚à® ‚àÉz (Rxz ‚à® (Ry1 z ‚àß Ry2 z))),
(d) (‚àÄx1 x)(‚àÉy1 x)(‚àÄy2 y1 ) (Ry1 x1 ‚à® (Rxy2 ‚àß Ry2 x1 )).
3.7.4 Prove that if œÜ ‚Üí œà is a simple Sahlqvist formula, then 2(œÜ ‚Üí œà) is equivalent to
a simple Sahlqvist formula.
3.7.5 Consdier the basic temporal similarity type. Show that over the class of bidirectional
frames, every simple Sahlqvist formula is equivalent to a very simple Sahlqvist formula.
(Hint: Ô¨Årst Ô¨Ånd a very simple Sahlqvist formula that is equivalent to the formula F Gp ‚Üí
GF p.)
3.8 Advanced Frame Theory
The main aim of this section is to prove Theorem 3.19, the Goldblatt-Thomason
Theorem, characterizing the elementary frame classes that are modally deÔ¨Ånable.
We will also prove a rather technical result needed in our later work on algebras.
We will start by proving the Goldblatt-Thomason Theorem.
Theorem 3.19 Let œÑ be a modal similarity type. A Ô¨Årst-order deÔ¨Ånable class K of œÑ -
frames is modally deÔ¨Ånable if and only if it is closed under taking bounded morphic
images, generated subframes, disjoint unions and reÔ¨Çects ultraÔ¨Ålter extensions.3.8 Advanced Frame Theory
179
Proof. The preservation direction follows from earlier results. For the other di-
rection let K be a class of frames which is elementary (hence, closed under taking
ultraproducts), closed under taking bounded morphic images, generated subframes
and disjoint unions, and reÔ¨Çecting ultraÔ¨Ålter extensions. Let ŒõK be the logic of K;
that is, ŒõK = {œÜ | F  œÜ, for all F ‚àà K}. We will show that ŒõK deÔ¨Ånes K. In order
to avoid cumbersome notation we restrict ourselves to the basic modal similarity
type.
Let F = (W, R) be a frame such that F  ŒõK . We need to show that F is a
member of K. This we will do by moving around lots of structures; here is a map
of where we are heading for in the proof:
{Fa | a ‚àà W }
ue F
1FF
G
HH
5
HH
6
HH
{GŒ¥ | Œ¥ ‚äÜf in Œî}
aa
4
G
aa3
2
aa
a
a

U GŒ¥
First, we can assume without loss of generality that F is point-generated. For if F
validates ŒõK , then each of its point-generated subframes does so as well. And if we
can prove that each point-generated subframe of F is in K, then the membership in
K of F itself follows immediately from the closure properties of K and the fact that
any frame is a bounded morphic image of the disjoint union of its point-generated
subframes (as the reader was asked to show in Exercise 3.3.4). So from now on we
assume that F is generated by the point w.
Now for (one of) the main idea(s) of the proof. Let Œ¶ be a set of proposition
letters containing a proposition letter pA for each subset A of W . This may be a
huge language: if W is inÔ¨Ånite, then Œ¶ will be uncountable. We will look at the
model M = (F, V ) where V is the natural valuation given by V (pA ) = A. Now
let Œî be the modal type of w; that is, Œî = {œÜ ‚àà ML(œÑ, Œ¶) | M, w  œÜ}. We claim
that
Œî is satisÔ¨Åable in K.
(3.26)
In order to prove this, we Ô¨Årst show that Œî is Ô¨Ånitely satisÔ¨Åable in K. Let Œ¥ be a
Ô¨Ånite subset of Œî. It is easy to see that Œ¥ is satisÔ¨Åable in K: if it were not, then


¬¨ Œ¥ would belong to ŒõK whence we would have F  ¬¨ Œ¥. (Note that whereas
Œî is written in a particular language, namely, the one having a proposition letter
for each subset of W , when we are talking about ŒõK we are not really interested

in a speciÔ¨Åc language. This is why we simply assume that ‚Äò¬¨ Œ¥ would belong
to ŒõK ‚Äô even though we have not veriÔ¨Åed that this formula uses only proposition


letters that occur in ŒõK .) But F  ¬¨ Œ¥ would contradict that M, w  Œ¥. Thus
each Ô¨Ånite Œ¥ ‚äÇ Œî is Ô¨Ånitely satisÔ¨Åable in some frame GŒ¥ in K, so Œî is satisÔ¨Åable
in some ultraproduct of these frames (the reader is asked to supply a proof of this3 Frames
180
in Exercise 3.8.2 below). Since K is closed under ultraproducts by assumption, this
proves (3.26).
But to say that Œî is satisÔ¨Åable in K amounts to the following. There is a model
N = (X, S, U ) and a point b in X such that the underlying frame G = (X, S)
is in K and N, b  Œî. Since K is closed under (point-)generated subframes and
modal truth is preserved under taking generated subframes, we may assume that
the frame G is generated from b.
The only thing left to do is to link up G with our original frame F. This link is
as follows:
ue F is a bounded morphic image of some ultrapower of G.
(3.27)
We Ô¨Årst ensure the existence of an m-saturated ultrapower of N. Note that we may
view N as a Ô¨Årst-order structure for the language L1œÑ (Œ¶), analogous to the per-
spective in the previous chapter. Now consider a countably saturated ultrapower of
this Ô¨Årst-order structure, which we see again as a modal model N = (X  , S  , U  ).
Note that the existence of such an ultrapower is not guaranteed by Lemma 2.73,
since the Ô¨Årst-order language L1œÑ,F may not be countable. We need some heavier
model-theoretic equipment here; the reader is referred to Theorems 6.1.4 and 6.1.8
in [91]. In any case, N is m-saturated and also has the property that every set Œ£
that is Ô¨Ånitely satisÔ¨Åable in N is satisÔ¨Åable in N .
How are we going to deÔ¨Åne the bounded morphism? That is, given an element s
of X  , which ultraÔ¨Ålter over W (the universe of our original frame F) are we going
to assign to it? Recall that an ultraÔ¨Ålter over W is some collection of subsets of
W ; this means that given s, we have to decide for each subset of W whether to put
it in f (s) or not. But now it will become clear that there is only one natural choice
for f (s): simply put a subset A of W in f (s) if pA is true at s in the model N :
f (s) = {A ‚äÜ W | N , s  pA }.
We will now show that f indeed maps points in N to ultraÔ¨Ålters over W , that f
is a bounded morphism, and that f is onto ue F. In these proofs, the following
equivalence comes in handy:
for all formulas œÜ ‚àà ML(œÑ, Œ¶), M  œÜ iff N  œÜ.
(3.28)
The proof of (3.28) is by the following chain of equivalences:
MœÜ
‚áî
‚áî
‚áî
‚áî
‚áî
This proves (3.28).
M, w  2n œÜ for all n ‚àà N
2n œÜ ‚àà Œî for all n ‚àà N
N, b  2n œÜ for all n ‚àà N
NœÜ
N  œÜ
(M is generated from w)
(deÔ¨Ånition of Œî)
(deÔ¨Ånition of N and b)
(N is generated from b)
(N is an ultrapower of N).3.8 Advanced Frame Theory
181
Let us now Ô¨Årst check that for all s ‚àà X , f (s) is indeed an ultraÔ¨Ålter over W .
We will only check the condition that f (s) is closed under intersection, leaving the
other conditions as exercises for the reader. Suppose that A and B are subsets of W
that both belong to f (s). Hence, by the deÔ¨Ånition of f (s) we have that N , s  pA
and N , s  pB . It is easy to see that the formula pA ‚àßpB ‚Üî pA‚à©B holds throughout
the original model M. It then follows from (3.28) that N  pA ‚àß pB ‚Üî pA‚à©B . In
particular, this formula is true at s, so we Ô¨Ånd that N , s  pA‚à©B . Hence, by the
deÔ¨Ånition of f , A ‚à© B belongs to f (s).
In order to show that f is a bounded morphism, we will prove that for all ultra-
Ô¨Ålters u over W and all points s in X , we have that u = f (s) if and only if u (in
ue M) and s (in N ) satisfy the same formulas. This sufÔ¨Åces, by Proposition 2.54
and the m-saturation of ue M and N . The right to left direction of the equivalence
is easy to prove. If the same formulas hold in s and u, then in particular we have for
each A ‚äÜ W that N , s  pA iff ue M, u  pA . But by deÔ¨Ånition of the valuation
on ue M we have that ue M, u  pA iff A = V (pA ) ‚àà u. Hence, we Ô¨Ånd that
N , s  pA iff A ‚àà u. This immediately yields u = f (s).
For the other direction, it sufÔ¨Åces to show that for each formula œÜ ‚àà ML(œÑ, Œ¶)
and each point s in N , ue M, f (s)  œÜ only if N , s  œÜ. Suppose that œÜ holds at
f (s) in ue M. By Proposition 2.59 we have that V (œÜ) ‚àà f (s). Thus by deÔ¨Ånition
of f we obtain that N , s  pV (œÜ) . It follows easily from the deÔ¨Ånition of V that
M  œÜ ‚Üî pV (œÜ) , so by (3.28) we have that N  œÜ ‚Üî pV (œÜ) . But then we may
immediately infer that N , s  œÜ.
Finally, we have to show that f is surjective; that is, each ultraÔ¨Ålter over W
should belong to its range. Let u be such an ultraÔ¨Ålter; we claim that the set Œ£ =
{pA | A ‚àà u} is Ô¨Ånitely satisÔ¨Åable in N . Let œÉ be a Ô¨Ånite subset of Œ£. To
start with, œÉ is satisÔ¨Åable in M. Since M is generated from w, this shows that

M, w  3n œÉ for some natural number n. From the deÔ¨Ånition of N and b it

follows that N, b  3n œÉ, so from the fact that N is point-generated from b we

obtain that œÉ is satisÔ¨Åable in N. Now N is an ultrapower of N, so we have that

œÉ is also satisÔ¨Åable in N . But N is countably saturated; so Œ£, being Ô¨Ånitely
satisÔ¨Åable in N , is satisÔ¨Åable in some point s of N . It is then immediate that
f (s) = u.
This proves (3.27), but why does that mean that F belongs to K? Here we use the
closure properties of K. Recall that G is the underlying frame of the model N in
which we assumed that the set Œî is satisÔ¨Åable. Since G is in K by assumption, G
belongs to K by closure under ultraproducts; ue F is in K as it is a bounded morphic
image of G ; and Ô¨Ånally, F is in K since K reÔ¨Çects ultraÔ¨Ålter extensions.
The following proposition, which is of a rather technical nature, will be put to good
use in Chapter 5.182
3 Frames
Proposition 3.63 Let œÑ be a modal similarity type, and K a class of œÑ -frames.
Suppose that G is an ultrapower of the disjoint union i‚ààI Fi , where {Fi | i ‚àà I}
is a family of frames in K. Then G is a bounded morphic image of a disjoint union
of ultraproducts of frames in K.
Proof. Let F = (W, R) denote the disjoint union i‚ààI Fi , and assume that G is

some ultrapower of F, say G = U F, where U is an ultraÔ¨Ålter over some index
set J. We assume that œÑ contains only one operator , of arity n. This allows us
to write F = (W, R) and Fi = (Wi , Ri ) (that is, the subscript i refers to an index
element of I, not to an operator from the similarity type).
Consider an arbitrary state t of G. By the deÔ¨Ånition of ultrapowers, there exists

a sequence ft ‚àà j‚ààJ W such that

t = (ft )U = {g ‚àà j‚ààJ W | ft ‚àºU g}.
As W is the disjoint union of the universes Wi , for each j ‚àà J there exists an
element ij ‚àà I such that ft (j) is an element of Wij . Form the ultraproduct

Ft := U Fij .
Clearly this frame is an ultraproduct of frames in K.
We will now deÔ¨Åne a map Œ∏t sending states of the frame Ft to states of the frame
G, and show that Œ∏t is a bounded morphism with t in its range. From this it easily
follows that G is a bounded morphic image of the disjoint union t‚ààX Ft , where
X is the universe of G. Observe that a typical element of Ft has the form

gU := {h ‚àà j‚ààJ Wij | g ‚àºU h}



for some g ‚àà j‚ààJ Wij . Since j‚ààJ Wij ‚äÜ j‚ààJ W , we have that gU ‚äÜ gU .
Note that in general these two equivalence classes will not be identical, since gU
may contain elements h for which h(j ) ‚àà W \ Wij for some index j . However,

it is evident that if both g and h are in j‚ààJ Wij , then we Ô¨Ånd that gU = hU iff
g ‚àºU h iff gU = hU . This means that if we put
Œ∏t (gU ) := gU ,
we have found a well-deÔ¨Åned map from the universe of Ft to the universe X of G
(in fact, this map is injective).

Now consider the element ft ‚àà j‚ààJ W . By deÔ¨Ånition of the indices ij , we

must have ft ‚àà j‚ààJ Wij . It follows that ftU is in the domain of Œ∏t . Now
Œ∏t (ftU ) = (ft )U = t.
It remains to be proved that Œ∏t is a bounded morphism. However, this follows by a
straightforward argument using standard properties of ultraÔ¨Ålters.3.9 Summary of Chapter 3
183
Exercises for Section 3.8
3.8.1 Let œÑ be an arbitrary modal similarity type and F a œÑ -frame. Prove that the ultraÔ¨Ålter
extension of F is the bounded morphic image of some œâ-saturated ultrapower of F; in other
words, supply a proof for Theorem 3.17. (Hint: use an argument analogous to one in the
proof of Theorem 3.19. That is, consider a language having a proposition letter p A for
each subset A of the universe of F, and take a countably saturated ultrapower of the model
M = (F, V ), where V is the natural valuation mapping p A to A for each variable p A .)
3.8.2 Let K be some class of frames, and Œî a set of formulas which is Ô¨Ånitely satisÔ¨Åable
in K. Show that Œî is satisÔ¨Åable in an ultraproduct of frames in K.
(a) Show that the complement of a modally deÔ¨Ånable class is closed under taking
ultrapowers.
Now suppose that the class K of frames is deÔ¨Ånable by a single formula œÜ.
3.8.3
(b) Show that the complement of K is closed under taking ultraproducts. (Hint: let
Œì (œÜ) be the set of Ô¨Årst-order sentences that are semantic consequences of œÜ, in the
sense that for any frame F we have that F  œÜ only if F |= Œì (œÜ). In other words,
Œì (œÜ) is the Ô¨Årst-order theory of K.)
(c) Prove that œÜ is a semantic consequence of Œì (œÜ). (Hint: reason by contraposition
and use (b).)
(d) Prove that œÜ is a semantic consequence of a Ô¨Ånite subset of Œì (œÜ). (Hint: prove that
Œì (œÜ) |= ‚àÄx ST x (œÜ), and use compactness.)
(e) Conclude that if a modal formula œÜ deÔ¨Ånes an elementary frame class, then œÜ cor-
responds to a (single) Ô¨Årst-order formula.
3.8.4 Prove the strong version of the Goldblatt-Thomason Theorem which applies to any
frame class that is closed under taking ultrapowers. (Hint: strengthen the result of Exer-
cise 3.8.2 by showing that any set of modal formulas that is Ô¨Ånitely satisÔ¨Åable in a frame
class K is itself satisÔ¨Åable in an ultrapower of a disjoint union of frames in K.)
3.8.5 Point out where, in the picture summarizing the proof of Theorem 3.19, we use
which closure conditions on K. (For instance: in step 2 we need the fact that K is closed
under taking ultraproducts.)
3.9 Summary of Chapter 3
 Frame DeÔ¨Ånability: A modal formula is valid on a frame if and only if it is
satisÔ¨Åed at every point in the frame, no matter which valuation is used. A modal
formula deÔ¨Ånes a class of frames if and only if it is valid on precisely the frames
in that class.
 Frame DeÔ¨Ånability is Second-Order: Because the deÔ¨Ånition of validity quan-
tiÔ¨Åes across all possible valuations, and because valuations are assignments of
subsets of frames, the concept of validity, and hence frame deÔ¨Ånability, is in-
trinsically second-order.
 Frame Languages: Every modal formula can be translated into the appropri-
ate second-order frame language. Such languages have an (n + 1)-place rela-
tion symbol for every n-place modality. Proposition letters correspond to unary184
3 Frames
predicate variables. The required translation is called the second-order transla-
tion. This is simply the standard translation modiÔ¨Åed to send proposition letters
to (unary) predicate variables rather than predicate constants.
 Correspondence: Sometimes the second-order formulas obtained using this
translation are equivalent to Ô¨Årst-order formulas. But often they correspond to
genuinely second-order formulas. This can sometimes be shown by exhibiting
a failure of Compactness or the L√∂wenhein-Skolem property.
 Frame Constructions: The four fundamental model constructions discussed in
the previous chapter have obvious frame-theoretic counterparts. Moreover, va-
lidity is preserved under the formation of disjoint unions, generated subframes
and bounded morphic images, and anti-preserved under ultraÔ¨Ålter extensions.
 Goldblatt-Thomason Theorem: A Ô¨Årst-order deÔ¨Ånable frame class is modally
deÔ¨Ånable if and only if it is closed under disjoint unions, generated subframes
and bounded morphic images, and reÔ¨Çects ultraÔ¨Ålter extensions.
 Modal DeÔ¨Ånability on Finite Transitive Frames: A class of Ô¨Ånite transitive
frames is modally deÔ¨Ånable if and only if it is preserved under (Ô¨Ånite) disjoint
unions, generated subframes and bounded morphic images.
 The Finite Frame Property: A normal modal logic Œõ has the Ô¨Ånite frame prop-
erty if and only if any formula that does not belong to Œõ can be falsiÔ¨Åed on a
Ô¨Ånite frame that validates all the formulas in Œõ. A normal logic has the Ô¨Ånite
frame property if and only if it has the Ô¨Ånite model property.
 The Sahlqvist Fragment: Formulas in the Sahlqvist fragment have the property
that the second-order formula obtained via the second-order translation can be
reduced to an equivalent Ô¨Årst-order formula. The Sahlqvist-van Benthem algo-
rithm is an effective procedure for carrying out such reductions.
 Why Sahlqvist Formulas have First-Order Correspondents: Syntactically, the
Sahlqvist fragment forbids universal operators to take scope over existential or
disjunctive connectives in the antecedent. Semantically, this guarantees that we
will always be able to Ô¨Ånd a unique minimal valuation that makes the antecedent
true. This ensures that Sahlqvist formulas have Ô¨Årst-order correspondents.
 Negative Results: There are non-Sahlqvist formulas that deÔ¨Åne Ô¨Årst-order con-
ditions. Moreover, Chagrova‚Äôs Theorem tells us that it is undecidable whether a
modal formula has a Ô¨Årst-order equivalent.
 Kracht‚Äôs Theorem: Kracht‚Äôs Theorem takes us back from Ô¨Årst-order languages
to modal languages. It identiÔ¨Åes a class of Ô¨Årst-order formulas that are the Ô¨Årst-
order correspondents of Sahlqvist formulas.
 Frames and their UltraÔ¨Ålter Extensions: The ultraÔ¨Ålter extension of a frame
may be obtained as a bounded morphic image of an ultrapower of the frame.
 Ultrapowers of Disjoint Unions: Ultrapowers of a disjoint union may be ob-
tained as bounded morphic images of disjoint unions of ultraproducts.Notes to Chapter 3
185
Notes
The study of frames has been central to modal logic since the dawn of the classical
era (see the Historical Overview in Chapter 1), but the way frames have been stud-
ied has changed dramatically over this period. The insight that gave birth to the
classical era was that simple properties of frames (such as transitivity and reÔ¨Çex-
ivity) could be used to characterize normal modal logics, and most of the 1960s
were devoted to exploring this topic. It is certainly an important topic. For ex-
ample, in the Ô¨Årst half of the following chapter we will see that most commonly
encountered modal logics can be given simple, intuitively appealing, frame-based
characterizations. But the very success of this line of work meant that for a decade
modal logicians paid little attention to modal languages as tools for describing
frame structure. Frames were simply tools for analyzing normal logics. The notion
of frame deÔ¨Ånability, and the systematic study of modal expressivity over frames,
only emerged as a research theme after the frame incompleteness results showed
that not all normal logics could be given frame-based characterizations. The Ô¨Årst
incompleteness result (shown for the basic temporal language) was published in
1972 by S.K. Thomason [433]. The Ô¨Årst incompleteness results for the basic modal
language were published in 1974 by S.K. Thomason [434] and Kit Fine [129].
The frame incompleteness theorems and the results which accompanied them
decisively changed the research agenda of modal logic, essentially because they
made it clear that the modal perspective on frames was intrinsically second-order.
We have seen ample evidence for this in this chapter: as we saw in Example 3.11
a formula as innocuous looking as McKinsey‚Äôs 23p ‚Üí 32p deÔ¨Ånes a non-
elementary class of frames. This was proved independently by Goldblatt [183]
and van Benthem [35]. The proof given in the text is from Theorem 10.2 of van
Benthem [42]. It was shown by S.K. Thomason [436] that on the level of frames,
modal logic is expressive enough to capture the semantic consequence relation for
L2 . Moreover, in unpublished work, Doets showed that modal formulas can act as
a reduction class for the theory of Ô¨Ånite types; see van Benthem [42, pages 23‚Äì24]
for further discussion.
So by the mid 1970s it was clear that modal logic embodied a substantial frag-
ment of second-order logic, and a radically different research program was well
under way. One strand of this program was algebraic: these years saw the (re)-
emergence of algebraic semantics together with a belated appreciation of the work
of J√≥nsson and Tarski [255, 256]; this line of work is treated in Chapter 5. The
other strand was the emergence of correspondence theory.
Given that modal logic over frames is essentially second-order logic in disguise,
it may seem that the most obvious way to develop correspondence theory would be
to chart the second-order powers of modal logic. In fact, examples of modal for-
mulas that deÔ¨Åne second-order classes of frames were known by the early 1970s186
3 Frames
(for example, Johan van Benthem proved that the L√∂b formula deÔ¨Åned the class
of transitive and converse well-founded frames using the argument given in Exam-
ple 3.9). And there is interesting work on more general results on second-order
frame deÔ¨Ånability, much of which may be found in Chapters XVII‚ÄìXIX of van
Benthem [42]. Nonetheless, most work on correspondence theory for frames has
concentrated on its Ô¨Årst-order aspects. There are two main reasons for this. First,
second-order model theory is less well understood than Ô¨Årst-order model theory, so
investigations of second-order correspondences have fewer useful results to draw
on. Second, there is a clear sense that it is the Ô¨Årst-order aspects of frame deÔ¨Ån-
ability which are truly mysterious (this has long been emphasized by Johan van
Benthem). With the beneÔ¨Åt of hindsight, the second-order nature of validity is
obvious; understanding when ‚Äì and why ‚Äì it is sometimes Ô¨Årst-order is far harder.
In this chapter we examined the two main strands in Ô¨Årst-order correspondence
theory (for frames): the semantic, exempliÔ¨Åed by the Goldblatt-Thomason The-
orem, and the syntactic, exempliÔ¨Åed by the Sahlqvist Correspondence Theorem.
(Incidentally, as we will learn in Chapter 5, both results have a substantial alge-
braic dimension.)
What we call the Goldblatt-Thomason Theorem was actually proved by Gold-
blatt. His result was in fact stronger than our Theorem 3.19, applying to any frame
class that is closed under elementary equivalence. This theorem was published in
a joint paper [188] with S.K. Thomason, who added a more general result which
applies to all deÔ¨Ånable frame classes but has a less appealing frame construction.
The model-theoretic proof of the theorem that we supplied in this chapter is due
to van Benthem [46], who also proved the Ô¨Ånite transitive version we recorded as
Theorem 3.21. Barwise and Moss [28] obtain correspondence results for models
as opposed to frames; their main result is that if a modal formula œÜ has a Ô¨Årst-
order frame correspondent cœÜ , then for all models M, M satisÔ¨Åes all substitution
instances of œÜ in inÔ¨Ånitary modal logic iff a certain frame underlying M satisÔ¨Åes
cœÜ .
Concerning the identiÔ¨Åcation of syntactic classes of modal formulas that corre-
spond to Ô¨Årst-order formulas, Sahlqvist‚Äôs result was not the Ô¨Årst. As early as in the
J√≥nsson-Tarski papers [255, 256] particular examples such as reÔ¨Çexivity and transi-
tivity were known. And an article by Fitch [136] was a stimulus for van Benthem‚Äôs
investigations in this area, which lead to van Benthem (unaware of Sahlqvist‚Äôs ear-
lier work) proving what is now known as Sahlqvist‚Äôs Theorem. But Sahlqvist‚Äôs
paper [396] (essentially a presentation of results contained in his Masters thesis)
remains the classic reference in the area. It greatly generalized all previous known
results in the area and drew a beautiful link between deÔ¨Ånability and completeness.
Kracht isolated the Ô¨Årst-order formulas that are the correspondents of Sahlqvist
formulas in [276], as an application of his so-called calculus of internal describa-Notes to Chapter 3
187
bility. This calculus relates modal and Ô¨Årst-order formulas on the level of general
frames; see also [279].
During the 1990s a number of alternative correspondence languages have been
considered for the basic modal language. In the so-called functional translation the
accessibility relations are replaced by certain terms which can be seen as functions
mapping worlds to accessible worlds. From a certain point of view this functional
language is more expressive than the relational language, and certain second-order
frame properties can be mapped to formulas expressed in the functional language
‚Äì but this is not too surprising: in the functional language one can quantify over
functions; this additional expressive power allows one to do without quantiÔ¨Åca-
tion over unary predicate variables; see Ohlbach and Schmidt [346] and Ohlbach
et al. [344] and Simmons [414].
As with Ô¨Ånite model theory, the theory of Ô¨Ånite frames is rather underdeveloped.
However, some of the basic results have been known a long time. We showed in
Theorem 3.28 that a normal logic has the Ô¨Ånite model property if and only if it has
the Ô¨Ånite frame property. This result is due to Segerberg [404, Corollary 3.8, page
33]. For some interesting results concerning frame correspondence theory over the
class of Ô¨Ånite frames the reader should consult the dissertation of Doets [110].
To conclude these Notes, we will tidy up a few loose ends. Exercise 3.6.2 is
due to van Benthem [42, Theorem 10.4]. Exercise 3.2.4 is based on a result in
Fine [132]. Second, we mentioned Chagrova‚Äôs Theorem [89] that it is undecidable
whether a modal formula has a Ô¨Årst-order equivalent. For pointers to, and a brief
discussion of, extensions of this line of work, see Chagrov and Zakharyaschev [88,
Chapter 17]. At the end of Section 3.2 we remarked that general frames can be seen
as a model version of the generalized models or Henkin models for second-order
logic. Henkin [217] introduced such models, and good discussions of them can be
found in Doets and van Benthem [112] or Manzano [314]. Finally, for more on the
lambda calculus see Barendregt [24] or Hindley and Seldin [223].4
Completeness
This chapter is about the completeness ‚Äì and incompleteness ‚Äì of normal modal
logics. As we saw in Section 1.6, normal modal logics are collections of formulas
satisfying certain simple closure conditions. They can be speciÔ¨Åed either syntac-
tically or semantically, and this gives rise to the questions which dominate the
chapter: Given a semantically speciÔ¨Åed logic, can we give it a syntactic characteri-
zation, and if so, how? And: Given a syntactically speciÔ¨Åed logic, can we give it a
semantic characterization (and in particular, a characterization in terms of frames),
and if so, how? To answer either type of question we need to know how to prove
(soundness and) completeness theorems, and the bulk of the chapter is devoted to
developing techniques for doing so.
The chapter has two major parts. The Ô¨Årst, comprising the Ô¨Årst four sections,
is an introduction to basic completeness theory. It introduces canonical models,
explains and applies the completeness-via-canonicity proof technique, discusses
the Sahlqvist Completeness Theorem, and proves two fundamental limitative re-
sults. The material introduced in these sections (which are all on the basic track) is
needed to follow the second part and the algebraic investigations of Chapter 5.
In the second part of the chapter we turn to the following question: what are we
to do when canonicity fails? (As will become clear, canonicity failure is a fact of
life for temporal logic, propositional dynamic logic, and other applied modal lan-
guages.) This part of the chapter is technique oriented: it introduces Ô¨Åve important
ways of dealing with such difÔ¨Åculties.
Chapter guide
Section 4.1: Preliminaries (Basic track). This section introduces the fundamental
concepts: normal modal logics, soundness, and completeness.
Section 4.2: Canonical Models (Basic track). Canonical models are introduced,
and the fundamental Canonical Model Theorem is proved.
Section 4.3: Applications (Basic track). This section discusses the key concept of
1884.1 Preliminaries
189
canonicity, and uses completeness-via-canonicity arguments to put canoni-
cal models to work. We prove completeness results for a number of modal
and temporal logics, and Ô¨Ånish with a discussion of the Sahlqvist Com-
pleteness Theorem.
Section 4.4: Limitative Results (Basic track). We prove two fundamental limita-
tive results: not all normal logics are canonical, and not all normal logics
are characterized by some class of frames. This section concludes our in-
troduction to basic completeness theory.
Section 4.5: Transforming the Canonical Model (Basic track). Often we need to
build models with properties for which we lack a canonical formula. What
are we to do in such cases? This section introduces one approach: use
transformation methods to try and massage the ‚Äòfaulty‚Äô canonical model
into the required shape.
Section 4.6: Step by Step (Basic track). Sometimes we can cope with canonicity
failure using the step-by-step method. This is a technique for building
models with special properties inductively.
Section 4.7: Rules for the UndeÔ¨Ånable (Basic track). Special proof rules (that in
a certain sense manage to express undeÔ¨Ånable properties of models and
frames) sometimes allow us to construct special canonical models con-
taining submodels with undeÔ¨Ånable properties.
Section 4.8: Finitary Methods I (Basic track). We discuss a method for proving
weak completeness results for non-compact logics: Ô¨Ånite canonical mod-
els. We use such models to prove the completeness of propositional dy-
namic logic.
Section 4.9: Finitary Methods II (Advanced track). This section further explores
Ô¨Ånitary methods, this time the direct use of Ô¨Åltrations. We illustrate this
with an analysis of the normal logics extending S4.3.
4.1 Preliminaries
In this section we introduce some of the fundamental concepts that we will use
throughout the chapter. We begin by deÔ¨Åning modal logics ‚Äì these could be de-
scribed as propositional logics in a modal language.
Throughout the chapter we assume we are working with a Ô¨Åxed countable lan-
guage of proposition letters.
DeÔ¨Ånition 4.1 (Modal Logics) A modal logic Œõ is a set of modal formulas that
contains all propositional tautologies and is closed under modus ponens (that is, if
œÜ ‚àà Œõ and œÜ ‚Üí œà ‚àà Œõ then œà ‚àà Œõ) and uniform substitution (that is, if œÜ belongs
to Œõ then so do all of its substitution instances). If œÜ ‚àà Œõ we say that œÜ is a theorem
of Œõ and write Œõ œÜ; if not, we write Œõ œÜ. If Œõ1 and Œõ2 are modal logics such190
4 Completeness
that Œõ1 ‚äÜ Œõ2 , we say that Œõ2 is an extension of Œõ1 . In what follows, we usually
drop the word ‚Äòmodal‚Äô and talk simply of ‚Äòlogics.‚Äô
Note that modal logics contain all substitution instances of the propositional tau-
tologies: for example, 3p ‚à® ¬¨3p, belongs to every modal logic. Even though
such substitution instances may contain occurrences of 3 and 2, we still call them
tautologies. Clearly tautologies are valid in every class of models.
Example 4.2
(i) The collection of all formulas is a logic, the inconsistent
logic.

(ii) If {Œõi | i ‚àà I} is a collection of logics, then i‚ààI Œõi is a logic.
(iii) DeÔ¨Åne ŒõS to be {œÜ | S  œÜ, for all structures S ‚àà S}, where S is any class
of frames or any class of general frames. ŒõS is a logic. If S is the singleton
class {S}, we usually call this logic ŒõS, rather than Œõ{S} .
(iv) If M is a class of models, then ŒõM need not be a logic. Consider a model
M in which p is true at all nodes but q is not. Then p ‚àà ŒõM, but q ‚àà ŒõM.
But q is obtainable from p by uniform substitution.
It follows from Examples 4.2(i) and 4.2(ii) that there is a smallest logic containing
any set of formulas Œì ; we call this the logic generated by Œì . For example, the logic
generated by the empty set contains all the tautologies and nothing else; we call it
PC and it is a subset of every logic. This generative perspective is essentially syn-
tactic. However, as Example 4.2(iii) shows, there is a natural semantic perspective
on logics: both frames and general frames give rise to logics in an obvious way.
Even the empty class of frames gives rise to a logic, namely the inconsistent logic.
Finally, Example 4.2(iv) shows that models may fail to give rise to logics. This
‚Äòfailure‚Äô is actually the behavior we should expect: as we discussed in Section 1.6,
genuine logics arise at the level of frames, via the concept of validity.
DeÔ¨Ånition 4.3 Let œà1 , . . . , œàn , œÜ be modal formulas. We say that œÜ is deducible
in propositional calculus from assumptions œà1 , . . . , œàn if (œà1 ‚àß ¬∑ ¬∑ ¬∑ ‚àß œàn ) ‚Üí œÜ is
a tautology.
All logics are closed under deduction in propositional calculus: if œÜ is deducible
in propositional calculus from assumptions œà1 , . . . , œàn , then Œõ œà1 , . . . , Œõ œàn
implies Œõ œÜ.
DeÔ¨Ånition 4.4 If Œì ‚à™ {œÜ} is a set of formulas then œÜ is deducible in Œõ from Œì (or:
œÜ is Œõ-deducible from Œì ) if Œõ œÜ or there are formulas œà1 ,. . . , œàn ‚àà Œì such that
Œõ (œà1 ‚àß ¬∑ ¬∑ ¬∑ ‚àß œàn ) ‚Üí œÜ.4.1 Preliminaries
191
If this is the case we write Œì Œõ œÜ, if not, Œì Œõ œÜ. A set of formulas Œì is Œõ-
consistent if Œì Œõ ‚ä•, and Œõ-inconsistent otherwise. A formula œÜ is Œõ-consistent if
{œÜ} is Œõ-consistent; otherwise œÜ is Œõ-inconsistent.
It is a simple exercise in propositional logic to check that a set of formulas Œì is
Œõ-inconsistent if and only if there is a formula œÜ such that Œì Œõ œÜ ‚àß ¬¨œÜ if and
only if for all formulas œà, Œì Œõ œà. Moreover, Œì is Œõ-consistent if and only if
every Ô¨Ånite subset of Œì is. (That is, our notion of deducibility has the compact-
ness property.) From now on, when Œõ is clear from context or irrelevant, we drop
explicit references to it and talk simply of ‚Äòtheorems‚Äô, ‚Äòdeducibility‚Äô, ‚Äòconsistency‚Äô
and ‚Äòinconsistency‚Äô, and use the notation  œÜ, Œì  œÜ, and so on.
The preceding deÔ¨Ånitions merely generalize basic ideas of propositional calculus
to modal languages. Now we come to a genuinely modal concept: normal modal
logics. These logics are the focus of this chapter‚Äôs investigations. We initially
restrict our discussion to the basic modal language; the full deÔ¨Ånition is given at
the end of the section. As we discussed in Section 1.6, the following deÔ¨Ånition is
essentially an abstraction from Hilbert-style approaches to modal proof theory.
DeÔ¨Ånition 4.5 A modal logic Œõ is normal if it contains the formulas:
(K)
(Dual)
2(p ‚Üí q) ‚Üí (2p ‚Üí 2q),
3p ‚Üî ¬¨2¬¨p,
and is closed under generalization (that is, if Œõ œÜ then Œõ 2œÜ).
Syntactic issues do not play a large role in this book; nonetheless, readers new to
modal logic should study the following lemma and attempt Exercise 4.1.2.
Lemma 4.6 For any normal logic Œõ, if Œõ œÜ ‚Üî œà then Œõ 3œÜ ‚Üî 3œà.
Proof. Suppose Œõ œÜ ‚Üî œà. Then Œõ œÜ ‚Üí œà and Œõ œà ‚Üí œÜ. If we can show that
Œõ 3œÜ ‚Üí 3œà and Œõ 3œà ‚Üí 3œÜ, the desired result follows. Now, as Œõ œÜ ‚Üí œà,
we have Œõ ¬¨œà ‚Üí ¬¨œÜ, hence by generalization Œõ 2(¬¨œà ‚Üí ¬¨œÜ). By uniform
substitution into the K axiom we obtain Œõ 2(¬¨œà ‚Üí ¬¨œÜ) ‚Üí (2¬¨œà ‚Üí 2¬¨œÜ). It
follows by modus ponens that Œõ 2¬¨œà ‚Üí 2¬¨œÜ. Therefore, Œõ ¬¨2¬¨œÜ ‚Üí ¬¨2¬¨œà,
and two uses of Dual yield Œõ 3œÜ ‚Üí 3œà, as desired. As  œà ‚Üí œÜ, an analogous
argument shows that Œõ 3œà ‚Üí 3œÜ, and the result follows.
Remark 4.7 The above deÔ¨Ånition of normal logics (with or without Dual, depend-
ing on the choice of primitive operators) is probably the most popular way of stip-
ulating what normal logics are. But it is not the only way. Here, for example, is
a simple diamond-based formulation of the concept, which will be useful in our
later algebraic work: a logic Œõ is normal if it contains the axioms 3‚ä• ‚Üî ‚ä• and
3(p ‚à® q) ‚Üî 3p ‚à® 3q, and is closed under the following rule: Œõ œÜ ‚Üí œà implies192
4 Completeness
Œõ 3œÜ ‚Üí 3œà. This formulation is equivalent to DeÔ¨Ånition 4.5, as the reader is
asked to show in Exercise 4.1.2.
Example 4.8
(i) The inconsistent logic is a normal logic.
(ii) PC is not a normal logic.

(iii) If {Œõi | i ‚àà I} is a collection of normal logics, then i‚ààI Œõi is a normal
logic.
(iv) If F is any class of frames, then ŒõF is a normal logic.
(v) If G is any class of general frames, then ŒõG is a normal logic. (The reader
is asked to prove this in Exercise 4.1.1.)
Examples 4.8(i) and 4.8(iii) guarantee that there is a smallest normal modal logic
containing any set of formulas Œì . We call this the normal modal logic generated
or axiomatized by Œì . The normal modal logic generated by the empty set is called
K, and it is the smallest (or minimal) normal modal logic: for any normal modal
logic Œõ, K ‚äÜ Œõ. If Œì is a non-empty set of formulas we usually denote the
normal logic generated by Œì by KŒì. Moreover, we often make use of Hilbert
axiomatization terminology, referring to Œì as axioms of this logic, and say that the
logic was generated using the rules of proof modus ponens, uniform substitution,
and generalization. We justiÔ¨Åed this terminology in Section 1.6, and also asked the
reader to prove that the logic KŒì consists of precisely those formulas that can be
proved in a Hilbert-style derivation from the axioms in Œì using the standard modal
proof rules (see Exercise 1.6.6).
DeÔ¨Åning a logic by stating which formulas generate it (that is, extending the
minimal normal logic K with certain axioms of interest) is the usual way of syn-
tactically specifying normal logics. Much of this chapter explores such axiomatic
extensions. Here are some of the better known axioms, together with their tradi-
tional names:
(4)
(T)
(B)
(D)
(.3)
(L)
33p ‚Üí 3p
p ‚Üí 3p
p ‚Üí 23p
2p ‚Üí 3p
3p ‚àß 3q ‚Üí 3(p ‚àß 3q) ‚à® 3(p ‚àß q) ‚à® 3(q ‚àß 3p)
2(2p ‚Üí p) ‚Üí 2p.
There is a convention for talking about the logics generated by such axioms: if
A1 , . . . , An are axioms then KA1 . . . An is the normal logic generated by A1 , . . . ,
An . But irregularities abound. Many historical names are Ô¨Årmly entrenched, thus
modal logicians talk of T, B, S4, S4.3, and S5 instead of KT, KB, KT4, KT4.3, and
KT4B respectively. Moreover, many axioms have multiple names. For example,4.1 Preliminaries
K
K4
T
B
KD
S4
S5
K4.3
S4.3
KL
193
the class of all frames
the class of transitive frames
the class of reÔ¨Çexive frames
the class of symmetric frames
the class of right-unbounded frames
the class of reÔ¨Çexive, transitive frames
the class of frames whose relation is an equivalence relation
the class of transitive frames with no branching to the right
the class of reÔ¨Çexive, transitive frames with no branching to the right
the class of Ô¨Ånite transitive trees (weak completeness only)
Table 4.1. Some Soundness and Completeness Results
the axiom we call L (for L√∂b) is also known as G (for G√∂del) and W (for well-
founded); and the axiom we call .3 has also been called H (for Hintikka). We adopt
a fairly relaxed attitude towards naming logics, and use the familiar names as much
as possible.
Now that we know what normal modal logics are, we are ready to introduce the
two fundamental concepts linking the syntactic and semantic perspectives: sound-
ness and completeness.
DeÔ¨Ånition 4.9 (Soundness) Let S be a class of frames (or models, or general
frames). A normal modal logic Œõ is sound with respect to S if Œõ ‚äÜ ŒõS . (Equiva-
lently: Œõ is sound with respect to S if for all formulas œÜ, and all structures S ‚àà S,
Œõ œÜ implies S  œÜ.) If Œõ is sound with respect to S we say that S is a class of
frames (or models, or general frames) for Œõ.
Table 4.1 lists a number of well-known logics together with classes of frames for
which they are sound. Recall that a right-unboundedness frame (W, R) is a frame
such that ‚àÄx‚àÉy Rxy. Also, a frame (W, R) satisfying ‚àÄx‚àÄy‚àÄz (Rxy ‚àß Rxz ‚Üí
(Ryz ‚à® y = z ‚à® Rzy)) is said to have no branching to the right.
The soundness claims made in Table 4.1 (with the exception of the last one,
which was shown in Example 3.9) are easily demonstrated. In all cases one shows
that the axioms are valid, and that the three rules of proof (modus ponens, gen-
eralization, and uniform substitution) preserve validity on the class of frames in
question. In fact, the proof rules preserve validity on any class of frames or general
frames (see Exercise 4.1.1), so proving soundness boils down to checking the va-
lidity of the axioms. Soundness proofs are often routine, and when this is the case
we rarely bother to explicitly state or prove them. But the concept of completeness
leads to the problems that will occupy us for the remainder of the chapter.
DeÔ¨Ånition 4.10 (Completeness) Let S be a class of frames (or models, or general194
4 Completeness
frames). A logic Œõ is strongly complete with respect to S if for any set of formulas
Œì ‚à™ {œÜ}, if Œì S œÜ then Œì Œõ œÜ. That is, if Œì semantically entails œÜ on S (recall
DeÔ¨Ånition 1.35) then œÜ is Œõ-deducible from Œì .
A logic Œõ is weakly complete with respect to S if for any formula œÜ, if S  œÜ then
Œõ œÜ. Œõ is strongly complete (weakly complete) with respect to a single structure
S if Œõ is strongly complete (weakly complete) with respect to {S}.
Note that weak completeness is the special case of strong completeness in which Œì
is empty, thus strong completeness with respect to some class of structures implies
weak completeness with respect to that same class. (The converse does not hold,
as we will later see.) Note that the deÔ¨Ånition of weak completeness can be refor-
mulated to parallel the deÔ¨Ånition of soundness: Œõ is weakly complete with respect
to S if ŒõS ‚äÜ Œõ. Thus, if we prove that a syntactically speciÔ¨Åed logic Œõ is both
sound and weakly complete with respect to some class of structures S, we have
established a perfect match between the syntactical and semantical perspectives:
Œõ = ŒõS . Given a semantically speciÔ¨Åed logic ŒõS (that is, the logic of some class
of structures S of interest) we often want to Ô¨Ånd a simple collection of formulas Œì
such that ŒõS is the logic generated by Œì ; in such a case we sometimes say that Œì
axiomatizes S.
Example 4.11 With the exception of KL, all the logics mentioned in Table 4.1 are
strongly complete with respect to the corresponding classes of frames. However,
KL is only weakly complete with respect to the class of Ô¨Ånite transitive trees. As
we will learn in section 4.4, KL is not strongly complete with respect to this class
of frames, or indeed with respect to any class of frames whatsoever.
These completeness results are among the best known in modal logic, and we will
soon be able to prove them. Together with their soundness counterparts, they con-
stitute perspicuous semantic characterizations of important logics. K4, for exam-
ple, is not just the logic obtained by enriching K with some particular axiom: it is
precisely the set of formulas valid on all transitive frames. There is always some-
thing arbitrary about syntactic presentations; it is pleasant (and useful) to have
these semantic characterizations at our disposal.
We make heavy use, usually without explicit comment, of the following result:
Proposition 4.12 A logic Œõ is strongly complete with respect to a class of struc-
tures S iff every Œõ-consistent set of formulas is satisÔ¨Åable on some S ‚àà S. Œõ
is weakly complete with respect to a class of structures S iff every Œõ-consistent
formula is satisÔ¨Åable on some S ‚àà S.
Proof. The result for weak completeness follows from the one for strong complete-
ness, so we examine only the latter. To prove the right to left implication we argue4.1 Preliminaries
195
by contraposition. Suppose Œõ is not strongly complete with respect to S. Thus
there is a set of formulas Œì ‚à™ {œÜ} such that Œì S œÜ but Œì Œõ œÜ. Then Œì ‚à™ {¬¨œÜ}
is Œõ-consistent, but not satisÔ¨Åable on any structure in S. The left to right direction
is left to the reader.
To conclude this section, we extend the deÔ¨Ånition of normal modal logics to arbi-
trary similarity types.
DeÔ¨Ånition 4.13 Assume we are working with a modal language of similarity type
œÑ . A modal logic in this language is (as before) a set of formulas containing all
tautologies that is closed under modus ponens and uniform substitution. A modal
logic Œõ is normal if for every operator  it contains the axiom Ki (for all i such
that 1 ‚â§ i ‚â§ œÅ()) and the axiom Dual, and is closed under the generalization
rules described below.
The required axioms are obvious polyadic analogs of the earlier K and Dual
axioms:
(r1 , . . ., p ‚Üí q, . . . , rœÅ() ) ‚Üí
‚Üí (r1 , . . . , p, . . . , rœÅ() ) ‚Üí (r1 , . . . , q, . . . , rœÅ() ) .
(Dual) (r1 , . . . , rœÅ() ) ‚Üî ¬¨(¬¨r1 , . . . , ¬¨rœÅ() ).
(Ki)
(Here p, q, r1 , . . . , rœÅ() are distinct propositional variables, and the occurrences
in Ki of p and q occur in the i-th argument place of .) Finally, for a polyadic
operator , generalization takes the following form:
Œõ œÉ implies Œõ (‚ä•, . . . , œÉ, . . . , ‚ä•).
That is, an n-place operator  is associated with n generalization rules, one for
each of its n argument positions.
Note that these axioms and rules do not apply to nullary modalities. Nullary
modalities are rather like propositional variables and ‚Äì as far as the minimal logic
is concerned ‚Äì they do not give rise to any axioms or rules.
DeÔ¨Ånition 4.14 Let œÑ be a modal similarity type. Given a set of œÑ -formulas Œì ,
we deÔ¨Åne KœÑ Œì, the normal modal logic axiomatized or generated by Œì , to be the
smallest normal modal œÑ -logic containing all formulas in Œì . Formulas in Œì are
called axioms of this logic, and Œì may be called an axiomatization of KœÑ Œì. The
normal modal logic generated by the empty set is denoted by KœÑ .
Exercises for Section 4.1
4.1.1 Show that if G is any class of general frames, then Œõ G is a normal logic. (To prove
this, you will have to show that the modal proof rules preserve validity on any general
frame.)196
4 Completeness
4.1.2 First, show that the diamond-based deÔ¨Ånition of normal modal logics given in Re-
mark 4.7 is equivalent to the box-based deÔ¨Ånition. Then, for languages of arbitrary simi-
larity type, formulate a -based deÔ¨Ånition of normal modal logics, and prove it equivalent
to the -based one given in DeÔ¨Ånition 4.13.
4.1.3 Show that the set of all normal modal logics (in some Ô¨Åxed language) ordered by set
theoretic inclusion forms a complete lattice. That is, prove that every family {Œõ i | i ‚àà I}
of logics has both an inÔ¨Åmum and a supremum. (An inÔ¨Åmum is a logic Œõ such that Œõ ‚äÜ Œõ i
for all i ‚àà I, and for any other logic Œõ  that has this property, it holds that Œõ  ‚äÜ Œõ; the
concept of a supremum is deÔ¨Åned analogously, with ‚Äò‚äá‚Äô replacing ‚Äò‚äÜ.‚Äô)
4.1.4 Show that the normal logic generated by 2(p ‚àß 2p ‚Üí q) ‚à® 2(q ‚àß 2q ‚Üí p) is sound
with respect to the class of K4.3 frames (see Table 4.1). Further, show that the normal
modal logic generated by 2(2p ‚Üí q) ‚à® 2(2q ‚Üí p) is not sound with respect to this class
of frames, but that it is sound with respect to the class of S4.3 frames.
4.2 Canonical Models
Completeness theorems are essentially model existence theorems ‚Äì that is the con-
tent of Proposition 4.12. Given a normal logic Œõ, we prove its strong completeness
with respect to some class of structures by showing that every Œõ-consistent set of
formulas can be satisÔ¨Åed in some suitable model. Thus the fundamental question
we need to address is: how do we build (suitable) satisfying models?
This section introduces the single most important answer: build models out of
maximal consistent sets of formulas, and in particular, build canonical models. It
is difÔ¨Åcult to overstress the importance of this idea. In one form or another it
underlies almost every modal completeness result the reader is likely to encounter.
Moreover, as we will learn in Chapter 5, the idea has substantial algebraic content.
DeÔ¨Ånition 4.15 (Œõ-MCSs) A set of formulas Œì is maximal Œõ-consistent if Œì is Œõ-
consistent, and any set of formulas properly containing Œì is Œõ-inconsistent. If Œì is
a maximal Œõ-consistent set of formulas then we say it is a Œõ-MCS.
Why use MCSs in completeness proofs? To see this, Ô¨Årst note that every point
w in every model M for a logic Œõ is associated with a set of formulas, namely
{œÜ | M, w  œÜ}. It is easy to check (and the reader should do so) that this
set of formulas is actually a Œõ-MCS. That is: if œÜ is true in some model for Œõ,
then œÜ belongs to a Œõ-MCS. Second, if w is related to w in some model M,
then it is clear that the information embodied in the MCSs associated with w and
w is ‚Äòcoherently related‚Äô. Thus our second observation is: models give rise to
collections of coherently related MCSs.
The idea behind the canonical model construction is to try and turn these obser-
vations around: that is, to work backwards from collections of coherently related
MCSs to the desired model. The goal is to prove a Truth Lemma which tells us that4.2 Canonical Models
197
‚ÄòœÜ belongs to an MCS‚Äô is actually equivalent to ‚ÄòœÜ is true in some model.‚Äô How will
we do this? By building a special model ‚Äì the canonical model ‚Äì whose points are
all MCSs of the logic of interest. We will pin down what it means for the informa-
tion in MCSs to be ‚Äòcoherently related,‚Äô and use this notion to deÔ¨Åne the required
accessibility relations. Crucially, we will be able to prove an Existence Lemma
which states that there are enough coherently related MCSs to ensure the success of
the construction, and this will enable us to prove the desired Truth Lemma.
To carry out this plan, we need to learn a little more about MCSs.
Proposition 4.16 (Properties of MCSs) If Œõ is a logic and Œì is a Œõ-MCS then:
(i) Œì is closed under modus ponens: if œÜ, œÜ ‚Üí œà ‚àà Œì , then œà ‚àà Œì ;
(ii) Œõ ‚äÜ Œì ;
(iii) for all formulas œÜ: œÜ ‚àà Œì or ¬¨œÜ ‚àà Œì ;
(iv) for all formulas œÜ, œà: œÜ ‚à® œà ‚àà Œì iff œÜ ‚àà Œì or œà ‚àà Œì .
Proof. Exercise 4.2.1.
As MCSs are to be our building blocks, it is vital that we have enough of them. In
fact, any consistent set of formulas can be extended to a maximal consistent one.
Lemma 4.17 (Lindenbaum‚Äôs Lemma) If Œ£ is a Œõ-consistent set of formulas then
there is a Œõ-MCS Œ£+ such that Œ£ ‚äÜ Œ£+ .
Proof. Let œÜ0 , œÜ1 , œÜ2 , . . . be an enumeration of the formulas of our language. We
deÔ¨Åne the set Œ£+ as the union of a chain of Œõ-consistent sets as follows:
Œ£0 = Œ£,
Œ£n+1 =
Œ£+ =
if this is Œõ-consistent
Œ£n ‚à™ {œÜn },
Œ£n ‚à™ {¬¨œÜn }, otherwise
n‚â•0 Œ£n .
The proof of the following properties of Œ£+ is left as Exercise 4.2.2: (i) Œ£n is
Œõ-consistent, for all n; (ii) exactly one of œÜ and ¬¨œÜ is in Œ£+ , for every formula œÜ;
(iii) if Œ£ + Œõ œÜ, then œÜ ‚àà Œ£ + ; and Ô¨Ånally (iv) Œ£+ is a Œõ-MCS.
We are now ready to build models out of MCSs, and in particular, to build the
very special models known as canonical models. With the help of these structures
we will be able to prove the Canonical Model Theorem, a universal completeness
result for normal logics. We Ô¨Årst deÔ¨Åne canonical models and prove this result for
the basic modal language; at the end of the section we generalize our discussion to
languages of arbitrary similarity type.
DeÔ¨Ånition 4.18 The canonical model MŒõ for a normal modal logic Œõ (in the basic
language) is the triple (W Œõ , RŒõ , V Œõ ) where:198
4 Completeness
(i) W Œõ is the set of all Œõ-MCSs;
(ii) RŒõ is the binary relation on W Œõ deÔ¨Åned by RŒõ wu if for all formulas œà,
œà ‚àà u implies 3œà ‚àà w. RŒõ is called the canonical relation;
(iii) V Œõ is the valuation deÔ¨Åned by V Œõ (p) = {w ‚àà W Œõ | p ‚àà w}. V Œõ is called
the canonical (or natural) valuation.
The pair FŒõ = (W Œõ , RŒõ ) is called the canonical frame for Œõ.
All three clauses deserve comment. First, the canonical valuation equates the truth
of a propositional symbol at w with its membership in w. Our ultimate goal is to
prove a Truth Lemma which will lift this ‚Äòtruth = membership‚Äô equation to arbitrary
formulas.
Second, note that the states of MŒõ consist of all Œõ-consistent MCSs. The signif-
icance of this is that, by Lindenbaum‚Äôs Lemma, any Œõ-consistent set of formulas
is a subset of some point in MŒõ ‚Äì hence, by the Truth Lemma proved below, any
Œõ-consistent set of formulas is true at some point in this model. In short, the sin-
gle structure MŒõ is a ‚Äòuniversal model‚Äô for the logic Œõ, which is why it is called
‚Äòcanonical.‚Äô
Finally, consider the canonical relation: a state w is related to a state u precisely
when for each formula œà in u, w contains the information 3œà. Intuitively, this
captures what we mean by MCSs being ‚Äòcoherently related.‚Äô The reader should
compare the present discussion with the account of ultraÔ¨Ålter extensions in Chap-
ter 2 ‚Äì in Chapter 5 we will discuss a unifying framework. In the meantime, the
following lemma shows that we are getting things right:
Lemma 4.19 For any normal logic Œõ, RŒõ wv iff for all formulas œà, 2œà ‚àà w
implies œà ‚àà v.
Proof. For the left to right direction, suppose RŒõ wv. Further suppose œà ‚àà v. As v
is an MCS, by Proposition 4.16 ¬¨œà ‚àà v. As RŒõ wv, 3¬¨œà ‚àà w. As w is consistent,
¬¨3¬¨œà ‚àà w. That is, 2œà ‚àà w and we have established the contrapositive. We
leave the right to left direction to the reader.
In fact, the deÔ¨Ånition of RŒõ is exactly what we require; all that remains to be
checked is that enough ‚Äòcoherently related‚Äô MCSs exist for our purposes.
Lemma 4.20 (Existence Lemma) For any normal modal logic Œõ and any state
w ‚àà W Œõ , if 3œÜ ‚àà w then there is a state v ‚àà W Œõ such that RŒõ wv and œÜ ‚àà v.
Proof. Suppose 3œÜ ‚àà w. We will construct a state v such that RŒõ wv and œÜ ‚àà v.
Let v‚àí be {œÜ} ‚à™ {œà | 2œà ‚àà w}. Then v‚àí is consistent. For suppose not. Then
there are œà1 , . . . , œàn such that Œõ (œà1 ‚àß ¬∑ ¬∑ ¬∑ ‚àß œàn ) ‚Üí ¬¨œÜ, and it follows by an
easy argument that Œõ 2(œà1 ‚àß ¬∑ ¬∑ ¬∑ ‚àß œàn ) ‚Üí 2¬¨œÜ. As the reader should check, the4.2 Canonical Models
199
formula (2œà1 ‚àß ¬∑ ¬∑ ¬∑ ‚àß 2œàn ) ‚Üí 2(œà1 ‚àß ¬∑ ¬∑ ¬∑ ‚àß œàn ) is a theorem of every normal
modal logic, hence by propositional calculus, Œõ (2œà1 ‚àß¬∑ ¬∑ ¬∑‚àß2œàn ) ‚Üí 2¬¨œÜ. Now,
2œà1 ‚àß ¬∑ ¬∑ ¬∑ ‚àß 2œàn ‚àà w (for 2œà1 , . . . , 2œàn ‚àà w, and w is an MCS) thus it follows
that 2¬¨œÜ ‚àà w. Using Dual, it follows that ¬¨3œÜ ‚àà w. But this is impossible: w is
an MCS containing 3œÜ. We conclude that v‚àí is consistent after all.
Let v be any MCS extending v‚àí ; such extensions exist by Lindenbaum‚Äôs Lemma.
By construction œÜ ‚àà v. Furthermore, for all formulas œà, 2œà ‚àà w implies œà ‚àà v.
Hence by Lemma 4.19, RŒõ wv.
With this established, the rest is easy. First we lift the ‚Äòtruth = membership‚Äô equa-
tion to arbitrary formulas:
Lemma 4.21 (Truth Lemma) For any normal modal logic Œõ and any formula œÜ,
MŒõ , w  œÜ iff œÜ ‚àà w.
Proof. By induction on the degree of œÜ. The base case follows from the deÔ¨Ånition
of V Œõ . The boolean cases follow from Proposition 4.16. It remains to deal with the
modalities. The left to right direction is more or less immediate from the deÔ¨Ånition
of RŒõ :
MŒõ , w  3œÜ
iff
iff
only if
‚àÉv (RŒõ wv ‚àß MŒõ , v  œÜ)
‚àÉv (RŒõ wv ‚àß œÜ ‚àà v)
(Induction Hypothesis)
3œÜ ‚àà w
(DeÔ¨Ånition RŒõ ).
For the right to left direction, suppose 3œÜ ‚àà w. By the equivalences above, it
sufÔ¨Åces to Ô¨Ånd an MCS v such that RŒõ wv and œÜ ‚àà v ‚Äì and this is precisely what
the Existence Lemma guarantees.
Theorem 4.22 (Canonical Model Theorem) Any normal modal logic is strongly
complete with respect to its canonical model.
Proof. Suppose Œ£ is a consistent set of the normal modal logic Œõ. By Linden-
baum‚Äôs Lemma there is a Œõ-MCS Œ£+ extending Œ£. By the previous lemma,
MŒõ , Œ£ +  Œ£.
At Ô¨Årst glance, the Canonical Model Theorem may seem rather abstract. It is a
completeness result with respect to a class of models, not frames, and a rather ab-
stract class at that. (That K4 is complete with respect to the class of transitive
frames is interesting; that it is complete with respect to the singleton class contain-
ing only its canonical model seems rather dull.) But appearances are misleading:
canonical models are by far the most important tool used in the present chapter.
For a start, the Canonical Model Theorem immediately yields the following result:
Theorem 4.23 K is strongly complete with respect to the class of all frames.200
4 Completeness
Proof. By Proposition 4.12, to prove this result it sufÔ¨Åces to Ô¨Ånd, for any K-
consistent set of formulas Œì , a model M (based on any frame whatsoever) and a
state w in M such that M, w  Œì . This is easy: simply choose M to be (FK , V K ),
the canonical model for K, and let Œì + be any K-MCS extending Œì . By the previous
lemma, (FK , V K ), Œì +  Œì .
More importantly, it is often easy to get useful information about the structure of
canonical frames. For example, as we will learn in the next section, the canonical
frame for K4 is transitive ‚Äì and this immediately yields the (more interesting) re-
sult that K4 is complete with respect to the class of transitive frames. Even when
a canonical model is not as cleanly structured as we would like, it still embod-
ies a vast amount of information about its associated logic; one of the important
themes pursued later in the chapter is how to make use of this information in-
directly. Furthermore, canonical models are mathematically natural. As we will
learn in Chapter 5, from an algebraic perspective canonical models are not abstract
oddities: indeed, they are precisely the structures one is lead to by considering the
ideas underlying the Stone Representation Theorem.
To conclude this section we sketch the generalizations required to extend the
results obtained so far to languages of arbitrary similarity types.
DeÔ¨Ånition 4.24 Let œÑ be a modal similarity type, and Œõ a normal modal logic in
Œõ, V Œõ)
the language over œÑ . The canonical model MŒõ = (W Œõ , R
‚ààœÑ for Œõ has
Œõ
Œõ
W and V as deÔ¨Åned in DeÔ¨Ånition 4.18, while for an n-ary operator  ‚àà œÑ the
Œõ ‚äÜ (W Œõ )n+1 is deÔ¨Åned by RŒõ wu . . . u if for all formulas œà ‚àà u ,
relation R
1
n
1
1

. . . , œàn ‚àà un we have (œà1 , . . . , œàn ) ‚àà w.
There is an analog of Lemma 4.19.
Œõ wu . . . u iff for all formulas
Lemma 4.25 For any normal modal logic Œõ, R
1
n
œà1 , . . . , œàn , (œà1 , . . . , œàn ) ‚àà w implies that for some i such that 1 ‚â§ i ‚â§ n,
œài ‚àà ui .
Proof. See Exercise 4.2.3.
Now for the crucial lemma ‚Äì we must show that enough coherently related MCSs
exist. This requires a more delicate approach than was needed for Lemma 4.20.
Lemma 4.26 (Existence Lemma) Suppose (œà1 , . . . , œàn ) ‚àà w. Then there are
u1 , . . . , un such that œà1 ‚àà u1 , . . . , œàn ‚àà un and RŒõ wu1 . . . un .
Proof. The proof of Lemma 4.20 establishes the result for any unary operators in
the language, so it only remains to prove the (trickier) case for modalities of higher
arity. To keep matters simple, assume that  is binary; this illustrates the key new
idea needed.4.3 Applications
201
So, suppose (œà1 , œà2 ) ‚àà w. Let œÜ0 , œÜ1 , . . . enumerate all formulas. We con-
struct two sequences of sets of formulas
{œà1 } = Œ†0 ‚äÜ Œ†1 ‚äÜ ¬∑ ¬∑ ¬∑ and {œà2 } = Œ£0 ‚äÜ Œ£1 ‚äÜ ¬∑ ¬∑ ¬∑
such that all Œ†i and Œ£i are Ô¨Ånite and consistent, Œ†i+1 is either Œ†i ‚à™ {œÜi } or


Œ†i ‚à™{¬¨œÜi }, and similarly for Œ£i+1 . Moreover, putting œÄi := Œ†i and œÉi := Œ£i ,
we will have that (œÄi , œÉi ) ‚àà w.
The key step in the inductive construction is
(œÄi , œÉi ) ‚àà w ‚áí  (œÄi ‚àß (œÜi ‚à® ¬¨œÜi ), œÉi ‚àß (œÜi ‚à® ¬¨œÜi )) ‚àà w
‚áí  ((œÄi ‚àß œÜi ) ‚à® (œÄi ‚àß ¬¨œÜi ), (œÉi ‚àß œÜi ) ‚à® (œÉi ‚àß ¬¨œÜi )) ‚àà w
‚áí one of the formulas (œÄi ‚àß [¬¨]œÜi , œÉi ‚àß [¬¨]œÜi ) is in w.
If, for example, (œÄi ‚àß œÜi , œÉi ‚àß ¬¨œÜi ) ‚àà w, we take Œ†i+1 := Œ†i ‚à™ {œÜi }, Œ£i+1 :=
Œ£i ‚à™ {¬¨œÜi }. Under this deÔ¨Ånition, all Œ†i and Œ£i have the required properties.
Finally, let u1 = i Œ†i and u2 = i Œ£i . It is easy to see that u1 , u2 are Œõ-MCSs
Œõ wu u , as required.
and R
1 2
With this lemma established, the real work has been done. The Truth Lemma
and the Canonical Model Theorem for general modal languages are now obvious
analogs of Lemma 4.21 and Theorem 4.22. The reader is asked to state and prove
them in Exercise 4.2.4.
Exercises for Section 4.2
4.2.1 Show that all MCSs have the properties stated in Proposition 4.16. In addition, show
that if Œ£ and Œì are distinct MCSs, then there is at least one formula œÜ such that œÜ ‚àà Œ£ and
¬¨œÜ ‚àà Œì .
4.2.2 Lindenbaum‚Äôs Lemma is not fully proved in the text. Give proofs of the four claims
made at the end of our proof sketch.
4.2.3 Prove Lemma 4.25. (This is a good way of getting to grips with the deÔ¨Ånition of
normality for modal languages of arbitrary similarity type.)
4.2.4 State and prove the Truth Lemma and the Canonical Model Theorem for languages
of arbitrary similarity type. Make sure you understand the special case for nullary modali-
ties (recall that we have no special axioms or rules of proof for these).
4.3 Applications
In this section we put canonical models to work. First we show how to prove
the frame completeness results noted in Example 4.11 using a simple and uniform
method of argument. This leads us to isolate one of most important concepts of
modal completeness theory: canonicity. We then switch to the basic temporal202
4 Completeness
language and use similar arguments to prove two important temporal completeness
results. We conclude with a statement of the Sahlqvist Completeness Theorem,
which we will prove in Chapter 5.
Suppose we suspect that a normal modal logic Œõ is strongly complete with re-
spect to a class of frames F; how should we go about proving it? Actually, there is
no infallible strategy. (Indeed, as we will learn in the following section, many nor-
mal modal logics are not complete with respect to any class of frames whatsoever.)
Nonetheless, a very simple technique works in a large number of interesting cases:
simply show that the canonical frame for Œõ belongs to F. We call such proofs
completeness-via-canonicity arguments, for reasons which will soon become clear.
Let us consider some examples.
Theorem 4.27 The logic K4 is strongly complete with respect to the class of tran-
sitive frames.
Proof. Given a K4-consistent set of formulas Œì , it sufÔ¨Åces to Ô¨Ånd a model (F, V )
and a state w in this model such that (1) (F, V ), w  Œì , and (2) F is transitive.
Let (W K4 , RK4 , V K4 ) be the canonical model for K4 and let Œì + be any K4-
MCS extending Œì . By Lemma 4.21, (W K4 , RK4 , V K4 ), Œì +  Œì so step (1) is
established. It remains to show that (W K4 , RK4 ) is transitive. So suppose w, v
and u are points in this frame such that RK4 wv and RK4 vu. We wish to show that
RK4 wu. Suppose œÜ ‚àà u. As RK4 vu, 3œÜ ‚àà v, so as RK4 wv, 33œÜ ‚àà w. But w is
a K4-MCS, hence it contains 33œÜ ‚Üí 3œÜ, thus by modus ponens it contains 3œÜ.
Thus RK4 wu.
In spite of its simplicity, the preceding result is well worth reÔ¨Çecting on. Two
important observations should be made.
First, the proof actually establishes something more general than the theorem
claims: namely, that the canonical frame of any normal logic Œõ containing 33p ‚Üí
3p is transitive. The proof works because all MCSs in the canonical frame contain
the 4 axiom; it follows that the canonical frame of any extension of K4 is transitive,
for all such extensions contain the 4 axiom.
Second, the result suggests that there may be a connection between the structure
of canonical frames and the frame correspondences studied in Chapter 3. We know
from our previous work that 33p ‚Üí 3p deÔ¨Ånes transitivity ‚Äì and now we know
that it imposes this property on canonical frames as well.
Theorem 4.28 T, KB and KD are strongly complete with respect to the classes of
reÔ¨Çexive frames, of symmetric frames, and of right-unbounded frames, respectively.
Proof. For the Ô¨Årst claim, it sufÔ¨Åces to show that the canonical model for T is
reÔ¨Çexive. Let w be a point in this model, and suppose œÜ ‚àà w. As w is a T-MCS,
œÜ ‚Üí 3œÜ ‚àà w, thus by modus ponens, 3œÜ ‚àà w. Thus RT ww.4.3 Applications
203
For the second claim, it sufÔ¨Åces to show that the canonical model for KB is
symmetric. Let w and v be points in this model such that RKB wv, and suppose
that œÜ ‚àà w. As w is a KB-MCS, œÜ ‚Üí 23œÜ ‚àà w, thus by modus ponens 23œÜ ‚àà w.
Hence by Lemma 4.19, 3œÜ ‚àà v. But this means that RKB vw, as required.
For the third claim, it sufÔ¨Åces to show that the canonical model for KD is right-
unbounded. (This is slightly less obvious than the previous claims since it requires
an existence proof.) Let w be any point in the canonical model for KD. We
must show that there exists a v in this model such that RKD wv. As w is a KD-
MCS it contains 2p ‚Üí 3p, thus by closure under uniform substitution it contains
2 ‚Üí 3. Moreover, as  belongs to all normal modal logics, by generalization
2 does too; so 2 belongs to KD, hence by modus ponens 3 ‚àà w. Hence,
by the Existence Lemma, w has an RKD successor v.
Once again, these results hint at a link between deÔ¨Ånability and the structure of
canonical frames: after all, T deÔ¨Ånes reÔ¨Çexivity, B deÔ¨Ånes symmetry, and D right
unboundedness. And yet again, the proofs actually establish something more gen-
eral than the theorem states: the canonical frame of any normal logic containing
T is reÔ¨Çexive, the canonical frame of any normal logic containing B is symmetric,
and the canonical frame of any normal logic containing D is right unbounded. This
allows us to ‚Äòadd together‚Äô our results. Here are two examples:
Theorem 4.29 S4 is strongly complete with respect to the class of reÔ¨Çexive, tran-
sitive frames. S5 is strongly complete with respect to the class of frames whose
relation is an equivalence relation.
Proof. The proof of Theorem 4.27 shows that the canonical frame of any normal
logic containing the 4 axiom is transitive, while the proof of the Ô¨Årst clause of
Theorem 4.28 shows that the canonical frame of any normal logic containing the
T axiom is reÔ¨Çexive. As S4 contains both axioms, its canonical frame has both
properties, thus the completeness result for S4 follows.
As S5 contains both the 4 and the T axioms, it also has a reÔ¨Çexive, transitive
canonical frame. As it also contains the B axiom (which by the proof of the second
clause of Theorem 4.28 means that its canonical frame is symmetric), its canonical
relation is an equivalence relation. The desired completeness result follows.
As these examples suggest, canonical models are an important tool for proving
frame completeness results. Moreover, their utility evidently hinges on some sort
of connection between the properties of canonical frames and the frame corre-
spondences studied earlier. Let us introduce some terminology to describe this
important phenomenon.
DeÔ¨Ånition 4.30 (Canonicity) A formula œÜ is canonical if, for any normal logic Œõ,
œÜ ‚àà Œõ implies that œÜ is valid on the canonical frame for Œõ. A normal logic Œõ is204
4 Completeness
canonical if its canonical frame is a frame for Œõ. (That is, Œõ is canonical if for all
œÜ such that Œõ œÜ, œÜ is valid on the canonical frame for Œõ.)
Clearly 4, T, B and D axioms are all canonical formulas. For example, any normal
logic Œõ containing the 4 axiom has a transitive canonical frame, and the 4 axiom is
valid on transitive frames. Similarly, any modal logic containing the B axiom has
a symmetric canonical frame, and the B axiom is valid on symmetric frames.
Moreover K4, T, KB, KD, S4 and S5 are all canonical logics. Our previous
work has established that all the axioms involved are valid on the relevant canonical
frames. But (see Exercise 4.1.1) modus ponens, uniform substitution, and general-
ization preserve frame validity. It follows that every formula in each of these logics
is valid on that logic‚Äôs canonical frame. In general, to show that KA1 . . . An is a
canonical logic it sufÔ¨Åces to show that A1 , . . . , An are canonical formulas.
DeÔ¨Ånition 4.31 (Canonicity for a Property) Let œÜ be a formula, and P be a prop-
erty. If the canonical frame for any normal logic Œõ containing œÜ has property P ,
and œÜ is valid on any class of frames with property P , then œÜ is canonical for P .
For example, we say that the 4 axiom is canonical for transitivity, because the pres-
ence of 4 forces canonical frames to be transitive, and 4 is valid on all transitive
frames.
Let us sum up the discussion so far. Many important frame completeness results
can be proved straightforwardly using canonical models. The key idea in such
proofs is to show that the relevant canonical frame has the required properties.
Such proofs boil down to the following task: showing that the axioms of the logic
are canonical for the properties we want (which is why we call them completeness-
via-canonicity arguments).
Now for some rather different application of completeness-via-canonicity argu-
ments. The theorems just proved were syntactically driven: we began with syn-
tactically speciÔ¨Åed logics (for example K4 and T) and showed that they could be
semantically characterized as the logics of certain frame classes. Canonical models
are clearly useful for such proofs ‚Äì but how do they fare when proving semantically
driven results? That is, suppose F is a class of frames we Ô¨Ånd interesting, and we
have isolated a set of axioms which we hope generates ŒõF . Can completeness-via-
canonicity arguments help establish their adequacy?
As such semantically driven questions are typical of temporal logic, let us switch
to the basic temporal language. Recall from Example 1.14 that this language has
two diamonds, F and P , whose respective duals are G and H. The F operator
looks forwards along the Ô¨Çow of time, and P looks backwards. Furthermore, recall
from Example 1.25 that we are only interested in the frames for this language in
which the relations corresponding to F and P are mutually converse. That is, a4.3 Applications
205
bidirectional frame is a triple (W, {RP , RF }) such that
RP = {(y, x) | (x, y) ‚àà RF }.
Recall that by convention we present bidirectional frames as unimodal frames
(T, R); in such presentations we understand that RF = R and RP = RÀá. The
class of all bidirectional frames is denoted by Ft , and a bidirectional model is a
model whose underlying frame belongs to Ft .
So, what is a temporal logic? As a Ô¨Årst step towards answering this we deÔ¨Åne:
DeÔ¨Ånition 4.32 The minimal temporal logic ŒõFt is {œÜ | Ft  œÜ}.
That is, the minimal temporal logic contains precisely the formulas valid on all
bidirectional frames. This is a semantic deÔ¨Ånition, and, given our interest in frames,
a sensible one. But can we axiomatize ŒõFt ? That is, can we give ŒõFt a simple syn-
tactic characterization? First, note that ŒõFt is not identical to the minimal normal
logic in the basic temporal language. As we noted in Example 1.29(v), for any
frame F = (W, {RF , RP }) we have that
F  (q ‚Üí HF q) ‚àß (q ‚Üí GP q) iff F ‚àà Ft .
The two conjuncts deÔ¨Åne the ‚Äòmutually converse‚Äô property enjoyed by RF and
RP . Clearly, both conjuncts belong to ŒõFt . Equally clearly, they do not belong to
the minimal normal logic in the basic temporal language. Nonetheless, although
ŒõFt is stronger, it is not much stronger: the only axioms we need to add are these
converse-deÔ¨Åning conjuncts.
DeÔ¨Ånition 4.33 A normal temporal logic Œõ is a normal modal logic (in the basic
temporal language) that contains p ‚Üí GP p and p ‚Üí HF p (the converse axioms).
The smallest normal temporal logic is called Kt . We usually call normal temporal
logics tense logics.
Note that in the basic temporal language the K axioms are G(p ‚Üí q) ‚Üí (Gp ‚Üí
Gq) and H(p ‚Üí q) ‚Üí (Hp ‚Üí Hq), and the Dual axioms are F p ‚Üî ¬¨G¬¨p and
P p ‚Üî ¬¨H¬¨p. Closure under generalization means that if Œõ œÜ then Œõ GœÜ and
Œõ HœÜ.
We want to show that Kt generates exactly the formulas in ŒõFt . Soundness is
immediate: clearly Kt ‚äÜ ŒõFt . We show completeness using a canonicity argument.
So, what are canonical models for tense logics? Nothing new: simply the following
instance of DeÔ¨Ånition 4.24:
DeÔ¨Ånition 4.34 The canonical model for a tense logic Œõ is the structure MŒõ =
(T Œõ , {RPŒõ , RFŒõ }, V Œõ ) where:
(i) T Œõ is the set of all Œõ-MCSs.206
4 Completeness
(ii) RPŒõ is the binary relation on T Œõ deÔ¨Åned by RPŒõ ts if for all formulas œÜ, œÜ ‚àà s
implies P œÜ ‚àà t.
(iii) RFŒõ is the binary relation on T Œõ deÔ¨Åned by RFŒõ ts if for all formulas œÜ, œÜ ‚àà s
implies F œÜ ‚àà t.
(iv) V Œõ is the valuation deÔ¨Åned by V Œõ (p) = {t ‚àà T Œõ | p ‚àà t}.
We immediately inherit a number of results from the previous section, such as an
Existence Lemma, a Truth Lemma, and a Canonical Model Theorem telling us that
each tense logic is complete with respect to its canonical model. This is very useful
‚Äì but it is not quite enough. We want to show that Kt generates all the temporal
validities. None of the results just mentioned allow us to conclude this, and for a
very obvious reason: we do not yet know whether canonical frames for tense logics
are bidirectional frames! In fact they are, and this is where the converse axioms
come into play. As the next lemma shows, these axioms are canonical; they force
RPŒõ and RFŒõ to be mutually converse.
Lemma 4.35 For any tense logic Œõ, if RPŒõ ts then RFŒõ st, and if RFŒõ ts then RPŒõ st.
Proof. Rather like the proof that B is canonical for symmetry (see Theorem 4.28).
We leave it to the reader as Exercise 4.3.2.
Thus canonical frames of tense logics are bidirectional frames, so from now on we
present them as pairs (T Œõ , RŒõ ). Moreover, we now have the desired result:
Corollary 4.36 Kt is strongly complete with respect to the class of all bidirec-
tional frames, and Kt = ŒõFt .
Proof. Kt is strongly complete with respect to its canonical model. As we have just
seen, this model is based on a bidirectional frame, so the strong frame complete-
ness result follows. Strong completeness implies weak completeness, so ŒõFt ‚äÜ Kt .
The inclusion Kt ‚äÜ ŒõFt has already been noted.
With this basic result established, we are ready to start a semantically driven ex-
ploration of tense logic. That is, we can now attempt to capture the logics of ‚Äòtime-
like‚Äô classes of frames as axiomatic extensions of Kt . Here we limit ourselves to
the following question: how can the temporal logic of dense unbounded weak total
orders be axiomatized? From the point of view of tense logic, this is an interesting
problem: dense frames and totally ordered frames both play an important role in
modeling temporal phenomena. Moreover, as we will see, there is an instructive
problem that must be overcome if we build totally ordered models. This will give
us a gentle initiation to the fundamental difÔ¨Åculty faced by semantically driven
completeness results, a difÔ¨Åculty which we will explore in more detail later in the
chapter.4.3 Applications
207
DeÔ¨Ånition 4.37 A bidirectional frame (T, R) is dense if there is a point between
any two related points (‚àÄxy (Rxy ‚Üí ‚àÉz (Rxz ‚àß Rzy))). It is right-unbounded if
every point has a successor, left-unbounded if every point has a predecessor, and
unbounded if it is both right- and left-unbounded. It is trichotomous if any two
points are equal or are related one way or the other (‚àÄxy (Rxy ‚à® x = y ‚à® Ryx)),
and a weak total order (or weakly linear) if it is both transitive and trichotomous.
We call a frame with all these properties a DUWTO-frame.
Note that weakly linear frames are allowed to contain both reÔ¨Çexive and irreÔ¨Çexive
points. Indeed, they are allowed to contain non-empty subsets S such that for all
s, s ‚àà S, Rss . Thus they do not fully model the idea of linearity. Linearity is
better captured by the class of strict total orders, which are transitive, trichotomous
and irreÔ¨Çexive. Building strictly totally ordered models is harder than building
weakly totally ordered models; we examine the problem in detail later in the chap-
ter.
Our Ô¨Årst task is to select suitable axioms. Three of the choices are fairly obvious:
(4)
FFp ‚Üí Fp
(Dr ) Gp ‚Üí F p
(Dl ) Hp ‚Üí P p
Note that F F p ‚Üí F p is simply the 4 axiom in tense logical notation. We know
(by the proof of Theorem 4.27) that it is canonical for transitivity, hence choosing
it as an axiom ensures the transitive canonical frame we want. Next, Dr (a tense
logical analog of the D axiom) is (by the proof of the third claim of Theorem 4.28)
canonical for right-unboundedness. Similarly, its backwards-looking companion
Hp ‚Üí P p is canonical for left-unboundedness, so we obtain an unbounded canon-
ical frame without difÔ¨Åculty.
What about density? Here we are in luck. The following formula is canonical
for density:
(den)
Fp ‚Üí FFp
This is worth a lemma, since the proof is not trivial. (Note that density is a
universal-existential property, rather than a universal property like transitivity or
reÔ¨Çexivity. This means that proving canonicity requires establishing the existence
of certain MCSs.)
Lemma 4.38 F p ‚Üí F F p is canonical for density.
Proof. Let Œõ be any tense logic containing F p ‚Üí F F p, let (TŒõ , RŒõ ) be its canon-
ical frame, and let t and t be points in this frame such that RŒõ tt . We have to
show that there is a Œõ-MCS s such that RŒõ ts and RŒõ st . If we could show that
{œÜ | GœÜ ‚àà t} ‚à™ {F œà | œà ‚àà t } was consistent we would have the desired result208
4 Completeness
(for by the Lemmas 4.19 and 4.35, any MCS extending this set would be a suitable
choice for s).
So suppose for the sake of contradiction that this set is not consistent. Then, for
some Ô¨Ånite set of formulas œÜ1 , . . . , œÜm , œà1 , . . . , œàn from this set,
Œõ (œÜ1 ‚àß ¬∑ ¬∑ ¬∑ ‚àß œÜm ‚àß F œà1 ‚àß ¬∑ ¬∑ ¬∑ ‚àß F œàn ) ‚Üí‚ä• .
DeÔ¨Åne œÜ to be œÜ1 ‚àß ¬∑ ¬∑ ¬∑ ‚àß œÜm and œà to be œà1 ‚àß ¬∑ ¬∑ ¬∑ ‚àß œàn . Note that œà ‚àà t .


Now, Œõ F œà ‚Üí F œà1 ‚àß¬∑ ¬∑ ¬∑‚àßF œàn , hence Œõ œÜ‚àßF
œà ‚Üí‚ä•, hence Œõ œÜ ‚Üí ¬¨F œà,
 Because GœÜ1 , . . . , GœÜm ‚àà t, we have that GœÜ ‚àà t
and hence Œõ GœÜ ‚Üí G¬¨F œà.

too, hence G¬¨F œà ‚àà t, and hence ¬¨G¬¨F œà ‚àà t. That is, F F œà ‚àà t. But this
means that F œà ‚àà t, as (by uniform substitution in den) Fœà ‚Üí F F œà ‚àà t. But
now we have a contradiction: as œà ‚àà t and RŒõ tt , F œà must be in t. We conclude
that {œÜ | GœÜ ‚àà t} ‚à™ {F œà | œà ‚àà t } is consistent after all. (Note that this proof
makes no use of the converse axioms, thus we have also proved that 3p ‚Üí 33p
is canonical for density.)
So it only remains to ensure trichotomy ‚Äì but here we encounter an instructive
difÔ¨Åculty. Because modal (and temporal) validity is preserved under the formation
of disjoint unions (see Theorem 3.14) no formula of tense logic deÔ¨Ånes trichotomy.
Moreover, a little experimentation will convince the reader that canonical frames
may have disjoint point generated subframes; such canonical frames are clearly
not trichotomous. In short, to prove the desired completeness result we need to
build a model with a property for which no modal formula is canonical. This is
the problem we encounter time and time again when proving semantically driven
results.
In the present case, a little lateral thinking leads to a solution. First, let us get rid
of a possible preconception. Until now, we have always used the entire canonical
model ‚Äì but we do not need to do this. A point generated submodel sufÔ¨Åces. More
precisely, if MŒõ , w  Œì , then as modal satisfaction is preserved in generated
submodels (see Proposition 2.6) S, w  Œì , where S is the submodel of MŒõ
generated by w.
The observation is trivial, but its consequences are not. By restricting our at-
tention to point-generated submodels, we increase the range of properties we can
impose. In particular, we can impose trichotomy on point-generated submodels.
We met the relevant axioms when working with the basic modal language. From
our discussion of S4.3 and K4.3 (in particular, Exercise 4.3.3) we know that
(.3r )
(F p ‚àß F q) ‚Üí F (p ‚àß F q) ‚à® F (p ‚àß q) ‚à® F (q ‚àß F p)
is canonical for no-branching-to-the-right. Analogously
(.3l )
(P p ‚àß P q) ‚Üí P (p ‚àß P q) ‚à® P (p ‚àß q) ‚à® P (q ‚àß P p).4.3 Applications
209
is canonical for no-branching-to-the-left. Call a frame with no branching to the left
or right a non-branching frame.
Proposition 4.39 Any trichotomous frame (T, R) is non-branching. Furthermore,
if R is transitive and non-branching and t ‚àà T , then the subframe of (T, R) gen-
erated by t is trichotomous.
Proof. Trivial ‚Äì though the reader should recall that when forming generated sub-
frames for the basic temporal language, we generate on both the relation corre-
sponding to F and that corresponding to P . That is, we generate both forwards
and backwards along R.
In short, although no formula is canonical for trichotomy, there is a good ‚Äòap-
proximation‚Äô to it (namely, the non-branching property) for which we do have a
canonical formula (namely, the conjunction of .3l and .3r ). With this observed, the
desired result is within reach.
DeÔ¨Ånition 4.40 Let Kt Q be the smallest tense logic containing 4, Dl , Dr , den, .3l
and .3r .
Theorem 4.41 Kt Q is strongly complete with respect to the class of DUWTO-
frames.
Proof. If Œì is a Kt Q-consistent set of formulas, extend it to a Kt Q-MCS Œì + . Let
M be the canonical model for Kt Q, and let S be the submodel of M generated
by Œì + . As we just noted, S, Œì +  Œì . Moreover, the frame underlying S is
a DUWTO-frame as required. First, as Kt Q contains axioms that are canonical
for transitivity, unboundedness, and density, M has these properties; it is then not
difÔ¨Åcult to show that S has them too. Moreover, as the conjunction of .3l and .3r
is canonical for non-branching, M is non-branching and S trichotomous.
To conclude, two important remarks. First, the need to build models possessing
properties for which no formula is canonical is the fundamental difÔ¨Åculty facing
semantically driven results. In the present case, a simple idea enabled us to bypass
the problem ‚Äì but we will not always be so lucky and in the second part of the
chapter we develop more sophisticated techniques for tackling the issue.
Second, the relationships between completeness, canonicity and correspondence
are absolutely fundamental to the study of normal modal logics. These relation-
ships are further discussed in the following section, and explored algebraically in
Chapter 5, but let us immediately mention one of the most elegant positive results
in the area: the Sahlqvist Completeness Theorem. In Chapter 3 we proved the
Sahlqvist Correspondence Theorem: every Sahlqvist formula deÔ¨Ånes a Ô¨Årst-order
class of frames. Here is its completeness theoretic twin, which we will prove in
Chapter 5:210
4 Completeness
Theorem 4.42 Every Sahlqvist formula is canonical for the Ô¨Årst-order property
it deÔ¨Ånes. Hence, given a set of Sahlqvist axioms Œ£, the logic KŒ£ is strongly
complete with respect to the class of frames FŒ£ (that is, the Ô¨Årst-order class of
frames deÔ¨Åned by Œ£).
This is an extremely useful result. Most commonly encountered axioms in the
basic modal language are Sahlqvist (the L√∂b and McKinsey formulas are the ob-
vious exceptions) thus it provides an immediate answer to a host of completeness
problems. Moreover, like the Sahlqvist Correspondence Theorem, the Sahlqvist
Completeness Theorem applies to modal languages of arbitrary similarity type.
Finally, the theorem generalizes to a number of extended modal logics, most no-
tably D-logic (which we introduce in Chapter 7). Note that Kracht‚Äôs Theorem (see
Chapter 3) can be viewed as providing a sort of ‚Äòconverse‚Äô to Sahlqvist‚Äôs result, for
it gives us a way of computing formulas that are canonical for certain Ô¨Årst-order
classes of frames.
Exercises for Section 4.3
4.3.1 Let 1.1 be the axiom 3p ‚Üí 2p. Show that K1.1 is sound and strongly complete
with respect to the class of all frames (W, R) such that R is a partial function.
4.3.2 Let Œõ be a normal temporal logic containing the axioms p ‚Üí GP p and p ‚Üí HF p.
Show that if RPŒõ ts then RFŒõ st, and if RFŒõ ts then RPŒõ st.
4.3.3 Use canonical models to show that K4.3 is strongly complete with respect to the class
of frames that are transitive and have no branching to the right. Then, by proving suitable
completeness results (and making use of the soundness results proved in Exercise 4.1.4),
show that the normal logic axiomatized by 4 and 2(p ‚àß 2p ‚Üí q) ‚à® 2(q ‚àß 2q ‚Üí p) is
K4.3. Try proving the equivalence of these logics syntactically.
Formulate and prove similar results for S4.3.
4.3.4 Prove directly that 32p ‚Üí 23p is canonical for the Church-Rosser property.
4.3.5 Let W5 be the formula 32p ‚Üí (p ‚Üí 2p), and let S4W5 be the smallest normal
logic extending S4 that contains W5. Find a simple class of frames that characterizes this
logic.
4.3.6 Show that S5 is complete with respect to the the class of globally related frames,
that is, those frames (W, R) in which R connects any two points.
4.3.7 Consider a similarity type œÑ with one binary operator . For each of the following
Sahlqvist formulas, Ô¨Årst compute the (global) Ô¨Årst-order correspondent. Then, give a direct
proof that the modal formula is canonical for the corresponding Ô¨Årst-order property.
(a) pq ‚Üí qp,
(b) (pq)r ‚Üí p(qr),
(c) ((q¬¨(pq)) ‚àß p) ‚Üí ‚ä•.4.4 Limitative Results
211
4.4 Limitative Results
Although completeness-via-canonicity is a powerful method, it is not infallible.
For a start, not every normal modal logic is canonical. Moreover, not every normal
logic is the logic of some class of frames. In this section we prove both claims and
discuss their impact on modal completeness theory.
We Ô¨Årst demonstrate the existence of non-canonical logics. We will show that
KL, the normal modal logic generated by the L√∂b axiom 2(2p ‚Üí p) ‚Üí 2p,
is not canonical. We prove this by showing that KL is not sound and strongly
complete with respect to any class of frames. Now, every canonical logic is sound
and strongly complete with respect to some class of frames. (For suppose Œõ is a
canonical logic and Œì is a Œõ-consistent set of formulas. By the Truth Lemma, Œì is
satisÔ¨Åable on FŒõ ; as Œõ is canonical, FŒõ is a frame for Œõ.) Hence if KL is not sound
and strongly complete with respect to any class of frames, it cannot be canonical
either.
Theorem 4.43 KL is not sound and strongly complete with respect to any class of
frames, and hence it is not canonical.
Proof. Let Œì be {3q1 } ‚à™ {2(qi ‚Üí 3qi+1 ) | 1 ‚â§ i ‚àà œâ}. We will show that Œì is
KL-consistent, and that no model based on a KL-frame can satisfy all formulas in
Œì at a single point. The theorem follows immediately.
To show that Œì is consistent, it sufÔ¨Åces to show that every Ô¨Ånite subset Œ® of Œì is
consistent. Given any such Œ® , for some natural number n there is a Ô¨Ånite set Œ¶ of
the form {3q1 } ‚à™ {2(qi ‚Üí 3qi+1 ) | 1 ‚â§ i < n} such that Œ® ‚äÜ Œ¶ ‚äÇ Œì . We show
that Œ¶, and hence Œ® , is consistent.
 be the conjunction of all the formulas in Œ¶. To show that Œ¶
 is KL-
Let Œ¶
consistent, it sufÔ¨Åces to show that it can be satisÔ¨Åed in a model based on a frame for
 is not valid on all frames for KL, and hence is not one
KL, for this shows that ¬¨Œ¶
of its theorems. Let F be the frame consisting of {0, . . . , n} in their usual order; as
this is a transitive, converse well-founded frame, by Example 3.9 it is a frame for
KL. Let M be any model based on F such that for all 1 ‚â§ i ‚â§ n, V (qi ) = {i}.
 and Œ¶
 is KL consistent.
Then M, 0  Œ¶
Next, suppose for the sake of a contradiction that KL is sound and strongly com-
plete with respect to some class of frames F; note that as KL is not the inconsistent
logic, F must be non-empty. Thus any KL-consistent set of formulas can be satis-
Ô¨Åed at some point in a model based on a frame in F. In particular, there is a model
M based on a frame in F and a point w in M such that M, w  Œì . But this is
impossible: because M, w  Œì , we can inductively deÔ¨Åne an inÔ¨Ånite path through
M starting at w; however as M is based on a frame for KL it cannot contain such
inÔ¨Ånite paths. Hence KL is not sound and strongly complete with respect to any
class of frames, and so cannot be canonical.212
4 Completeness
Remark 4.44 A normal logic Œõ is said to be compact when any Œõ-consistent set
Œ£ can be satisÔ¨Åed in a frame for Œõ at a single point. So the above proof shows that
KL is not compact. Note that a non-compact logic cannot be canonical, and cannot
be sound and strongly complete with respect to any class of frames. We will see a
similar compactness failure when we examine PDL in Section 4.8.
What are we to make of this result? The reader should not jump to the conclusion
that it is impossible to characterize KL as the logic of some class of frames. Al-
though no strong frame completeness result is possible, as we noted in Table 4.1
there is an elegant weak frame completeness result for KL, namely:
Theorem 4.45 KL is weakly complete with respect to the class of all Ô¨Ånite transi-
tive trees.
Proof. The proof uses the Ô¨Ånitary methods studied later in the chapter. The reader
is asked to prove the theorem in Exercises 4.8.7 and 4.8.8.
Thus KL is the logic of all Ô¨Ånite transitive trees ‚Äì and there exist non-canonical
but (weakly) complete normal logics. We conclude that, powerful though it is, the
completeness-via-canonicity method cannot handle all interesting frame complete-
ness results.
Let us turn to the second conjecture: are all normal logics weakly complete with
respect to some class of frames? No: incomplete normal logics exist.
DeÔ¨Ånition 4.46 Let Œõ be a normal modal logic. Œõ is (frame) complete if there is a
class of frames F such that Œõ = ŒõF , and (frame) incomplete otherwise.
We now demonstrate the existence of incomplete logics in the basic temporal lan-
guage. The demonstration has three main steps. First, we introduce a tense logic
called Kt Tho and show that it is consistent. Second, we show that no frame
for Kt Tho can validate the McKinsey axiom (which in tense logical notation is
GF œÜ ‚Üí F GœÜ). It is tempting to conclude that Kt ThoM, the smallest tense logic
containing both Kt Tho and the McKinsey axiom, is the inconsistent logic. Sur-
prisingly, this is not the case. Kt ThoM is consistent ‚Äì and hence is not the tense
logic of any class of frames at all. We prove this in the third step with the help of
general frames.
Kt Tho is the tense logic generated by the following axioms:
(.3r )
(Dr )
(Ll )
F p ‚àß F q ‚Üí F (p ‚àß F q) ‚à® F (p ‚àß q) ‚à® F (F p ‚àß q)
Gp ‚Üí F p
H(Hp ‚Üí p) ‚Üí Hp
As we have already seen, the Ô¨Årst two axioms are canonical for simple Ô¨Årst-order
conditions (no branching to the right, and right-unboundedness, respectively). The4.4 Limitative Results
213
third axiom is simply the L√∂b axiom written in terms of the backwards looking
operator H; it is valid on precisely those frames that are transitive and contain no
inÔ¨Ånite descending paths. (Note that such frames cannot contain reÔ¨Çexive points.)
Let Kt Tho be the tense logic generated by these three axioms. As all three axioms
are valid on the natural numbers, Kt Tho is consistent. If (T, R) is a frame for
Kt Tho and t ‚àà T , then {u ‚àà T | Rtu} is a right-unbounded strict total order.
Now for the second step. Let Kt ThoM be the smallest tense logic containing
Kt Tho and the McKinsey axiom GF p ‚Üí F Gp. What are the frames for this
enriched logic? The answer is: none at all, or, to put it another way, Kt ThoM
deÔ¨Ånes the empty class of frames. To see this we need the concept of coÔ¨Ånality.
DeÔ¨Ånition 4.47 Let (U, <) be a strict total order and S ‚äÜ U . S is coÔ¨Ånal in U if
for every u ‚àà U there is an s ‚àà S such that u < s.
For example, both the even numbers and the odd numbers are coÔ¨Ånal in the natural
numbers. Indeed, they are precisely the kind of coÔ¨Ånal subsets we will use in the
work that follows: mutually complementary coÔ¨Ånal subsets.
Lemma 4.48 Let T be any frame for Kt Tho. Then T  GF p ‚Üí F Gp.
Proof. Let t be any point in T, let U = {u ‚àà T | Rtu}, and let < be the restriction
of R to U . As T validates all the Kt Tho axioms, (U, <) is a right-unbounded strict
total order. Suppose we could show that there is a non-empty proper subset S of
U such that both S and U \S are coÔ¨Ånal in U . Then the lemma would be proved,
for we would merely need to deÔ¨Åne a valuation V on T such that V (p) = S, and
(T, V ), t  GF p ‚Üí F Gp.
Such subsets S of U exist by (3.18) in Example 3.57. For a more direct proof,
take a cardinal Œ∫ that is larger than the size of U . By ordinal induction, we will
deÔ¨Åne a sequence of pairs of sets (RŒ± , SŒ± )Œ±‚â§Œ∫ such that RŒ∫ ‚à© SŒ∫ = ‚àÖ and both
RŒ∫ and SŒ∫ are coÔ¨Ånal. We can easily prove the lemma from this by taking S = SŒ∫ .
The deÔ¨Ånition is as follows:
(i) For Œ± = 0, take some points r0 and s0 in U such that r0 < s0 and deÔ¨Åne
R0 = {r0 } and S0 = {s0 }.
(ii) If Œ± is a successor ordinal Œ≤ + 1, then distinguish two cases:
(a) if RŒ≤ or SŒ≤ is coÔ¨Ånal, then deÔ¨Åne RŒ± = RŒ≤ and SŒ± = SŒ≤ ,
(b) if neither RŒ≤ nor SŒ≤ is coÔ¨Ånal, then take some upper bound rŒ≤ of
SŒ≤ (that is, rŒ≤ > s for all s ‚àà SŒ≤ ), take some sŒ≤ bigger than rŒ≤ and
deÔ¨Åne RŒ± = RŒ≤ ‚à™ {rŒ≤ } and SŒ± = SŒ≤ ‚à™ {sŒ≤ }.
(iii) If Œ± is a limit ordinal, then deÔ¨Åne RŒ± =
Œ≤<Œ± RŒ≤ and SŒ± =
Œ≤<Œ± SŒ≤ .
It is easy to prove that RŒ± ‚à© SŒ± = ‚àÖ for every ordinal Œ± ‚â§ Œ∫, so it remains to
be shown that both RŒ∫ and SŒ∫ are coÔ¨Ånal. The key to this proof is the observation214
4 Completeness
that if RŒ∫ and SŒ∫ were not coÔ¨Ånal, then the map f : Œ∫ ‚Üí U given by f : Œ± ‚Üí
rŒ±+1 would be injective (further proof details are left to the reader). This would
contradict the assumption that Œ∫ exceeds the size of U .
We are ready for the Ô¨Ånal step. As Kt ThoM deÔ¨Ånes the empty class of frames, it is
tempting to conclude that it is also complete with respect to this class; that is, that
Kt ThoM is the inconsistent logic. However, this is not the case.
Theorem 4.49 Kt ThoM is consistent and incomplete.
Proof. Let (N, <) be the natural numbers in their usual order. Let A be the col-
lection of Ô¨Ånite and co-Ô¨Ånite subsets of N; we leave it to the reader to show that
A is closed under boolean combinations and modal operations. Thus (N, <, A) is
a general frame; we claim that it validates all the Kt ThoM axioms. Now, it cer-
tainly validates all the Kt Tho axioms, for these are already valid on the underlying
frame. But what about M? As we noted in Example 1.34, GF p ‚Üí F Gp cannot be
falsiÔ¨Åed under assignments mapping p to either a Ô¨Ånite or a co-Ô¨Ånite set. Hence all
the axioms are valid and Kt ThoM must be consistent.
Now, by Lemma 4.48, Kt ThoM is not the logic of any non-empty class of
frames. But as Kt ThoM is consistent, it is not the logic of the empty class of
frames either. In short, it is not the logic of any class of frames whatsoever, and is
incomplete.
Frame incompleteness results are not some easily Ô¨Åxed anomaly. As normal logics
are sets of formulas closed under three rules of proof, the reader may be tempted to
think that these rules are simply too weak. Perhaps there are yet-to-be-discovered
rules which would strengthen our deductive apparatus sufÔ¨Åciently to overcome in-
completeness? (Indeed, later in the chapter we introduce an additional proof rule,
and it will turn out to be very useful.)
Nonetheless, no such strengthening of our deductive apparatus can eliminate
frame incompleteness. Why is this? Ultimately it boils down to something we
learned in Chapter 3: frame consequence is essentially a second-order relation.
Moreover, as we discussed in the Notes to Chapter 3, it is a very strong relation
indeed: strong enough to simulate the standard second-order consequence relation.
Frame incompleteness results reÔ¨Çect the fact that (over frames) modal logic is sec-
ond order logic in disguise. Hence, it will come as no surprise that incompleteness
hits every modal similarity type: in Exercise 4.4.2 we meet an example in the basic
modal similarity type. However, examples (such as Kt ThoM) of consistent logics
with an empty frame class cannot be found for the basic modal similarity type, as
the reader is asked to prove in Exercise 4.4.3.
There are many incomplete logics. Indeed, if anything, incomplete logics are
the norm. An analogy may be helpful. When differential calculus is Ô¨Årst encoun-4.4 Limitative Results
215
tered, most students have rather naive ideas about functions and continuity; poly-
nomials, and other simple functions familiar from basic physics, are taken to be
typical of all real-valued functions. The awakening comes with the study of anal-
ysis. Here the student encounters such specimens as everywhere-continuous but
nowhere-differentiable functions ‚Äì and comes to see that the familiar functions are
actually abnormally well-behaved. The situation is much the same in modal logic.
The logics of interest to philosophers ‚Äì logics such as T, S4 and S5 ‚Äì were the Ô¨Årst
to be semantically characterized using frames. It is tempting to believe that such
logics are typical, but they are actually fairly docile creatures; the lattice of normal
logics contains far wilder inhabitants.
The signiÔ¨Åcance of the incompleteness results depends on one‚Äôs goals. Logi-
cians interested in applications are likely to focus on certain intended classes of
models, and completeness results for these classes. Beyond providing a salutary
warning about the folly of jumping to hasty generalizations, incompleteness results
are usually of little direct signiÔ¨Åcance here. On the other hand, for those whose pri-
mary interest is syntactically driven completeness results, the results could hardly
be more signiÔ¨Åcant: they unambiguously show the inadequacy of frame-based clas-
siÔ¨Åcations. Unsurprisingly, this has had considerable impact on the study of modal
logic. For a start, it lead to a rebirth of interest in alternative tools ‚Äì and, in partic-
ular, to the renaissance of algebraic semantics, which we will study in Chapter 5.
Moreover, it has lead modal logicians to study new types of questions. Let us
consider some of the research themes that have emerged.
One response has been to look for general syntactic constraints on axioms which
guarantee canonicity. The most elegant such result is the Sahlqvist Completeness
Theorem, which we have already discussed. A second response has been to investi-
gate the interplay between completeness, canonicity, and correspondence. Typical
of the questions that can be posed is the following: If A1 , . . . , An are axioms that
deÔ¨Åne an elementary class of frames, is KA1 . . . An frame complete? (In fact,
the answer here is no ‚Äì as the reader is asked to show in Exercise 4.4.4.) The
most signiÔ¨Åcant positive result that has emerged from this line of enquiry is the
following:
Theorem 4.50 If F is a Ô¨Årst-order deÔ¨Ånable class of frames, then ŒõF is canonical.
Again, we prove this in Chapter 5 using algebraic tools (see Theorem 5.56). Tanta-
lizingly, at the time of writing the status of the converse was unknown: If a normal
modal logic Œõ is canonical, then there is a Ô¨Årst-order deÔ¨Ånable class of frames F
such that Œõ = ŒõF . This conjecture seems plausible, but neither proof nor coun-
terexample has been found.
A third response has been to examine particular classes of normal modal log-
ics more closely. The entire lattice may have undesirable properties ‚Äì but many216
4 Completeness
sub-regions are far better behaved. We will examine a particularly well-behaved
sub-region (namely, the normal logics extending S4.3) in the Ô¨Ånal section of this
chapter.
This concludes our survey of basic completeness theory. The next four sections
(all of which are on the basic track) explore the following issue: how are we to
prove completeness results when we need to build a model that has a property for
which no formula is canonical? Some readers may prefer to skip this for now and
go straight on to the following chapter. This discusses completeness, canonicity
and correspondence from an algebraic perspective.
Exercises for Section 4.4
4.4.1 Recall that any normal modal logic that has the Ô¨Ånite model property also has the
Ô¨Ånite frame property. What are the consequences of this for incomplete normal modal
logics?
4.4.2 The logic KvB consists of all formulas valid on the general frame J. The domain J
of J is N ‚à™ {œâ, œâ + 1} (the set of natural numbers together with two further points), and R
is deÔ¨Åned by Rxy iff x = œâ + 1 and y < x or x = œâ + 1 and y = œâ. (The frame (J, R)
is shown in Figure 6.2 on page 351.) A, the collection of subsets of J admissible in J,
consists of all X ‚äÜ J such that either X is Ô¨Ånite and œâ ‚àà X, or X is co-Ô¨Ånite and œâ ‚àà X.
(a) Show that 23() ‚Üí 2(2(2p ‚Üí p) ‚Üí p) is valid on J.
(b) Show that on any frame on which the previous formula is valid, 23() ‚Üí 2(‚ä•)
is valid too.
(c) Show that 23() ‚Üí 2(‚ä•) is not valid on J.
(d) Conclude that KvB is incomplete.
4.4.3 Prove that any consistent normal modal logic in the basic modal similarity type is
either valid on the frame consisting of a single reÔ¨Çexive point or valid on the frame con-
sisting of a single irreÔ¨Çexive point. (Hint: use the fact that either 2‚ä• is Œõ-consistent or
3 is a Œõ-theorem.)
Conclude that no consistent normal modal logic in the basic similarity type deÔ¨Ånes the
empty frame class.
4.4.4 Consider the formulas (T) p ‚Üí 3p, (M) 23p ‚Üí 32p, (E) 3(3p ‚àß 2q) ‚Üí 2(3p ‚à®
2q) and (Q) (3p ‚àß 2(p ‚Üí 2p)) ‚Üí p. Let Œõ denote the normal modal logic axiomatized
by these formulas.
(a) Prove that E corresponds to the following Ô¨Årst-order formula: ‚àÄxy 1 y2 ((Rxy1 ‚àß
Rxy2 ) ‚Üí (‚àÄz (Ry1 z ‚Üí Ry2 z) ‚à® ‚àÄz (Ry2 z ‚Üí Ry1 z))).
(b) Prove that within the class of frames validating both T and E, Q deÔ¨Ånes the frames
satisfying the condition RÀá ‚äÜ R‚àó (that is, if Rst then there is a Ô¨Ånite path back
from t to s).
(c) Prove that the conjunction of the four axioms deÔ¨Ånes the class of frames with a
trivial accessibility relation ‚Äì that is, T ‚àß M ‚àß E ‚àß Q corresponds to ‚àÄxy (Rxy ‚Üî
x = y). (Hint: consider the effect of the McKinsey formula on the frames satisfying
the condition RÀá ‚äÜ R‚àó .)4.5 Transforming the Canonical Model
217
(d) Consider the so-called veiled recession frame (N, R, A), where N is the set of natu-
ral numbers, Rmn holds iff m ‚â§ n+1 and A is the collection of Ô¨Ånite and co-Ô¨Ånite
subsets of N. Show that all four axioms are valid on this general frame, but that the
formula p ‚Üí 2p can be refuted.
(e) Conclude that Œõ is incomplete, although it deÔ¨Ånes an elementary class of frames.
(f) Does this contradict Theorem 4.50?
4.4.5 Given a class K of frames, let Œò(K) = Œõ K denote the set {œÜ | F  œÜ for all F in K }
and given a logic Œõ, let Fr(Œõ) denote the class of frames on which Œõ is valid.
(a) Show that the operations Œò and Fr form a so-called Galois connection. That is,
prove that for all classes K and logics Œõ:
Œõ ‚äÜ Œò(K) iff K ‚äÜ Fr(Œõ).
(b) What does it mean for a logic Œõ if Œõ = Œò(Fr(Œõ))? (Give an example of a logic for
which it does not hold.)
(c) What does it mean for a frame class K if K = Fr(Œò(K))? (Give an example of a
frame class for which it does not hold.)
4.5 Transforming the Canonical Model
What is the modal logic of partial orders? And what is the tense logic of strict total
orders? Such questions bring us face to face with the fundamental problem con-
fronting semantically driven completeness results. Partial orders are antisymmet-
ric, and strict total orders are irreÔ¨Çexive. No modal formula deÔ¨Ånes either property,
and (as the reader probably suspects) no formula is canonical for them either. Thus,
to answer either question, we need to build a model for which we lack a canoni-
cal formula ‚Äì and hence we will need to expand our repertoire of model building
techniques. This is the main goal of the present section and the three that follow.
In this section we explore a particularly natural strategy: transforming the canon-
ical model. Although a canonical model may lack some desired properties, it does
get a lot of things right. Perhaps it is possible to reshape it, transforming it into
a model with all the desired properties? We have done this once already, though
in a very simple way: in the completeness proof for Kt Q (see Theorem 4.41 and
surrounding discussion) we formed a point-generated submodel of the canonical
model to ensure trichotomy. Here we will study two more sophisticated transfor-
mations ‚Äì unraveling and bulldozing ‚Äì and use them to answer the questions with
which this section began.
It seems plausible that S4 is the modal logic of partial orders: Theorem 4.29 tells
us that S4 is complete with respect to the class of reÔ¨Çexive transitive frames (that
is, preorders) and there do not seem to be any modal formulas we could add to S4
to reÔ¨Çect antisymmetry. Furthermore, it seems reasonable to hope that we could
prove this using some sort of model transformation: as every S4-consistent set of
formulas can be satisÔ¨Åed on a preorder, and as we know that modal languages are
blind to antisymmetry (at least as far as frame deÔ¨Ånability is concerned) maybe we4 Completeness
218
t
t
@
R t 
t
t
@
Rt
@
Rt
@
Rt
@
Rt
..
.
Fig. 4.1. A model and its unraveling
can Ô¨Ånd a way of transforming any satisfying preorder into a partial order without
affecting satisÔ¨Åability? (It is worth stressing that this informal line of argument is
not a proof; it is intended solely to motivate the work that follows.)
A transformation called unraveling will enable us do this. Indeed, unraveling
will let us prove the stronger result that S4 is complete with respect to the class of
reÔ¨Çexive and transitive trees. (This will be useful in Chapter 6 when we discuss
decidability). We brieÔ¨Çy discussed unraveling in Chapter 2, where we used it to
show that modal logic has the tree property (see Proposition 2.15). Informally,
given any model, unraveling builds a new model, whose points are paths of the
original model. That is, transition sequences in the original model are explicitly
represented as states in the unraveled model. More precisely:
DeÔ¨Ånition 4.51 (Unraveling) Let (W, R) be a frame generated by some point w ‚àà
 , R)
 where:
W . The unraveling of (W, R) around w is the frame (W
 is the set of all Ô¨Ånite sequences (w, w1 , . . . , wn ) such that w1 , . . . , wn ‚àà
(i) W
W and Rww1 , . . . , Rwn‚àí1 wn , and
 , then R
 s1s2 if there is some v ‚àà W such that s1 + (v) = s2 ,
(ii) If s1 , s2 ‚àà W
where + denotes sequence concatenation.
 , R)
 is the unraveling of (W, R) around w,
If M = (W, R, V ) is a model and (W
 on (W
 , R)
 as follows:
then we deÔ¨Åne the valuation V
 (p) = {(w, w1 , . . . , wn ) ‚àà W
 | wn ‚àà V (p)}
V
 = (W
 , R,
 V
 ) is called the unraveling of M around w.
The model M
A simple example is given in Figure 4.1. As this example suggests (and as the
reader should check) unraveling any frame around a generating point w yields an
irreÔ¨Çexive, intransitive, and asymmetric frame. Indeed, note that unraveled frames
 is just the familiar
are trees: the root node is the sequence (w), and the relation R
(immediate) successor (or daughter-of) relation on trees.
 = (W
 , R,
 V
 ) be the unraveling of M = (W, R, V ) around
Lemma 4.52 Let M4.5 Transforming the Canonical Model
219
 , R),
 and M is a bounded
w. Then (W, R) is a bounded morphic image of (W

morphic image of M.
 ‚Üí W be deÔ¨Åned by f (w, w1 , . . . , wn ) = wn . It is easy to see
Proof. Let f : W
 , s
that f is surjective, has the back and forth properties, and that for any s ‚àà W
and f (s) satisfy the same propositional variables.
A simple corollary is that any satisÔ¨Åable set of formulas is satisÔ¨Åable on a (irreÔ¨Çex-
ive, intransitive, and asymmetric) tree: for if a set of formulas is satisÔ¨Åable, it is
satisÔ¨Åable on a point-generated model (take the submodel generated by the satis-
fying point), hence by unraveling we have the result. It follows that K is (strongly)
complete with respect to this class of models.
But our real interest is S4. How do we use unraveling to make the partially or-
dered models we require for the completeness result? In the most obvious way
possible: we simply take the reÔ¨Çexive transitive closures of unraveled models.
More precisely, suppose we unravel M around some generating point w to obtain
 , R,
 V ). Now consider the model M‚àó = (W
 , R‚àó , V
 ) where R‚àó is the reÔ¨Çexive
(W
 Trivially, M‚àó is an S4 model. Moreover, as (W
 , R)
 is a
transitive closure of R.
‚àó
 , R ) is an antisymmetric frame. Indeed, it is a reÔ¨Çexive and transitive
tree, (W
tree, for R‚àó is simply the familiar dominates (or ancestor-of) relation on trees. So
only one question remains: is M a bounded morphic image of M‚àó ? In general, no.
But if the model M we started with was itself reÔ¨Çexive and transitive, yes:
Lemma 4.53 Let M = (W, R, V ) be a reÔ¨Çexive transitive model generated by
 , R,
 V
 ) be the unraveling of M around w. Let R‚àó be the
some w ‚àà W , and let (W
 and deÔ¨Åne M‚àó to be (W
 , R‚àó , V ). Then M is a
reÔ¨Çexive transitive closure of R,
‚àó
bounded morphic image of M .
Proof. It is easy to see that the function f deÔ¨Åned in Lemma 4.52 remains the
required bounded morphism; as far as surjectivity, the back property, and the dis-
tribution of proposition letters are concerned, nothing has changed. We only have
 does not harm the forth
to check that taking the reÔ¨Çexive transitive closure of R
property. But, as R is itself reÔ¨Çexive and transitive, the forth property survives.
Theorem 4.54 S4 is strongly complete with respect to the class of partially or-
dered reÔ¨Çexive and transitive trees.
Proof. If Œ£ is an S4-consistent set of formulas, and Œ£+ is an S4-MCS extending
Œ£, then MS4 , Œ£ +  Œ£. Moreover, as the S4 axioms are canonical, MS4 is a
reÔ¨Çexive transitive model. We now transform this model into the required partial
order in two steps.
Step 1. Let MS be the submodel of MS4 generated by Œ£+ . Clearly this is a
reÔ¨Çexive, transitive, point-generated model such that MS , Œ£ +  Œ£.220
4 Completeness
 , R‚àó , V ) be the reÔ¨Çexive transitive closure of the unraveling
Step 2. Let M‚àó = (W
of MS around Œ£+ .
By Lemma 4.53, MS is a bounded morphic image of M‚àó under f , hence for all
sequences s ‚àà f ‚àí1 [Œ£], we have M‚àó , s  Œ£, and by the surjectivity of f there is at
least one such s. Hence we have satisÔ¨Åed Œ£ on a reÔ¨Çexive and transitive tree.
The previous proof could be summed up as follows: we found a way to use the
information in a canonical model indirectly. The canonical model for S4 did not
have the structure we wanted ‚Äì nonetheless, we successfully tapped into the in-
formation it contained via a short sequence of bisimulations (M‚àó had MS as a
bounded morphic image, and MS was a generated submodel of MS4 ).
Unraveling is an intrinsically global transformation that can change a model‚Äôs
geometry drastically. This is in sharp contrast to the transformation we will now
examine ‚Äì bulldozing ‚Äì which works locally, and (in spite of its name) rather more
gently. We will use bulldozing to answer the second of the questions posed above.
Recall that a strict total order (STO) is a relation that is transitive, trichotomous
and irreÔ¨Çexive. The class of strict total orders contains such important structures as
(N, <), (Z, <), (Q, <), and (R, <) (the natural numbers, the integers, the rationals
and the reals in their usual order) and is widely used to model various temporal
phenomena. What is its tense logic?
Once again, it is not hard to Ô¨Ånd a plausible candidate: Kt 4.3, the tense logic
generated by 4, .3l and .3r , seems the only reasonable candidate. For a start, Kt 4.3
is strongly complete with respect to the class of weak total orders. (To see this,
observe that the axioms are canonical for transitivity and non-branching. Hence
any point generated submodel MS of the canonical model is transitive and tri-
chotomous, and the completeness result is immediate.) Moreover, there simply are
no other plausible axioms ‚Äì in particular, irreÔ¨Çexivity is not deÔ¨Ånable. Has this
(somewhat dangerous) line of reasoning led to the right answer? Let us see.
If we could Ô¨Ånd a way of transforming weakly linear models into strictly linear
models we would have the desired completeness result. Note that unraveling will
not help ‚Äì it would turn the weak total order into a tree, thus destroying trichotomy.
If only we could Ô¨Ånd a method which replaced the undesirable parts of the model
with some suitable STO, and left the good parts untouched: then trichotomy would
not be affected, and we would have assembled the required strict total order. Bull-
dozing is a way of doing this. The Ô¨Årst step is to pin down what the ‚Äòundesirable‚Äô
parts of weak total orders are. The obvious response is ‚ÄòreÔ¨Çexive points‚Äô ‚Äì but
while this is not exactly wrong, it misses the crucial insight. The entities we really
need to think about are clusters, introduced in Chapter 2. We repeat the deÔ¨Ånition:
DeÔ¨Ånition 4.55 Let (T, R) be a transitive frame. A cluster on (T, R) is a subset
C of T that is a maximal equivalence relation under R. That is, the restriction of4.5 Transforming the Canonical Model
221
R to C is an equivalence relation, and this is not the case for any other subset D
of T such that C ‚äÇ D. A cluster is simple if it consists of a single reÔ¨Çexive point,
and proper if it contains more than one point. When we say that a model contains
clusters, we mean that its underlying frame does.
The point is this: we should not think in terms of removing isolated reÔ¨Çexive points;
rather, we should remove entire clusters at one stroke. (Intuitively, the information
in a cluster is information that ‚Äòbelongs together.‚Äô) Any transitive trichotomous
frame can be thought of as a strictly totally ordered collection of clusters (cf. Exer-
cise 1.1.1). If we could remove each cluster as a single chunk, and replace it with
something equivalent, we would have performed a local model transformation.
So the key question is: what should we replace clusters with? Clearly some sort
of STO ‚Äì but how can we do this in a truth preserving way? Note that any cluster C,
even a simple one, introduces an inÔ¨Ånity of information recurrence in both the for-
wards and backwards directions: we can follow paths within C, moving forwards
and backwards, for as long as we please. Thus, when we replace a cluster C with a
STO, we must ensure that the STO duplicates all the information in C inÔ¨Ånitely of-
ten, in both directions. Bulldozing does precisely this in a straightforward way. We
simply impose a strict total order on the cluster (that is, we pick some path through
the cluster that visits each point once and only once) and then lay out inÔ¨Ånitely
many copies of this path in both the forwards and backwards direction. We then
replace the cluster by the inÔ¨Ånite repetition of the chosen path. We have squashed
the clusters down into inÔ¨Ånitely long STOs ‚Äì hence the name ‚Äòbulldozing‚Äô.
Theorem 4.56 Kt 4.3 is strongly complete with respect to the class of strict total
orders.
Proof. Let Œ£ be a Kt 4.3-consistent set of formulas; expand it to a Kt 4.3-MCS
Œ£ + . Let M = (T, R, V ) be the canonical model for Kt 4.3. By the canonicity
of the axioms, M is transitive and non-branching. Let MS = (S, RS , V S ) be the
submodel of M generated by Œ£+ ; MS is a transitive and trichotomous model such
that MS , Œ£ +  Œ£. But MS may contain clusters, which we will bulldoze away.
Step 1. Index the clusters in MS by some suitable set I.
Step 2. DeÔ¨Åne an arbitrary strict total order <i on each cluster Ci .
Step 3. DeÔ¨Åne Ci to be Ci √ó Z. (Z is the set of integers.)
Step 4. DeÔ¨Åne B, the set underlying the bulldozed model, to be
S‚àí ‚à™
Ci ,
i‚ààI
where S ‚àí is the set (S \ i‚ààI Ci ) of points not belonging to any cluster.
Step 5. DeÔ¨Åne a mapping Œ≤ : B ‚Üí S by: Œ≤(b) = b, if b ‚àà S‚àí ; and Œ≤(b) = s, if
b = (s, z).222
4 Completeness
Step 6. DeÔ¨Åne an ordering <b on B by b <b b iff
either (b ‚àà S ‚àí or b ‚àà S ‚àí ) and Œ≤(b)RS Œ≤(b );
or b = (s, z) and b = (s , z  ) and
either s and s belong to distinct clusters and Œ≤(b)RS Œ≤(b );
or s and s belong to the same cluster and z <Z z  (where <Z is
the usual ordering on the integers);
or s and s belong to the same cluster Ci and z = z and s <i s .
Step 7. DeÔ¨Åne a valuation V b on (B, <b ) by b ‚àà V (p) iff Œ≤(b) ‚àà V S (p).
Step 8. DeÔ¨Åne MB , the bulldozed model, to be (B, <b , V b ).
We now make the following claims:
Claim 1. The mapping Œ≤ is a surjective bounded morphism from (B, <b ) to
(S, RS ), and the model MS is a bounded morphic image of MB under Œ≤.
Claim 2. (B, <b ) is a strict total order.
Proving these claims is a matter of checking the deÔ¨Ånitions; we leave this to the
reader as Exercise 4.5.5. With this done, the theorem is immediate. By Claim 1,
for any b ‚àà Œ≤‚àí1 (Œ£ + ) we have MB , b  Œ£, and since Œ≤ is surjective, there is at
least one such b. Thus B is a model of Œ£, and by Claim 2 it has the structure we
want.
Although it works more locally, like unraveling, bulldozing is a way of using the
information in canonical models indirectly. Indeed, like unraveling, it accesses
the information in the relevant canonical model via a sequence of bisimulations:
the Ô¨Ånal model MB had MS as a bounded morphic image, and MS in turn was a
generated submodel of M.
Bulldozing is a Ô¨Çexible method. For example, we are not forced to deÔ¨Åne Ci to
be Ci √ó Z; any unbounded STO would do. Moreover, if we used a reÔ¨Çexive total
order (for example (Z, ‚â§)) instead, we could prove analogous completeness results
for reÔ¨Çexive total orders; for example, the reader is asked to show in Exercise 4.5.6
that St 4.3 is the logic of this class of frames. Moreover, for modal languages,
we only need to ensure inÔ¨Ånite information repetition in the forward direction, so
structures such as (N, <) and (N, ‚â§) sufÔ¨Åce.
But there are more interesting variations. For example, instead of simply or-
dering the points in the cluster, one can embed the cluster in some suitable total
order, and work with its embedded image instead. By embedding the clusters in a
dense set, it is possible to build dense totally ordered models. And by combining
such ideas with other transformations (notably Ô¨Åltrations) the method can be used
to prove many classic completeness results of modal and tense logics.
Model manipulation methods, and completeness proofs making use of them,4.6 Step by Step
223
abound. Further examples are mentioned in the Notes, but it is not remotely possi-
ble to be encyclopedic: such methods trade on speciÔ¨Åc insights into the geometry
of relational structures, and this gives rise to a wide variety of variants and combi-
nations. The reader should certainly be familiar with such methods ‚Äì they are often
simple to adapt to speciÔ¨Åc problems ‚Äì but it is just as important to appreciate the
general point that has emerged from our discussion: even if the canonical model
is not quite what we need, it can still be extremely useful. The following section
further explores this theme.
Exercises for Section 4.5
4.5.1 K is complete with respect to the class of irreÔ¨Çexive frames. Unraveling shows this,
but there is a much simpler transformation proof. (Hint: given a model M, tinker with the
disjoint union of M with itself.)
4.5.2 Formulate the unraveling method for modal languages containing two diamonds.
Then formulate the method in such a way that bidirectional frames unravel into bidirec-
tional frames.
4.5.3 Consider a similarity type œÑ with one binary operator . Call a œÑ -frame F = (W, T )
acyclic if the binary relation R = {(s, t) ‚àà W 2 | T stu or T sut for some u ‚àà W } is
acyclic (that is to say, R + is irreÔ¨Çexive). Prove that the basic modal logic K œÑ is strongly
sound and complete with respect to the class of acyclic frames.
4.5.4 Show that the canonical model for K t Q contains proper clusters.
4.5.5 Prove Claims 1 and 2 of Theorem 4.56.
4.5.6 Let K t QT be the smallest normal temporal logic containing both K t Q and p ‚Üí F p.
Show, using a light bulldozing argument, that K t QT is strongly complete with respect to
the class of all dense unbounded reÔ¨Çexive total orders. (In this context of reÔ¨Çexive orders,
density refers to the property ‚àÄx‚àÄy ((Rxy ‚àß x = y) ‚Üí ‚àÉz (Rxz ‚àß x = z ‚àß Rzy ‚àß z = y)).)
4.6 Step by Step
Three main ideas underly the step-by-step method:
(i) Do not consider the entire canonical model to be the key ingredient of a
completeness proof. Rather, think of selections of MCSs from the canonical
model as the basic building blocks.
(ii) The standard way of proving completeness is by constructing a model for
a consistent set of formulas. Take the term ‚Äòconstructing‚Äô as literally as
possible: break it down into a sequence of steps.
(iii) Putting the Ô¨Årst two observations together, think of the construction of a
model as the stepwise selection of the needed MCSs. More precisely, think
of the model construction process as approaching a limit via a sequence224
4 Completeness
of ever better approximations, using local conÔ¨Ågurations of the canonical
model to make improvements at each step of the construction.
The method gives us enormous control over the models we build, and even at this
stage it is easy to see why. First, we do not have to worry about unpleasant features
of the canonical model (such as clusters) since we only work with selections of
the information that canonical structures contain. Furthermore, as we select our
information one step at a time, we obtain an iron grip on what ends up in the
model.
To illustrate the method‚Äôs potential, we use it to prove that the logic Kt Q de-
Ô¨Åned in DeÔ¨Ånition 4.40 is strongly complete with respect to (Q, <). In what fol-
lows, consistency means Kt Q-consistency, and Mc = (T c , Rc , V c ) is this logic‚Äôs
canonical model. Furthermore we Ô¨Åx a maximal consistent set Œ£; the goal of our
proof is to construct a model M = (T, <, V ) for Œ£ such that (T, <) is an ordering
which is isomorphic to (Q, <). At each step of the construction we will be dealing
with an approximation of M consisting of a strictly ordered Ô¨Ånite set of points (that
will ultimately end up) in T and for each of these, the set of all formulas that we
want to be the point‚Äôs modal type (that is, the set of formulas holding at the point).
DeÔ¨Ånition 4.57 A network is a triple N = (N, <, ŒΩ) such that R is a binary re-
lation on the set N , and ŒΩ is a labeling function mapping each point in N to a
maximal consistent set.
We are not interested in networks that are blatantly faulty as approximations of our
desired model. For example, we want < to be a strict total ordering. Moreover,
whenever a formula œà is in the label set of a point s, then F œà should be in ŒΩ(t) for
any t with t < s. Such requirements lead to the following deÔ¨Ånition.
DeÔ¨Ånition 4.58 A network N = (N, <, ŒΩ) is coherent if it satisÔ¨Åes:
(C1) < is a strict total ordering,
(C2) ŒΩ(s)Rc ŒΩ(t) for all s, t ‚àà N such that s < t.
A network for Œ£ is a network such that Œ£ is the label set of some node.
C1 and C2 are the minimal requirements for a network to be useful to us; note that
both requirements are universal. (C2 is equivalent to the requirement that if s < t
then F œÜ ‚àà ŒΩ(s) for all œÜ ‚àà ŒΩ(t) and P œÜ ‚àà ŒΩ(t) for all œÜ ‚àà ŒΩ(s).) But if a network
is to really resemble a model, it must also satisfy certain existential requirements.
DeÔ¨Ånition 4.59 A network N = (N, <, ŒΩ) is saturated if it satisÔ¨Åes:
(S1) < is unbounded to the left and to the right,
(S2) < is dense,4.6 Step by Step
225
(S3) N is modally saturated. That is, we demand that (F) if F œà ‚àà ŒΩ(s) for some
s ‚àà N , then there is some t ‚àà N such that s < t and œà ‚àà ŒΩ(t), and (P) if
P œà ‚àà ŒΩ(s) for some s ‚àà N , then there is some t ‚àà N such that t < s and
œà ‚àà ŒΩ(t).
A network is perfect if it is both coherent and saturated.
We want networks to give rise to models. Let us now check that we have imposed
sufÔ¨Åciently many criteria on networks to achieve this.
DeÔ¨Ånition 4.60 Let N = (N, <, ŒΩ) be a network. The frame FN = (N, <) is
called the underlying frame of N . The induced valuation VN on F is deÔ¨Åned by
VN (p) = {s ‚àà N | p ‚àà ŒΩ(s)}. The structure IN = (FN , VN ) is the induced
model.
The following lemma shows that our deÔ¨Ånition of perfection is the right one.
Lemma 4.61 (Truth Lemma) Let N be a countably inÔ¨Ånite perfect network. Then
for all formulas œà, and all nodes s in N ,
IN , s  œà iff œà ‚àà ŒΩ(s).
Moreover, FN is isomorphic to the ordering of the rational numbers.
Proof. The Ô¨Årst part of the proof is by induction on the degree of œà. The base case
is clear from the deÔ¨Ånition of the induced valuation, and the steps for the booleans
are straightforward. As for the modal operators, the coherency of N drives the left
to right implication through, and saturation takes care of the other direction.
Finally, the underlying frame of a perfect network must be a dense, unbounded,
strict total ordering. Hence, if it is countably inÔ¨Ånite, it must be isomorphic to
(Q, <) by Cantor‚Äôs Theorem. (Readers unfamiliar with this theorem should try
to prove this classic result from Ô¨Årst principles. The standard proof builds up the
isomorphism using a step-by-step argument!)
It follows from Lemma 4.61 that we have reduced the task of Ô¨Ånding a model for
our MCS Œ£ to the quest for a countable, perfect network for Œ£. And now we arrive
at the heart of the step-by-step method: the crucial idea is that each witness to
the imperfection of a coherent network can be removed, one step at a time. Such
witnesses will be called defects. There are three kinds of defect: each corresponds
to a violation of a saturation condition.
DeÔ¨Ånition 4.62 Let N = (N, <, ŒΩ) be a network. An S1-defect of N consists of
a node s ‚àà N that has no successor, or no predecessor; an S2-defect is a pair (s, t)
of nodes for which there is no intermediate point. An S3-defect consists of (F) a
node s and a formula F œà ‚àà ŒΩ(s) for which there is no t in N such that s < t and226
4 Completeness
œà ‚àà ŒΩ(t), or (P) a node s and a formula P œà ‚àà ŒΩ(s) for which there is no t in N
such that t < s and œà ‚àà ŒΩ(t).
Now we need to say more about what it means to repair a defect. To do so, we
need the notion of one network extending another.
DeÔ¨Ånition 4.63 Let N0 = (N0 , <0 , ŒΩ0 ) and N1 = (N1 , <1 , ŒΩ1 ) be two networks.
We say that N1 extends N0 (notation: N1  N0 ) if FN0 is a subframe of FN1 and
ŒΩ0 agrees with ŒΩ1 on N0 .
The key lemma of this (or for that matter, any) step-by-step proof states that any
defect of a Ô¨Ånite coherent network can be repaired. More precisely:
Lemma 4.64 (Repair Lemma) For any defect of a Ô¨Ånite, coherent network N
there is a Ô¨Ånite, coherent N   N lacking this defect.
Proof. Let N = (N, <, ŒΩ) be a Ô¨Ånite, coherent network and assume that N has
some defect. We prove the Lemma by showing that all three types of defect can be
removed.
S1-defects.
These are left as an exercise to the reader.
S2-defects.
Assume that there are nodes s and t in N for which there is no intermediate point.
How should we repair this defect? The basic idea is simple: just throw in a
new point between s and t, and Ô¨Ånd an appropriate label for it. This can be done
easily, since it follows by coherence of N that ŒΩ(s)Rc ŒΩ(t), and by canonicity of
the density axiom that there is some MCS Œì such that ŒΩ(s)Rc Œì Rc ŒΩ(t). Hence,
take some new node u (new in the sense that u ‚àà N ) and deÔ¨Åne N = (N  , < , ŒΩ  )
by
N  := N ‚à™ {u},
< := < ‚à™ {(x, u) | x ‚â§ s} ‚à™ {(u, x) | t ‚â§ x},
ŒΩ  := ŒΩ ‚à™ {(u, Œì )}.
It is clear that N  is a network that does not suffer from the old defect. But is N
coherent? Condition C1 is almost immediate by the deÔ¨Ånition, so we concentrate
on C2. Let x and y be two arbitrary nodes in N  such that x < y; we have to check
that ŒΩ  (x)Rc ŒΩ  (y). Now, as < is irreÔ¨Çexive, x and y are distinct. Moreover, there
can only be a problem if one of the nodes is the new point u; assume that y = u
(the other case is similar). If x = s then we have ŒΩ (x)Rc ŒΩ  (u) by our assumption
on Œì , so suppose that x = s. By deÔ¨Ånition of < and the fact that there are no
old nodes between s and t, this means that x < s, so by the coherency of N we4.6 Step by Step
227
have that ŒΩ(x)Rc ŒΩ(s). Hence, it follows by the transitivity of Rc that ŒΩ(x)Rc Œì ;
but then it is immediate by the deÔ¨Ånition of ŒΩ that ŒΩ  (x)Rc ŒΩ  (u).
S3-defects.
We only treat the P-defects; the case for F-defects follows by symmetry. Assume
that there is a node s in N and a formula P œà in ŒΩ(s) for which there is no t in N
such that t < s and œà ‚àà ŒΩ(t).
Again, the basic strategy is simple: we insert a new point s into the network
(before s!) and choose an adequate label for it; this has to be a maximal consistent
set containing œà and preceding ŒΩ(s) in the preorder Rc . But where should s be
inserted? If we are not careful we will destroy the coherency of N . The following
maneuver (which takes advantage of the fact that FN is a Ô¨Ånite STO) overcomes
the difÔ¨Åculty.
Let m be the unique point in N such that (i) (m, P œà) is an S3-defect in N , and
(ii) for all w < m, (w, P œà) is not a defect. Such an m must exist (it is either s
itself, or one of the Ô¨Ånitely many points preceding s) and, as we will see, we can
repair (m, P œà) without problems by simply inserting the new point s immediately
before m. Repairing this minimal defect automatically repairs the defect (s, P œà).
Choose some new point s (that is, s ‚àà S) and let Œ® be an MCS containing œà
such that Œ® Rc ŒΩ(m); such a Œ® exists by the Existence Lemma for normal logics.
DeÔ¨Åne N  = (N  , < , ŒΩ  ) as follows:
N  := N ‚à™ {s },
< := < ‚à™ {(x, s ) | x < m} ‚à™ {(s , x) | m ‚â§ x},
ŒΩ  := f ‚à™ {(s , Œ® )}.
Observe that FN  is a strict total order, and that N  does not contain the defect
(s, P œà). It only remains to ensure that N  satisÔ¨Åes the second coherency condition.
Consider two nodes x, y ‚àà N  such that x < y. Again, the only cases worth
checking are when either x or y is the new point s . If we have x = s we are in a
similar situation as in the case of S2-defects, so we do not go into details here.
Hence, assume that y = s . By construction ŒΩ(s ) = Œ® Rc ŒΩ(m), and by the co-
herency of N , ŒΩ(x)Rc ŒΩ(m). But Rc is the canonical relation for Kt Q ‚Äì a relation
with no branching to the left ‚Äì hence either Œ® Rc ŒΩ(x), Œ® = ŒΩ(x) or ŒΩ(x)Rc Œ® . We
claim that the Ô¨Årst two options are impossible. For, if Œ® Rc ŒΩ(x) then œà ‚àà Œ® would
imply that P œà ‚àà ŒΩ(x) and this contradicts the minimality of m; and if Œ® = ŒΩ(x),
then œà ‚àà ŒΩ(x) would mean that (s, P œà) was not a defect in the Ô¨Årst place! We
conclude that ŒΩ(x)Rc Œ® , which establishes coherence.
With both the Truth Lemma for induced models and the Repair Lemma at our
disposal, we can prove the desired strong completeness result. The idea is straight-
forward. We start with a singleton network and extend it step by step to larger4 Completeness
228
(but Ô¨Ånite) networks by repeated use of the Repair Lemma. We obtain the required
perfect network by taking the union of our sequence of networks.
Theorem 4.65 Kt Q is strongly complete with respect to (Q, <).
Proof. Choose some set S = {si | i ‚àà œâ} (we will use its elements to build the
required frame) and enumerate the set of potential defects (that is, the union of the
sets S, S √ó S and S √ó {F, P } √ó Form). Given a consistent set of formulas Œ£,
expand it to an MCS Œ£0 . Let N0 be the network ({s0 }, ‚àÖ, (s0 , Œ£0 )). Trivially, N0
is a Ô¨Ånite, coherent network for Œ£0 .
Let n ‚â• 0 and suppose Nn is a Ô¨Ånite, coherent network. Let D be the defect of
Nn that is minimal in our enumeration. Such a D exists, since any Ô¨Ånite network
must at least have S1- and S2-defects. Form Nn+1 by repairing the defect D as
described in the proof of the Repair Lemma. Observe that D will not be a defect
of any network extending Nn .
Let N = (N, <, ŒΩ) be given by
N=
Nn , < =
n‚ààœâ
<n , and ŒΩ =
n‚ààœâ
ŒΩn .
n‚ààœâ
It is easy to see that FN is a strict total order. Moreover, as we chose the points in
N from a countably inÔ¨Ånite set, N is countable.
It should be intuitively clear that N is perfect, but the actual proof has to take
care of a subtlety. Suppose that N is not perfect; let D be the minimal (according
to our enumeration) defect of N , say D = Dk . By our construction, there must be
an approximation Ni of N of which D is also a defect. Note that D need not be
the minimal defect of Ni ‚Äì this is the subtlety. Fortunately, there can be at most
k defects that are more urgent, so D will be repaired before stage k + i of the
construction.
Finally, by the perfection of N it follows from Lemma 4.61 that the induced
model IN satisÔ¨Åes Œ£ at s0 .
The step-by-step method is one of the most versatile tools at the modal logician‚Äôs
disposal: a wide variety of results in modal and tense logic have been using this
method, it is the tool of choice for many stronger modal systems such as arrow
logic and since/until logic, and we will make use of step-by-step arguments when
we discuss rules for the undeÔ¨Ånable in the following section. We urge the reader to
experiment with it. A good starting point is Exercise 4.6.1.
Exercises for Section 4.6
4.6.1 Consider a modal language with three diamonds 3 1 , 32 and 33 . Give a complete
axiomatization for the class of frames F = (W, R 1 , R2 , R3 ) satisfying R3 = R1 ‚à© R2 .4.7 Rules for the UndeÔ¨Ånable
229
4.6.2 Consider, for a modal language with two diamonds 3 0 and 31 , the normal modal
logic (S5)2 axiomatized by S5 axioms for both diamonds, and the commutativity axiom
30 31 p ‚Üî 31 30 p. Prove that this logic is complete for the class of square frames. A
square frame for this language is of the form F = (W, R 0 , R1 ) where for some set U we
have
W
Ri st
=
iff
U 2,
s i = ti .
(Hint: take as approximations networks of the form (N, ŒΩ) where ŒΩ is a labeling mapping
pairs over N to maximal consistent sets.)
4.6.3 Consider a similarity type œÑ with one binary operator ‚ó¶, as in arrow logic. Call a
œÑ -frame F = (W, T ) a relativized square if W is some collection of pairs over a base set
U , and T ‚äÜ W 3 satisÔ¨Åes T stu iff s0 = t0 , t1 = u0 and s1 = u1 .
(a) Prove that the basic modal logic K œÑ is strongly sound and complete with respect to
the class of relativized squares.
(b) Try to axiomatize the logic of the class of frames (W, R) in which W is as above,
but T satisÔ¨Åes T stu iff s0 = t1 , t0 = u and u0 = s1 .
4.7 Rules for the UndeÔ¨Ånable
In the previous two sections we proved semantically driven completeness results
by using standard canonical models indirectly. The present section takes a rather
different approach: we enrich the deductive system with a special proof rule, and
consider a special (not necessarily generated) submodel of the canonical model for
this new logic. The submodel that we study contains only special distinguishing (or
witnessing) MCSs. The completeness proof shows that this new canonical model
has all the good properties of the original, and that, in addition, it is already in
the right shape. We will make use of ideas introduced in our discussion of the
step-by-step method in the previous section (in particular, the concept of a defect).
The running example in this section will (again) be the tense logic of dense un-
bounded strict total orderings. Recall that the difÔ¨Åculty when working with this
logic is that there is no axiom ensuring the irreÔ¨Çexivity of the canonical frame ‚Äì we
have all the other required properties: point generated submodels of the candidate
logic Kt Q are transitive, trichotomous, dense, and unbounded. Now, in previous
sections we achieved irreÔ¨Çexivity indirectly: either we bulldozed away clusters,
or we used the canonical model for Kt Q to induce a model on a carefully con-
structed irreÔ¨Çexive frame. In this section we will construct a canonical frame that
is transitive, non-branching, dense and irreÔ¨Çexive right from the start. Indeed, if
we work with a countably inÔ¨Ånite language, every point generated subframe of this
canonical model will be countable, and hence (by Cantor‚Äôs Theorem) isomorphic
to (Q, <).
The starting point of the enterprise is that irreÔ¨Çexivity, although not deÔ¨Ånable in
basic modal languages, can be characterized in an alternative sense:230
4 Completeness
If a temporal formula œà is satisÔ¨Åable on an irreÔ¨Çexive frame, then for any
proposition letter p not occurring in œà, the conjunction (¬¨P p ‚àß p ‚àß ¬¨F p) ‚àß œà
is also satisÔ¨Åable on that frame.
For, if F, V, s  œà, then F, V  , s  (¬¨P p ‚àß p ‚àß ¬¨F p) ‚àß œà, where V  is just like V
except that it assigns the singleton {s} to p. The condition that p does not occur in
œà is crucial here: it ensures that changing the set assigned to p does not affect the
satisfaction of œà.
Now, by taking the contrapositive of the above statement, we turn it into a proof
rule:
(IRR)
if  (¬¨P p ‚àß p ‚àß ¬¨F p) ‚Üí œÜ then  œÜ, provided p does not occur in œÜ.
We have just seen that this rule is sound on the class of irreÔ¨Çexive frames. More-
over, note that on the class of strict total orders the formula (¬¨P œÜ ‚àß œÜ ‚àß ¬¨F œÜ) is
true at some state s iff s is the only state where œÜ holds (we need trichotomy and
transitivity to guarantee this). That is, the formula ¬¨P œÜ ‚àß œÜ ‚àß ¬¨F œÜ acts as a sort of
‚Äòname‚Äô for the satisfying point. Call this formula name(œÜ). Bearing these remarks
in mind, let us now see how adding this rule is of any help in proving the desired
completeness result.
DeÔ¨Ånition 4.66 The logic Kt Q+ is obtained by adding to Kt Q the irreÔ¨Çexivity
rule IRR. In what follows, consistency means Kt Q+ -consistency,  œÜ means that
œÜ is provable in Kt Q+ , and so on. The canonical model for Kt Q+ is denoted by
Mc , the canonical relation by Rc .
The remainder of this section is devoted to proving completeness of the proof sys-
tem Kt Q+ with respect to (Q, <). Of course the result is not surprising: we have
already seen that plain old Kt Q is strongly complete with respect to (Q, <). It
is the method that is important: rules such as IRR give us a way of forming more
cleanly structured canonical models.
Our goal is to construct an irreÔ¨Çexive version of the canonical model for Kt Q+ .
The basic idea is to work only with special witnessing MCSs:
DeÔ¨Ånition 4.67 A maximal consistent set is called witnessing if it contains a for-
mula of the form name(œÜ).
Why are these witnessing MCSs so interesting? Well, suppose that we are dealing
with a collection W of witnessing maximal consistent sets. This collection induces
a model in the obvious way: the relation is just the canonical accessibility relation
restricted to W and likewise for the valuation. Now suppose that we can prove a
Truth Lemma for this model; that is, suppose we can show that ‚Äòtruth and mem-
bership coincide‚Äô for formulas and MCSs. It is then immediate that the underlying
relation of the model is irreÔ¨Çexive: name(œÜ) ‚àà Œì implies œÜ ‚àà Œì and F œÜ ‚àà Œì .4.7 Rules for the UndeÔ¨Ånable
231
This is all very well, but it is obvious that we cannot just throw away non-
witnessing MCSs from the canonical model without paying a price. How can we
be sure that we did not throw away too many MCSs? An examination of the stan-
dard canonical completeness proof reveals that there are two spots where claims
are made concerning the existence of certain MCSs.
(i) There is the Existence Lemma, which is needed to prove the Truth Lemma.
In our case, whenever the formula F œÜ is an element of one of our witness-
ing MCSs (Œì , say) then there must be a witnessing Œî such that Œì Rc Œî and
œÜ ‚àà Œî. But if Œî is witnessing, then there is some Œ¥ with name(Œ¥) ‚àà Œî;
it follows from the deÔ¨Ånition of the canonical accessibility relation that
F (œÜ ‚àß name(Œ¥)) ‚àà Œì . This shows that it will not do to just take the
witnessing MCSs: the Existence Lemma requires stronger saturation condi-
tions on MCSs, namely that whenever F œÜ ‚àà Œì , then there is some Œ¥ such
that F (œÜ ‚àß name(Œ¥)) ‚àà Œì too.
(ii) If there are axioms in the logic that are canonical for some property with
existential import, how can we make sure that the trimmed down version
of the canonical model still validates these properties? Examples are the
formulas 32p ‚Üí 23p, or, in the present case, the density axiom. The
point is that from the density of the standard canonical frame we may not
infer that its subframe formed by witnessing MCSs is dense as well: why
should there be a witnessing MCS between two witnessing MCSs?
These two kinds of problems will be taken care of in two different ways. We Ô¨Årst
deal with the Existence Lemma. To start with, let us see how sets of MCSs give
rise to models ‚Äì the alternative versions of the canonical model that we already
mentioned.
DeÔ¨Ånition 4.68 Let W be a set of maximal consistent sets of formulas. DeÔ¨Åne
Mc |W to be the submodel of the canonical model induced by W ; that is, Mc |W =
(W, R, V ) where R is the relation Rc restricted to W , and V is the canonical
relation restricted to W .
Obviously, we are only interested in such models for which we can prove a Truth
Lemma. The following deÔ¨Ånition gives a sufÔ¨Åcient condition for that.
DeÔ¨Ånition 4.69 A set W of maximal consistent sets is called diamond saturated if
it satisÔ¨Åes the requirement that for each Œ£ ‚àà W and each formula F œà ‚àà Œ£ there
is a set Œ® ‚àà W such that Œ£Rc Œ® and œà ‚àà Œ® , and the analogous condition holds for
past formulas.232
4 Completeness
Lemma 4.70 (Truth Lemma) Let W be a diamond saturated set of maximal con-
sistent sets of formulas. Then for any Œì ‚àà W and any formula œÜ:
Mc |W , Œì  œÜ iff œÜ ‚àà Œì.
Proof. Straightforward by induction on œÜ.
Our goal is now to prove the existence of diamond saturated collections of witness-
ing MCSs.
Proposition 4.71 Let Œæ be some consistent formula. Then there is a countable,
diamond saturated collection W of witnessing MCSs such that Œæ ‚àà Œû for some
Œû ‚àà W.
Proof. The basic idea of the proof is to deÔ¨Åne W step by step, in a sort of parallel
Lindenbaum construction on graphs. During the construction we are dealing with
Ô¨Ånite approximations of W . At each stage, one of the shortcomings of the current
approximation is taken care of; this can be done in such a way that the limit of the
construction has no shortcomings at all. A Ô¨Ånite approximation of W will consist
of a Ô¨Ånite graph together with a labeling which assigns a Ô¨Ånite set of formulas to
each node of the graph. We associate a formula with each of these Ô¨Ånite labeled
graphs, and require that this corresponding formula be consistent for each of the
approximations. The Ô¨Årst graph has no edges, and just one point whose label set
is the singleton {Œæ}. The construction is such that the graph is growing in two
senses: edges may be added to the graph, and formulas may be added to the label
sets. (Some readers may Ô¨Ånd it helpful to think of this process as a rather abstract
tableaux construction.) All this is done to ensure that in the limit we are dealing
with a (possibly inÔ¨Ånite) labeled graph meeting the requirements that (i) the label
set of each point is an MCS, (ii) each label set contains a witness and (iii) if a
formula of the form F œÜ (P œÜ) belongs to the label set of some node, then there is
an edge connecting this node to another one containing œÜ in its label set. Finally,
W is deÔ¨Åned as the range of this inÔ¨Ånite labeling function ‚Äì note that the label
function will not be required to be injective.
Now for the technical details. Approximations to W will be called networks: a
network is a quadruple N = (N, E, d, Œõ) such that (N, E) is a Ô¨Ånite, undirected,
connected and acyclic graph; d is a direction function mapping each edge (s, t) of
the graph to either R or its converse RÀá; and Œõ is a label function mapping each
node of N to a Ô¨Ånite set of formulas.
As in our earlier example of a step-by-step construction, we Ô¨Årst want to formu-
late coherence conditions on networks and deÔ¨Åne the notion of a defect of network
with respect to its ideal, W . We start with a formulation of the coherence of a
network. Since we are working in the basic temporal similarity type ‚Äì that is, we
have diamonds both for looking along R and along RÀá ‚Äì there is an obvious way of4.7 Rules for the UndeÔ¨Ånable
233
describing the network, from each of its nodes. Let N = (N, E, d, Œõ) be some net-
work, and let s and t be two adjacent nodes of N . We use the following notational
conventions:
F if d(s, t) = R,
st :=
P if d(t, s) = RÀá.
Moreover, let E(s) denote the set of nodes adjacent to s. Finally, we let Œª(s)

denote the conjunction Œõ(s). DeÔ¨Åne

Œî(N , s) := Œª(s) ‚àß v‚ààE(s) svŒ∏(N , v, s),

Œ∏(N , t, s) := Œª(t) ‚àß s=v‚ààE(t) tvŒ∏(N , v, t).
In words, Œî(N , s) starts with a local description Œª(s) of s and then proceeds to its
neighbors. For each neighbor v, Œî(N , s) writes a future operator if d(s, v) = R
(and a past operator if d(s, v) = RÀá) and then starts to describe the network after v
by calling Œ∏. Œ∏(N , v, s) Ô¨Årst gives a local description Œª(v) of v, and then recursively
proceeds to the neighbors of v ‚Äì except for s. The omission of s, together with the
Ô¨Åniteness and acyclicity of the graph, ensures that we end up with a Ô¨Ånite formula.
The following claim shows that it does not really matter from which perspective
we describe N .
Lemma 4.72 For any network N and any two nodes s, t in N , Œî(N , s) is consis-
tent iff Œî(N , t) is consistent.
Proof. By the connectedness of N it is sufÔ¨Åcient to prove the Lemma for adjacent
s and t; the general case can be proved by a simple induction on the length of the
path connecting the two nodes.
So suppose that s and t are adjacent; without loss of generality assume that
d(s, t) = R. Since N is Ô¨Åxed it will not lead to confusion if we abbreviate Œî(N , x)
by Œî(x) and Œ∏(N , x, y) by Œ∏(x, y). Then by deÔ¨Ånition, Œî(s) is given by

Œî(s) = Œª(s) ‚àß
suŒ∏(u, s)
u‚ààE(s)
= Œª(s) ‚àß F Œ∏(t, s) ‚àß

suŒ∏(u, s)
t=u‚ààE(s)
= F Œ∏(t, s) ‚àß Œ∏(s, t).
Likewise, we can show that
Œî(t) = Œ∏(t, s) ‚àß P Œ∏(s, t).
But it is a general property of any logic extending Kt that for any two formulas
Œ± and Œ≤, F Œ± ‚àß Œ≤ is consistent iff Œ± ‚àß P Œ≤ is consistent. From this, the Lemma is
immediate.234
4 Completeness
The upshot of Lemma 4.72 is a good deÔ¨Ånition of the coherence of a network: we
will call a network N coherent if Œî(N , s) is consistent for each of (equivalently:
some of) its nodes s. However, being Ô¨Ånite, our networks will never be perfect.
What kinds of defects can they have?
A defect of a network is either (D1) a pair (s, œÜ) such that neither œÜ nor ¬¨œÜ
belongs to Œõ(s); (D2) a pair (s, F œÜ) such that F œÜ ‚àà Œõ(s) while there is no witness
for this (in the sense that œÜ ‚àà Œõ(t) for some node t with Est and d(s, t) = R); (D3)
a similar pair (s, P œÜ); or (D4) a node s without a name; that is, name(œÜ) ‚àà Œõ(s)
for no formula œÜ.
We will show that each kind of defect of a network can be repaired. For this we
need some terminology. A network N  extends a network N (notation: N   N ),
if N ‚äÜ N  , while E = E  ‚à© N √ó N , d = d |N and Œõ(s) ‚äÜ Œõ (s) for each node s
of N .
Lemma 4.73 For any defect of a Ô¨Ånite, coherent network N there is a Ô¨Ånite, co-
herent N   N lacking this defect.
Proof. Let N = (N, E, d, Œõ) be a coherent network and assume that N has some
defect. We will prove the Lemma by showing how to remove the various types of
defect.
D1-defects.
Assume that there is a node s and a formula œÜ such that neither œÜ nor ¬¨œÜ belongs
to Œõ. Since the formula Œî(N , s) is consistent, it follows that either Œî(N , s) ‚àß œÜ
or Œî(N , s) ‚àß ¬¨œÜ is consistent; let ¬±œÜ denote the formula such that Œî(N , s) ‚àß ¬±œÜ
is consistent. Now deÔ¨Åne N  by N  := N , E  := E, d := d, while Œõ is given by
Œõ (t) = Œõ(t) for t = s and
Œõ(s) := Œõ(s) ‚à™ {¬±œÜ}.
Clearly, N  is a Ô¨Ånite network lacking the defect (s, œÜ). It is also obvious that
Œî(N  , s) is the formula Œî(N , s) ‚àß ¬±œÜ, so Œî(N  , s) is consistent, and hence, N 
is coherent.
D2-defects.
Assume that there is a node s and a formula œÜ such that F œÜ ‚àà Œõ(s) while there is
no witness for this. Take a new node t (that is, t does not belong to N ) and deÔ¨Åne
N  as follows:
N  := N ‚à™ {t},
E  := E ‚à™ {(s, t)},
d := d ‚à™ {((s, t), R)},
Œõ := Œõ ‚à™ {(t, {œÜ})}.4.7 Rules for the UndeÔ¨Ånable
235
It is obvious that N  extends N and that the defect has been repaired. Finally,
it is clear by the deÔ¨Ånitions that Œî(N  , s) = Œî(N , s): the only information that
the new node adds to the description is a conjunct F œÜ and by assumption this was
already a member of Œõ(s), and thus a conjunct of Œª(s). Hence, the coherence of
N  is an immediate consequence of the coherence of N .
D3-defects.
Repaired analogously to D2-defects.
D4-defects.
These are repaired in the same way as D1-defects, using the fact that if Œî(N , s)
is consistent, then there is a propositional variable p that does not occur in any of
the label sets. And here ‚Äì at last ‚Äì we use the IRR-rule to show that the formula
Œî(N , s) ‚àß name(p) is consistent. This completes the proof of Lemma 4.73.
Finally, we return to the proof of Proposition 4.71. Assume that Œæ is a consistent
formula.
By a standard step-by-step construction we can deÔ¨Åne a sequence (Ni )i‚ààN of
networks such that
(i) N0 is a one-node network with label set {Œæ},
(ii) Nj extends Ni whenever i < j, and
(iii) for every defect of any network Ni there is a network Nj with j > i lacking
this defect.
Let N be the set i‚ààN Ni ; and for s ‚àà N , deÔ¨Åne Œõ(s) = i‚ààN Œõi (s). We claim
that for every s ‚àà N , Œõ(s) is a witnessing MCS. We Ô¨Årst show that for all formulas
œÜ, either œÜ or ¬¨œÜ belongs to Œõ(s). Let i ‚àà N be such that s is already in existence
in Ni ; if neither œÜ nor ¬¨œÜ belongs to Œõi (s), this constitutes a defect of Ni . Hence,
by the construction there is some j > i such that either œÜ or ¬¨œÜ belongs to Œõj (s).
But then the same formula belongs to Œõ(s). In the same manner we can prove
that every set Œõ(s) contains a name. Now assume that Œõ(s) is not consistent; then
there are formulas œÜ1 , . . . , œÜn in Œõ(s) such that œÜ1 ‚àß ¬∑ ¬∑ ¬∑ ‚àß œÜn is inconsistent. By
construction, there must be a k ‚àà N such that each œÜi belongs already to Œõk (s).
But this contradicts the consistency of Œî(Nk , s) and hence, the coherency of Nk .
Finally, deÔ¨Åne W as the range of Œõ. The preceding paragraphs show that W is
a collection of witnessing MCSs. By our deÔ¨Ånition of N0 , it follows that Œæ belongs
to some MCS in W .
Now let F œÜ be some formula in Œì ‚àà W . By deÔ¨Ånition, there is some s ‚àà N such
that Œì = Œõ(s), and thus, some i ‚àà N such that F œÜ ‚àà Œõi (s). By our construction
there is some j ‚â• i and some t ‚àà Nj such that Ej st and œÜ ‚àà Œõj (t). It follows that
œÜ ‚àà Œõ(t), so it remains to prove that Œõ(s)Rc Œõ(t). In order to reach a contradiction,
suppose otherwise. Then there is a formula œà ‚àà Œõ(t) such that F œà ‚àà Œõ(s). Since236
4 Completeness
Œõ(s) is an MCS, this implies that ¬¨F œà ‚àà Œõ(s). Now let k ‚àà N be large enough
that œà ‚àà Œõk (t) and ¬¨F œà ‚àà Œõk (s). From this it is immediate that Œî(Nk , s) is
inconsistent; this contradicts the coherency of Nk . This proves that W is diamond
saturated.
But then we have proved that W meets all requirements phrased in Proposi-
tion 4.71, and this completes its proof.
This shows that we have more or less solved the Ô¨Årst problem concerned with work-
ing in a trimmed down version of the canonical model: we have established that
every consistent formula Œæ can be satisÔ¨Åed in an irreÔ¨Çexive canonical-like model.
Let us now think about the second kind of problem. Concretely, how can we prove
that we have not destroyed the nice properties of the canonical frame by moving
to a subframe? In particular, how can we ascertain density? We will see that here
we will make good use of the special naming property of the formulas name(œÜ),
namely that they can be used as identiÔ¨Åers of MCSs.
Lemma 4.74 Let W be a diamond saturated collection of witnessing maximal
consistent sets of formulas, and let < denote the canonical relation Rc restricted to
W . Then the frame (W, <) is a non-branching, unbounded, dense, strict ordering.
Proof. Let W and < be as in the statement of the lemma. Clearly, (W, <) is a
subframe of the canonical frame; hence, it inherits every universal property of T,
such as transitivity or non-branching. IrreÔ¨Çexivity follows from the fact that Œì Rc Œì
for no witnessing Œì . This shows that < is a non-branching, strict ordering of W .
Unboundedness is not a universal condition, but nevertheless follows rather eas-
ily: simply use the fact that the formulas F  and P  are theorems of the logic
and, hence, belong to every maximal consistent set. Unboundedness then follows
by the diamond saturation of W .
The case of density is more difÔ¨Åcult, and here is where names are genuinely
useful. Assume that Œì and Œî are two MCSs such that Œì < Œî. We have to Ô¨Ånd an
MCS Œò in W that lies between Œì and Œî. Let Œ¥ be the formula such that name(Œ¥) ‚àà
Œî. It follows from Œì < Œî that F name(Œ¥) ‚àà Œì , so using the density axiom, we
Ô¨Ånd that F F name(Œ¥) ‚àà Œì . From this we may infer the existence of an MCS
Œò ‚àà W with Œì < Œò and F name(Œ¥) ‚àà Œò.
But is Œò < Œî? Note that since < is non-branching to the right, we already know
that Œò < Œî or Œò = Œî or Œî < Œò. But it clearly cannot be the case that Œò = Œî,
since F Œ¥ ‚àà Œò and ¬¨F Œ¥ ‚àà Œî. Neither is it possible that Œî < Œò, for suppose
otherwise. It would follows from F Œ¥ ‚àà Œò that F F Œ¥ ‚àà Œî, so by the transitivity
axiom, F Œ¥ ‚àà Œî; but this would contradict the fact that ¬¨F Œ¥ ‚àà Œî.
We now have all the ingredients for the main theorem of this section:
Theorem 4.75 Kt Q+ is complete with respect to (Q, <).4.7 Rules for the UndeÔ¨Ånable
237
Proof. Given any consistent formula Œæ, construct a countable, diamond saturated
set W of witnessing MCSs for Œæ, as in the proof of Proposition 4.71. By the Truth
Lemma 4.70, Œæ is satisÔ¨Åable at some MCS Œû in the model Mc |W induced by W ;
and by Lemma 4.74, this model is based on a non-branching, unbounded, dense,
strict ordering. But then the subframe generated by Œû is based on a countable,
dense, unbounded, strict total order and, hence, is isomorphic to the ordering of
the rationals.
How widely applicable are these ideas? Roughly speaking, the situation is as fol-
lows. The basic idea is widely applicable; various rules for the undeÔ¨Ånable have
been employed in many different modal languages, and for many different classes
of models (we will see further examples in Chapter 7). Moreover, the use of such
rules can be fruitfully combined with other techniques, notably the step-by-step
method (this combination sometimes succeeds when all else fails). Rules for the
undeÔ¨Ånable are fast becoming a standard item in the modal logicians‚Äô toolkit.
Nonetheless the method has its limitations, at least in the kinds of modal lan-
guages we have been considering so far. These limitations are centered on the
problem of working with submodels of the original canonical model.
As we saw, the Ô¨Årst problem ‚Äì retaining sufÔ¨Åciently many MCSs for proving the
Truth Lemma ‚Äì has a fairly satisfactory solution. Two remarks are in order here.
(i) The method only works well when we are working in tense logic. In the
proof of the ‚Äòmultiple Lindenbaum Lemma‚Äô, we crucially needed operators
for looking in both directions in order to show that it does not matter from
which perspective we describe a graph. If we have no access to the infor-
mation of nodes lying ‚Äòbehind,‚Äô we are forced to add a countably inÔ¨Ånite
family of more and more complex rules, instead of one single irreÔ¨Çexivity
rule.
But there are no problems in generalizing the proof of Proposition 4.71 to
similarity types with more than one tense diamond and/or versatile polyadic
operators. For example, in Exercise 4.7.3 the reader is asked to use the
method to prove completeness for the language of PDL with converse pro-
grams.
(ii) Observe that we only proved weak completeness for Kt Q+ . This is be-
cause our proof of Proposition 4.71 only works with Ô¨Ånite networks. In the
presence of names, however, it is possible to prove a stronger version of
Proposition 4.71; the basic idea is that when an MCS Œì contains a name,
other MCSs may have complete access to the information in Œì through the
Ô¨Ånite ‚Äòchannel‚Äô of Œì ‚Äôs name. For details we refer to Exercise 4.7.2.
There is a second problem which seems to be more serious. Which properties of the
canonical frame can we guarantee to hold in a trimmed down version? In general,238
4 Completeness
very few. Obviously, universal properties of the canonical model hold in each of
its submodels, and Ô¨Årst-order properties that are the standard translation of closed
modal formulas (such as ‚àÄx‚àÉy Rxy) are valid in each subframe for which a Truth
Lemma holds, but that is about it.
This is the point where the names come in very handy. In fact, in order to prove
the inheritance of universal-existential properties like density, the names seem to
be really indispensable. If, on the other hand, we have names at our disposal,
we can prove completeness results for a wide range of logics. Roughly speaking,
in case the logic is a tense logic, we can show that every Sahlqvist formula is
‚Äòdistinguishing-canonical‚Äô. The crucial observation is that the witnessing submodel
of the canonical model is a named model.
DeÔ¨Ånition 4.76 Let œÑ be some modal similarity type. A œÑ -model M is called
named if for every state s in M there is a formula œÜ such that s is the only point in
M satisfying œÜ.
Theorem 4.77 Let œÑ be some modal similarity type, and suppose that M = (F, V )
is a named œÑ -model. Then for every very simple Sahlqvist formula œÉ:
M  œÉ iff F  œÉ.
(4.1)
In the particular case of the basic temporal similarity type, if M is in addition a
bidirectional model, then (4.1) holds for every Sahlqvist formula.
Proof. Let M be a named model. It was the aim of Exercise 1.4.7 to let the reader
show that the collection
A := {V (œÜ) | œÜ a formula }
is closed under the boolean and modal operations. Hence, the structure g = (F, A)
is a general frame. Since M is named, A contains all singletons. The result then
follows from Theorem 5.90 in Chapter 5 ‚Äì for the second part of the theorem,
Exercise 5.6.1 is needed as well.
The use of rules for the undeÔ¨Ånable really comes into its own in some of the ex-
tended modal languages studied for Chapter 7. Two main paths have been explored,
and we will discuss both. In the Ô¨Årst, the difference operator is added to an ortho-
dox modal language. It is then easy to state a rule for the undeÔ¨Ånable (even if the
underlying modal language does not contain converse operators) and (by extending
the remarks just made) to prove a D-Sahlqvist theorem. In the second approach,
atomic formulas called nominals and operators called satisfaction operators are
added to an orthodox modal language. These additions make it straightforward to
deÔ¨Åne simple rules for the undeÔ¨Ånable (even if the underlying modal language does
not contain converse operators) and to prove a general completeness result without
making use of step-by-step arguments.4.8 Finitary Methods I
239
Exercises for Section 4.7
4.7.1 We are working in the basic modal similarity type. First, prove that a frame is intran-
sitive (‚àÄxyz (Rxy ‚àß Ryz ‚Üí ¬¨Rxz)) iff we can falsify the formula 2p ‚Üí 33p at every
state of the frame.
Second, let KB be the logic K, extended with the symmetry axiom p ‚Üí 23p and the
rule
(ITR)
if  (2p ‚àß 22¬¨p) ‚Üí œÜ then  œÜ, provided p does not occur in œÜ.
Show that KB is sound and complete with respect to the class of symmetric, intransitive
frames.
4.7.2 Assume that we are working with the logic K t Q+ . Show that for each consistent
set Œ£ there is a diamond saturated set of MCSs W such that Œ£ ‚äÜ Œû for some Œû ‚àà W .
(Hint: use a construction analogous to the one employed in the proof of Proposition 4.71.
Add an inÔ¨Ånite set of new variables to the language and Ô¨Årst prove that Œ£ ‚à™ {name(p)} is
consistent for any new variable p. A network is now allowed to have one special node with
an inÔ¨Ånite label set, which should contain Œ£ ‚à™ {name(p)}. A description of a network is
now an inÔ¨Ånite set of formulas.)
4.7.3 Assume that we extend the language of PDL with a reverse program constructor:
‚Ä¢ if œÄ is a program then so is œÄ ‚àí1 .
The intended accessibility relation of œÄ ‚àí1 is the converse relation of R œÄ . Let PDLœâ be
the axiom system of PDL (see Section 4.8), modulo the following changes:
(i) Add the converse axiom schemas p ‚Üí [œÄ]œÄ ‚àí1 p and p ‚Üí [œÄ ‚àí1 ]œÄp,
(ii) Replace the Segerberg induction axiom with the following inÔ¨Ånitary rule:
(œâ‚Äì‚àó)
If  œÜ ‚Üí [œÄ n ]œà for all n ‚àà œâ, then  œÜ ‚Üí [œÄ ‚àó ]œà.
Prove that this logic is sound and complete with respect to the standard models.
4.8 Finitary Methods I
In this section we introduce Ô¨Ånite canonical models. We use such models to prove
weak completeness results for non-compact logics. We examine one of the best
known examples ‚Äì propositional dynamic logic ‚Äì in detail. More precisely, we
will axiomatize the validities of regular (test free) propositional dynamic logic.
Recall from Chapter 1 that this has a set of diamonds œÄ indexed by a collection
of programs Œ†. Œ† consists of a collection of basic programs, and the programs
generated from them using the constructors ‚à™, ; and ‚àó. A frame for this language is
a transition system F = (W, RœÄ )œÄ‚ààŒ† , but we are only interested in regular frames,
that is, frames such that for all programs œÄ, œÄ1 and œÄ2 :
RœÄ1 ‚à™œÄ2
= R œÄ 1 ‚à™ RœÄ 2 ,
RœÄ1 ;œÄ2 = RœÄ1 ; RœÄ2 ,
RœÄ‚àó
= (RœÄ )‚àó .240
4 Completeness
We say that a formula œÜ is a PDL-validity (written  œÜ) if it is valid on all regular
frames.
The collection of PDL-validities is not compact: consider the set
Œ£ = {a‚àó p, ¬¨p, ¬¨ap, ¬¨aap, ¬¨aaap, . . .}.
Any Ô¨Ånite subset of Œ£ is satisÔ¨Åable on a regular frame at a single point, but Œ£
itself is not. This compactness failure indicates that a strong completeness result
will be out of reach (recall Remark 4.44) so our goal (as with KL) should be to
prove a weak completeness result. It is not too hard to come up with a candidate
axiomatization. For a start, the Ô¨Årst two regularity conditions given above can be
axiomatized by Sahlqvist axioms. The last condition is more difÔ¨Åcult, but even
here we have something plausible: recall that in Example 3.10 we saw that this last
condition is deÔ¨Åned by the formula set
Œî = {(p ‚àß [œÄ ‚àó ](p ‚Üí [œÄ]p)) ‚Üí [œÄ ‚àó ]p, œÄ ‚àó p ‚Üî (p ‚à® œÄœÄ ‚àó p) | œÄ ‚àà Œ†}.
This suggests the following axiomatization.
DeÔ¨Ånition 4.78 A logic Œõ in the language of propositional dynamic logic is a nor-
mal propositional dynamic logic if it contains every instance of the following ax-
iom schemas:
(i) [œÄ](p ‚Üí q) ‚Üí ([œÄ]p ‚Üí [œÄ]q),
(ii) œÄp ‚Üî ¬¨[œÄ]¬¨p,
(iii) œÄ1 ; œÄ2 p ‚Üî œÄ1 œÄ2 p,
(iv) œÄ1 ‚à™ œÄ2 p ‚Üî œÄ1 p ‚à® œÄ2 p,
(v) œÄ‚àó p ‚Üî (p ‚à® œÄœÄ ‚àó p),
(vi) [œÄ‚àó ](p ‚Üí [œÄ]p) ‚Üí (p ‚Üí [œÄ ‚àó ]p),
and is closed under modus ponens, generalization (Œõ œÜ implies Œõ [œÄ]œÜ, for all
programs œÄ) and uniform substitution. We call the smallest normal propositional
dynamic logic PDL. In this section,  œÜ means that œÜ is a theorem of PDL,
consistency means PDL-consistency, and so on.
As we have already remarked, axioms (iii) and (iv) are (conjunctions of) Sahlqvist
axioms; they are canonical for the Ô¨Årst two regularity conditions, respectively. Fur-
ther, observe that axiom (v) is a Sahlqvist formula as well; it is canonical for the
condition RœÄ‚àó = Id ‚à™RœÄ ; RœÄ‚àó . Thus we have isolated the difÔ¨Åcult part: axiom (vi),
which we will call the induction axiom for obvious reasons, is the formula we need
to think about if we are to understand how to cope with the canonicity failure. It is
probably a good idea for the reader to attempt Exercise 4.8.1 right away.
Proving the soundness of PDL is straightforward (though the reader should
(re-)check that the induction axiom really is valid on all regular frames). We will4.8 Finitary Methods I
241
prove completeness with the help of Ô¨Ånite canonical models. Our work falls into
two parts. First we develop the needed background material: Ô¨Ånitary versions of
MCSs, Lindenbaum‚Äôs Lemma, canonical models, and so on. Following this, we
turn to the completeness proof proper.
Recall that a set of formulas Œ£ is closed under subformulas if for all œÜ ‚àà Œ£, if
œà is a subformula of œÜ then œà ‚àà Œ£.
DeÔ¨Ånition 4.79 (Fischer-Ladner Closure) Let X be a set of formulas. Then X is
Fischer-Ladner closed if it is closed under subformulas and satisÔ¨Åes the following
additional constraints:
(i) If œÄ1 ; œÄ2 œÜ ‚àà X then œÄ1 œÄ2 œÜ ‚àà X.
(ii) If œÄ1 ‚à™ œÄ2 œÜ ‚àà X then œÄ1 œÜ ‚à® œÄ2 œÜ ‚àà X.
(iii) If œÄ‚àó œÜ ‚àà X then œÄœÄ‚àó œÜ ‚àà X.
If Œ£ is any set of formulas then FL(Œ£) (the Fischer-Ladner closure of Œ£) is the
smallest set of formulas containing Œ£ that is Fischer-Ladner closed.
Given a formula œÜ, we deÔ¨Åne ‚àºœÜ as the following formula:
‚àºœÜ =
œà
if œÜ is of the form ¬¨œà,
¬¨œÜ otherwise.
A set of formulas X is closed under single negations if ‚àºœÜ belongs to X whenever
œÜ ‚àà X.
We deÔ¨Åne ¬¨FL(Œ£), the closure of Œ£, as the smallest set containing Œ£ which is
Fischer-Ladner closed and closed under single negations.
It is convenient to talk as if ‚àºœÜ really is the negation of œÜ, and we often do so in
what follows. The motivation of closing a set under single negations is simply to
have a ‚Äòconnective‚Äô that is just as good as negation, while keeping the set Ô¨Ånite.
(If we naively closed under ordinary negation, then any set would have an inÔ¨Ånite
closure.)
It is crucial to note that if Œ£ is Ô¨Ånite, then so is its closure. Some reÔ¨Çection on the
closure conditions will convince the reader of this fact, but it is not entirely trivial
to give a precise proof. We leave this little combinatorial puzzle to the reader as
Exercise 4.8.2.
We are now ready to deÔ¨Åne the generalization of the notion of a maximal con-
sistent set that we will use in this section.
DeÔ¨Ånition 4.80 (Atoms) Let Œ£ be a set of formulas. A set of formulas A is an
atom over Œ£ if it is a maximal consistent subset of ¬¨FL(Œ£). That is, A is an atom
over Œ£ if A ‚äÜ ¬¨FL(Œ£), if A is consistent, and if A ‚äÇ B ‚äÜ ¬¨FL(Œ£) then B is
inconsistent. At(Œ£) is the set of all atoms over Œ£.4 Completeness
242
Lemma 4.81 Let Œ£ be any set of formulas, and A any element of At(Œ£). Then:
(i) For all œÜ ‚àà ¬¨FL(Œ£): exactly one of œÜ and ‚àºœÜ is in A.
(ii) For all œÜ ‚à® œà ‚àà ¬¨FL(Œ£): œÜ ‚à® œà ‚àà A iff œÜ ‚àà A or œà ‚àà A.
(iii) For all œÄ1 ; œÄ2 œÜ ‚àà ¬¨FL(Œ£): œÄ1 ; œÄ2 œÜ ‚àà A iff œÄ1 œÄ2 œÜ ‚àà A.
(iv) For all œÄ1 ‚à™œÄ2 œÜ ‚àà ¬¨FL(Œ£): œÄ1 ‚à™œÄ2 œÜ ‚àà A iff œÄ1 œÜ ‚àà A or œÄ2 œÜ ‚àà A.
(v) For all œÄ‚àó œÜ ‚àà ¬¨FL(Œ£): œÄ ‚àó œÜ ‚àà A iff œÜ ‚àà A or œÄœÄ‚àó œÜ ‚àà A.
Proof. With the possible exception of the last item, obvious.
Atoms are a straightforward generalization of MCSs. Note, for example, that if we
choose Œ£ to be the set of all formulas, then At(Œ£) is just the set of all MCSs. More
generally, the following holds:
Lemma 4.82 Let M be the set of all MCSs, and Œ£ any set of formulas. Then
At(Œ£) = {Œì ‚à© ¬¨FL(Œ£) | Œì ‚àà M}.
Proof. Exercise 4.8.3.
Unsurprisingly, an analog of Lindenbaum‚Äôs Lemma holds:
Lemma 4.83 If œÜ ‚àà ¬¨FL(Œ£) and œÜ is consistent, then there is an A ‚àà At(Œ£)
such that œÜ ‚àà A.
Proof. If Œ£ is inÔ¨Ånite, the result is exactly Lindenbaum‚Äôs Lemma, so let us turn to
the more interesting Ô¨Ånite case. There are two ways to prove this. We could simply
apply Lindenbaum‚Äôs Lemma: as œÜ is consistent, there is an MCS Œì that contains œÜ.
Thus, by the previous lemma, Œì ‚à© ¬¨FL(Œ£) is an atom containing œÜ.
But this is heavy handed: let us look for a Ô¨Ånitary proof instead. Note that the

information in an atom A can be represented by the single formula œÜ‚ààA œÜ. We
 Obviously A
 ‚àà A.
will write such conjunctions of atoms as A.
Using this notation, we construct the desired atom as follows. Enumerate the
elements of ¬¨FL(Œ£) as œÉ1 , . . . , œÉm . Let A0 be {œÜ}. Suppose that An has been
deÔ¨Åned, where n < m. We have that
n ‚Üî (A
n ‚àß œÉn+1 ) ‚à® (A
n ‚àß ‚àºœÉn+1 ),
A
as this is a propositional tautology, thus either An ‚à™ {œÉn+1 } or An ‚à™ {‚àºœÉn+1 } is
consistent. Let An+1 be the consistent extension, and let A be Am . Then A is an
atom containing œÜ.
Note the technique: we forced a Ô¨Ånite sequence of choices between œÉ and ‚àºœÉ.
Actually, we did much the same thing in the proof of Lemma 4.26, the Existence
Lemma for modal languages of arbitrary similarity type, and we will soon have
other occasions to use the idea.
Now that we have Lemma 4.83, it is time to deÔ¨Åne Ô¨Ånite canonical models:4.8 Finitary Methods I
243
DeÔ¨Ånition 4.84 (Canonical Model over Œ£) Let Œ£ be a Ô¨Ånite set of formulas.
The canonical model over Œ£ is the triple (At(Œ£), {SœÄŒ£ }œÄ‚ààŒ† , V Œ£ ) where for all
propositional variables p, V Œ£ (p) = {A ‚àà At(Œ£) | p ‚àà A}, and for all atoms
A, B ‚àà At(Œ£) and all programs œÄ,
 ‚àß œÄB
 is consistent.
ASœÄŒ£ B if A
V Œ£ is called the canonical valuation, and the SœÄ are called the canonical relations.
We generally drop the Œ£ superscripts.
Although we have deÔ¨Åned it purely Ô¨Ånitarily, the canonical model over Œ£ is ac-
tually something very familiar: a Ô¨Åltration. Which Ô¨Åltration? Exercise 4.8.4 asks
the reader to Ô¨Ånd out. Further, note that although some of the above discussion is
speciÔ¨Åc to propositional dynamic logic (for example, the use of the Fischer-Ladner
closure) the basic ideas are applicable to any modal language. In Exercise 4.8.7 we
ask the reader to apply such techniques to the logic KL.
But of course, the big question is: does this Ô¨Ånite canonical model work? Given
a consistent formula œÜ, we need to satisfy œÜ in a regular model. This gives two
natural requirements on the canonical model: Ô¨Årst, we need to prove some kind of
Truth Lemma, and second, we want the model to be regular. The good news is that
we can easily prove a Truth Lemma; the bad news is that we are unable to show
regularity. This means that we cannot use the canonical model itself; rather, we
will work with the canonical relations SœÄ for the atomic relations only, and deÔ¨Åne
relations RœÄ for the other programs in a way that forces the model to be regular.
DeÔ¨Ånition 4.85 (Regular PDL-model over Œ£) Let Œ£ be a Ô¨Ånite set of formulas.
For all basic programs a, deÔ¨Åne RaŒ£ to be SaŒ£ . For the complex programs, induc-
tively deÔ¨Åne the PDL-relations RœÄŒ£ in the usual way using unions, compositions,
and reÔ¨Çexive transitive closures. Finally, deÔ¨Åne R, the regular PDL-model over Œ£,
to be (At(Œ£), {RœÄŒ£ }œÄ‚ààŒ† , V Œ£ ), where V Œ£ is the canonical valuation. Again, we
generally drop the Œ£ superscripts.
But of course, now the main question is, will we be able to prove a Truth Lemma?
Fortunately, we can prove the key element of this lemma, namely, an Existence
Lemma (cf. Lemma 4.89 below). First the easy part. As the canonical relations Sa
are identical to the PDL-relations Ra for all basic programs a, we have:
Lemma 4.86 (Existence Lemma for Basic Programs) Let A be an atom, and let
a be a basic program. Then for all formulas aœà in ¬¨FL(Œ£), aœà ‚àà A iff there
is a B ‚àà At(Œ£) such that ARa B and œà ‚àà B.
Proof. This can be proved by appealing to the standard Existence Lemma and then
taking intersections (as in Lemma 4.83) ‚Äì but it is more interesting to prove it244
4 Completeness
Ô¨Ånitarily. For the right to left direction, suppose there is a B ‚àà At(Œ£) such that
ARa B and œà ‚àà B. As Ra and Sa are identical for basic programs, we have that
 ‚àß aB
 is consistent. As œà is one of the conjuncts in B,
 A
 ‚àß aœà is
ASa B, thus A
consistent. As aœà is in ¬¨FL(Œ£) it must also be in A, for A is an atom and hence
maximal consistent in ¬¨FL(Œ£).
For the left to right direction, suppose aœà ‚àà A. We construct an appropriate
atom B by forcing choices. Enumerate the formulas in ¬¨FL(Œ£) as œÉ1 , . . . , œÉm .
DeÔ¨Åne B0 to be {œà}. Suppose as an inductive hypothesis that Bn is deÔ¨Åned such
 ‚àß aB
!n is consistent (where 0 ‚â§ n < m). We have
that A
n ‚Üî a((B
n ‚àß œÉn+1 ) ‚à® (B
n ‚àß ‚àºœÉn+1 ))
 aB
thus
n ‚Üî (a(B
n ‚àß œÉn+1 ) ‚à® a(B
n ‚àß ‚àºœÉn+1 )).
 aB
Therefore either for B = Bn ‚à™ {œÉn+1 } or for B  = Bn ‚à™ {‚àºœÉn+1 } we have that
! is consistent. Choose Bn+1 to be this consistent expansion, and let B
 ‚àß aB
A
be Bm . B is the atom we seek.
Now for the hard part. Axioms (v) and (vi) from DeÔ¨Ånition 4.78 cannot enforce
the desired identity between SœÄ and RœÄ . But good news is at hand. These axioms
are very strong and manage to ‚Äòapproximate‚Äô the desired behavior fairly well. In
particular, they are strong enough to ensure that SœÄ ‚äÜ RœÄ for arbitrary programs
œÄ. This inclusion will enable us to squeeze out a proof of the desired Existence
Lemma. The following lemma is the crucial one:
Lemma 4.87 For all programs œÄ, SœÄ‚àó ‚äÜ (SœÄ )‚àó .
Proof. We need to show that for all programs œÄ, if ASœÄ‚àó B then there is a Ô¨Ånite
sequence of atoms C0 , . . . , Cn such that A = C0 SœÄ C1 , . . . , Cn‚àí1 SœÄ Cn = B. Let
D be the set of all atoms reachable from A by such a sequence. We will show that
B ‚àà D.

 Note that Œ¥ ‚àß œÄ¬¨Œ¥ is inconsistent, for suppose other-
DeÔ¨Åne Œ¥ to be D‚ààD D.
 would be consistent for at least one atom E not in D, which
wise. Then Œ¥ ‚àß œÄE

 was consistent for at least one D ‚àà D. But then by
would mean that D ‚àß œÄE
DSœÄ E, E could be reached from A in Ô¨Ånitely many SœÄ steps, which would imply
that E ‚àà D ‚Äì which it is not.
As Œ¥ ‚àß œÄ¬¨Œ¥ is inconsistent,  Œ¥ ‚Üí [œÄ]Œ¥, hence by generalization  [œÄ‚àó ](Œ¥ ‚Üí
 is one of the disjuncts
[œÄ]Œ¥). By axiom (vi),  Œ¥ ‚Üí [œÄ‚àó ]Œ¥. Now, as A(SœÄ )‚àó A, A
‚àó
 ‚Üí Œ¥ and hence  A
 ‚Üí [œÄ ]Œ¥. As our initial assumption was that
in Œ¥, thus  A
‚àó


 ‚àß œÄ ‚àó (B
 ‚àß Œ¥) is consistent too. But this
A ‚àß œÄ B is consistent, it follows that A
 of Œ¥, B
‚àßD
 is consistent. As B and D are
means that for one of the disjuncts D
atoms, B = D and hence B ‚àà D.4.8 Finitary Methods I
245
With the help of this lemma, it is straightforward to prove the desired inclusion:
Lemma 4.88 For all programs œÄ, SœÄ ‚äÜ RœÄ .
Proof. Induction on the structure of œÄ. The base case is immediate, for we deÔ¨Åned
 ‚àß œÄ1 ; œÄ2 B

Ra to be Sa for all basic programs a. So suppose ASœÄ1 ;œÄ2 B, that is, A


is consistent. By axiom (iii) of DeÔ¨Ånition 4.78, A ‚àß œÄ1 œÄ2 B is consistent as
well. Using a ‚Äòforcing choices‚Äô argument we can construct an atom C such that




A‚àßœÄ
1 C and C‚àßœÄ2 B are both consistent. But then, by the inductive hypothesis,
ARœÄ1 C and CRœÄ2 B. It follows that ARœÄ1 ;œÄ2 B, as required. A similar argument
using axiom (iv) from DeÔ¨Ånition 4.78 shows that SœÄ1 ‚à™œÄ2 ‚äÜ RœÄ1 ‚à™œÄ2 .
The case for reÔ¨Çexive transitive closures follows from the previous lemma and
the observation that SœÄ ‚äÜ RœÄ implies (SœÄ )‚àó ‚äÜ (RœÄ )‚àó .
We can now prove an Existence Lemma for arbitrary programs.
Lemma 4.89 (Existence Lemma) Let A be an atom and let œÄœà be a formula in
¬¨FL(Œ£). Then œÄœà ‚àà A iff there is a B such that ARœÄ B and œà ‚àà B.
Proof. The left to right direction puts the crucial inclusion to work. Suppose
œÄœà ‚àà A. We can build an atom B such that œà ‚àà B and ASœÄ B by ‚Äòforcing
choices‚Äô in the now familiar manner. But we have just proved that SœÄ ‚äÜ RœÄ , thus
ARœÄ B as well.
For the right to left direction we proceed by induction on the structure of œÄ.
The base case is just the Existence Lemma for basic programs, so suppose œÄ has
the form œÄ1 ; œÄ2 , and further suppose that ARœÄ1 ;œÄ2 B and œà ‚àà B. Thus there is
an atom C such that ARœÄ1 C and CRœÄ2 B and œà ‚àà B. By the Fischer-Ladner
closure conditions, œÄ2 œà belongs to ¬¨FL(Œ£), hence by the inductive hypothesis,
œÄ2 œà ‚àà C. Similarly, as œÄ1 œÄ2 œà is in ¬¨FL(Œ£), œÄ1 œÄ2 œà ‚àà A. Hence by
Lemma 4.81, œÄ1 ; œÄ2 œà ‚àà A, as required.
We leave the case œÄ = œÄ1 ‚à™ œÄ2 to the reader and turn to the reÔ¨Çexive transitive
closure: suppose œÄ is of the form œÅ‚àó . Assume that ARœÅ‚àó B and œà ‚àà B. This
means there is a Ô¨Ånite sequence of atoms C0 , . . . , Cn such that A = C0 RœÅ C1 , . . . ,
Cn‚àí1 RœÅ Cn = B. By a subinduction on n we prove that œÅ‚àó œà ‚àà Ci for all i; the
required result for A = C0 is then immediate.
Base case: n = 0. This means A = B. From axiom (v) in DeÔ¨Ånition 4.78
we have that  œÅ‚àó œà ‚Üî œà ‚à® œÅœÅ‚àó œà, and hence that  œà ‚Üí œÅ‚àó œà. Thus
œÅ‚àó œà ‚àà A.
Inductive step. Suppose the result holds for n ‚â§ k, and that
A = C0 RœÅ C1 , . . . , Ck RœÅ Ck+1 = B.
By the inductive hypothesis, œÅ‚àó œà ‚àà C1 . Hence œÅœÅ‚àó œà ‚àà A, for œÅœÅ‚àó œà ‚àà
¬¨FL(Œ£). But  œÅ‚àó œà ‚Üî œà ‚à® œÅœÅ‚àó œà. Hence œÅ‚àó œà ‚àà A.246
4 Completeness
This completes the subinduction, and establishes the required result for œÅ‚àó . It
also completes the main induction and thus the proof of the lemma.
Lemma 4.90 (Truth Lemma) Let R be the regular PDL-model over Œ£. For all
atoms A and all œà ‚àà ¬¨FL(Œ£), R, A  œà iff œà ‚àà A.
Proof. Induction on the number of connectives. The base case follows from the
deÔ¨Ånition of the canonical valuation over Œ£. The boolean case follows from
Lemma 4.81 on the properties of atoms. Finally, the Existence Lemma pushes
through the step for the modalities in the usual way.
The weak completeness result for propositional dynamic logic follows.
Theorem 4.91 PDL is weakly complete with respect to the class of all regular
frames.
Exercises for Section 4.8
4.8.1 Show that the induction axiom is not canonical.
4.8.2 Prove that for a Ô¨Ånite set Œ£, its closure set ¬¨FL(Œ£) is Ô¨Ånite as well.
4.8.3 Prove Lemma 4.82. That is, show that At(Œ£) = {Œì ‚à© ¬¨FL(Œ£) | Œì ‚àà M}, where
M is the set of all MCSs, and Œ£ is any set of formulas.
4.8.4 Show that the Ô¨Ånite models deÔ¨Åned in the PDL completeness proofs are isomorphic
to certain Ô¨Åltrations.
4.8.5 Show that for any collection of formulas Œ£, 


A‚ààAt(Œ£) A.
4.8.6 Extend the completeness proof in the text to PDL with tests. Once you have found
an appropriate axiom governing tests, the main line of the argument follows that given in
the text. However, because tests build modalities from formulas you will need to think
carefully about how to state and prove analogs of the key lemmas (such as Lemmas 4.87
and 4.88).
4.8.7 Use Ô¨Ånite canonical models to show that KL is weakly complete with respect to the
class of Ô¨Ånite strict partial orders (that is, the class of Ô¨Ånite irreÔ¨Çexive transitive frames).
(Hint: given a formula œÜ, let Œ¶ be the set of all œÜ‚Äôs subformulas closed under single nega-
tions. Let the points in the Ô¨Ånite canonical model be all the maximal KL-consistent subsets
of Œ¶. For the relation R, deÔ¨Åne Rww  iff (1) for all 2œÜ ‚àà w, both 2œÜ and œÜ belong to w 
and (2) there is some 2œÜ ‚àà w  such that 2œÜ ‚àà w. Use the natural valuation. You will need
to make use of the fact that  KL 2œÜ ‚Üí 22œÜ; bonus points if you can Ô¨Ågure out how to
prove this yourself!)
4.8.8 Building on the previous result, show that KL is weakly complete for the class of
Ô¨Ånite transitive trees. (Hint: unravel.)4.9 Finitary Methods II
247
4.9 Finitary Methods II
As we remarked at the end of Section 4.4, although the incompleteness results show
that frame-theoretic tools are incapable of analyzing the entire lattice of normal
modal logics, they are capable of yielding a lot of information about some of its
subregions. The normal logics extending S4.3 are particularly well-behaved, and
in this section we prove three results about them. First, we prove Bull‚Äôs Theorem:
all such logics have the Ô¨Ånite frame property. Next, we show that they are all
Ô¨Ånitely axiomatizable. Finally, we show that each of these logics has a negative
characterization in terms of Ô¨Ånite sets of Ô¨Ånite frames, which will be important
when we analyze their computational complexity in Chapter 6.
The logics extending S4.3 are logics of frames that are rooted, transitive, and
connected (‚àÄxy (Rxy ‚à®Ryx))). To see this, recall that S4.3 has as axioms 4, T, and
.3. These formulas are canonical for transitivity, reÔ¨Çexivity, and no branching to the
right, respectively. Hence any point-generated submodel of the canonical model
for these logics inherits all three properties, and will in addition be rooted and
connected. Now, any connected model is reÔ¨Çexive. Thus rootedness, transitivity,
and connectedness are the fundamental properties, and we will call any frame that
has them an S4.3 frame. Note that any S4.3 frame can be viewed as a chain of
clusters (see DeÔ¨Ånition 2.43), a perspective which will frequently be useful in what
follows.
Bull‚Äôs Theorem
Our Ô¨Årst goal is to prove Bull‚Äôs Theorem: all extensions of S4.3 have the Ô¨Ånite
frame property. In DeÔ¨Ånition 3.23 we deÔ¨Åned the Ô¨Ånite frame property as follows:
Œõ has the Ô¨Ånite frame property with respect to a class of Ô¨Ånite frames F if and
only if F  Œõ, and for every formula œÜ such that œÜ ‚àà Œõ there is some F ‚àà F
such that œÜ is falsiÔ¨Åable on F. Using the terminology introduced in this chapter,
we can reformulate this more concisely as follows: Œõ has the Ô¨Ånite frame property
if and only if there is a class of Ô¨Ånite frames F such that Œõ = ŒõF . So, to prove
Bull‚Äôs Theorem, we need to show that if Œõ extends S4.3, then any Œõ-consistent
formula œÜ is satisÔ¨Åable in a Ô¨Ånite model (W, R, V ) such that (W, R)  Œõ. In
short, Bull‚Äôs Theorem is essentially a general weak completeness result covering
all logics extending S4.3.
But how are we to build the required models? By transforming the canonical
model. Suppose œÜ is Œõ-consistent. Let w be any Œõ-MCS containing œÜ, and let
Mw = (W w , Rw , V w ) be the submodel of MŒõ generated by w. Then Mw , w  œÜ,
and (as just discussed) Mw is based on an S4.3 frame. We are going to transform
Mw into a Ô¨Ånite model Ms that satisÔ¨Åes œÜ and is based on an S4.3 frame that
validates Œõ.
Figure 4.2 shows what is involved. We are going to transform Mw in two distinct4 Completeness
248
MŒõ
generated
submodel
- Mw
deÔ¨Ånable
variant
- M
bounded
morphism
Ô¨Åltration
?
Mf
?
- Ms
elimination
Fig. 4.2. The models we will construct, and their relationships
ways. One involves taking a Ô¨Åltration and eliminating certain points; this is the
technical heart of the proof. The other involves deÔ¨Åning a bounded morphism on
a deÔ¨Ånable variant M of Mw ; this part uses the results on deÔ¨Ånable variants and
distinguishing models proved in Section 3.4. These transformations offer us two
perspectives on the properties of Ms , and together yield enough information to
prove the result.
And so to work. We Ô¨Årst discuss the Ô¨Åltration/elimination transformation. Let Œ¶
be the (Ô¨Ånite) set consisting of all subformulas of 3œÜ, and let Mf = (W f , Rf , V f )
be the result of transitively Ô¨Åltrating Mw through Œ¶. Recall that the relation Rf
used in transitive Ô¨Åltrations is deÔ¨Åned by Rf |u||v| iff 3œà ‚àà v implies 3œà ‚àà u,
for all 3œà ‚àà Œ¶, and all u, v ‚àà W w ; see Lemma 2.42. As Œ¶ is Ô¨Ånite, so is W f .
By the Filtration Theorem (Theorem 2.39), Mf , |u|  œà iff Mw , u  œà, for all
œà ‚àà Œ¶, and all u ‚àà W w . Moreover, Rf is transitive, reÔ¨Çexive, and connected, and
|w| is a root of the Ô¨Åltration, thus Mf is based on an S4.3 frame. Hence the frame
underlying Mf is a Ô¨Ånite chain of Ô¨Ånite clusters.
Now for the key elimination step. We want to build a Ô¨Ånite model based on a
frame for Œõ. Now, we do not know whether Mw is based on such a frame, but we
do know that Mw  Œõ. If we could transfer the truth of Œõ in Mw to a Ô¨Ånite dis-
tinguishing model, then by item (iii) of Lemma 3.27 we would immediately have
Bull‚Äôs Theorem. Unfortunately, while Mf is Ô¨Ånite, and also (being a Ô¨Åltration) dis-
tinguishing, we have no guarantee that Mf  Œõ. This reÔ¨Çects something discussed
in Section 2.3: the natural map associated with a Ô¨Åltration need not be a bounded
morphism. It also brings us to the central idea of the proof: eliminate all points in
Mf which prevent the natural map from being a bounded morphism. Obviously,
any model built from Mf by eliminating points will be Ô¨Ånite and distinguishing.
So the crucial questions facing us are: which points should be eliminated, and how
do we know that they can be thrown away without affecting the satisÔ¨Åability of
formulas in Œ¶?
Recall that the natural map associated with a Ô¨Åltration sends each point u in
the original model to the equivalence class |u| in the Ô¨Åltration. So if the natural4.9 Finitary Methods II
249
map from the frame underlying Mw to the frame underlying Mf is not a bounded
morphism, this means that for some Œ≤, Œ± ‚àà W f we have that Rf Œ≤Œ± but
¬¨‚àÄv ‚àà Œ≤ ‚àÉz (Rw vz ‚àß z ‚àà Œ±),
or equivalently, that Rf Œ≤Œ± but
‚àÉv ‚àà Œ≤ ‚àÄz (z ‚àà Œ± ‚Üí ¬¨Rw vz).
This motivates the following deÔ¨Ånition:
DeÔ¨Ånition 4.92 Suppose Œ≤, Œ± ‚àà W f . We say that Œ± is subordinate to Œ≤ (Œ± sub Œ≤)
if there is a v ‚àà Œ≤ such that for all z ‚àà Œ±, it is not the case that Rw vz.
So: if Mf is not a bounded morphic image of Mw under the natural map, then
there is some Œ± ‚àà W f such that for some Œ≤ ‚àà W f , Rf Œ≤Œ± and Œ± sub Œ≤. We must
get rid of all such Œ±s; we will call them eliminable points. But to show that we can
safely eliminate them, we need to understand the sub relation a little better.
Lemma 4.93
(i) If Œ± sub Œ≤, then there is a v ‚àà Œ≤ such that for all z ‚àà Œ±,
Rw zv.
(ii) If Œ± sub Œ≤ then Rf Œ±Œ≤.
(iii) The sub relation is transitive and asymmetric.
(iv) Suppose Œ±, Œ≤, Œ≥ ‚àà W f such that Œ± sub Œ≥ and not Œ± sub Œ≤. Then Œ≤ sub Œ≥.
Proof. For item (i), note that by deÔ¨Ånition there is a v ‚àà Œ≤ such that for all z ‚àà Œ±,
it is not the case that Rw vz. But Rw is a connected relation, hence for every z ‚àà Œ±,
Rw zv.
For item (ii), suppose Œ± sub Œ≤. By item (i), this means that there is some
element v of Œ≤, such that every element of Œ± Rw -precedes v. Now if 3œà ‚àà Œ≤, then
Mw , v  3œà. Hence (by the transitivity of Rw ) for all z ‚àà Œ±, Mw , z  3œà too.
This means that 3œà ‚àà Œ±, that is, Rf Œ±Œ≤. (It follows that if the natural map fails
to be bounded morphism because of its behavior on the points Œ≤ and Œ±, then the
eliminable point Œ± belongs to the same cluster as Œ≤.)
Items (iii) and (iv) are left for the reader as Exercise 4.9.1.
We are now ready for the key result: we can safely get rid of all the eliminable
points; there are enough non-eliminable points left to prove an Existence Lemma:
Lemma 4.94 (Existence Lemma) Let u ‚àà W w and suppose 3œà ‚àà u ‚à© Œ¶. Then
there is a |v| ‚àà W f such that Rf |u||v|, œà ‚àà |v|, and |v| is not eliminable.
Proof. Construct a maximal sequence Œ±0 , Œ±1 , . . . through W f with the following
properties:
(i) Œ±0 = |u|.250
4 Completeness
(ii) If i > 0 and odd, then Œ±i is some |v| such that œà ‚àà v, Rf Œ±i‚àí1 |v|, and not
|v| sub Œ±i‚àí1 .
(iii) If i > 0 and even, then Œ±i is some |v| such that Rf |v|Œ±i‚àí1 and Œ±i‚àí1 sub |v|.
Here is the basic idea. Think of this sequence as a series of moves through the
model. We are given 3œà, and our goal is to Ô¨Ånd an Rf -related œà-containing point
that is not eliminable. So, on our Ô¨Årst move (an odd move) we select an Rf -
related œà-containing point (we are guaranteed to Ô¨Ånd one, pretty much as in any
Existence Lemma). If the point is not-eliminable we have found what we need
and are Ô¨Ånished. Unfortunately, the point may well be eliminable. If so, we make
a second move (an even move) to another point in the same cluster ‚Äì namely a
point to which the Ô¨Årst point we found is subordinate. We iterate the process, and
eventually we will Ô¨Ånd what we are looking for. We now make this (extremely
sketchy) outline precise.
Claim 1. For every item Œ±i = |v| in the sequence, 3œà ‚àà v.
If i = 0, Œ±i = |u| and by assumption 3œà ‚àà u. If i > 0 and odd, then œà ‚àà |v| by
construction, hence œà ‚àà v. As v is a Œõ-MCS it contains œà ‚Üí 3œà, thus 3œà ‚àà v
also. Finally, if i > 0 and even, then as we have just seen, 3œà ‚àà Œ±i‚àí1 . By
construction, Rf |v|Œ±i‚àí1 hence 3œà ‚àà |v| and hence 3œà ‚àà v. This proves Claim 1.
Claim 2. The sequence terminates.
Suppose i is even. By property (iii), Œ±i+1 sub Œ±i+2 and by property (ii), it is not the
case that Œ±i+1 sub Œ±i . Hence by item 3 of Lemma 4.93, Œ±i sub Œ±i+2 . By item (ii)
of Lemma 4.93, sub is a transitive and asymmetric relation, thus all Œ±i with even i
are different. As there are only Ô¨Ånitely many elements in Wf , the sequence must
terminate. This proves Claim 2.
Claim 3. The sequence does not terminate on even i.
Suppose i is even. We need to show that there is an Œ±i+1 ‚àà W f such that Rf Œ±i Œ±i+1
and not Œ±i+1 sub Œ±i . Let {Œ≤1 , . . . , Œ≤m } be {Œ≤ ‚àà W f | Œ≤ sub Œ±i }. Then for each
k (1 ‚â§ k ‚â§ m) there is a vk ‚àà Œ±i such that not Rw vk z, for all z ‚àà Œ≤k . Let v be
one of these points vk such that for all k, Rw vk v, for 1 ‚â§ k ‚â§ m. (It is always
possible to choose such a v as Rw is connected.) As Œ±i = |v|, by Claim 1 3œà ‚àà v.
By the Existence Lemma for normal logics (Lemma 4.20), there is an x ‚àà W such
that œà ‚àà x and Rw vx. Moreover, not |x| sub |v|. For suppose for the sake of a
contradiction that |x| sub |v|. Then |x| = Œ≤k , for some 1 ‚â§ k ‚â§ m, and hence not
Rw vk x. But Rw vk v and Rw vx, hence (by transitivity) Rw vk x ‚Äì contradiction. We
conclude that not |x| sub |v|, hence (recalling that |v| = Œ±i ) we can always choose
Œ±i+1 to be |x|. This proves Claim 3.
We can now prove the result. By Claims 2 and 3, the sequence terminates on
Œ±m = |v|, for some odd number m. By construction, œà ‚àà v, hence œà ‚àà |v|.4.9 Finitary Methods II
251
Since Œ±m+1 does not exist, Œ±m is not eliminable. By construction, for all even i,
Rf Œ±i Œ±i+1 . By item (ii) of Lemma 4.93, for all odd i, Rf Œ±i Œ±i+1 . Hence by the
transitivity of Rf , Rf |u||v|, and we are through.
We now deÔ¨Åne the model Ms . Let W s be the set of non-eliminable points in
W f . (Note that by the previous lemma there must be at least one such point, for
3œÜ ‚àà w ‚à© Œ¶.) Then Ms = (W s , Rs , V s ) is Mf restricted to W s . Hence Ms is a
Ô¨Ånite distinguishing model, and (W s , Rs ) is an S4.3 frame.
Lemma 4.95 Ms satisÔ¨Åes œÜ.
Proof. First, we show by induction on the structure of œà that for all œà ‚àà Œ¶, and
all |u| ‚àà W s , Ms , |u|  œà iff œà ‚àà u. The only interesting case concerns the
modalities. So suppose 3œà ‚àà u. By the previous lemma, there is some |v| such
that Rf |u||v|, œà ‚àà |v|, and |v| is not eliminable. As œà ‚àà |v|, œà ‚àà v, hence by the
inductive hypothesis, Ms , |v|  œà, hence Ms , |u|  3œà as desired. The converse
is straightforward; we leave it to the reader.
It follows that œÜ is satisÔ¨Åed somewhere in Ms . For, as 3œÜ ‚àà w ‚à© Œ¶, by
Lemma 4.94 there is a non-eliminable |u| such that Rf |w||u| and œÜ ‚àà |u|. Hence
œÜ ‚àà u, and Ms , |u|  œÜ.
We are almost there. If we can show that Ms  Œõ, then as Ms is a Ô¨Ånite distin-
guishing model, its frame validates Œõ and we are through. Showing that Ms  Œõ,
will take us along the other path from Mw to Ms shown in Figure 4.2. That is, we
will show that Ms is a bounded morphic image of a deÔ¨Ånable variant M of Mw .
The required bounded morphism f is easy to describe: it agrees with the natural
map on all non-eliminable points, and where the natural map sent a point w to a
point that has been eliminated, f (w) will be a point ‚Äòas close as possible‚Äô to the
eliminated point. Let us make this precise. Enumerate the elements of Ws . DeÔ¨Åne
f : W w ‚Üí W s by
‚éß
s
‚é™
‚é® |w|, if |w| ‚àà W ,
f (w) =
the Ô¨Årst element in the enumeration which is an Rs -minimal
‚é™
‚é©
element of {Œ± ‚àà W s | Rs |w|Œ±}, otherwise.
As W s is Ô¨Ånite, the minimality requirement (which captures the ‚Äòas close as possi-
ble‚Äô idea) is well deÔ¨Åned.
As we will show, f is a bounded morphism from (W w , Rw ) into (W s , Rs ).
But we have no guarantee that f is a bounded morphism from the model Mw
to Ms , for while the underlying frame morphism is Ô¨Åne, we need to ensure that
the valuations agree on propositional symbols. We Ô¨Åx this as follows. For any
propositional symbol p, deÔ¨Åne V  (p) to be {u ‚àà W w | f (u) ‚àà V s (p)}, and let M
be (W w , Rw , V  ). That is, M is simply a variant of Mw that agrees with Ms under252
4 Completeness
the mapping f . But it is not just any variant: as we will now see, it is a deÔ¨Ånable
variant. It is time to pull all the threads together and prove the main result.
Theorem 4.96 (Bull‚Äôs Theorem) Every normal modal logic extending S4.3 has
the Ô¨Ånite frame property.
Proof. First we will show that M is a deÔ¨Ånable variant of Mw . If Œ≤ is any of the
equivalence classes that make up the Ô¨Åltration Mf , then Œ≤ ‚äÜ W w . Moreover, Mw
can deÔ¨Åne any such Œ≤: the deÔ¨Åning formula Œ≤ÃÇ is simply a conjunction of all the
formulas in some subset of Œ¶, the set we Ô¨Åltrated through. (Incidentally, we take
the conjunction of the empty set to be ‚ä•.) It follows that Mw can deÔ¨Åne V  (p)
for any propositional symbol p. To see this, note that V s (p) is either the empty set
or some Ô¨Ånite collection of equivalence classes {Œ≤1 , . . . , Œ≤n }. In the former case,

deÔ¨Åne Œ¥p to be ‚ä•. In the latter case, deÔ¨Åne Œ¥p to be i‚ààn Œ≤ÃÇi . Either way, Œ¥p deÔ¨Ånes
V  (p) in Mw , for V  (p) is {u ‚àà W w | f (u) ‚àà V s (p)}. Thus M is a deÔ¨Ånable
variant of Mw . (Note that this argument makes use of facts about all four models
constructed in the course of the proof.)
Next we claim that f is indeed a surjective bounded morphism from Ms onto
M ; we show here that it satisÔ¨Åes the back condition and leave the rest to the
reader. Suppose Rs f (u)f (v). As f (v) ‚àà W s , it is not eliminable, hence not
f (v) sub f (u). But this means that every element in f (u) Rw -precedes an element
in f (v), as required.
But now Bull‚Äôs Theorem follows. If Œõ is a normal modal logic extending S4.3
and œÜ is a Œõ-consistent formula, build Ms as described above. By Lemma 4.95,
Ms satisÔ¨Åes œÜ. Moreover Ms  Œõ. To see this, simply follow the upper left to
right path through Figure 4.2. MŒõ  Œõ, hence so does Mw , for it is a generated
submodel of MŒõ . As M is a deÔ¨Ånable variant of Mw , by Lemma 3.25 item (iii),
M  Œõ. Hence, as Ms is a bounded morphic image of M , it too validates Œõ as
required. But Ms is a Ô¨Ånite distinguishing model, hence, by Lemma 3.27 item (iii),
its frame validates Œõ and we are through.
Finite axiomatizability
We now show that every normal logic extending S4.3 is Ô¨Ånitely axiomatizable. (A
logic Œõ is Ô¨Ånitely axiomatizable if there is a Ô¨Ånite set of formulas Œì such that Œõ
is the logic generated by Œì .) The proof makes use of a special representation for
Ô¨Ånite S4.3 frames.
Because every Ô¨Ånite S4.3 frame is a Ô¨Ånite chain of Ô¨Ånite clusters, any such frame
can be represented as a list of positive integers: each positive integer in the list
records the cardinality of the corresponding cluster. For example, the list [3, 1, 2]
represents the following frame:'

t?
@

 @
I@
R

@

: t





-
t
9


&
4.9 Finitary Methods II
$
'

t?
=‚áí$
&%
%
253
$
'


?
t
=‚áí

- t?
&
%
Such representations will allow us to reduce the combinatorial heart of the follow-
ing proofs to a standard result about lists. The following deÔ¨Ånition pins down the
relationship between lists that will be important.
DeÔ¨Ånition 4.97 A list is a Ô¨Ånite non-empty list of positive integers. A list t con-
tains a list s if t has a sublist of the same length as s, each item of which is greater
than or equal to the corresponding item of s. A list t covers a list s if t contains s
and the last item of t is greater than or equal to the last item of s.
For example, the list [9, 40, 1, 9, 3] contains the list [8, 2, 9], for it has [9, 40, 9] as a
sublist, but it does not cover this list. But [9, 40, 1, 9, 10] covers [8, 2, 9].
The modal relevance of list covering stems from the following lemma:
Lemma 4.98 Let F and G be Ô¨Ånite S4.3 frames, and let f and g be their associated
lists. Then f covers g iff there is a bounded morphism from F onto G.
Proof. Exercise 4.9.2.
In view of this result, the following well-known result can be viewed as asserting
the existence of inÔ¨Ånite sequences of bounded morphisms:
Theorem 4.99 (Kruskal‚Äôs Theorem) Every countably inÔ¨Ånite sequence of lists t
contains an inÔ¨Ånite subsequence s such that for all lists si and sj in s, i > j implies
si covers sj .
Proof. Let us call a (Ô¨Ånite or inÔ¨Ånite) subsequence (ti )i‚ààI of a sequence of lists
t = (ti )i‚ààœâ a chain in t if for all i, j ‚àà I, tj covers ti whenever j > i. We assume
familiarity with the notions of the head, the tail and the sum of a list. For instance,
the head of [8, 2, 9] is 8, its tail is [2, 9] and its sum is 19. Call s smaller than t if
the sum of s is smaller than that of t.
In order to prove the theorem, we will show the following holds:
every countably inÔ¨Ånite sequence of lists t contains a chain of length 2.
(4.2)
Assume that (4.2) does not hold; that is, there are countably inÔ¨Ånite sequences
without chains of length 2 as subsequences.
Without loss of generality we may assume that t does not contain inÔ¨Ånitely many254
4 Completeness
lists of length 1. For otherwise, consider its subsequence (ti )i‚ààI of these one-
item lists. This subsequence may be identiÔ¨Åed with a sequence of natural numbers
(ni )i‚ààœâ . But
any sequence (ni )i‚ààœâ of natural numbers contains a subsequence
(ni )i‚ààI such that for all i, j ‚àà I, i < j implies ni ‚â§ nj ,
(4.3)
as can easily be proved. But if ni ‚â§ nj then clearly tj covers ti . But then we
may also assume that t does not contain one-item lists at all: simply consider the
sequence found by eliminating all one-item lists.
Let t be a minimal such sequence. That is, t is a sequence of more-item lists,
t has no 2-chains, and for all n, there are no more-item lists tn , tn+1 , . . . such
that tn is smaller than tn , while the sequence t0 , t1 , . . . , tn‚àí1 , tn , tn+1 , . . . has no
2-chains.
Now we arrive at the heart of the argument. DeÔ¨Åne (ni )i‚ààœâ and (ui )i‚ààœâ as the
sequences of the heads and the tails of t; that is, for each i, ni is the head of ti and
ui is the tail of ti . By (4.3), there is a subsequence (ni )i‚ààI such that i < j implies
ni ‚â§ nj , whenever i, j ‚àà I. Now consider the corresponding subsequence (ui )i‚ààI
of u. We need the following result:
any subsequence (vi )i‚ààœâ of tails of t contains a 2-chain.
(4.4)
By the same argument as before, we may assume that v contains only more-item
lists. Let k be the natural number such that v0 is the tail of tk , and consider the
sequence t0 , t1 , . . . , tk‚àí1 , v0 , v1 , . . . . Since v0 is the tail of tk and, hence, smaller
than tk , it follows by the minimality of tk that the mentioned sequence contains a
2-chain. But obviously this 2-chain can only occur in the v-part of the sequence.
This proves (4.4).
But if u contains a 2-chain, this means that there are two numbers i and j in
I with i < j and uj covers ui . Also, by deÔ¨Ånition of I, ni ‚â§ nj . But then
ti = [mi ] ‚àó ui is covered by tj = [mj ] ‚àó uj . This proves (4.2).
Finally, it remains to prove the theorem from (4.2). Let t be an arbitrary count-
ably inÔ¨Ånite sequence of lists. By successive applications of (4.2), it follows that t
contains inÔ¨Ånitely many chains. We claim that one of these chains is inÔ¨Ånite. For if
we suppose that there are only Ô¨Ånite chains, we may consider the sequence z of last
items of right-maximal Ô¨Ånite chains in t (a chain is right-maximal if it can not be
extended to the right). There must be inÔ¨Ånitely many such right-maximal chains,
so z is an inÔ¨Ånite sequence. Hence, by yet another application of (4.2), z contains
a chain of length 2. But then some chain was not right-maximal after all.
We now extract the consequences for logics extending S4.3:
Corollary 4.100 There is no inÔ¨Ånite sequence Œõ0 , Œõ1 , . . . of normal logics con-
taining S4.3 such that for all i, Œõi ‚äÇ Œõi+1 .4.9 Finitary Methods II
255
Proof. Suppose otherwise. Then for some inÔ¨Ånite sequence of logics Œõ0 , Œõ1 ,
. . . extending S4.3, and for all natural numbers i, there is a formula œÜi such that
œÜi ‚àà Œõi and œÜi ‚àà Œõi+1 . So, by Bull‚Äôs Theorem, for all natural numbers i there
is a Ô¨Ånite S4.3 frame Fi that validates Œõi and does not satisfy œÜi . Let t be the
inÔ¨Ånite sequence of lists ti associated with the frames Fi . By Kruskal‚Äôs Theorem,
there exist natural numbers k and l, such that k > l and tk covers tl . Hence by
Lemma 4.98 there is a bounded morphism from Fk onto Fl . It follows that Fl  œÜl
and we have a contradiction.
Theorem 4.101 Every normal modal logic extending S4.3 is Ô¨Ånitely axiomatiz-
able.
Proof. To arrive at a contradiction, we will assume that there does exist an ex-
tension Œõ of S4.3 that is not Ô¨Ånitely axiomatizable. We will construct an inÔ¨Ånite
sequence Œõ0 ‚äÇ Œõ1 ‚äÇ ¬∑ ¬∑ ¬∑ of extensions of S4.3, thus contradicting Corollary 4.100.
As Œõ is not Ô¨Ånitely axiomatizable, it must be a proper extension of S4.3. Let
œÜ0 be an arbitrary formula in Œõ \ S4.3, and deÔ¨Åne Œõ0 to be the logic generated by
S4.3 ‚à™ {œÜ0 }. Then S4.3 ‚äÇ Œõ0 ‚äÇ Œõ. The latter inclusion is strict because Œõ is
not Ô¨Ånitely axiomatizable. Hence, there exists œÜ1 ‚àà Œõ \ Œõ0 . Let Œõ1 be the logic
generated by Œõ0 ‚à™ {œÜ1 }. Continuing in this fashion we Ô¨Ånd the required inÔ¨Ånite
sequence Œõ0 ‚äÇ Œõ1 ‚äÇ ¬∑ ¬∑ ¬∑ of extensions of S4.3.
A negative characterization
We turn to the Ô¨Ånal task: showing that every normal logic extending S4.3 has a
negative characterization in terms of Ô¨Ånite sets of Ô¨Ånite frames. Once again, the
proof makes use of the representation of S4.3 frames as lists of positive integers.
First some terminology. A set of lists X is Ô¨Çat if for every two distinct lists in X,
neither covers the other. In view of Lemma 4.98, the modal relevance of Ô¨Çatness
is this: if two frames are associated with distinct lists belonging to a Ô¨Çat set, then
neither frame is a bounded morphic image of the other.
Lemma 4.102 All Ô¨Çat sets are Ô¨Ånite. Furthermore, for any set of lists Y there is a
maximal set X such that X ‚äÜ Y and X is Ô¨Çat.
Proof. Easy consequences of Kruskal‚Äôs Theorem.
If X is a Ô¨Çat set of lists, then C(X) is the set of lists covered by some list in X.
Note that C(X) is Ô¨Ånite and that X ‚äÜ C(X). If X is a set of lists, then B(X) is
the class of all Ô¨Ånite S4.3 frames F such that there is a bounded morphism from F
onto some frame whose list is in X.
Theorem 4.103 For every normal modal logic Œõ extending S4.3 there is a Ô¨Ånite set4 Completeness
256
N of Ô¨Ånite S4.3 frames with the following property: for any Ô¨Ånite frame F, F  Œõ
iff F is an S4.3 frame and there does not exist a bounded morphism from F onto
any frame in N.
Proof. Let Œõ ‚äá S4.3, and let L be the set of lists associated with Ô¨Ånite S4.3 frames
which do not validate Œõ. Let L be a maximal Ô¨Çat set such that L ‚äÜ L . Note that
C(L) ‚äÜ L .
We claim that for any Ô¨Ånite S4.3 frame F, F  Œõ iff F ‚àà B(C(L)). The left to
right implication is clear, for as no frame whose list belongs to C(L) validates Œõ,
there cannot be a bounded morphism from F onto any such frame. For the other
direction, we show the contrapositive. Suppose that F  Œõ. Let F‚Äôs list be f. Then
f ‚àà L . Now either f ‚àà C(L) or f ‚àà L \ C(L). If f ‚àà C(L), then the identity
morphism on F guarantees that F ‚àà B(C(L)) as required. So suppose instead that
f ‚àà L \ C(L). This means that f ‚àà L (as L ‚äÜ C(L)), hence as L is a maximal
Ô¨Çat subset of L , f must cover some list g in L. Thus by Lemma 4.98, any S4.3
frame G whose list is g is a bounded morphic image of F, hence F ‚àà B(C(L)) as
required. This completes the proof of the claim.
We can now deÔ¨Åne the desired Ô¨Ånite set N: for each g ‚àà C(L), choose a frame
whose list is g, and let N be the set of all our choices.
Exercises for Section 4.9
4.9.1 Show that the sub relation is transitive and asymmetric. Furthermore, show that if
Œ± sub Œ≥ and not Œ± sub Œ≤, then Œ≤ sub Œ≥.
4.9.2 Prove Lemma 4.98. That is, let F and G be Ô¨Ånite S4.3 frames, and let f and g be their
associated lists. Then show that f covers g iff there is a bounded morphism from F onto
G. (First hint: look at how we deÔ¨Åned the bounded morphism used in the proof of Bull‚Äôs
Theorem. Second hint: look at the statement (but not the proof!) of Lemma 6.39.)
4.9.3 Give a complete characterization of all the normal logics extending S5. Your answer
should include axiomatizations for all such logics.
4.9.4 Let Kt 4.3 be the smallest tense logic containing 4, T , .3 l and .3r . Show that there
are tense logics extending K t 4.3 that do not have the Ô¨Ånite frame property. (Hint: look
at the tense logic obtained by adding the Grzegorczyk axiom in the operator F . Is the
Grzegorczyk axiom in P satisÔ¨Åable in a model for this logic? Is the Grzegorczyk axiom in
P satisÔ¨Åable in a Ô¨Ånite model for this logic?)
4.10 Summary of Chapter 4
 Completeness: A logic Œõ is weakly complete with respect to a class of structures
S if every formula valid on S is a Œõ-theorem. It is strongly complete with
respect to S if whenever a set of premises entails a conclusion over S, then the
conclusion is Œõ-deducible from the premises.4.10 Summary of Chapter 4
257
 Canonical Models and Frames: Completeness theorems are essentially model
existence theorems. The most important model building technique is the canon-
ical model construction. The points of the underlying canonical frames are max-
imal consistent sets of formulas, and the relations and valuation are deÔ¨Åned in
terms of membership of formulas in such sets.
 Canonicity: Many formulas are canonical for a property P . That is, they are
valid on any frame with property P , and moreover, when used as axioms, they
guarantee that the canonical frame has property P . When working with such
formulas, it is possible to prove strong completeness results relatively straight-
forwardly.
 Sahlqvist‚Äôs Completeness Theorem: Sahlqvist formulas not only deÔ¨Åne Ô¨Årst-
order properties of frames, each Sahlqvist formula is also canonical for the Ô¨Årst-
order property it deÔ¨Ånes. As a consequence, strong completeness is automatic
for any logic that is axiomatized by axioms in Sahlqvist form.
 Limitative Results: The canonical model method is not universal: there are
weakly complete logics whose axioms are not valid on any canonical frame. In-
deed, no method is universal, for there are logics that are not sound and weakly
complete with respect to any class of frames at all.
 Unraveling and Bulldozing: Often we need to build models with properties for
which no modal formula is canonical. Sometimes this can be done by transform-
ing the logic‚Äôs canonical model so that it has the relevant properties. Unraveling
and bulldozing are two useful transformation methods.
 Step by Step: Instead of modifying canonical models directly, the step-by-step
method builds models by selecting MCSs. Because it builds these selections
inductively, it offers a great deal of control over the properties of the resulting
model.
 Rules for the UndeÔ¨Ånable: By enriching our deductive machinery with special
proof rules, it is sometimes possible to construct canonical models that have the
desired properties right from the start, thus avoiding the need to massage the
(standard) canonical model into some desired shape.
 Finitary Methods: The canonical model method establishes strong complete-
ness. Only weak completeness results are possible for non-compact logics such
as propositional dynamic logic, and Ô¨Ånite canonical models (essentially Ô¨Åltra-
tions of standard canonical models) are a natural tool for proving such results.
 Logics extending S4.3: Although the incompleteness results show that a frame
based analysis of all normal logics is impossible, many subregions of the lattice
of normal modal logics are better behaved. For example, the logics extend-
ing S4.3 all have the Ô¨Ånite frame property, are Ô¨Ånitely axiomatizable, and have
negative characterizations in terms of Ô¨Ånite frames.258
4 Completeness
Notes
Modal completeness results can be proved using a variety of methods. Kripke‚Äôs
original modal proof systems (see [283, 284]) were tableaux systems, and com-
pleteness proofs for tableaux typically do not make use of MCSs (Fitting [137] is
a good introduction to modal tableaux methods). Completeness via normal form
arguments have also proved useful. For example, Fine [131] uses normal forms to
prove the completeness of the normal logic generated by the McKinsey axiom; this
logic is not canonical (see Goldblatt [187]).
Nonetheless, most modal completeness theory revolves, directly or indirectly,
around canonical models; pioneering papers include Makinson [307] (who uses
a method close to the step-by-step construction to pick out generated subframes
of canonical models) and Cresswell [99]. But the full power of canonical models
and completeness-via-canonicity arguments did not emerge clearly till the work
of Lemmon and Scott [296]. Their monograph stated and proved the Canoni-
cal Model Theorem and used completeness-via-canonicity arguments to establish
frame completeness results; these included a general canonicity result for axioms
of the form 3k 2j p ‚Üí 2m 3n p, where k, j, m, n ‚â• 0. While less general than
Sahlqvist‚Äôs [396] later result (Theorem 4.42), this covered most of the better-known
systems, and was testimony to the generality of the canonical model method.
That KL is weakly complete with respect to the class of Ô¨Ånite transitive trees
is proved in Segerberg [404]. (Strictly speaking, Segerberg proved that KL4 is
complete with respect to the transitive trees, as it was not then known that 4 was
derivable in KL; derivations of 4 were independently found by de Jongh, Kripke,
and Sambin: see Boolos [69, page 11] and Hughes and Cresswell [235, page 150].)
Segerberg Ô¨Årst proves weak completeness with respect to the class of Ô¨Ånite strict
partial orders (the result we asked the reader to prove in Exercise 4.8.7), however
he does so by Ô¨Åltrating the canonical model for KL, whereas we asked the reader to
use a Ô¨Ånite canonical model argument. Of course, the two arguments are intimately
related, but the Ô¨Ånite canonical model argument (which we have taken from Hughes
and Cresswell [235, Theorem 8.4]) is rather more direct. Segerberg then proves
weak completeness with respect to Ô¨Ånite trees by unraveling the resulting model
(just as we asked the reader to do in Exercise 4.8.8).
The incomplete tense logic Kt ThoM discussed in the text was the Ô¨Årst known
frame incomplete logic, and it is still one of the most elegant and natural exam-
ples. It can be found in Thomason [434], and the text follows Thomason‚Äôs original
incompleteness proof. Shortly afterward, both Fine [129] and Thomason [434]
exhibited (rather complex) examples of incomplete logics in the the basic modal
language. The (much simpler) incomplete logic KvB examined in Exercise 4.4.2
is due to van Benthem [39]; KvB is further examined in Cresswell [100]. In Exer-
cise 4.4.4 we listed three formulas which jointly deÔ¨Åne a Ô¨Årst-order class of frames,Notes to Chapter 4
259
but which when used as axioms give rise to an incomplete normal logic; this ex-
ample is due to van Benthem [37, 43]. The logic of the veiled recession frame was
Ô¨Årst axiomatized by Blok [64]. It was also Blok [65, 66] who showed that incom-
pleteness is the rule rather than the exception among modal logics. The result that
every consistent normal modal logic in the basic modal similarity type deÔ¨Ånes a
non-empty frame class is due to Makinson [309].
Although Ô¨Åltration and unraveling had been used earlier to prove complete-
ness results, the systematic use of transformation methods stems from the work
of Segerberg [404]. Segerberg reÔ¨Åned the Ô¨Åltration method, developed the bulldoz-
ing technique, and used them (together with other transformations) to prove many
important completeness results, including characterizations of the tense logics of
(N, <), (Z, <), (Q, <), (R, <) and their reÔ¨Çexive counterparts.
We do not know who Ô¨Årst developed the modal step-by-step method. Certainly
the idea of building models inductively is a natural one, and has long been used in
both algebraic logic (see [226]) and set-theory (see [417]). One inÔ¨Çuential source
for the method is the work of Burgess: for example, in [78] he uses it to prove
completeness results in since/until logic (see also Xu [466] for some instructive
step-by-step proofs for this language). Moreover, in [79], his survey article on
tense logic, Burgess proves a number of completeness results for the basic modal
language using the method. A set of lecture notes by de Jongh and Veltman [250] is
the source of the popularity among Amsterdam logicians. Recent work on Arrow
Logic uses the method (and the related mosaic method) heavily, often combined
with the use of rules for the undeÔ¨Ånable (see, for example, [320]). Step-by-step
arguments are now widely used in a variety of guises.
Gabbay [149] is one of the earliest papers on rules for the undeÔ¨Ånable, and one of
the most inÔ¨Çuential (an interesting precursor is Burgess [77], in which these rules
are used in the setting of branching time logic). Gabbay and Hodkinson [155] is an
important paper which shows that such rules can take a particularly simple form in
the basic temporal language. For rules in modal languages equipped with the D-
operator, see de Rijke [378] and Venema [444]. For rules in modal languages with
nominals, see Passy and Tinchev [358], Gargov and Goranko [164], Blackburn and
Tzakova [63], and Blackburn [56].
The axiomatization of PDL that we gave in the text is from [407], Segerberg‚Äôs
1977 abstract. But there was a gap in Segerberg‚Äôs completeness proof, and by the
time he had published a full corrected version (see [409]) very different proofs by
Parikh [353] and Kozen and Parikh [273], had appeared. It seems that several other
unpublished completeness proofs were also in circulation at this time: see Harel‚Äôs
survey of dynamic logic [209] for details. The proof in the text is based on lecture
notes by van Benthem and Meyer Viol [50].
Bull‚Äôs Theorem was the Ô¨Årst general result about the Ô¨Åne structure of the lattice
of normal modal logics. Bull‚Äôs original proof (in [74]) was algebraic; the model-260
4 Completeness
theoretic proof given in the text is due to Fine [128]. A discussion of the relation-
ship between the two proofs may be found in Bull and Segerberg [75]. Moreover,
Goldblatt [177] presents Fine‚Äôs proof from a rather different perspective, empha-
sizing a concept he calls ‚Äòclusters within clusters‚Äô; the reader will Ô¨Ånd it instructive
to compare Goldblatt‚Äôs presentation with ours. Fine‚Äôs [128] also contains the Ô¨Ånite
axiomatizability result for logics extending S4.3 (Theorem 4.101) and the (nega-
tive) characterization in terms of Ô¨Ånite sets of Ô¨Ånite frames (Theorem 4.103), and
the text follows Fine‚Äôs original proofs here too.
The work of Bull and Fine initiated a (still Ô¨Çourishing) investigation into subre-
gions of the lattice of normal modal logics. For example, the position of logics in
the lattice characterized by a single structure is investigated in Maksimova [311],
Esakia and Meskhi [124] and (using algebraic methods) Blok [66]. In [130, 133],
Fine adapts his methods to analyze the logics extending K4.3 (the adaptation is
technically demanding as not all these logics have the f.f.p.). The Berlin school
has a long tradition in this area: see Rautenberg [372, 373, 374], Kracht [277, 278,
279], and Wolter [459]. More recently, the structure of the lattice of tense log-
ics has received attention: see, for example, Kracht [275] and Wolter [457]. And
Wolter [458] investigates the transfer of properties when the converse operator P is
added to a logic (in the basic modal language) that extends K4, obtaining various
axiomatizability and decidability results.
Work by Zakharyaschev has brought new ideas to bear. As we pointed out in the
Notes to Chapter 3, in the 1960s (the early years following the introduction of re-
lational semantics for modal logic) it was hoped that one could describe any modal
formula by imposing Ô¨Årst-order conditions on its frames. But the incompleteness
results, and the discovery of modal formulas that do not correspond to any Ô¨Årst-
order condition, destroyed this hope. In a series of papers Zakharyaschev [470,
471, 472, 473] has studied an alternative, purely frame-theoretic approach to the
classiÔ¨Åcation of modal formulas. Given a modal (or intuitionistic) formula œÜ, one
can effectively construct Ô¨Ånite rooted frames F1 , . . . , Fn such that a general frame
g refutes œÜ iff there is a (not necessarily generated) subframe g of g which satisÔ¨Åes
certain natural conditions and which can be mapped to one of the Fi by a bounded
morphism. Conversely, with every Ô¨Ånite rooted frame F Zakharyaschev associates
a canonical formula which can be refuted on a frame iff that frame contains a sub-
frame (satisfying certain natural conditions) that can be mapped to F by a bounded
morphism. Like the search for Ô¨Årst-order characterizations, the classiÔ¨Åcation ap-
proach in terms of canonical formulas is not universal either. But its limitations are
of a different kind: it only characterizes transitive general frames ‚Äì but for every
modal (and intuitionistic) formula. Zakharyaschev [467] is a very accessible sur-
vey of canonical formulas, with plenty of motivations, examples and deÔ¨Ånitions;
technical details and discussions of the algebraic and logical background of canon-
ical formulas are provided by Chagrov and Zakharyaschev [88, Chapter 9].5
Algebras and General Frames
In this chapter we develop an algebraic semantics for modal logic. The basic idea
is to extend the algebraic treatment of classical propositional logic (which uses
boolean algebras) to modal logic. The algebras employed to do this are called
boolean algebras with operators (BAOs). The boolean part handles the underlying
propositional logic, the additional operators handle the modalities.
But why algebraize modal logic? There are two main reasons. First, the alge-
braic perspective allows us to bring powerful new techniques to bear on modal-
logical problems. Second, the algebraic semantics turns out to be better-behaved
than frame-based semantics: we will be able to prove an algebraic completeness
result for every normal modal logic. As our discussion of incompleteness in Sec-
tion 4.4 makes clear, no analogous result holds for frames.
This chapter has three main parts. The Ô¨Årst, consisting of the Ô¨Årst three sections,
introduces the algebraic approach: we survey the basic ideas in the setting of clas-
sical propositional logic, extend them to modal logic, and prove the J√≥nsson-Tarski
Theorem. The second part, which consists of the fourth section, introduces dual-
ity theory, the study of correspondences between the universe of algebras and the
universe of frames. The last part (the only part on the advanced track) is devoted
to general frames. These turn out to be set-theoretic representations of boolean
algebras with operators, and we examine their properties in detail, and use them to
prove the Sahlqvist Completeness Theorem. Background information on universal
algebra can be found in Appendix B.
Chapter guide
Section 5.1: Logic as Algebra (Basic track). What is algebraic logic? This sec-
tion provides some preliminary answers by examining the relationship be-
tween propositional logic and boolean algebras.
Section 5.2: Algebraizing Modal Logic (Basic track). To algebraize modal logic,
we introduce boolean algebras with operators (BAOs). We discuss BAOs
261262
5 Algebras and General Frames
from a semantic perspective (introducing an important class of BAOs called
complex algebras), and from a syntactic perspective (we use Lindenbaum-
Tarski algebras to obtain abstract BAOs from normal modal logics).
Section 5.3: The J√≥nsson-Tarski Theorem (Basic track). Here we prove the the-
orem underlying algebraic approaches to modal completeness theory. First
we learn how to construct a frame from an algebra by forming the ultra-
Ô¨Ålter frame. By turning this frame back into a complex algebra, we ob-
tain the canonical embedding algebra. We then prove the J√≥nsson-Tarski
Theorem: every boolean algebra with operators can be embedded in its
canonical embedding algebra.
Section 5.4: Duality Theory (Basic track). Frames are inter-related by bounded
morphisms, generated subframes, and disjoint union. Boolean algebras
with operators are inter-related by homomorphisms, subalgebras, and di-
rect products. Modal duality theory studies the relationship between these
two mathematical universes. Two applications are given, one of which is
an algebraic proof of the Goldblatt-Thomason Theorem.
Section 5.5: General Frames (Advanced track). We (re)introduce general frames
and study them in detail, focusing on the relationship between general
frames, frames, and boolean algebras with operators. We conclude with a
brief discussion of some important topological aspects of general frames.
Section 5.6: Persistence (Advanced track). In this section we introduce a natural
generalization of the notion of canonicity encountered in Chapter 4: per-
sistence. We use it to prove the Sahlqvist Completeness Theorem.
5.1 Logic as Algebra
What do algebra and logic have in common? And why bring algebra into the study
of logic? This section provides some preliminary answers: we show that algebra
and logic share key ideas, and analyze classical propositional logic algebraically.
Along the way we will meet a number of important concepts (notably formula
algebras, the algebra of truth values, set algebras, abstract boolean algebras, and
Lindenbaum-Tarski algebras) and results (notably the Stone Representation Theo-
rem), but far more important is the overall picture. Algebraic logic offers a natural
way of re-thinking many basic logical issues, but it is important not to miss the
wood for the trees. The bird‚Äôs eye view offered here should help guide the reader
through the more detailed modal investigations that follow.
Algebra as logic
Most school children learn how to manipulate simple algebraic equations. Given
the expression (x + 3)(x + 1), they learn how to multiply these factors to form5.1 Logic as Algebra
263
x2 + 4x + 3, and (somewhat later) study methods for doing the reverse (that is, for
decomposing quadratics into factors).
Such algebraic manipulations are essentially logical. For a start, we have a well-
deÔ¨Åned syntax: we manipulate equations between terms. This syntax is rarely
explicitly stated, but most students (building on the analogy with basic arithmetic)
swiftly learn how to build legitimate terms using numerals, variables such as x, y
and z, and +, ¬∑ and ‚àí. Moreover, they learn the rules which govern this symbol
manipulation process: replacing equals by equals, doing the same thing to both
sides of an equation, appealing to commutativity, associativity and distributivity to
simplify and rearrange expressions. High-school algebra is a form of proof theory.
But there is also a semantic perspective on basic algebra, though this usually
only becomes clear later. As students learn more about mathematics, they realize
that the familiar ‚Äòlaws‚Äô do not hold for all mathematical objects: for example, ma-
trix multiplication is not commutative. Gradually the student grasps that variables
need not be viewed as standing for numbers: they can be viewed as standing for
other objects as well. Eventually the semantic perspective comes into focus: there
are various kinds of algebras (that is, sets equipped with collections of functions,
or operations, which satisfy certain properties), and terms denote elements in al-
gebras. Moreover, an equation such as x ¬∑ y = y ¬∑ x is not a sacrosanct law: it is
simply a property that holds for some algebras and not for others.
So algebra has a syntactic dimension (terms and equations) and a semantic di-
mension (sets equipped with a collection of operations). And in fact there is a
tight connection between the proof theory algebra offers and its semantics. In
Appendix B we give a standard derivation system for equational logic (that is, a
standard set of rules for manipulating equations) and state a fundamental result due
to Birkhoff: the system is strongly sound and complete with respect to the standard
algebraic semantics. Algebra really can be viewed as logic.
But logic can also be viewed as algebra. We will now illustrate this by examin-
ing classical propositional logic algebraically. Our discussion is based around three
main ideas: the algebraization of propositional semantics in the class of set alge-
bras; the algebraization of propositional axiomatics in the class of abstract boolean
algebras; and how the Stone Representation Theorem links these approaches.
Algebraizing propositional semantics
Consider any propositional formula, say (p ‚à® q) ‚àß (p ‚à® r). The most striking thing
about propositional formulas (as opposed to Ô¨Årst-order formulas) is their syntactic
simplicity. In particular, there is no variable binding ‚Äì all we have is a collection of
atomic symbols (p, q, r, and so on) that are combined into more complex expres-
sions using the symbols ‚ä•, , ¬¨, ‚à® and ‚àß. Recall that we take ‚ä•, ¬¨ and ‚à® as the
primitive symbols, treating the others as abbreviations.264
5 Algebras and General Frames
Now, as the terminology ‚Äòproposition letters‚Äô suggests, we think of p, q, and r
as symbols denoting entities called propositions, abstract bearers of information.
So what do ‚ä•, , ¬¨, ‚à® and ‚àß denote? Fairly obviously: ways of combining
propositions, or operations on propositions. More precisely, ‚à® and ‚àß must denote
binary operations on propositions (let us call these operations + and ¬∑ respectively),
¬¨ must denote a unary operation on propositions (let us call it ‚àí), while ‚ä• and 
denote special nullary operations on propositions (that is, they are the names of
two special propositions: let us call them 0 and 1 respectively). In short, we have
worked our way towards the idea that formulas can be seen as terms denoting
propositions.
But which kinds of algebras are relevant? Here is a Ô¨Årst step towards an answer.
DeÔ¨Ånition 5.1 Let Bool be the algebraic similarity type having one constant (or
nullary function symbol) ‚ä•, one unary function symbol ¬¨, and one binary function
symbol ‚à®. Given a set of propositional variables Œ¶, Form(Œ¶) is the set of Bool -
terms in Œ¶; this set is identical to the collection of propositional formulas in Œ¶.
Algebras of type Bool are usually presented as 4-tuples A = (A, +, ‚àí, 0). We
make heavy use of the standard abbreviations ¬∑ and 1. That is, a ¬∑ b is shorthand for
‚àí(‚àía + ‚àíb), and 1 is shorthand for ‚àí0.
But this only takes us part of the way. There are many different algebras of this
similarity type ‚Äì and we are only interested in algebras which can plausibly be
viewed as algebras of propositions. So let us design such an algebra. Propositional
logic is about truth and falsehood, so let us take the set 2 = {0, 1} as the set A
underlying the algebra; we think of ‚Äò0‚Äô as the truth value false, and ‚Äò1‚Äô as the value
true. But we also need to deÔ¨Åne suitable operations over these truth values, and we
want these operations to provide a natural interpretation for the logical connectives.
Which operations are appropriate?
Well, the terms we are working with are just propositional formulas. So how
would we go about evaluating a formula œá in the truth value algebra? Obviously
we would have to know whether the proposition letters in œá are true or false, but let
us suppose that this has been taken care of by a function Œ∏ : Œ¶ ‚Üí 2 mapping the set
Œ¶ of proposition letters to the set 2 of truth values. Given such a Œ∏ (logicians will
call Œ∏ a valuation, algebraists will call it an assignment) it is clear what we have to
do: compute Œ∏ÃÉ(œÜ) according to the following rules:
Œ∏ÃÉ(p)
Œ∏ÃÉ(‚ä•)
Œ∏ÃÉ(¬¨œÜ)
Œ∏ÃÉ(œÜ ‚à® œà)
=
=
=
=
Œ∏(p), for all p ‚àà Œ¶,
0,
1 ‚àí Œ∏ÃÉ(œÜ),
max(Œ∏ÃÉ(œÜ), Œ∏ÃÉ(œà)).
(5.1)
Clearly the operations used here are the relevant ones; they simply restate the fa-
miliar truth table deÔ¨Ånitions. This motivates the following deÔ¨Ånition:5.1 Logic as Algebra
265
DeÔ¨Ånition 5.2 The algebra of truth values is 2 = ({0, 1}, +, ‚àí, 0)), where ‚àí and
+ are deÔ¨Åned by ‚àía = 1 ‚àí a and a + b = max(a, b), respectively.
Let us sum up our discussion so far. The crucial observations are that formulas can
be viewed as terms, that valuations can be identiÔ¨Åed with algebraic assignments
in the algebra 2, and that evaluating the truth of a formula under such a valua-
tion/assignment is exactly the same as determining the meaning of the term in the
algebra 2 under the assignment/valuation.
So let us move on. We have viewed meaning as a map Œ∏ÃÉ from the set Form(Œ¶)
to the set {0, 1} ‚Äì but it is useful to consider this meaning function in more math-
ematical detail. Note the ‚Äòshape‚Äô of the conditions on Œ∏ÃÉ in (5.1): the resemblance
to the deÔ¨Åning condition of a homomorphism is too blatant to miss. But since ho-
momorphisms are the fundamental maps between algebras (see Appendix B) why
not try and impose algebraic structure on the domain of such meaning functions
(that is, on the set of formulas/terms) so that meaning functions really are homo-
morphisms? This is exactly what we are about to do. We Ô¨Årst deÔ¨Åne the needed
algebraic structure on the set of formulas.
DeÔ¨Ånition 5.3 Let Œ¶ be a set of proposition letters. The propositional formula
algebra over Œ¶ is the algebra
Form(Œ¶) = (Form(Œ¶), +, ‚àí, ‚ä•),
where Form(Œ¶) is the collection of propositional formulas over Œ¶, and ‚àí and +
are the operations deÔ¨Åned by ‚àíœÜ := ¬¨œÜ and œÜ + œà := œÜ ‚à® œà, respectively.
In other words, the carrier of this algebra is the collection of propositional formulas
over the set of proposition letters Œ¶, and the operations ‚àí and + give us a simple
mathematical picture of the dynamics of formula construction.
Proposition 5.4 Let Œ¶ be some set of proposition letters. Given any assignment
Œ∏ : Œ¶ ‚Üí 2, the function Œ∏ÃÉ : Form(Œ¶) ‚Üí 2 assigning to each formula its meaning
under this valuation, is a homomorphism from Form(Œ¶) to 2.
Proof. A precise deÔ¨Ånition of homomorphism is given in Appendix B. Essentially,
homomorphisms between algebras map elements in the source algebra to elements
in the target algebra in an operation preserving way ‚Äì and this is precisely what the
conditions on Œ∏ÃÉ in (5.1) express.
The idea of viewing formulas as terms, and meaning as a homomorphism, is fun-
damental to algebraic logic.
Another point is worth stressing. As the reader will have noticed, sometimes we
call a sequence of symbols like p ‚à® q a formula, and sometimes we call it a term.
This is intentional. Any propositional formula can be viewed as ‚Äì simply is ‚Äì an266
5 Algebras and General Frames
algebraic term. The one-to-one correspondence involved is so obvious that it is not
worth talking about ‚Äòtranslating‚Äô formulas to terms or vice-versa; they are simply
two ways of looking at the same thing. We simply choose whichever terminology
seems most appropriate to the issue under discussion.
But let us move on. As is clear from high-school algebra, algebraic reasoning is
essentially equational. So a genuinely algebraic logic of propositions should give
us a way of determining when two propositions are equal. For example, such a
logic should be capable of determining that the formulas p ‚à® (q ‚àß p) and p denote
the same proposition. How does the algebraic approach to propositional semantics
handle this? As follows: an equation s ‚âà t is valid in an algebra A if for every
assignment to the variables occurring in the terms, s and t have the same meaning
in A (see Appendix B for further details). Hence, an algebraic way of saying that
a formula œÜ is a classical tautology (notation: |=C œÜ) is to say that the equation
œÜ ‚âà  is valid in the algebra of truth values.
Now, an attractive feature of propositional logic (a feature which extends to
modal logic) is that not only terms, but equations correspond to formulas. There
is nothing mysterious about this: we can deÔ¨Åne the bi-implication connective ‚Üî in
classical propositional logic, and viewed as an operation on propositions, ‚Üî asserts
that both terms have the same meaning:
Œ∏ÃÉ(œÜ ‚Üî œà) =
1 if Œ∏ÃÉ(œÜ) = Œ∏ÃÉ(œà),
0 otherwise.
So to speak, propositional logic is intrinsically equational.
Theorem 5.5 neatly summarizes our discussion so far: it shows how easily we
can move from a logical to an algebraic perspective and back again.
Theorem 5.5 (2 Algebraizes Classical Validity) Let œÜ and œà be propositional
formulas/terms. Then
|=C œÜiff2 |= œÜ ‚âà .(5.2)
2 |= œÜ ‚âà œàiff|=C œÜ ‚Üî œà.(5.3)
|=C œÜ ‚Üî (œÜ ‚Üî ).
(5.4)
Proof. Immediate from the deÔ¨Ånitions.
Remark 5.6 The reader may wonder about the presence of (5.3) and in particular,
of (5.4) in the Theorem. The point is that for a proper, ‚Äòfull‚Äô, algebraization of a
logic, one has to establish not only that the membership of some formula œÜ in the
logic can be rendered algebraically as the validity of some equation œÜ‚âà in some
(class of) algebra(s). One also has to show that conversely, there is a translation
of equations to formulas such that the equation holds in the class of algebras if
and only if its translation belongs to the logic. And Ô¨Ånally, one has to prove that5.1 Logic as Algebra
267
translating a formula œÜ to an equation œÜ‚âà , and then translating this equation back
to a formula, one obtains a formula œÜ that is equivalent to the original formula œÜ.
The fact that our particular translations satisfy these requirements is stated by (5.3)
and (5.4), respectively.
Since we will not go far enough into the theory of algebraic logic to use these
‚Äòfull‚Äô algebraizations, in the sequel we will only mention the Ô¨Årst kind of equiva-
lence when we algebraize a logic. Nevertheless, in all the cases that we consider,
the second and third requirements are met as well.
Set algebras
Propositional formulas/terms and equations may be interpreted in any algebra of
type Bool . Most algebras of this type are uninteresting as far as the semantics
of propositional logic is concerned ‚Äì but other algebras besides 2 are relevant. A
particularly important example is the class of set algebras. As we will now see,
set algebras provide us with a second algebraic perspective on the semantics of
propositional logic. And as we will see in the following section, the perspective
they provide extends neatly to modal logic.
DeÔ¨Ånition 5.7 (Set Algebras) Let A be a set. As usual, we denote the power set
of A (the set of all subsets of A) by P(A). The power set algebra P(A) is the
structure
P(A) = (P(A), ‚à™, ‚àí, ‚àÖ),
where ‚àÖ denotes the empty set, ‚àí is the operation of taking the complement of
a set relative to A, and ‚à™ that of taking the union of two sets. From these basic
operations we deÔ¨Åne in the standard way the operation ‚à© of taking the intersection
of two sets, and the special element A, the top set of the algebra.
A set algebra or Ô¨Åeld of sets is a subalgebra of a power set algebra. That is, a set
algebra (on A) is a collection of subsets of A that contains ‚àÖ and is closed under
‚à™ and ‚àí (so any set algebra contains A and is closed under ‚à© as well). The class
of all set algebras is called Set.
Set algebras provide us with a simple concrete picture of propositions and the way
they are combined ‚Äì moreover, it is a picture that even at this stage contains a
number of traditional modal ideas. Think of A as a set of worlds (or situations,
or states) and think of a proposition as a subset of A. And think of a proposition
as a set of worlds ‚Äì the worlds that make it true. So viewed, ‚àÖ is a very special
proposition: it is the proposition that is false in every situation, which is clearly a
good way of thinking about the meaning of ‚ä•. Similarly, A is the proposition true
in all situations, which is a suitable meaning for . It should also be clear that ‚à™
is a way of combining propositions that mirrors the role of ‚à®. After all, in what268
5 Algebras and General Frames
worlds is p ‚à® q true? In precisely those worlds that make p true or q true. Finally,
complementation mirrors negation, for ¬¨p is true in precisely those worlds where
p is not true.
As we will now show, set algebras and the algebra 2 make precisely the same
equations true. We will prove this algebraically by showing that the class of set
algebras coincides (modulo isomorphism) to the class of subalgebras of powers of
2. The crucial result needed is the following:
Proposition 5.8 Every power set algebra is isomorphic to a power of 2, and con-
versely.
Proof. Let A be an arbitrary set, and consider the following function œá mapping
elements of P(A) to 2-valued maps on A:
œá(X)(a) =
1 if a ‚àà X,
0 otherwise.
In other words, œá(X) is the characteristic function of X. The reader should verify
that œá is an isomorphism between P(A) and 2A , where the latter algebra is as
deÔ¨Åned in DeÔ¨Ånition B.6.
Conversely, to show that every power of 2 is isomorphic to some power set
algebra, let 2I be some power of 2. Consider the map Œ± : 2I ‚Üí P(I) deÔ¨Åned by
Œ±(f ) = {i ‚àà I | f (i) = 1}.
Again, we leave it for the reader to verify that Œ± is the required isomorphism be-
tween 2I and P(I).
Theorem 5.9 (Set Algebraizes Classical Validity) Let œÜ and œà be propositional
formulas/terms. Then
|=C œÜ
iff
Set |= œÜ ‚âà .
(5.5)
Proof. It is not difÔ¨Åcult to show from Ô¨Årst principles that the validity of equations is
preserved under taking direct products (and hence powers) and subalgebras. Thus,
with the aid of Theorem 5.5 and Proposition 5.8, the result follows.
Algebraizing propositional axiomatics
We now have two equational perspectives on the semantics of propositional logic:
one via the algebra 2, the other via set algebras. But what about the syntactic
aspects of propositional logic? It is time to see how the equational perspective
handles such notions as theoremhood and provable equivalence.
Assume we are working in some Ô¨Åxed (sound and complete) proof system for
classical propositional logic. Let C œÜ mean that œÜ is a theorem of this system, and5.1 Logic as Algebra
269
call two propositional formulas œÜ and œà provably equivalent (notation: œÜ ‚â°C œà)
if the formula œÜ ‚Üî œà is a theorem. Theorem 5.11 is a syntactic analog of Theo-
rem 5.9: it is the fundamental result concerning the algebraization of propositional
axiomatics. Its statement and proof makes use of boolean algebras, so let us deÔ¨Åne
these important entities right away.
DeÔ¨Ånition 5.10 (Boolean Algebras) Let A = (A, +, ‚àí, 0) be an algebra of the
boolean similarity type. Then A is called a boolean algebra iff it satisÔ¨Åes the
following identities (recall that x ¬∑ y and 1 are shorthand for ‚àí(‚àíx + ‚àíy) and ‚àí0,
respectively):
(B0)
(B1)
(B2)
(B3)
(B4)
x+y =y+x
x + (y + z) = (x + y) + z
x+0=x
x + (‚àíx) = 1
x + (y ¬∑ z) = (x + y) ¬∑ (x + z)
x¬∑y =y¬∑x
x ¬∑ (y ¬∑ z) = (x ¬∑ y) ¬∑ z
x¬∑1=x
x ¬∑ (‚àíx) = 0
x ¬∑ (y + z) = (x ¬∑ y) + (x ¬∑ z)
The operations + and ¬∑ are called join and meet, respectively, and the elements 1
and 0 are referred to as the top and bottom elements. We order the elements of a
boolean algebra by deÔ¨Åning a ‚â§ b if a + b = b (or equivalently, if a ¬∑ b = a). Given
a boolean algebra A = (A, +, ‚àí, 0), the set A is called its carrier set. We call the
class of boolean algebras BA.
By a famous result of Birkhoff (discussed in Appendix B) a class of algebras de-
Ô¨Åned by a collection of equations can be structurally characterized as a variety.
Thus in what follows we sometimes speak of the variety of boolean algebras, rather
than the class of boolean algebras.
If you have not encountered boolean algebras before, you should check that the
algebra 2 and the set algebras deÔ¨Åned earlier are both examples of boolean algebras
(that is, check that these algebras satisfy the listed identities). In fact, set algebras
are what are known as concrete boolean algebras. As we will see when we dis-
cuss the Stone Representation Theorem, the relationship between abstract boolean
algebras (that is, any algebraic structure satisfying the previous deÔ¨Ånition) and set
algebras lies at the heart of the algebraic perspective on propositional soundness
and completeness.
But this is jumping ahead: our immediate task is to state the syntactic analog of
Theorem 5.9 promised above.
Theorem 5.11 (BA Algebraizes Classical Theoremhood) Let œÜ and œà be propo-
sitional formulas/terms. Then
C œÜ
iff
BA |= œÜ ‚âà .
(5.6)270
5 Algebras and General Frames
Proof. Soundness (the direction from left to right in (5.6)) can be proved by a
straightforward inductive argument on the length of propositional proofs. Com-
pleteness will follow from the Propositions 5.14 and 5.15 below.
How are we to prove this completeness result? Obviously we have to show that ev-
ery non-theorem of classical propositional logic can be falsiÔ¨Åed on some boolean
algebra (falsiÔ¨Åed in the sense that there is some assignment under which the for-
mula does not evaluate to the top element of the algebra). So the key question is:
how do we build falsifying algebras? Our earlier work on relational completeness
suggests an answer. In Chapter 4 we made use of canonical models: that is, we
manufactured models out of syntactical ingredients (sets of formulas) taking care
to hardwire in all the crucial facts about the logic. So the obvious question is: can
we construct algebras from (sets of) formulas in a way that builds in all the proposi-
tional logic we require? Yes, we can. Such algebras are called Lindenbaum-Tarski
algebras. In essence, they are ‚Äòcanonical algebras.‚Äô
First, some preliminary work. The observation underpinning what follows is
that the relation of provable equivalence is a congruence on the formula algebra. A
congruence on an algebra is essentially an equivalence relation on the algebra that
respects the operations (a precise deÔ¨Ånition is given in Appendix B) and it is not
hard to see that provable equivalence is such a relation.
Proposition 5.12 The relation ‚â°C is a congruence on the propositional formula
algebra.
Proof. We have to prove that ‚â°C is an equivalence relation satisfying
œÜ ‚â°C œà only if ¬¨œÜ ‚â°C ¬¨œà(5.7)
œÜ0 ‚â°C œà0 and œÜ1 ‚â°C œà1 only if (œÜ0 ‚à® œÜ1 ) ‚â°C (œà0 ‚à® œà1 ).(5.8)
and
In order to prove that ‚â°C is reÔ¨Çexive, we have to show that for any formula œÜ, the
formula œÜ ‚Üî œÜ is a theorem of the proof system. The reader is invited to prove
this in his or her favorite proof system for proposition calculus. The properties of
symmetry and transitivity are also left to the reader.
But we want to prove that ‚â°C is not merely an equivalence relation but a congru-
ence. We deal with the case for negation, leaving (5.8) to the reader. Suppose that
œÜ ‚â°C œà, that is, C œÜ ‚Üî œà. Again, given that we are working with a sound and
complete proof system for propositional calculus, this implies that C ¬¨œÜ ‚Üî ¬¨œà.
Given this, (5.7) is immediate.
The equivalence classes under ‚â°C are the building blocks for what follows. As any
such class is a maximal set of mutually equivalent formulas, we can think of such5.1 Logic as Algebra
271
classes as propositions. And as ‚â°C is a congruence, we can deÔ¨Åne a natural al-
gebraic structure on these propositions. Doing so gives rise to Lindenbaum-Tarski
algebras.
DeÔ¨Ånition 5.13 (Lindenbaum-Tarski Algebra) Given a set of proposition letters
Œ¶, let Form(Œ¶)/‚â°C be the set of equivalence classes that ‚â°C induces on the set
of formulas, and for any formula œÜ let [œÜ] denote the equivalence class containing
œÜ. Then the Lindenbaum-Tarski algebra (for this language) is the structure
LC (Œ¶) := (Form(Œ¶)/‚â°C , +, ‚àí, 0),
where +, ‚àí and 0 are deÔ¨Åned by: [œÜ] + [œà] := [œÜ ‚à® œà], ‚àí[œÜ] := [¬¨œÜ] and 0 :=
[‚ä•]. Strictly speaking, we should write [œÜ]Œ¶ instead of [œÜ], for œÜ‚Äôs congruence
class depends on the set Œ¶ of proposition letters. But unless there is potential for
confusion, we usually will not bother to do so.
Lindenbaum-Tarski algebras are easy to work with. For instance, it is easy to see
that the meet operation in such an algebra is given by [œÜ] ¬∑ [œà] = [œÜ ‚àß œà], while
the top element 1 is []. As another example, we show that a + (‚àía) = 1 for
all elements a of LC (Œ¶). The Ô¨Årst observation is that a, just like any element of
LC (Œ¶), is of the form [œÜ] for some formula œÜ. But then we have
a + (‚àía) = [œÜ] + (‚àí[œÜ]) = [œÜ] + [¬¨œÜ] = [œÜ ‚à® (¬¨œÜ)] = [] = 1,
(5.9)
where the fourth equality holds because C (œÜ ‚à® ¬¨œÜ) ‚Üî .
It is fairly obvious that the structure of a Lindenbaum-Tarski algebra only de-
pends on the cardinality of the set Œ¶ of proposition letters; the reader is asked to
prove this in Exercise 5.1.4.
We need two results concerning Lindenbaum-Tarski algebras. First, we have to
show that they are indeed an ‚Äòalgebraic canonical model‚Äô ‚Äì that is, that they give us
a counterexample for every non-theorem of propositional logic. Second, we have
to show that they are counterexamples of the right kind: that is, we need to prove
that any Lindenbaum-Tarski algebra is a boolean algebra.
Proposition 5.14 Let œÜ be some propositional formula, and Œ¶ a set of proposition
letters of size not smaller than the number of proposition letters occurring in œÜ.
Then
C œÜ iff LC (Œ¶) |= œÜ ‚âà .
(5.10)
Proof. We may and will assume that Œ¶ actually contains all variables occurring in
œÜ, cf. Exercise 5.1.4. We Ô¨Årst prove the easy direction from right to left. Assume
that œÜ is not a theorem of classical propositional logic. This implies that œÜ and
 are not provably equivalent, whence we have [œÜ] = []. We have to Ô¨Ånd an
assignment on LC (Œ¶) that forms a counterexample to the validity of œÜ. There is272
5 Algebras and General Frames
one obvious candidate, namely the assignment Œπ given by Œπ(p) = [p]. It can easily
be veriÔ¨Åed (by a straightforward formula induction) that with this deÔ¨Ånition we
obtain ŒπÃÉ(œà) = [œà] for all formulas œà that use variables from the set Œ¶. But then by
our assumption on œÜ we Ô¨Ånd that
ŒπÃÉ(œÜ) = [œÜ] = [] = 1,
as required.
For the other direction we have to work a bit harder. If C œÜ then it is obvious
that ŒπÃÉ(œÜ) = [œÜ] = [] = 1, but only looking at Œπ is not sufÔ¨Åcient now. We have to
show that Œ∏ÃÉ(œÜ) = [] for all assignments Œ∏.
So let Œ∏ be an arbitrary assignment. That is, Œ∏ assigns an equivalence class
(under ‚â°C ) to each proposition letter. For each variable p, take a representing
formula œÅ(p) in the equivalence class Œ∏(p); that is, we have Œ∏(p) = [œÅ(p)]. We
may view œÅ as a function mapping proposition letters to formulas; in other words,
œÅ is a substitution. Let œÅ(œà) denote the effect of performing this substitution on the
formula œà. It can be proved by an easy formula induction that, for any formula œà,
we have
Œ∏ÃÉ(œà) = [œÅ(œà)].
(5.11)
Now, the collection of propositional theorems is closed under uniform substitution
(depending on the formulation of your favorite sound and complete proof system,
this is either something that is hardwired in or can be shown to hold). This closure
property implies that the formula œÅ(œÜ) is a theorem, and hence that œÅ(œÜ) ‚â°C , or
equivalently, [œÅ(œÜ)] = []. But then it follows from (5.11) that
Œ∏ÃÉ(œÜ) = [],
which is precisely what we need to show that LC (Œ¶) |= œÜ.
Thus it only remains to check that LC (Œ¶) is the right kind of algebra.
Proposition 5.15 For any set Œ¶ of proposition letters, LC (Œ¶) is a boolean algebra.
Proof. Fix a set Œ¶. The proof of this Proposition boils down to proving that all the
identities B0‚Äì4 hold in LC (Œ¶). In (5.9) we proved that the Ô¨Årst part of B3 holds;
we leave the reader to verify that the other identities hold as well.
Summarizing, we have seen that the axiomatics of propositional logic can be al-
gebraized in a class of algebras, namely the variety of boolean algebras. We have
also seen that Lindenbaum-Tarski algebras act as canonical representatives of the
class of boolean algebras. (For readers with some background in universal algebra,
we remark that Lindenbaum-Tarski algebras are in fact the free boolean algebras.)5.1 Logic as Algebra
273
Weak completeness via Stone
It is time to put our Ô¨Åndings together, and to take one Ô¨Ånal step. This step is more
important than any taken so far.
Theorem 5.9 captured tautologies as equations valid in set algebras:
|=C œÜ iff Set |= œÜ ‚âà .
On the other hand, in Theorem 5.11 we found an algebraic semantics for the notion
of classical theoremhood:
C œÜ iff BA |= œÜ ‚âà .
But there is a fundamental logical connection between |=C and C : the soundness
and completeness theorem for propositional logic tells us that they are identical.
Does this crucial connection show up algebraically? That is, is there an algebraic
analog of the soundness and completeness result for classical propositional logic?
There is: it is called the Stone Representation Theorem.
Theorem 5.16 (Stone Representation Theorem) Any boolean algebra is isomor-
phic to a set algebra.
Proof. We will make a more detailed statement of this result, and prove it, in Sec-
tion 5.3.
(Incidentally, this immediately tells us that any boolean algebra is isomorphic to a
subalgebra of a power of 2 ‚Äì for Proposition 5.8 tells us that any power set algebra
is isomorphic to a power of 2.) But what really interests us here is the logical
content of Stone‚Äôs Theorem. In essence, it is the key to the weak completeness of
classical propositional logic.
Corollary 5.17 (Soundness and Weak Completeness) For any formula œÜ, œÜ is
valid iff it is a theorem.
Proof. Immediate from the equations above, since by the Stone Representation
Theorem, the equations valid in Set must coincide with those valid in BA.
The relation between Theorem 5.11 and Corollary 5.17 is the key to much of our
later work. Note that from a logical perspective, Corollary 5.17 is the interesting re-
sult: it establishes the soundness and completeness of classical propositional logic
with respect to the standard semantics. So why is Theorem 5.11 important? After
all, as it proves completeness with respect to an abstractly deÔ¨Åned class of boolean
algebras, it does not have the same independent logical interest. This is true, but
given that the abstract algebraic counterexamples it provides can be represented as
standard counterexamples ‚Äì and this is precisely what Stone‚Äôs Theorem guarantees
‚Äì it enables us to prove the standard completeness result for propositional logic.274
5 Algebras and General Frames
To put it another way, the algebraic approach to completeness factors the algebra
building process into two steps. We Ô¨Årst prove completeness with respect to an
abstract algebraic semantics by building an abstract algebraic model. It is easy to
do this ‚Äì we just use Lindenbaum-Tarski algebras. We then try and represent the
abstract algebras in the concrete form required by the standard semantics; that is,
in terms of set algebras or of the algebra 2.
In the next two sections we extend this approach to modal logic. Algebraizing
modal logic is more demanding than algebraizing propositional logic. For a start,
there is not just one logic to deal with ‚Äì we want to be able to handle any normal
modal logic whatsoever. Moreover, the standard semantics for modal logic is given
in terms of frame-based models ‚Äì so we are going to need a representation result
that tells us how to represent algebras as relational structures.
But all this can be done. In the following section we will generalize boolean
algebras to boolean algebras with operators; these are the abstract algebras we will
be dealing with throughout the chapter. We also generalize set algebras to com-
plex algebras; these are the concrete algebras which model the idea of set-based
algebras of propositions for modal languages. We then deÔ¨Åne the Lindenbaum-
Tarski algebras we need ‚Äì and every normal modal logic will give rise to its own
Lindenbaum-Tarski algebra. This is all a fairly straightforward extension of ideas
we have just discussed. We then turn, in Section 5.3, to the crucial representation
result: the J√≥nsson-Tarski Theorem. This is an extension of Stone‚Äôs Representa-
tion Theorem that tells us how to represent a boolean algebra with operators as an
ordinary modal model. It is an elegant result in its own right, but for our purposes
its importance is the bridge it provides between completeness in the universe of
algebras and completeness in the universe of relational structures.
Exercises for Section 5.1
5.1.1 Let A and B be two sets, and f : A ‚Üí B some map. Show that f ‚àí1 : P(B) ‚Üí
P(A) given by f ‚àí1 (Y ) = {a ‚àà A | f (a) ‚àà Y } is a homomorphism from the power set
algebra of B to that of A.
5.1.2 Prove that every power set algebra is isomorphic to a power of the algebra 2, and
that conversely, every power of 2 is isomorphic to a power set algebra. That is, Ô¨Åll in the
details of the proof of Theorem 5.8.
5.1.3 Here is a standard set of axioms for propositional calculus: p ‚Üí (q ‚Üí p), (p ‚Üí
(q ‚Üí r)) ‚Üí ((p ‚Üí q) ‚Üí (p ‚Üí r)), and (¬¨p ‚Üí ¬¨q) ‚Üí (q ‚Üí p). Show that all three
axioms are valid on any set algebra. That is, show that whatever subset is used to interpret
the proposition letters, these formulas are true in all worlds. Furthermore, show that modus
ponens and uniform substitution preserve validity.
5.1.4 Let Œ¶ and Œ® be two sets of proposition letters.
(a) Prove that Form(Œ¶) is a subalgebra of Form(Œ® ) iff Œ¶ ‚äÜ Œ® .5.2 Algebraizing Modal Logic
275
(b) Prove that L C (Œ¶) can be embedded in L C (Œ® ) iff |Œ¶| ‚â§ |Œ® |.
(c) Prove that LC (Œ¶) and LC (Œ® ) are isomorphic iff |Œ¶| = |Œ® |.
(d) Does Œ¶ ‚äÜ Œ® imply that L C (Œ¶) is a subalgebra of L C (Œ® )?
5.2 Algebraizing Modal Logic
Let us adapt the ideas introduced in the previous section to modal logic. The most
basic principle of algebraic logic is that formulas of a logical language can be
viewed as terms of an algebraic language, so let us Ô¨Årst get clear about the algebraic
languages we will use in the remainder of this chapter:
DeÔ¨Ånition 5.18 Let œÑ be a modal similarity type. The corresponding algebraic
similarity type FœÑ contains as function symbols all modal operators, together with
the boolean symbols ‚à® (binary), ¬¨ (unary), and ‚ä• (constant). For a set Œ¶ of vari-
ables, we let Ter œÑ (Œ¶) denote the collection of FœÑ -terms over Œ¶.
The algebraic similarity type FœÑ can be seen as the union of the modal similarity
type œÑ and the boolean type Bool . In practice we often identify œÑ and FœÑ , speaking
of œÑ -terms instead of FœÑ -terms. The previous deÔ¨Ånition takes the formulas-as-
terms paradigm quite literally: by our deÔ¨Ånitions
Form(œÑ, Œ¶) = Ter œÑ (Œ¶).
Just as boolean algebras were the key to the algebraization of classical proposi-
tional logic, in modal logic we are interested in boolean algebras with operators or
BAOs. Let us Ô¨Årst deÔ¨Åne BAOs abstractly; we will discuss concrete BAOs shortly.
DeÔ¨Ånition 5.19 (Boolean Algebras with Operators) Let œÑ = (O, œÅ) be a modal
similarity type. A boolean algebra with œÑ -operators is an algebra
A = (A, +, ‚àí, 0, f )‚ààœÑ
such that (A, +, ‚àí, 0) is a boolean algebra and every f is an operator of arity
œÅ(); that is, f is an operation satisfying
(normality) f(a1 , . . . , aœÅ() ) = 0 whenever ai = 0 for some i (0 < i ‚â§ œÅ()).
(additivity) for all i (such that 0 < i ‚â§ œÅ()),
f(a1 , . . . , ai + ai , . . . , aœÅ() ) =
f(a1 , . . . , ai , . . . , aœÅ() ) + f(a1 , . . . , ai , . . . , aœÅ() ).
If we abstract from the particular modal similarity type œÑ , or if œÑ is known from
context, we simply speak of boolean algebras with operators, or BAOs.5 Algebras and General Frames
276
Now, the boolean structure is obviously there to handle the propositional connec-
tives, but what is the meaning of the normality and additivity conditions on the f?
Consider a unary operator f . In this case these conditions boil down to:
f (0) = 0,
f (x + y) = f x + f y.
But these equations correspond to the following modal formulas:
3‚ä• ‚Üî ‚ä•,
3(p ‚à® q) ‚Üî 3p ‚à® 3q,
both of which formulas are modal validities. Indeed (as we noted in Remark 4.7)
they can be even be used to axiomatize the minimal normal logic K. Thus, even
at this stage, it should be clear that our algebraic operators are well named: their
deÔ¨Åning properties are modally crucial.
Furthermore, note that all operators have the property of monotonicity. An oper-
ation g on a boolean algebra is monotonic if a ‚â§ b implies ga ‚â§ gb. (Here ‚â§ refers
to the ordering on boolean algebra given in DeÔ¨Ånition 5.10: a ‚â§ b iff a ¬∑ b = a
iff a + b = b.) Operators are monotonic, because if a ‚â§ b, then a + b = b, so
f a + f b = f (a + b) = f b, and so f a ‚â§ f b. Once again there is an obvious
modal analog, namely the rule of proof mentioned in Remark 4.7: if Œõ p ‚Üí q
then Œõ 3p ‚Üí 3q.
Example 5.20 Consider the collection of binary relations over a given set U . This
collection forms a set algebra on which we can deÔ¨Åne the operations | (compo-
sition), (¬∑)‚àí1 (inverse) and Id (the identity relation); these are binary, unary and
nullary operations respectively. It is easy to verify that these operations are actu-
ally operators; to give a taste of the kind of argumentation required, we show that
composition is additive in its second argument:
(x, y) ‚àà R | (S ‚à™ T )
iffthere is a z with (x, z) ‚àà R and (z, y) ‚àà S ‚à™ T
iffthere is a z with (x, z) ‚àà R and (z, y) ‚àà S or (z, y) ‚àà T
iffthere is a z with (x, z) ‚àà R and (z, y) ‚àà S,
or there is a z with (x, z) ‚àà R and (z, y) ‚àà T
iff(x, y) ‚àà R | S or (x, y) ‚àà R | T
iff(x, y) ‚àà R | S ‚à™ R | T.
The reader should check the remaining cases.5.2 Algebraizing Modal Logic
277
Algebraizing modal semantics
However it is the next type of BAO that is destined to play the leading role: complex
algebras. These structures make crucial use of the operations mR that we met in
DeÔ¨Ånition 1.30 and DeÔ¨Ånition 2.55.
DeÔ¨Ånition 5.21 (Complex Algebras) Let œÑ be a modal similarity type, and F =
(W, R)‚ààœÑ a œÑ -frame. The (full) complex algebra of F (notation: F+ ), is the
expansion of the power set algebra P(W ) with operations mR for every operator
 in œÑ . A complex algebra is a subalgebra of a full complex algebra. If K is a
class of frames, then we denote the class of full complex algebras of frames in K
by CmK.
It is important that you fully understand this deÔ¨Ånition. For a start, note that com-
plex algebras are set algebras (that is, concrete propositional algebras) to which
mR operations have been added. Recall that for a binary relation R, the unary
operation mR yields the set of all states which ‚Äòsee‚Äô a state in a given subset X of
the universe:
mR (X) = {y ‚àà W | there is an x ‚àà X such that Ryx}.
For a relation of arity n + 1, the n-ary operation mR maps an n-tuple of subsets of
the universe to the set of all points which ‚Äòsee‚Äô an n-tuple of states each of which
belongs to the corresponding subset. It easily follows that if we have some model
in mind and denote with ·πº (œÜ) the set of states where œÜ is true, then
·πº ((œÜ1 , . . . , œÜn )) = mR (·πº (œÜ1 ), . . . , ·πº (œÜn )).
Thus it should be clear that complex algebras are intrinsically modal. In the previ-
ous section we said that set algebras model propositions as sets of possible worlds.
By adding the mR operations, we have modeled the idea that one world may be
able to access the information in another. In short, we have deÔ¨Åned a class of con-
crete algebras which capture the modal notion of access between states in a natural
way.
How are complex algebras connected with abstract BAOs? One link is obvious:
Proposition 5.22 Let œÑ be a modal similarity type, and F = (W, R)‚ààœÑ a œÑ -
frame. Then F+ is a boolean algebra with œÑ -operators.
Proof. We have to show that operations of the form mR are normal and additive.
This rather easy proof is left to the reader; see Exercise 5.2.2.
The other link is deeper. As we will learn in the following section (Theo-
rem 5.43), complex algebras are to BAOs what set algebras are to boolean algebras:278
5 Algebras and General Frames
every abstract boolean algebra with operators has a concrete set theoretic repre-
sentation, for every boolean algebra with operators is isomorphic to a complex
algebra.
But we have a lot to do before we are ready to prove this ‚Äì let us continue our
algebraization of the semantics of modal logic. We will now deÔ¨Åne the interpreta-
tion of œÑ -terms and equations in arbitrary boolean algebras with œÑ -operators. As
we saw for propositional logic, the basic idea is very simple: given an assignment
that tells us what the variables stand for, we can inductively deÔ¨Åne the meaning of
any term.
DeÔ¨Ånition 5.23 Assume that œÑ is a modal similarity type and that Œ¶ is a set of
variables. Assume further that A = (A, +, ‚àí, 0, f )‚ààœÑ is a boolean algebra with
œÑ -operators. An assignment for Œ¶ is a function Œ∏ : Œ¶ ‚Üí A. We can extend Œ∏
uniquely to a meaning function Œ∏ÃÉ: Ter œÑ (Œ¶) ‚Üí A satisfying:
Œ∏ÃÉ(p) = Œ∏(p), for all p ‚àà Œ¶,
Œ∏ÃÉ(‚ä•) = 0,
Œ∏ÃÉ(¬¨s) = ‚àíŒ∏ÃÉ(s),
Œ∏ÃÉ(s ‚à® t) = Œ∏ÃÉ(s) + Œ∏ÃÉ(t),
Œ∏ÃÉ((s1 , . . . , sn )) = f(Œ∏ÃÉ(s1 ), . . . , Œ∏ÃÉ(sn )).
Now let s ‚âà t be a œÑ -equation. We say that s ‚âà t is true in A (notation: A |= s ‚âà t)
if for every assignment Œ∏: Œ∏ÃÉ(s) = Œ∏ÃÉ(t).
But now consider what happens when A is a complex algebra F+ . Since elements
of F+ are subsets of the power set P(W ) of the universe W of F, assignments Œ∏ are
simply ordinary modal valuations! The ramiÔ¨Åcations of this observation are listed
in the following proposition:
Proposition 5.24 Let œÑ be a modal similarity type, œÜ a œÑ -formula, F a œÑ -frame, Œ∏
an assignment (or valuation) and w a point in F. Then
(F, Œ∏), w  œÜ
iffw ‚àà Œ∏ÃÉ(œÜ),(5.12)
FœÜiffF |= œÜ ‚âà ,(5.13)
F+ |= œÜ ‚âà œàiffF  œÜ ‚Üî œà.(5.14)
+
Proof. We will only prove the Ô¨Årst part of the proposition (for the basic modal
similarity type); the second and third part follow immediately from this and the
deÔ¨Ånitions.
Let œÜ, F and Œ∏ be as in the statement of the theorem. We will prove (5.12) (for
all w) by induction on the complexity of œÜ. The only interesting part is the modal5.2 Algebraizing Modal Logic
279
case of the inductive step. Assume that œÜ is of the form 3œà. The key observation
is that
Œ∏ÃÉ(3œà) = mR3 (Œ∏ÃÉ(œà)).
(5.15)
We now have:
(F, Œ∏), w  3œà
iff
iff
iff
iff
there is a v such that R3 wv and (F, Œ∏), v  œà
there is a v such that R3 wv and v ‚àà Œ∏ÃÉ(œà)
w ‚àà mR3 (Œ∏ÃÉ(œà))
w ‚àà Œ∏ÃÉ(3œà).
Here the second equivalence is by the inductive hypothesis, and the last one by
(5.15). This proves (5.12).
The previous proposition is easily lifted to the level of classes of frames and com-
plex algebras. The resulting theorem is a fundamental one: it tells us that classes
of complex algebras algebraize modal semantics. It is the modal analog of Theo-
rem 5.9.
Theorem 5.25 Let œÑ be a modal similarity type, œÜ and œà œÑ -formulas, and K a
class of œÑ -frames. Then
KœÜiffCmK |= œÜ ‚âà ,(5.16)
CmK |= œÜ ‚âà œàiffK  œÜ ‚Üî œà.(5.17)
Proof. Immediate by Proposition 5.24.
This proposition allows us to identify the modal logic ŒõK of a class of frames K
(that is, the set of formulas that are valid in each F ‚àà K}) with the equational
theory of the class CmK of complex algebras of frames in K (that is, the set of
equations {s ‚âà t | F+ |= s ‚âà t, for all F ‚àà K}).
Let us summarize what we have learned so far. We have developed an algebraic
approach to the semantics of modal logic in terms of complex algebras. These
complex algebras, concrete boolean algebras with operators, generalize to modal
languages the idea of algebras of propositions provided by set algebras. And most
important of all, we have learned that complex algebras embody all the information
about normal modal logics that frames do. Thus, mathematically speaking, we can
dispense with frames and instead work with complex algebras.
Algebraizing modal axiomatics
Turning to the algebraization of modal axiomatics, we encounter a situation similar
to that of the previous section. Once again, we will see that the algebraic counter-
part of a logic is an equational class of algebras. To give a precise formulation we
need the following deÔ¨Ånition.280
5 Algebras and General Frames
DeÔ¨Ånition 5.26 Given a formula œÜ, let œÜ‚âà be the equation œÜ ‚âà . Now let œÑ be a
modal similarity type. For a set Œ£ of œÑ -formulas, we deÔ¨Åne VŒ£ to be the class of
those boolean algebras with œÑ -operators in which the set Œ£‚âà = {œÉ ‚âà | œÉ ‚àà Œ£} is
valid.
We now state the algebraic completeness theorem for modal logic. It is the obvious
analog of Theorem 5.11.
Theorem 5.27 (Algebraic Completeness) Let œÑ be a modal similarity type, and
Œ£ a set of œÑ -formulas. Then KœÑ Œ£ (the normal modal œÑ -logic axiomatized by Œ£) is
sound and complete with respect to VŒ£ . That is, for all formulas œÜ we have
KœÑ Œ£ œÜ iff VŒ£ |= œÜ‚âà .
Proof. We leave the soundness direction as an exercise to the reader. Completeness
is an immediate corollary of Theorems 5.32 and 5.33.
As a corollary to the soundness direction of Theorem 5.27, we have that VKœÑ Œ£ =
VŒ£ , for any set Œ£ of formulas. In the sequel this will allow us to forget about
axiom sets and work with logics instead.
To prove the completeness direction of Theorem 5.27, we need a modal version
of the basic tool used to prove algebraic completeness results: Lindenbaum-Tarski
algebras. As in the the case of propositional languages, we will build an algebra on
top of the set of formulas in such a way that the relation of provable equivalence
between two formulas is a congruence relation. The key difference is that we do
not have just one relation of provable equivalence, but many: we want to deÔ¨Åne the
notion of Lindenbaum-Tarski algebras for arbitrary normal modal logics.
DeÔ¨Ånition 5.28 Let œÑ be an algebraic similarity type, and Œ¶ a set of proposition
letters. The formula algebra of œÑ over Œ¶ is the algebra Form(œÑ, Œ¶) = (Form(œÑ, Œ¶),
+, ‚àí, ‚ä•, f)‚ààœÑ where +, ‚àí and ‚ä• are given as in DeÔ¨Ånition 5.3, while for each
modal operator , the operation f is given by
f(t1 , . . . , tn ) = (t1 , . . . , tn ).
Notice the double role of  in this deÔ¨Ånition: on the right-hand side of the equation,
 is a ‚Äòstatic‚Äô part of the term (t1 , . . . , tn ), whereas in the-left hand side we have
a more ‚Äòdynamic‚Äô perspective on the interpretation f of the operation symbol .
DeÔ¨Ånition 5.29 Let œÑ be a modal similarity type, Œ¶ a set of propositional variables,
and Œõ a normal modal œÑ -logic. We deÔ¨Åne ‚â°Œõ as a binary relation between œÑ -
formulas (in Œ¶) by
œÜ ‚â°Œõ œà iff Œõ œÜ ‚Üî œà.
If œÜ ‚â°Œõ œà, we say that œÜ and œà are equivalent modulo Œõ.5.2 Algebraizing Modal Logic
281
Proposition 5.30 Let œÑ be a modal similarity type, Œ¶ a set of proposition letters
and Œõ a normal modal œÑ -logic. Then ‚â°Œõ is a congruence relation on Form(œÑ, Œ¶).
Proof. We conÔ¨Åne ourselves to proving the proposition for the basic modal simi-
larity type. First, we have to show that ‚â°Œõ is an equivalence relation; this is easy,
and we leave the details to the reader. Next, we must show that ‚â°Œõ is a congruence
relation on the formula algebra; that is, we have to demonstrate that ‚â°Œõ has the
following properties:
œÜ0 ‚â°Œõ œà0 and œÜ1 ‚â°Œõ œà1 imply
œÜ0 ‚à® œÜ1 ‚â°Œõ œÜ0 ‚à® œà1 ,
œÜ ‚â°Œõ œà implies ¬¨œÜ ‚â°Œõ ¬¨œà,
œÜ ‚â°Œõ œà implies 3œÜ ‚â°Œõ 3œà.
(5.18)
The Ô¨Årst two properties are easy exercises in propositional logic. The third is an
immediate corollary of Lemma 4.6.
Proposition 5.30 tells us that the following are correct deÔ¨Ånitions of functions on
the set Form(œÑ, Œ¶)/‚â°Œõ of equivalence classes under ‚â°Œõ :
[œÜ] + [œà] := [œÜ ‚à® œà],
‚àí[œÜ] := [¬¨œÜ],
f([œÜ1 ], . . . , [œÜn ]) := [(œÜ1 , . . . , œÜn )].
(5.19)
For unary diamonds, the last clause boils down to: f3 [œÜ] := [3œÜ].
Given Proposition 5.30, the way is open to deÔ¨Åne the Lindenbaum-Tarski algebra
for any normal modal logic Œõ: we simply deÔ¨Åne it to be the quotient algebra of the
formula algebra over the congruence relation ‚â°Œõ .
DeÔ¨Ånition 5.31 (Lindenbaum-Tarski Algebras) Let œÑ be a modal similarity
type, Œ¶ a set of proposition letters, and Œõ a normal modal œÑ -logic in this language.
The Lindenbaum-Tarski algebra of Œõ over the set of generators Œ¶ is the structure
LŒõ (Œ¶) := (Form(œÑ, Œ¶)/‚â°Œõ , +, ‚àí, f),
where the operations +, ‚àí and f are deÔ¨Åned as in (5.19).
As with propositional logic, we need two results about Lindenbaum-Tarski alge-
bras. First, we must show that modal Lindenbaum-Tarski algebras are boolean
algebras with operators; indeed, we need to show that the Lindenbaum-Tarski al-
gebra of any normal modal logic Œõ belongs to VŒõ . Second, we need to prove that
Lindenbaum-Tarski algebras provide canonical counterexamples to the validity of
non-theorems of Œõ in VŒõ . The second point is easily dealt with:
Theorem 5.32 Let œÑ be a modal similarity type, and Œõ a normal modal œÑ -logic.5 Algebras and General Frames
282
Let œÜ be some propositional formula, and Œ¶ a set of proposition letters of size not
smaller than the number of proposition letters occurring in œÜ. Then
Œõ œÜ iff LŒõ (Œ¶) |= œÜ‚âà .
(5.20)
Proof. This proof is completely analogous to that of Proposition 5.14 and is left to
the reader.
So let us verify that Lindenbaum-Tarski algebras are canonical algebraic models of
the right kind:
Theorem 5.33 Let œÑ be a modal similarity type, and Œõ be a normal modal œÑ -logic.
Then for any set Œ¶ of proposition letters, LŒõ (Œ¶) belongs to VŒõ .
Proof. Once we have shown that LŒõ (Œ¶) is a boolean algebra with œÑ -operators, the
theorem immediately follows from Theorem 5.32. Now, that LŒõ (Œ¶) is a boolean
algebra is clear, so the only thing that remains to be done is to show that the modal-
ities really give rise to œÑ -operators.
As an example, assume that œÑ contains a diamond 3; let us prove additivity of
f3 . We have to show that
f3 (a + b) = f3 a + f3 b,
for arbitrary elements a and b of LŒõ (Œ¶). Let a and b be such elements; by deÔ¨Ånition
there are formulas œÜ and œà such that a = [œÜ] and b = [œà]. Then
f3 (a + b) = f3 ([œÜ] + [œà]) = f3 ([œÜ ‚à® œà]) = [3(œÜ ‚à® œà)]
while
f3 a + f3 b = f3 ([œÜ]) + f3 ([œà]) = [3œÜ] + [3œà] = [3œÜ ‚à® 3œà].
It is easy to check that
Œõ 3(œÜ ‚à® œà) ‚Üî (3œÜ ‚à® 3œà),
whence it follows that [3(œÜ ‚à® œà)] = [3œÜ ‚à® 3œà]. We leave it for the reader to Ô¨Åll
in the remaining details of this proof as Exercise 5.2.4.
As an immediate corollary we have the following result: modal logics are always
complete with respect to the variety of boolean algebras with operators where their
axioms are valid. This is in sharp contrast to the situation in relational semantics,
where (as we saw in Chapter 4) modal logics need not be complete with respect to
the class of frames that they deÔ¨Åne.
This is an interesting result, but it is not what we really want, for it proves com-
pleteness with respect to abstract BAOs rather than complex algebras. Not only are
complex algebras concrete algebras of propositions, we also know (recall Proposi-
tion 5.24) that complex algebras embody all the information of relevance to frame5.3 The J√≥nsson-Tarski Theorem
283
validity ‚Äì so we really should be aiming for completeness results with respect to
classes of complex algebras.
And that is why the long-promised J√≥nsson-Tarski Theorem, which we state
and prove in the following section, is so important. This tells us that every boolean
algebra with operators is isomorphic to a complex algebra, and thus guarantees that
we can represent the Lindenbaum-Tarski algebras of any normal modal logics Œõ
as a complex algebra. In effect, it will convert Theorem 5.32 into a completeness
result with respect to complex algebras. Moreover, because of the link between
complex algebras and relational semantics, it will open the door to exploring frame
completeness algebraically.
Exercises for Section 5.2
5.2.1 Let A be a boolean algebra. Prove that ¬∑ is an operator. How about +?
5.2.2 Show that every complex algebra is a boolean algebra with operators (that is, prove
Proposition 5.22).
5.2.3 Let A be the collection of Ô¨Ånite and co-Ô¨Ånite subsets of N. DeÔ¨Åne f : A ‚Üí A by
f (X) =
{y ‚àà N | y + 1 ‚àà X} if X is Ô¨Ånite,
N
if X is co-Ô¨Ånite.
Prove that (A, ‚à™, ‚àí, ‚àÖ, f ) is a boolean algebra with operators.
5.2.4 Let Œõ be a normal modal logic. Prove that the Lindenbaum-Tarski algebra L Œõ is a
boolean algebra with œÑ -operators (that is, Ô¨Åll in the missing proof details in Theorem 5.33).
5.2.5 Let Œ£ be a set of œÑ -formulas. Prove that for any formula œÜ,  KœÑ Œ£ œÜ implies VŒ£ |=
œÜ‚âà . That is, prove the soundness direction of Theorem 5.27.
5.2.6 Call a variety V of BAOs complete if it is generated by a class of full complex alge-
bras, i.e., if V = HSPCmK for some frame class K. Prove that a logic Œõ is complete iff
the variety VŒõ is complete.
5.2.7 Let A be a boolean algebra. In this exercise we assume familiarity with the notion
of an inÔ¨Ånite sum (supremum). An operation f : A ‚Üí A is called completely additive if it
distributes over inÔ¨Ånite sums (in each of its arguments).
(a) Show that every operation of the form m R is completely additive.
(b) Give an example of an operation that is additive, but not completely additive. (Hint:
as the boolean algebra, take the set of Ô¨Ånite and co-Ô¨Ånite subsets of some frame.)
5.3 The J√≥nsson-Tarski Theorem
We already know how to construct a BAO from a frame: simply form the frame‚Äôs
complex algebra. We will now learn how to construct a frame from a BAO by form-
ing the ultraÔ¨Ålter frame of the algebra. As we will see, this operation generalizes284
5 Algebras and General Frames
two constructions that we have met before: taking the ultraÔ¨Ålter extension of a
model, and forming the canonical frame associated with a normal modal logic.
Our new construction will lead us to the desired representation theorem: by tak-
ing the complex algebra of the ultraÔ¨Ålter frame of a BAO, we obtain the canonical
embedding algebra of the original BAO. The fundamental result of this section
(and, indeed, of the entire chapter) is that every boolean algebra with operators
can be isomorphically embedded in its canonical embedding algebra. We will
prove this result and along the way discuss a number of other important issues,
such as the algebraic status of canonical models and ultraÔ¨Ålter extensions, and the
importance of canonical varieties of BAOs for modal completeness theory.
Let us consider the problem of (isomorphically) embedding an arbitrary BAO
A in a complex algebra. Obviously, the Ô¨Årst question to ask is: what should be
the underlying frame of the complex algebra? To keep our notation simple, let
us assume for the moment that we are working in a similarity type with just one
unary modality, and that A = (A, +, ‚àí, 0, f ) is a boolean algebra with one unary
operator f . Thus we have to Ô¨Ånd a universe W and a binary relation R on W
such that A can be embedded in the complex algebra of the frame (W, R). Stone‚Äôs
Representation Theorem 5.16 gives us half the answer, for it tells us how to embed
the boolean part of A in the power set algebra of the set Uf A of ultraÔ¨Ålters of A.
Let us take a closer look at this fundamental result.
Stone‚Äôs Representation Theorem
We have already met Ô¨Ålters and ultraÔ¨Ålters in Chapter 2, when we deÔ¨Åned the ul-
traÔ¨Ålter extension of a model. Now we generalize these notions to the context of
abstract boolean algebras.
DeÔ¨Ånition 5.34 A Ô¨Ålter of a boolean algebra A = (A, +, ‚àí, 0) is a subset F ‚äÜ A
satisfying
(F1) 1 ‚àà F ,
(F2) F is closed under taking meets; that is, if a, b ‚àà F then a ¬∑ b ‚àà F ,
(F3) F is upward closed; that is, if a ‚àà F and a ‚â§ b then b ‚àà F .
A Ô¨Ålter is proper if it does not contain the smallest element 0, or, equivalently, if
F = A. An ultraÔ¨Ålter is a proper Ô¨Ålter satisfying
(F4) For every a ‚àà A, either a or ‚àía belongs to F .
The collection of ultraÔ¨Ålters of A is called Uf A.
Note the difference in terminology: an (ultra)Ô¨Ålter over the set W is an (ultra)Ô¨Ålter
of the power set algebra P(W ).5.3 The J√≥nsson-Tarski Theorem
285
Example 5.35 For any element a of a boolean algebra A, the set a‚Üë = {b ‚àà A |
a ‚â§ b} is a Ô¨Ålter. In the Ô¨Åeld of Ô¨Ånite and co-Ô¨Ånite subsets of a countable set W ,
the collection of co-Ô¨Ånite subsets of W forms an ultraÔ¨Ålter.
Example 5.36 Since the collection of Ô¨Ålters of a boolean algebra is closed under
taking intersections, we may speak of the smallest Ô¨Ålter FD containing a given set
D ‚äÜ A. This Ô¨Ålter can also be deÔ¨Åned as the following set:
{a ‚àà A | there are d0 , . . . , dn ‚àà D such that d0 ¬∑ . . . ¬∑ dn ‚â§ a}
(5.21)
which explains why we will also refer to FD as the Ô¨Ålter generated by D. This
Ô¨Ålter is proper if D has the so-called Ô¨Ånite meet property; that is, if there is no Ô¨Ånite
subset {d0 , . . . , dn } of D such that d0 ¬∑ . . . ¬∑ dn = 0.
For future reference, we gather some properties of ultraÔ¨Ålters; the proof of the next
proposition is left to the reader.
Proposition 5.37 Let A = (A, +, ‚àí, 0) be a boolean algebra. Then
(i) For any ultraÔ¨Ålter u of A and for every pair of elements a, b ‚àà A we have
that a + b ‚àà u iff a ‚àà u or b ‚àà u.
(ii) Uf A coincides with the set of maximal proper Ô¨Ålters on A (‚Äòmaximal‚Äô is
understood with respect to set inclusion).
The main result that we need in the proof of Stone‚Äôs Theorem is the UltraÔ¨Ålter
Theorem: this guarantees that there are enough ultraÔ¨Ålters for our purposes.
Proposition 5.38 (UltraÔ¨Ålter Theorem) Let A be a boolean algebra, a an element
of A, and F a proper Ô¨Ålter of A that does not contain a. Then there is an ultraÔ¨Ålter
extending F that does not contain a.
Proof. We Ô¨Årst prove that every proper Ô¨Ålter can be extended to an ultraÔ¨Ålter. Let
G be a proper Ô¨Ålter of A, and consider the set X of all proper Ô¨Ålters H extending
G. Suppose that Y is a chain in X; that is, Y is a nonempty subset of X of which
the elements are pairwise ordered by set inclusion. We leave it to the reader to
verify that Y is a proper Ô¨Ålter; obviously, Y extends G; so Y belongs to X
itself. This shows that X is closed under taking unions of chains, whence it follows
from Zorn‚Äôs Lemma that X contains a maximal element u. We claim that u is an
ultraÔ¨Ålter.
For suppose otherwise. Then there is a b ‚àà A such that neither b nor ‚àíb belongs
to u. Consider the Ô¨Ålters H and H generated by u‚à™{b} and u‚à™{‚àíb}, respectively.
Since neither of these can belong to X, both must be improper; that is, 0 ‚àà H and286
5 Algebras and General Frames
0 ‚àà H  . But then by deÔ¨Ånition there are elements u1 , . . . , un , u1 , . . . , um in u such
that
u1 ¬∑ . . . ¬∑ un ¬∑ b ‚â§ 0 and u1 ¬∑ . . . ¬∑ um ¬∑ ‚àíb ‚â§ 0.
From this it easily follows that
u1 ¬∑ . . . ¬∑ un ¬∑ u1 ¬∑ ... ¬∑ um = 0,
contradicting the fact that u is a proper Ô¨Ålter.
Now suppose that a and F are as in the statement of the proposition. It is not
hard to show that F ‚à™ {‚àía} is a set with the Ô¨Ånite meet property. In Example 5.36
we saw that there is a proper Ô¨Ålter G extending F and containing ‚àía. Now we use
the Ô¨Årst part of the proof to Ô¨Ånd an ultraÔ¨Ålter u extending G. But if u extends G it
also extends F , and if it contains ‚àía it cannot contain a.
It follows from Proposition 5.38 and the facts mentioned in Example 5.36 that any
subset of a boolean algebra can be extended to an ultraÔ¨Ålter provided that it has
the Ô¨Ånite meet property. We now have all the necessary material to prove Stone‚Äôs
Theorem.
Theorem 5.16 (Stone Representation Theorem) Any boolean algebra is iso-
morphic to a Ô¨Åeld of sets, and hence, to a subalgebra of a power of 2. As a
consequence, the variety of boolean algebras is generated by the algebra 2:
BA = V({2}).
Proof. Fix a boolean algebra A = (A, +, ‚àí, 0). We will embed A in the power set
of Uf A. Consider the map œÅ : A ‚Üí P(Uf A) deÔ¨Åned as follows:
œÅ(a) = {u ‚àà Uf A | a ‚àà u}.
We Ô¨Årst show that œÅ is a homomorphism. As an example we treat the join operation:
œÅ(a + b) = {u ‚àà Uf A | a + b ‚àà u}
= {u ‚àà Uf A | a ‚àà u or b ‚àà u}
= {u ‚àà Uf A | a ‚àà u} ‚à™ {u ‚àà Uf A | b ‚àà u}
= œÅ(a) ‚à™ œÅ(b).
Note that the crucial second equality follows from Proposition 5.37.
It remains to prove that œÅ is injective. Suppose that a and b are distinct elements
of A. We may derive from this that either a ‚â§ b or b ‚â§ a. Without loss of
generality we may assume the second. But if b ‚â§ a then a does not belong to the
Ô¨Ålter b‚Üë generated by {b}, so by Proposition 5.38 there is some ultraÔ¨Ålter u such
that b‚Üë ‚äÜ u and a ‚àà u. Obviously, b‚Üë ‚äÜ u implies that b ‚àà u. But then we have
that u ‚àà œÅ(b) and u ‚àà œÅ(a).5.3 The J√≥nsson-Tarski Theorem
287
This shows that A is isomorphic to a Ô¨Åeld of sets; it then follows by Propo-
sition 5.8 that A is isomorphic to a subalgebra of a power of 2. From this it is
immediate that BA is the variety generated by the algebra 2.
Remark 5.39 That every boolean algebra is isomorphic to a subalgebra of a power
of the algebra 2 can be proved more directly by observing that there is a one-to-
one correspondence between ultraÔ¨Ålters of A and homomorphisms from A onto 2.
Given an ultraÔ¨Ålter u of A, deÔ¨Åne Œ±u : A ‚Üí 2 by
Œ±u (a) =
1 if a ‚àà u,
0 otherwise.
And conversely, given a homomorphism Œ± : A ‚Üí 2, deÔ¨Åne the ultraÔ¨Ålter uŒ± by
uŒ± = Œ±‚àí1 (1) (= {a ‚àà A | Œ±(a) = 1}).
We leave further details to the reader.
UltraÔ¨Ålter frames
Now that we have a candidate for the universe of the ultraÔ¨Ålter frame of a given
BAO A, let us see how to deÔ¨Åne a relation R on ultraÔ¨Ålters such that we can embed
A in the algebra (Uf A, R)+ . To motivate the deÔ¨Ånition of R, we will view the
elements of the algebra as propositions, and imagine that r(a) (the representation
map r applied to proposition a) yields the set of states where a is true according
to some valuation. Hence, reading f a as 3a, it seems natural that a state u should
be in r(f a) if and only if there is a v with Ruv and v ‚àà r(a). So, in order to
decide whether Ruv should hold for two arbitrary states (ultraÔ¨Ålters) u and v, we
should look at all the propositions a holding at v (that is, all elements a ‚àà v) and
check whether f a holds at u (that is, whether f a ‚àà u). Putting it more formally,
the natural, ‚Äòcanonical‚Äô choice for R seems to be the relation Qf given by
Qf uv iff f a ‚àà u for all a ‚àà v.
The reader should compare this deÔ¨Ånition with the deÔ¨Ånition of the canonical re-
lation given in DeÔ¨Ånition 4.18. Although one is couched in terms of ultraÔ¨Ålters,
and the other in terms of maximal consistent sets (MCSs), both clearly trade on the
same idea. As we will shortly learn (and as the above identiÔ¨Åcation of ‚ÄòultraÔ¨Ålters‚Äô
and ‚Äòmaximal sets of propositions‚Äô already suggests), this is no accident.
In the general case, we use the following deÔ¨Ånition (an obvious analog of DeÔ¨Å-
nition 4.24).
DeÔ¨Ånition 5.40 Given an n-ary operator f on a boolean algebra (A, +, ‚àí, 0), we
deÔ¨Åne the (n + 1)-ary relation Qf on the set of ultraÔ¨Ålters of the algebra by
Qf uu1 . . . un iff f (a1 , . . . , an ) ‚àà u for all a1 ‚àà u1 , . . . , an ‚àà un .288
5 Algebras and General Frames
Let A = (A, +, ‚àí, 0, f )‚ààœÑ be a boolean algebra with operators. The ultraÔ¨Ålter
frame of A, notation: A+ , is the structure (Uf A, Qf )‚ààœÑ . The complex algebra
(A+ )+ is called the (canonical) embedding algebra of A (notation: EmA).
We leave it to the reader to verify that the ultraÔ¨Ålter extension ue F of a frame
F is nothing but the ultraÔ¨Ålter frame of the complex algebra of F, in symbols:
ue F = (F+ )+ .
For later reference, we state the following proposition (an obvious analog of
Lemma 4.25) which shows that we could have given an alternative but equivalent
deÔ¨Ånition of the relation Qf .
Proposition 5.41 Let f be an n-ary operator on the boolean algebra A, and u,
u1 , . . . , un an (n + 1)-tuple of ultraÔ¨Ålters of A. Then
Qf uu1 . . . un iff ‚àíf (‚àía1 , . . . , ‚àían ) ‚àà u implies that for some i, ai ‚àà ui .
Proof. We only prove the direction from left to right. Suppose that Qf uu1 . . . un ,
and that ‚àíf (‚àía1 , . . . , ‚àían ) ‚àà u. To arrive at a contradiction, suppose that there is
no i such that ai ‚àà ui . But as Qf uu1 . . . un , it follows that f (‚àía1 , . . . , ‚àían ) ‚àà u.
But this contradicts the fact that ‚àíf (‚àía1 , . . . , ‚àían ) ‚àà u.
As the above sequence of analogous deÔ¨Ånitions and results suggest, we have al-
ready encountered a kind of frame which is very much like an ultraÔ¨Ålter frame,
namely the canonical frame of a normal modal logic (see DeÔ¨Ånition 4.18). The
basic idea should be clear now: the states of the canonical frame are the MCSs
of the logic, and an ultraÔ¨Ålter is nothing but an abstract version of an MCS. But
this is no mere analogy: the canonical frame of a logic is actually isomorphic to
the ultraÔ¨Ålter frame of its Lindenbaum-Tarski algebra, and the mapping involved
is simple and intuitive. When making this connection, the reader should keep in
mind that when we deÔ¨Åned ‚Äòthe‚Äô canonical frame in Chapter 4, we always had a
Ô¨Åxed, countable set Œ¶ of proposition letters in mind.
Theorem 5.42 Let œÑ be a modal similarity type, Œõ a normal modal œÑ -logic, and Œ¶
the set of proposition letters used to deÔ¨Åne the canonical frame FŒõ . Then
FŒõ ‚àº
= (LŒõ (Œ¶))+ .
Proof. We leave it to the reader to show that the function Œ∏ deÔ¨Åned by
Œ∏(Œì ) = {[œÜ] | œÜ ‚àà Œì },
mapping a maximal Œõ-consistent set Œì to the set of equivalence classes of its mem-
bers, is the required isomorphism between FŒõ and (LŒõ (Œ¶))+ .5.3 The J√≥nsson-Tarski Theorem
289
The J√≥nsson-Tarski Theorem
We are ready to prove the J√≥nsson-Tarski Theorem: every boolean algebra with
operators is embeddable in the full complex algebra of its ultraÔ¨Ålter frame.
Theorem 5.43 (J√≥nsson-Tarski Theorem) Let œÑ be a modal similarity type, and
A = (A, +, ‚àí, 0, f)‚ààœÑ be a boolean algebra with œÑ -operators. Then the repre-
sentation function r : A ‚Üí P(Uf A)) given by
r(a) = {u ‚àà Uf A | a ‚àà u}
is an embedding of A into EmA.
Proof. To simplify our notation a bit, we work in a similarity type with a single
n-ary modal operator, assuming that A = (A, +, ‚àí, 0, f ) is a boolean algebra with
a single n-ary operator f . By Stone‚Äôs Representation Theorem, the map r : A ‚Üí
P(Uf A) given by
r(x) = {u ‚àà Uf A | x ‚àà u}
is a boolean embedding. So, it sufÔ¨Åces to show that r is also a modal homomor-
phism; that is, that
r(f (a1 , . . . , an )) = mQf (r(a1 ), . . . , r(an )).
(5.22)
We will Ô¨Årst prove (5.22) for unary f . In other words, we have to prove that
r(f a) = mQf (r(a)).
We start with the inclusion from right to left: assume u ‚àà mQf (r(a)). Then by
deÔ¨Ånition of mQf , there is an ultraÔ¨Ålter u1 with u1 ‚àà r(a) (that is, a ‚àà u1 ) and
Qf uu1 . By deÔ¨Ånition of Qf this implies f a ‚àà u, or u ‚àà r(f a).
For the other inclusion, let u be an ultraÔ¨Ålter in r(f a), that is, f a ‚àà u. To
prove that u ‚àà mQf (r(a)), it sufÔ¨Åces to Ô¨Ånd an ultraÔ¨Ålter u1 such that Qf uu1 and
u1 ‚àà r(a), or a ‚àà u1 . The basic idea of the proof is that we Ô¨Årst pick out those
elements of A (other than a) that we cannot avoid putting in u1 . These elements are
given by the condition Qf uu1 . By Proposition 5.41 we have that for every element
of the form ‚àíf (‚àíy) in u, y has to be in u1 ; therefore, we deÔ¨Åne
F := {y ‚àà A | ‚àíf (‚àíy) ‚àà u}.
We will now show that there is an ultraÔ¨Ålter u1 ‚äá F containing a. First, an easy
proof (using the additivity of f ), shows that F is closed under taking meets. Sec-
ond, we prove that
F  := {a ¬∑ y | y ‚àà F }
has the Ô¨Ånite meet property. As F is closed under taking meets, it is sufÔ¨Åcient to
show that a ¬∑ y = 0 whenever y ‚àà F . To arrive at a contradiction, suppose that5 Algebras and General Frames
290
a ¬∑ y = 0. Then a ‚â§ ‚àíy, so by the monotonicity of f , f a ‚â§ f (‚àíy); therefore,
f (‚àíy) ‚àà u, contradicting y ‚àà F .
By Proposition 5.38 there is an ultraÔ¨Ålter u1 ‚äá F  . Note that a ‚àà u1 , as 1 ‚àà F .
Finally, Qf uu1 holds by deÔ¨Ånition of F : if ‚àíf (‚àíy) ‚àà u then y ‚àà F ‚äÜ u1 .
We now prove (5.22) for arbitrary n ‚â• 1 by induction on the arity n of f . We
have just proved the base case. So, assume that the induction hypothesis holds for
n. We only treat the direction from left to right, since the other direction can be
proved as in the base case. Let f be a normal and additive function of rank n + 1,
and suppose that a1 , . . . , an+1 are elements of A such that f (a1 , . . . , an+1 ) ‚àà u.
We have to Ô¨Ånd ultraÔ¨Ålters u1 , . . . , un+1 of A such that (i) ai ‚àà ui for all i with
1 ‚â§ i ‚â§ n + 1, and (ii) Qf uu1 . . . un+1 . Our strategy will be to let the induction
hypothesis take care of u1 , . . . , un and then to search for un+1 .
Let f  : An ‚Üí A be the function given by
f  (x1 , . . . , xn ) = f (x1 , . . . , xn , an+1 ).
That is, for the time being we Ô¨Åx an+1 . It is easy to see that f  is normal and
additive, so we may apply the induction hypothesis. Since f (a1 , . . . , an ) ‚àà u, this
yields ultraÔ¨Ålters u1 , . . . , un such that ai ‚àà ui for all i with 1 ‚â§ i ‚â§ n, and
f (x1 , . . . , xn , an+1 ) ‚àà u, whenever xi ‚àà ui (1 ‚â§ i ‚â§ n).
(5.23)
Now we will deÔ¨Åne an ultraÔ¨Ålter un+1 such that an+1 ‚àà un+1 and Qf uu1 . . . un+1 .
This second condition can be rewritten as follows (we abbreviate ‚Äòx1 ‚àà u1 , . . . ,
xn ‚àà un ‚Äô by ‚Äòx ‚àà u‚Äô):
Qf uu1 . . . un+1
ifffor all x, y: if x ‚àà u, then y ‚àà un+1 implies f (x, y) ‚àà u
ifffor all x, y: if x ‚àà u, then f (x, y) ‚àà u implies y ‚àà un+1
ifffor all x, y: if x ‚àà u, then ‚àíf (x, y) ‚àà u implies ‚àíy ‚àà un+1
ifffor all x, z: if x ‚àà u, then ‚àíf (x, ‚àíz) ‚àà u implies z ‚àà un+1 .
This provides us with a minimal set of elements that un+1 should contain; put
F := {z ‚àà A | ‚àÉx ‚àà u (‚àíf (x, ‚àíz) ‚àà u)}.
If ‚àíf (x, ‚àíz) ‚àà u, we say that x drives z into F . We now take the Ô¨Årst condition
into account as well, deÔ¨Åning F  := {an+1 } ‚à™ F .
Our aim is to prove the existence of an ultraÔ¨Ålter un+1 containing F  . It will be
clear that this is sufÔ¨Åcient to prove the theorem (note that an+1 ‚àà F  as 1 ‚àà F ). To
be able to apply the UltraÔ¨Ålter Theorem 5.38, we will show that F has the Ô¨Ånite
meet property. We Ô¨Årst need the following fact:
F is closed under taking meets.
(5.24)5.3 The J√≥nsson-Tarski Theorem
291
Let z  , z  be in F ; assume that z and z are driven into F by x and x , respec-
tively. We will now see that x := (x1 ¬∑ x1 , . . . , xn ¬∑ xn ) drives z := z ¬∑ z  into F ,
that is, that ‚àíf (x, ‚àíz) ‚àà u.
Since f is monotonic, we have f (x, ‚àíz ) ‚â§ f (x , ‚àíz  ), and hence we Ô¨Ånd that
‚àíf (x , ‚àíz  ) ‚â§ ‚àíf (x, ‚àíz  ). As u is upward closed and ‚àíf (x , ‚àíz  ) ‚àà u by
our ‚Äòdriving assumption‚Äô, this gives ‚àíf (x, ‚àíz ) ‚àà u. In the same way we Ô¨Ånd
‚àíf (x, ‚àíz  ) ‚àà u. Now
f (x, ‚àíz) = f (x, ‚àí(z  ¬∑ z  )) = f (x, (‚àíz  ) + (‚àíz  )) = f (x, ‚àíz  ) + f (x, ‚àíz  ),
whence
‚àíf (x, ‚àíz) = [‚àíf (x, ‚àíz  )] ¬∑ [‚àíf (x, ‚àíz  )].
Therefore, ‚àíf (x, ‚àíz) ‚àà u, since u is closed under taking meets. This proves
(5.24).
We can now Ô¨Ånish the proof and show that indeed
F  has the Ô¨Ånite meet property.
(5.25)
By (5.24) it sufÔ¨Åces to show that an+1 ¬∑z = 0 for all z ‚àà F . To prove this, we reason
by contraposition: suppose that z ‚àà F and an+1 ¬∑ z = 0. Let x ‚àà u be a sequence
that drives z into F , that is, ‚àíf (x, ‚àíz) ‚àà u. From an+1 ¬∑ z = 0 it follows that
an+1 ‚â§ ‚àíz, so by monotonicity of f we get ‚àíf (x, ‚àíz) ‚â§ ‚àíf (x, an+1 ). But then
‚àíf (x, an+1 ) ‚àà u, which contradicts (5.23). This proves that indeed an+1 ¬∑ z = 0
and hence we have shown (5.25) and thus, Theorem 5.43.
Canonicity: the algebraic perspective
To conclude this section, let us discuss the signiÔ¨Åcance of this result. Clearly the
J√≥nsson-Tarski Theorem guarantees that we can represent the Lindenbaum-Tarski
algebras of normal modal logics as complex algebras, so it immediately converts
Theorem 5.32 into a completeness result with respect to complex algebras.
But we want more: because of the link between complex algebras and relational
semantics, it seems to offer a plausible algebraic handle on frame completeness.
And in fact it does ‚Äì but we need to be careful. As should be clear from our work in
Chapter 4, even with the J√≥nsson-Tarski Theorem at our disposal, one more hurdle
remains to be cleared. In Exercise 5.2.6 we deÔ¨Åned the notion of a complete variety
of BAOs: a variety V is complete if there is a frame class K that generates V in the
sense that V = HSPCmK. The exercise asked the reader to show that any logic
Œõ is complete if and only if VŒõ is a complete variety. Now does the J√≥nsson-Tarski
Theorem establish such a thing? Not really ‚Äì it does show that every algebra A is
a complex algebra over some frame, thus proving that for any logic Œõ we have that
VŒõ ‚äÜ SCmK for some frame class K. So, this certainly gives VŒõ ‚äÜ HSPCmK.292
5 Algebras and General Frames
However, in order to prove completeness, we have to establish an equality instead
of an inclusion. One way to prove this is to show that the complex algebras that we
have found form a subclass of VŒõ . By Proposition 5.24 it would sufÔ¨Åce to show
that for any algebra A in the variety VŒõ , the frame A+ is a frame for the logic Œõ.
This requirement gives us an algebraic handle on the notion of canonicity.
Let us examine a concrete example. Recall that K4 is the normal logic gen-
erated by the 4 axiom, 33p ‚Üí 3p. We know from Theorem 4.27 that K4 is
complete with respect to the class of transitive frames. How can we prove this
result algebraically?
A little thought reveals that the following is required: we have to show that
the Lindenbaum-Tarski algebras for K4 are embeddable in full complex algebras
of transitive frames. Recall from Section 3.1 that the 4 axiom characterizes the
transitive frames, thus in our proposed completeness proof, we would have to show
that 4 is valid in the ultraÔ¨Ålter frame (LK4 (Œ¶))+ of LK4 (Œ¶), or equivalently, that
((LK4 (Œ¶))+ )+ belongs to the variety V4 . Note that by Theorem 5.32 we already
know that LK4 (Œ¶) belongs to V4 .
As this example suggests, proving frame completeness results for extensions of
K algebraically leads directly to the following question: which varieties of BAOs
are closed under taking canonical embedding algebras? In fact, this is the required
algebraic handle on canonicity and motivates the following deÔ¨Ånition.
DeÔ¨Ånition 5.44 Let œÑ be a modal similarity type, and C a class of boolean algebras
with œÑ -operators. C is canonical if it is closed under taking canonical embedding
algebras; that is, if for all algebras A, EmA is in C whenever A is in C. Likewise,
an equation is canonical if its validity is preserved when moving from a BAO to its
canonical embedding algebra.
Thus we now have two notions of canonicity, namely the logical one of DeÔ¨Åni-
tion 4.30 and the algebraic one just deÔ¨Åned. Using Theorem 5.32, we show that
these two concepts are closely related.
Proposition 5.45 Let œÑ be a modal similarity type, and Œ£ a set of œÑ -formulas. If
VŒ£ is a canonical variety, then Œ£ is canonical.
Proof. Assume that the variety VŒ£ is canonical, and let Œ¶ be the Ô¨Åxed countable set
of proposition letters that we use to deÔ¨Åne canonical frames. By Theorem 5.32, the
Lindenbaum-Tarski algebra LKŒ£ (Œ¶) is in VŒ£ ; then, by assumption, its canonical
embedding algebra EmLKŒ£ is in VŒ£ . However, from Theorem 5.42 it follows that
this algebra is isomorphic to the complex algebra of the canonical frame of KŒ£:
EmLKŒ£ (Œ¶) = ((LKŒ£ (Œ¶))+ )+ ‚àº
= (FKŒ£ )+ .5.3 The J√≥nsson-Tarski Theorem
293
Now the fact that (FKŒ£ )+ is in VŒ£ means that FKŒ£  Œ£ by Proposition 5.24. But
this implies that Œ£ is canonical.
An obvious question is whether the converse of Proposition 5.45 holds as well;
that is, whether a variety VŒ£ is canonical if Œ£ is a canonical set of modal formu-
las. However, note that canonicity of Œ£ only implies that one particular boolean
algebra with operators has its embedding algebra in VŒ£ , namely the Lindenbaum-
Tarski algebra over a countably inÔ¨Ånite number of generators. This is because
throughout the completeness chapter we were working in a Ô¨Åxed, countable set of
proposition letters. In fact, we are facing an open problem here:
Open Problem 1 Let œÑ be a modal similarity type, and Œ£ a canonical set of œÑ -
formulas. Is VŒ£ a canonical variety?
Equivalently, suppose that E is a set of equations such that for all countable
boolean algebras with œÑ -operators we have the following implication
if A |= E then EmA |= E.
(5.26)
Is VE a canonical variety? In other words, does (5.26) hold for all boolean alge-
bras with œÑ -operators?
This is an interesting problem. However, arguably the restriction of the notion of
canonicity to countable languages that we adopted in Chapter 4 was not mathe-
matically natural. Thus, let us redeÔ¨Åne the logical notion of canonicity so that it
refers to languages of arbitrary size. The deÔ¨Ånition of canonical frames and models
can easily be parametrized by a set of proposition letters: the maximal consistent
sets are supposed to be maximal within the induced set of formulas. We now sim-
ply deÔ¨Åne a logic Œõ to be canonical if it is valid on each of its canonical frames.
With this deÔ¨Ånition we can indeed establish equivalence between the logical and
algebraic notions of canonicity. (An alternative, and mathematically quite interest-
ing alternative, would be to introduce, both logically and algebraically, a hierarchy
of canonicity notions, parametrized by cardinal numbers. Such an approach has
indeed been studied in the literature, but this option will not be pursued here.)
Regardless of our approach towards this issue, the algebraic notion of canonic-
ity can do a lot of work for us. The important point is that it offers a genuinely
new perspective on what canonicity is, a perspective that will allow us to use al-
gebraic arguments. This will be demonstrated in Section 5.6 when we introduce
persistence, a generalization of the notion of canonicity, and prove the Sahlqvist
Completeness Theorem.
Exercises for Section 5.3
5.3.1 Prove that for any frame F, ue F = (F + )+ .5 Algebras and General Frames
294
5.3.2 Let Œõ be a normal modal logic. Give a detailed proof that the canonical frame F Œõ is
isomorphic to the ultraÔ¨Ålter frame of L Œõ (over a countable set of proposition letters).
5.3.3 Let A denote the collection of sets X of integers satisfying one of the following
four conditions: (i) X is Ô¨Ånite, (ii) X is co-Ô¨Ånite, (iii) X ‚äï E is Ô¨Ånite, (iv) X ‚äï E is
co-Ô¨Ånite. Here E denotes the set of all even integers, and ‚äï denotes symmetric difference:
X ‚äï E = (X \ E) ‚à™ (E \ X). Consider the following algebra A = (A, ‚à™, ‚àí, ‚àÖ, f ) where
the operation f is given by
f (X) =
{x ‚àí 1 | x ‚àà X}
Z
if X is of type (i) or (iii),
if X is of type (ii) or (iv).
(a) Show that A is a boolean algebra with operators.
(b) Describe A+ .
5.3.4 Let W be the set Z ‚à™ {‚àí‚àû, ‚àû} and let S be the successor relation on Z, that is,
S = {(z, z + 1) | z ‚àà Z}.
(a) Give a BAO whose ultraÔ¨Ålter frame is isomorphic to the frame F = (W, R) with
R = S ‚à™ {(‚àí‚àû, ‚àí‚àû), (‚àû, ‚àû)}.
(b) Give a BAO whose ultraÔ¨Ålter frame is isomorphic to the frame F = (W, R) with
R = S ‚à™ (W √ó {‚àí‚àû, ‚àû}).
(c) Give a BAO whose ultraÔ¨Ålter frame is isomorphic to the frame F = (W, R) with
R = S ‚à™ {(‚àí‚àû, ‚àí‚àû)} ‚à™ (W √ó {‚àû}).
5.3.5 An operation on a boolean algebra is called 2-additive if it satisÔ¨Åes
f (x + y + z) = f (x + y) + f (x + z) + f (y + z).
Prove an analog of the J√≥nsson-Tarski Theorem for boolean algebras augmented with 2-
additive operations.
5.4 Duality Theory
We now know how to build frames from algebras and algebras from frames in
ways that preserve crucial logical properties. But something is missing. Modal
logicians rarely study frames in isolation: rather, they are interested in how to con-
struct new frames from old using bounded morphisms, generated subframes, and
disjoint unions. And algebraists adopt an analogous perspective: they are inter-
ested in relating algebras via such constructions as homomorphisms, subalgebras,
and direct products. Thus modal logicians work in one mathematical universe, and
algebraists in another, and it is natural to ask whether these universes are system-
atically related. They are, and duality theory studies these links.
In this section we will do two things. First, we will introduce the basic dualities
that exist between the modal and algebraic universes. Second, we will demonstrate
that these dualities are useful by proving two major theorems of modal logic. We
assume that by this stage the reader has picked up the basic deÔ¨Ånitions and re-
sults concerning the algebraic universe (and in particular, what homomorphisms,
subalgebras, and direct products are). If not, check out Appendix B.5.4 Duality Theory
295
Basic duality results
Theorems 5.47 and 5.48 below give a concise formulation of the basic links be-
tween the algebraic and frame-theoretic universes. They are stated using the fol-
lowing notation.
DeÔ¨Ånition 5.46 Let œÑ be a modal similarity type, F and G two œÑ -frames, and A
and B two boolean algebras with œÑ -operators. We recall (deÔ¨Åne, respectively) the
following notation for relations between these structures:
‚Ä¢ F  G for F is isomorphic to a generated subframe of G,
‚Ä¢ F
G for G is a bounded morphic image of F,
‚Ä¢ A  B for A is isomorphic to a subalgebra of B,
‚Ä¢ A
B for B is a homomorphic image of A.
Theorem 5.47 Let œÑ be a modal similarity type, F and G two œÑ -frames, and A and
B two boolean algebras with œÑ -operators.
(i) If F  G, then G+
F+ .
(ii) If F
G, then G+  F+ .
(iii) If A  B, then B+
A+ .
(iv) If A
B, then B+  A+ .
Proof. This follows immediately from Propositions 5.51 and 5.52 below.
Theorem 5.48 Let œÑ be a modal similarity type, and Fi , i ‚àà I, a family of œÑ -
frames. Then

+
&
'
‚àº
Fi
F+ .
=
i
i‚ààI
i‚ààI
Proof. We deÔ¨Åne a map Œ∑ from the power set of the disjoint union i‚ààI Wi to the

carrier i‚ààI P(Wi ) of the product of the family of complex algebras (F+
i )i‚ààI .
Let X be a subset of i‚ààI Wi . Clearly, Œ∑(X) has to be an element of the set


i‚ààI P(Wi ). And elements of the set
i‚ààI P(Wi ) are sequences œÉ such that
œÉ(i) ‚àà P(Wi ). So it sufÔ¨Åces to say what the i-th element of the sequence Œ∑(X) is:
Œ∑(X)(i) = X ‚à© Wi .
We leave it as an exercise to show that Œ∑ is an isomorphism; see Exercise 5.4.6.
Note that Theorem 5.48 (in contrast to Theorem 5.47) only states a connection in
the direction from frames to algebras. This is because in general


'
&
‚àº
Ai
(Ai )+ .
=
i‚ààI
+
i‚ààI296
5 Algebras and General Frames
The reader is asked to give an example to this effect in Exercise 5.4.1.
In order to prove Theorem 5.47, the reader is advised to recall the deÔ¨Ånitions
of the back and forth properties of bounded morphisms between frames (DeÔ¨Åni-
tion 3.13). We also need some terminology for morphisms between boolean alge-
bras with operators.
DeÔ¨Ånition 5.49 Let A and A be two BAOs of the same similarity type, and let
Œ∑ : A ‚Üí A be a function. We say that Œ∑ is a boolean homomorphism if Œ∑ is a
homomorphism from (A, +, ‚àí, 0) to (A , + , ‚àí , 0 ). We call Œ∑ a modal homomor-
phism if Œ∑ satisÔ¨Åes, for all modal operators :
Œ∑(f(a1 , . . . , aœÅ() )) = f (Œ∑a1 , . . . , Œ∑aœÅ() ).
(Here Œ∑ai means Œ∑(ai ); we will sometimes use this shorthand to keep the notation
uncluttered.) Finally, Œ∑ is a (BAO-)homomorphism if it is both a boolean and a
modal homomorphism.
In the following deÔ¨Ånition, the construction of dual or lifted morphisms is given
(here the word ‚Äòdual‚Äô is not used in the sense of 3 being the dual of 2).
DeÔ¨Ånition 5.50 Suppose Œ∏ is a map from W to W  ; then its dual, Œ∏+ : P(W  ) ‚Üí
P(W ) is deÔ¨Åned as:
Œ∏ + (X  ) = {u ‚àà W | Œ∏(u) ‚àà X  }.
In the other direction, let A and A be two BAOs, and Œ∑ : A ‚Üí A be a map from A
to A ; then its dual is given as the following map from ultraÔ¨Ålters of A to subsets
of A:
Œ∑+ (u ) = {a ‚àà A | Œ∑(a) ‚àà u }.
The following propositions assert that the duals of bounded morphisms are nothing
but BAO-homomorphisms:
Proposition 5.51 Let F, F be frames, and Œ∏ : W ‚Üí W  a map.
(i) Œ∏+ is a boolean homomorphism.
(ii) mR (Œ∏ + (Y1 ), . . . , Œ∏ + (Yn )) ‚äÜ Œ∏ + (mR (Y1 , . . . , Yn )), if Œ∏ has the forth prop-
erty.
(iii) mR (Œ∏ + (Y1 ), . . . , Œ∏ + (Yn )) ‚äá Œ∏ + (mR (Y1 , . . . , Yn )), if Œ∏ has the back prop-
erty.
(iv) Œ∏+ is a BAO-homomorphism from F+ to F+ , if Œ∏ is a bounded morphism.
(v) Œ∏+ is surjective, if Œ∏ is injective.
(vi) Œ∏+ is injective, if Œ∏ is surjective.5.4 Duality Theory
297
Proof. For notational convenience, we assume that œÑ has only one modal operator,
so that we can write F = (W, R).
(i) (Note that this was Exercise 5.1.1.) As an example, we treat complementa-
tion:
x ‚àà Œ∏ + (‚àíX  ) iff Œ∏(x) ‚àà ‚àíX  iff Œ∏(x) ‚àà
/ X  iff x ‚àà Œ∏+ (X  ).
From this it follows immediately that Œ∏+ (‚àíX  ) = ‚àíŒ∏ + (X  ).
(ii) Assume that Œ∏ has the forth property. Then we have
x ‚àà mR (Œ∏ + (Y1 ), . . . , Œ∏ + (Yn ))
=‚áí ‚àÉ y1 , . . . , yn such that Œ∏(yi ) ‚àà Yi and Rxy1 . . . yn
=‚áí ‚àÉ y1 , . . . , yn such that Œ∏(yi ) ‚àà Yi and R Œ∏(x)Œ∏(y1 ) . . . Œ∏(yn )
=‚áí Œ∏(x) ‚àà mR (Y1 , . . . , Yn )
=‚áí x ‚àà Œ∏ + (mR (Y1 , . . . , Yn )).
(iii) Now suppose x ‚àà Œ∏+ (mR (Y1 , . . . , Yn )). Then Œ∏(x) ‚àà mR (Y1 , . . . , Yn ).
So there are y1 , . . . , yn in W  with yi ‚àà Yi and R Œ∏(x)y1 . . . yn . As Œ∏ has the back
property, there are y1 , . . . , yn ‚àà W with Œ∏(yi ) = yi for all i, and Rxy1 . . . yn . But
then yi ‚àà Œ∏ + (Yi ) for every i, so x ‚àà mR (Œ∏ + (Y1 ), . . . , Œ∏ + (Yn )).
(iv) This follows immediately from items (i), (ii) and (iii).
(v) Assume that Œ∏ is injective, and let X be a subset of W . We have to Ô¨Ånd a
subset X  of W  such that Œ∏+ (X  ) = X. DeÔ¨Åne
Œ∏[X] := {Œ∏(x) ‚àà W  | x ‚àà X}.
We claim that this set has the desired properties. Clearly X ‚äÜ Œ∏+ (Œ∏[X]). For the
other direction, let x be an element of Œ∏+ (Œ∏[X]). Then by deÔ¨Ånition, Œ∏(x) ‚àà Œ∏[X],
so there is a y ‚àà X such that Œ∏(x) = Œ∏(y). By the injectivity of Œ∏, x = y. So
x ‚àà X.
(vi) Assume that Œ∏ is surjective, and let X and Y  be distinct subsets of W  .
Without loss of generality we may assume that there is an x such that x ‚àà X  and
x ‚àà Y  . As Œ∏ is surjective, there is an x in W such that Œ∏(x) = x . So x ‚àà Œ∏ + (X  ),
but x ‚àà Œ∏+ (Y  ). So Œ∏(X  ) = Œ∏(Y  ), whence Œ∏+ is injective.
Going in the opposite direction, that is, from algebras to relational structures, we
Ô¨Ånd that the duals of BAO-homomorphisms are bounded morphisms:
Proposition 5.52 Let A, A be boolean algebras with operators, and Œ∑ a map from
A to A .
(i) If Œ∑ is a boolean homomorphism, then Œ∑+ maps ultraÔ¨Ålters to ultraÔ¨Ålters.
(ii) If f  (Œ∑(a1 ), . . . , Œ∑(an )) ‚â§ Œ∑(f (a1 , . . . , an )), then Œ∑+ has the forth prop-
erty.298
5 Algebras and General Frames
(iii) If f  (Œ∑(a1 ), . . . , Œ∑(an )) ‚â• Œ∑(f (a1 , . . . , an )) and Œ∑ is a boolean homomor-
phism, then Œ∑+ has the back property.
(iv) If Œ∑ is a BAO-homomorphism, then Œ∑+ is a bounded morphism from A+ to
A+ .
(v) If Œ∑ is an injective boolean homomorphism, then Œ∑+ : Uf A ‚Üí Uf A is
surjective.
(vi) If Œ∑ is a surjective boolean homomorphism, then Œ∑+ : Uf A ‚Üí Uf A is
injective.
Proof. Again, without loss of generality we assume that œÑ has only one modal
operator, so that we can write A = (A, +, ‚àí, 0, f ).
(i) This item is left as Exercise 5.4.2.
(ii) Suppose that Qf  u u1 . . . un holds between some ultraÔ¨Ålters u , u1 , . . . , un
of A . To show that A+ |= Qf Œ∑+ u Œ∑+ u1 . . . Œ∑+ un , let a1 , . . . , an be arbitrary
elements of Œ∑+ u1 , . . . , Œ∑+ un respectively. Then, by deÔ¨Ånition of Œ∑+ , Œ∑ai ‚àà
ui , so Qf u u1 . . . un gives f  (Œ∑a1 , . . . , Œ∑an ) ‚àà u . Now the assumption yields
Œ∑f (a1 , . . . , an ) ‚àà u , as ultraÔ¨Ålters are upward closed. But then f (a1 , . . . , an ) ‚àà
Œ∑+ u , which is what we wanted.
(iii) This item is left as Exercise 5.4.2.
(iv) This follows immediately from items (i), (ii) and (iii).
(v) Assume that Œ∑ is injective, and let u be an ultraÔ¨Ålter of A. We want to follow
the same strategy as in Proposition 5.51(v), and deÔ¨Åne
Œ∑[u] := {Œ∑(a) | a ‚àà u}.
The difference with the proof of Proposition 5.51(v) is that here, Œ∑+ (Œ∑[u]) may not
be deÔ¨Åned. The reason for this is that, in general, Œ∑[u] will not be upwards closed
and hence, not an (ultra)Ô¨Ålter, while Œ∑+ is deÔ¨Åned only for ultraÔ¨Ålters. Therefore,
we deÔ¨Åne
F  := {a | Œ∑(a) ‚â§ a for some a ‚àà u }.
Clearly, Œ∑[u] ‚äÜ F  . We will Ô¨Årst show that F  is a proper Ô¨Ålter of A (note that
the clauses (F 1)‚Äì(F 3) which deÔ¨Åne Ô¨Ålters are given in DeÔ¨Ånition 5.34). For (F 1),
observe that 1 ‚àà u, so Œ∑(1) = 1 ‚àà Œ∑[u] ‚äÜ F  . For (F 2), assume a , b ‚àà F  . Then
there are a, b in u such that Œ∑a ‚â§ a and Œ∑b ‚â§ b . It follows that Œ∑(a ¬∑ b) = Œ∑a ¬∑ Œ∑b ‚â§
a ¬∑ b ‚àà Œ∑[u]; hence, a ¬∑ b ‚àà F  since a ¬∑ b ‚àà u. This shows that F  is closed under
taking meets. It is trivial to prove (F 3), that is, that F is upwards closed. Finally,
in order to show that F  is proper, suppose that 0 ‚àà F  . Then 0 = Œ∑a for some
a ‚àà u; as 0 = Œ∑(0), injectivity of Œ∑ gives that 0 = a, and hence, 0 ‚àà u. But then
u is not an ultraÔ¨Ålter.
By the UltraÔ¨Ålter Theorem 5.38, F  can be extended to an ultraÔ¨Ålter u . We claim
that u = Œ∑+ (u ). First let a be in u, then Œ∑a ‚àà Œ∑[u] ‚äÜ u , so a ‚àà Œ∑+ (u ). This5.4 Duality Theory
299
shows that u ‚äÜ Œ∑+ (u ). For the other inclusion, it sufÔ¨Åces to show that a ‚àà Œ∑+ (u )
if a ‚àà u; we reason as follows:
a ‚àà u
=‚áí
=‚áí
=‚áí
=‚áí
=‚áí
‚àía ‚àà u
‚àíŒ∑a = Œ∑(‚àía) ‚àà Œ∑[u]
‚àíŒ∑(a) ‚àà u
Œ∑a ‚àà u
a ‚àà Œ∑+ (u ).
(vi) Similar to Proposition 5.51, item (vi); see Exercise 5.4.2.
Readers familiar with category theory will have noticed that the operation (¬∑)+ is a
functor from the category of œÑ -frames with bounded morphisms to the category of
boolean algebras with œÑ -operators, and vice versa for (¬∑)+ . This categorial perspec-
tive is implicit in what follows, but seldom comes to the surface. In the remainder
of the section we will see how our algebraic perspective on modal logic that we
have developed can be applied.
Applications
In this subsection we tie a number of threads together and show how to use the
duality between frames and algebras to give very short proofs of some major theo-
rems of modal logic.
Our Ô¨Årst example shows that all the results given in Theorem 3.14 on the preser-
vation of modal validity under the fundamental frame operations fall out as simple
consequences of well-known preservation results of universal algebra, namely that
equational validity is preserved under the formation of subalgebras, homomorphic
images and products of algebras.
Proposition 5.53 Let œÑ be a modal similarity type, œÜ a œÑ -formula and F a œÑ -frame.
Then
(i) If G is a bounded morphic image of F, then G  œÜ if F  œÜ.
(ii) If G is a generated subframe of F, then G  œÜ if F  œÜ.
(iii) If F is the disjoint union of a family {Fi | i ‚àà I}, then F  œÜ if for every
i ‚àà I, Fi  œÜ.
(iv) If ue F  œÜ, then F  œÜ.
Proof. We only prove the Ô¨Årst part of the proposition, leaving the other parts as
exercises for the reader.
Assume that F
G, and F  œÜ. By Proposition 5.24, we have F+ |= œÜ ‚âà ,
and by Theorem 5.47, G+ is a subalgebra of F+ . So by the fact that equational
validity is preserved under taking subalgebras, we obtain that œÜ ‚âà  holds in G+ .
But then Proposition 5.24 implies that G  œÜ.300
5 Algebras and General Frames
Our second example is a simple proof of the Goldblatt-Thomason Theorem, which
gives a precise structural characterization of the Ô¨Årst-order deÔ¨Ånable classes of
frames which are modally deÔ¨Ånable. We discussed this result in Chapter 3, and
gave a proof which drew on the tools of Ô¨Årst-order model theory (see Theorem 3.19
in Section 3.8). As we will now see, there is also an algebraic way of viewing the
theorem: it is a more or less immediate corollary of Birkhoff‚Äôs Theorem (see Ap-
pendix B) identifying equational classes and varieties. The version we prove here
is slightly stronger than Theorem 3.19, since it applies to any class of frames that
is closed under taking ultrapowers.
Theorem 5.54 (Goldblatt-Thomason Theorem) Let œÑ be a modal similarity type,
and let K be a class of œÑ -frames that is closed under taking ultrapowers. Then K
is modally deÔ¨Ånable if and only if it is closed under the formation of bounded
morphic images, generated subframes, and disjoint unions, and reÔ¨Çects ultraÔ¨Ålter
extensions.
Proof. The left to right direction is an immediate corollary of the previous propo-
sition. For the right to left direction, let K be any class of frames satisfying the
closure conditions given in the theorem. It sufÔ¨Åces to show that any frame F vali-
dating the modal theory of K is itself a member of K.
Let F be such a frame. It is not difÔ¨Åcult to show that Proposition 5.24 implies
that F+ is a model for the equational theory of the class CmK. It follows by
Birkhoff‚Äôs Theorem (identifying varieties and equational classes) that F+ is in the
variety generated by CmK, so F+ is in HSPCmK. In other words, there is a
family (Gi )i‚ààI of frames in K, and there are boolean algebras with operators A
and B such that

(i) B is the product i‚ààI G+
i of the complex algebras of the Gi ,
(ii) A is a subalgebra of B, and
(iii) F+ is a homomorphic image of A.
By Theorem 5.48, B is isomorphic to the complex algebra of the disjoint union G
of the family (Gi )i‚ààI :
+

&
+
‚àºG =
B=
Gi
.
i‚ààI
As K is closed under taking disjoint unions, G is in K.
Now we have the following picture: F+  A  G+ . By Theorem 5.47 it
follows that
(F+ )+  A+  (G+ )+ .
Since K is closed under ultrapowers, Theorem 3.17 implies that (G+ )+ = ue G is5.4 Duality Theory
301
in K. As K is closed under the formation of bounded morphic images and generated
subframes, it follows that A+ and ue F = (F+ )+ (in that order) are in K. But then
F itself is also a member of K, since K reÔ¨Çects ultraÔ¨Ålter extensions.
For our third example, we return to the concept of canonicity. We will prove an
important result and mention an intriguing open problem, both having to do with
the relation between canonical varieties and Ô¨Årst-order deÔ¨Ånable classes of frames.
Both the result and the open problem were mentioned in Chapter 4 (see Theo-
rem 4.50 and the surrounding discussion), albeit in a slightly weaker form. To link
the earlier statements with the versions discussed here, simply observe that any
elementary class of frames is closed under the formation of ultraproducts.
First we need the following deÔ¨Ånition.
DeÔ¨Ånition 5.55 Let œÑ be modal similarity type, and K be a class of œÑ -frames. The
variety generated by K (notation: VK ) is the class HSPCmK.
Theorem 5.56 Let œÑ be modal similarity type, and K be a class of œÑ -frames which
is closed under ultraproducts. Then the variety VK is canonical.
Proof. Assume that the class K of œÑ -frames is closed under taking ultraproducts.
We will Ô¨Årst prove that the class HSCmK is canonical. Let A be an element of
this class; that is, assume that there is a frame F in K and an algebra B such that
A  B  F+ .
It follows from Theorem 5.47 that
EmA  EmB  EmF+ = (ue F)+ .
(5.27)
From Theorem 3.17 we know that ue F is the bounded morphic image of some
ultrapower G of F. Note that G is in K, by assumption. Now Theorem 5.47 gives
(ue F)+  G+ .
(5.28)
Since G+ is in CmK, (5.27) and (5.28) together imply that EmA is in HSCmK.
Hence this class is canonical.
To prove that the variety generated by K is canonical, we need an additional fact.
Recall that according to Proposition 3.63, the ultrapower of a disjoint union can be
obtained as a bounded morphic image of a disjoint union of ultraproducts.
Now assume that A is in VK = HSPCmK. In other words, assume there is a
family {Fi | i ‚àà I} of frames in K and an algebra B such that
'
AB
F+
i .
i‚ààI

To prove that EmA is in VK , it sufÔ¨Åces to show that Em( i‚ààI F+
i ) is in SPCmK302
5 Algebras and General Frames
‚Äì the remainder of the proof is as before. Let F be the frame

Theorem 5.48, F+ ‚àº
= i‚ààI F+
i . Hence, by Theorem 5.47:


'
+
‚àº
Em
F
= ((F+ )+ )+ = (ue F)+ .
i‚ààI Fi , then by
i
(5.29)
i‚ààI
By Theorem 3.17, there is an ultrapower G of F such that G
ue F. Now we
apply Proposition 3.63, yielding a frame H such that (i) H is a disjoint union of
ultraproducts of frames in K and (ii) H
G. Putting these observations together
we have ue F  G  H. Hence, by Theorem 5.47:
(ue F)+  G+  H+ .
(5.30)
Note that H is a disjoint union of frames in K, since K is closed under taking
ultraproducts. This implies that H+ is in PCmK. But then it follows from (5.29)

and (5.30) that Em( i‚ààI F+
i ) is in SPCmK, which is what we needed.
Example 5.57 Consider the modal similarity type {‚ó¶, ‚äó, 1‚Äô} of arrow logic, where
‚ó¶ is binary, ‚äó is unary and 1‚Äô is a constant. The standard interpretation of this
language is given in terms of the squares (cf. Example 1.24). Recall that the square
SU = (W, C, R, I) is deÔ¨Åned as follows:
W=U √ó U,
C((u, v), (w, x), (y, z))iffu = w and v = z and x = y,
R((u, v), (w, x))iffu = x and v = w,
I(u, v)iffu = v.
It may be shown that the class SQ of (isomorphic copies of) squares is Ô¨Årst-order
deÔ¨Ånable in the frame language with predicates C, R and I. Therefore, Theo-
rem 5.56 implies that the variety generated by SQ is canonical. This variety is well
known in the literature on algebraic logic as the variety RRA of Representable Re-
lation Algebras. See Exercise 5.4.5.
Rephrased in terminology from modal logic, Theorem 5.56 boils down to the fol-
lowing result.
Corollary 5.58 Let œÑ be a modal similarity type, and K be a class of œÑ -frames
which is closed under ultraproducts. Then the modal theory of K is a canonical
logic.
We conclude the section with the foremost open problem in this area: does the
converse of Theorem 5.56 holds as well?5.5 General Frames
303
Open Problem 2 Let œÑ be modal similarity type, and V a canonical variety of
boolean algebras with œÑ -operators. Is there a class K of œÑ -frames, closed under
taking ultraproducts, such that V is generated by K?
Exercises for Section 5.4
5.4.1 Consider a countably inÔ¨Ånite collection (A i )i‚ààI of Ô¨Ånite algebras that are non-trivial,
that is, of size at least 2.

(a) Show that the product i‚ààI Ai has uncountably many ultraÔ¨Ålters.
(b) Show that the ultraÔ¨Ålter frame of a Ô¨Ånite algebra is Ô¨Ånite, and that hence, the disjoint
union i‚ààI (Ai)+ is countable.

‚àº
(c) Conclude that
i‚ààI Ai + =
i‚ààI (Ai )+ .
5.4.2 Prove Proposition 5.52(i), (iii) and (vi). Prove (iii) Ô¨Årst for unary operators; for the
general case, see the proof of the J√≥nsson-Tarski Theorem for inspiration.
5.4.3 Prove or disprove the following propositions:
(a) For any two boolean algebras with operators A and B: A + ‚àº
= B.
= B+ only if A ‚àº
(Hint: Ô¨Årst consider the question for plain boolean algebras, thinking of specimens
like the ones occurring in Exercise 5.2.3 and Exercise 5.3.3.)
(b) For any two frames F and G: F + ‚àº
= G.
= G+ only if F ‚àº
5.4.4 Consider the frames F = (X, R) and G = (Y, S) given by
X=N
R = {(x, y) ‚àà X √ó X | x = y}
Y = N ‚à™ {‚àû}
S = {(x, y) ‚àà Y √ó Y | x = y} ‚à™ {(‚àû, ‚àû)}.
(a) Show that F is not a bounded morphic image of G.
(b) Show that on the other hand, F + can be embedded in G + (that is, deÔ¨Åne an injective
homomorphism Œ∑: F +  G+ ).
5.4.5 Show that the class SQ of (isomorphic copies of) square arrow frames is Ô¨Årst-order
deÔ¨Ånable. See Example 5.57.
5.4.6 Show that the embedding Œ∑ used in the proof of Theorem 5.48 is an isomorphism.
5.5 General Frames
Although the algebraic semantics for modal logic has the nice property that there
is a fundamental completeness result (Theorem 5.27), many modal logicians still
prefer frame-based semantics, either because they Ô¨Ånd it more intuitive, or because
frames are the structures in which they take an (application-driven) interest. In
this (and the following) section we will discuss an intermediate semantics which
in a sense uniÔ¨Åes relational and algebraic semantics. As we will see below, a
general frame is an ordinary frame and a boolean algebra with operators rolled
into one. The nice thing about general frames is that we can prove a fundamental304
5 Algebras and General Frames
completeness theorem for modal logic and general frames ‚Äì and modal semantics
based on general frames is almost as intuitive as the familiar relational semantics.
Although we have already met general frames (we brieÔ¨Çy introduced them in
Section 1.4, and used them when we studied frame incompleteness in Section 4.4),
we have not yet discussed them systematically. We will now put that right. We will
reintroduce them, discuss some important classes of general frames, pin down the
relationship between general frames, frames and boolean algebras with operators,
and brieÔ¨Çy discuss them from a topological perspective.
Here is how general frames are deÔ¨Åned for an arbitrary similarity type œÑ :
DeÔ¨Ånition 5.59 (General Frame) Let œÑ be a modal similarity type. A general
œÑ -frame is a pair g = (F, A) such that F = (W, R)‚ààœÑ is a œÑ -frame, and A is
(the carrier of) a complex algebra over F. That is, A is a non-empty collection of
subsets of W which is closed under the boolean operations and under the modal
operation mR (X1 , . . . , Xn ) for each  ‚àà œÑ .
A valuation V on F is called admissible for g if for each proposition letter p,
V (p) is an admissible subset of W , that is, an element of A. A model based on
a general frame is a triple (F, A, V ) where (F, A) is a general frame and V is an
admissible valuation for (F, A). Truth in such a model is deÔ¨Åned in the obvious
way, that is, as if we were talking about the model (F, V ).
Convention 5.60 To avoid confusion, in this section we will use the term ‚ÄòKripke
frame‚Äô when talking about (ordinary) frames.
It is easy to verify that the closure conditions mentioned in DeÔ¨Ånition 5.59 en-
sure that if V is an admissible valuation on a general frame, then the set V (œÜ) is
admissible for every formula œÜ. Conversely, every model gives rise to a general
frame.
Example 5.61 Given a model M = (F, V ), it is obvious that the collection
AM = {V (œÜ) | œÜ a modal formula }
is closed under the boolean operations and under each mR . Hence the structure
(F, AM) is a general frame.
Note that we can apply this technique to the canonical model McŒõ of any normal
modal logic Œõ. It follows from the Truth Lemma (Lemma 4.21) that the resulting
structure (FcŒõ , AMcŒõ ) is isomorphic to the canonical general frame fcŒõ which is
deÔ¨Åned as
fc = (Fc , {œÜ | œÜ a formula }),
(5.31)
Œõ
Œõ
where œÜ is the set of maximal consistent sets Œì such that œÜ ‚àà Œì .uu
5.5 General Frames
..
.uv2
..
..
. >v
.
u1
*
vu
- vu0
*
ju
w
-u
w0
ju
..
..
1
. ~w
.
u
.. w2
.
305
ju
* x
Fig. 5.1.
The notions of validity and semantic consequence of classes of general frames are
deÔ¨Åned in the expected way:
DeÔ¨Ånition 5.62 Let g be a general frame. A formula œÜ is valid on g if œÜ holds in
every state of g under every admissible valuation V ; a similar deÔ¨Ånition holds for
sets of formulas and classes of general frames.
For a set of formulas, in particular for a normal modal logic Œõ, a general frame
is called a Œõ-frame if Œõ is valid on the frame.
Now, let K be a class of general frames, Œ£ a set of formulas and œÜ a formula.
We say that œÜ is a semantic consequence of Œ£ over K if for every general frame
g in K, every admissible valuation V on g and every state s in g, we have that
(g, V ), s  Œ£ implies (g, V ), s  œÜ.
The following example shows that a formula may be valid on a general frame,
while it is not valid on the underlying Kripke frame:
Example 5.63 Consider the following Kripke frame C = (C, R). Its set C of
states is given as C = {u, v, w, x} ‚à™ {vn , wn | n ‚àà œâ}, while the accessibility
relation R is deÔ¨Åned as follows: Ruv, Ruw, Rvvn and Rwwn (for all n), Rvn x
and Rwn x (for all n), and Rxx; see Figure 5.1.
We leave it as an exercise to verify that the pair c = (C, F ) is a general frame,
where F is the collection of all Ô¨Ånite and co-Ô¨Ånite subsets of C. We claim that
c  32p ‚Üí 23p, while C  32p ‚Üí 23p. Let us Ô¨Årst prove the latter: consider
the valuation V given by V (p) = {vn | n ‚àà N}. Now, from (C, V ), v  2p we
derive (C, V ), u  32p, but (C, V ), u  23p, as (C, V ), w  3p.
To prove that c  32p ‚Üí 23p, it sufÔ¨Åces to look at u (why?). Suppose that for
some admissible valuation V , 32p holds at u. Without loss of generality we may
assume that (c, V ), v  2p, so p holds at all vi . Then V (p) is not Ô¨Ånite and since306
5 Algebras and General Frames
V (p) must be admissible, it follows from the deÔ¨Ånition of F that V (p) is co-Ô¨Ånite.
Hence there are (co-Ô¨Ånitely many) wi with (c, V ), wi  p. But then 3p holds at w
and thus 23p at u.
And now for the promised general completeness result: general frames share with
boolean algebras with operators the property of providing an adequate semantics
for all normal modal logics.
Theorem 5.64 Let Œõ be a normal modal logic. Then Œõ is sound and strongly
complete with respect to the class of general Œõ-frames.
Proof. As usual, the soundness proof is rather trivial and is left to the reader.
For completeness, consider the canonical frame fcŒõ as deÔ¨Åned in (5.31) in Ex-
ample 5.61. It is easy to verify that fcŒõ  Œõ (see Exercise 5.5.4). Now assume
that Œ£ Œõ œÜ. It follows that the set Œ£ ‚à™ {¬¨œÜ} is Œõ-consistent. By deÔ¨Ånition
of the canonical frame and the Truth Lemma, there is a state s of fcŒõ such that
(fcŒõ , V c ), s  Œ£ ‚à™ {¬¨œÜ}. Since the canonical valuation V c is admissible, this
means that we have falsiÔ¨Åed the claim that œÜ is a semantical consequence of Œ£ on
the class of general Œõ-frames.
Properties of general frames
The following deÔ¨Ånition singles out some important properties and classes of gen-
eral frames.
DeÔ¨Ånition 5.65 (Properties of General Frames) Let œÑ be a modal similarity
type, and assume that g = (F, A) is a general œÑ -frame, with F being the Kripke
œÑ -frame (W, R)‚ààœÑ . Then g is called
differentiated if for all s, t in W :
s = t iff ‚àÄa ‚àà A (s ‚àà a ‚áê‚áí t ‚àà a),
tight if for all  ‚àà œÑ (assume that œÅ() = n) and for all s, s1 , . . . , sn in W :

Rss1 . . . sn iff ‚àÄa1 , . . . , an ‚àà A (( i si ‚àà ai ) ‚áí s ‚àà mR (a1 , . . . , an )),

compact if A0 = ‚àÖ for every subset A0 of A which has the Ô¨Ånite intersection
property,
reÔ¨Åned if g is differentiated and tight,
descriptive if g is reÔ¨Åned and compact,
full if every subset of W is admissible, that is, if A = P(W ), and
discrete if every singleton is admissible, that is, if {s} ‚àà A for every s ‚àà W .5.5 General Frames
307
Convention 5.66 When discussing general frames we will usually drop the ad-
jective ‚Äògeneral‚Äô when it is clear that we are talking about general frames and not
about Kripke frames. For instance, ‚Äòa descriptive frame‚Äô is short for: ‚Äòa descriptive
general frame.‚Äô
Let us try to develop some intuitions concerning the notions deÔ¨Åned above by con-
sidering a number of examples.
The best way to understand the concept of differentiation is by observing that
a general frame is differentiated if and only if for every distinct pair of states s
and t there is an admissible set a witnessing this difference in the sense that s ‚àà
a, t ‚àà a. Likewise (now we conÔ¨Åne ourselves to the basic similarity type), a
general frame is tight if and only if for every state s and every state t which is
not accessible from s, there is an admissible set a witnessing this in the sense that
t ‚àà a, s ‚àà mR3 (a). Thus both differentiation and tightness are an indication that
there are many admissible sets. On the other hand, compactness means that there
are a multitude of states, the basic intuition being as follows. Consider a collection
A0 of admissible sets; if A0 is not Ô¨Ånitely contradictory (in the sense that there is a
state in the intersection of any Ô¨Ånite subcollection of A0 ), then there is some state
belonging to every set in A0 . The other deÔ¨Ånitions speak for themselves.
The notions of differentiation and tightness are independent, as is shown in the
following example:
Example 5.67 Consider the structure h = (N, ‚â°2 , A), where N is the set of natural
numbers, m ‚â°2 n iff m ‚àí n is even, and A is the set {‚àÖ, N, E, O}, such that E and
O are the sets of even and odd numbers, respectively. We leave it to the reader to
check that this is indeed a general frame, and that h is tight but not differentiated;
see Exercise 5.5.6.
Conversely, let g be the structure (W, >, B) where W is the set N ‚à™ {œâ} and B
is given by
B = {b ‚äÜ W | b is Ô¨Ånite and œâ ‚àà b} ‚à™ {b ‚äÜ W | b is co-Ô¨Ånite and œâ ‚àà b}.
It is easy to see that m> (b) is co-Ô¨Ånite and œâ ‚àà m> (b) for every non-empty b ‚äÜ W .
From this observation it is easy to deduce that g is a general frame. It should also
be obvious that g is differentiated: for any two non-identical states s and t, at least
one, say s, belongs to N; but then the singleton {s} is admissible, and s ‚àà {s}, but
t ‚àà {s}.
Now suppose that g is tight. Consider an arbitrary co-Ô¨Ånite set a such that œâ ‚àà a.
Then a = ‚àÖ, whence the set m> (a) is co-Ô¨Ånite as well, and hence, œâ ‚àà m> (a).
But since a was arbitrary, by tightness we may infer that œâ > œâ, which is clearly
not the case. It follows that g is not tight.5 Algebras and General Frames
308
An example of a reÔ¨Åned frame is given by the structure c of Example 5.63. In fact,
its reÔ¨Ånedness follows from the fact that c is discrete.
Proposition 5.68 Discrete frames are reÔ¨Åned.
Proof. We only treat tightness and conÔ¨Åne ourselves to the basic similarity type.
Let g = (W, R, A) be a discrete frame. Assume that the state t is not a successor
of the state s. Then s ‚àà mR ({t}), while obviously t ‚àà {t}. By deÔ¨Ånition of
discreteness, {t} is admissible.
The converse of Proposition 5.68 does not hold. Examples of reÔ¨Åned frames that
are not discrete are provided by canonical general frames, cf. Proposition 5.69
below.
Of the classes mentioned in DeÔ¨Ånition 5.65, the class of descriptive frames is
the most important one. One reason for this is that in a certain (category-theoretic)
sense, descriptive general frames and boolean algebras with operators are the same
mathematical objects. For instance, below we will see that every boolean alge-
bra with operators can be represented as a descriptive general frame. Let us Ô¨Årst
consider a particular example of this.
Proposition 5.69 Let œÑ be a modal similarity type, and Œõ a normal modal œÑ -logic.
Then fcŒõ is a descriptive general frame.
Proof. To show that fcŒõ is differentiated, assume that Œì and Œî are distinct maximal
Œõ-consistent sets of formulas. In other words, there is a formula Œ≥ such that Œ≥ ‚àà Œì ,
Œ≥ ‚àà Œî. But then Œì ‚àà Œ≥
, while Œî ‚àà Œ≥
. It is almost as easy to prove tightness ‚Äì
simply use the deÔ¨Ånition of the canonical accessibility relation.
For compactness, assume that S := {
œÉ | œÉ ‚àà Œ£} is a collection of admissible
sets and that it has the Ô¨Ånite intersection property. It follows that Œ£ is consistent, for
suppose otherwise; then there are œÉ1 , . . . , œÉn ‚àà Œ£ such that Œõ (œÉ1 ‚àß ¬∑ ¬∑ ¬∑ ‚àß œÉn ) ‚Üí
‚ä•. This implies that there is no maximal Œõ-consistent Œì such that œÉi ‚àà Œì for all
i ‚â§ n. But then œÉ
1 ‚à© ¬∑ ¬∑ ¬∑ ‚à© œÉ
n = ‚àÖ, which contradicts our assumption on S.
But if Œ£ is consistent, it can be extended to a maximal Œõ-consistent set Œ£+ . It

is almost immediate that Œ£+ ‚àà {
œÉ | œÉ ‚àà Œ£}; this obviously bears witness to the
fact that S has a non-empty intersection.
The following example shows that the condition of compactness really adds to the
deÔ¨Ånition of a descriptive frame.
Example 5.70 In this example we will exhibit a general frame h = (W, R, A) that
is reÔ¨Åned but not descriptive. To deÔ¨Åne W , let S and T denote the sets S = {sn |
n ‚àà N} and T = {tn | n ‚àà N}, respectively. Now, put
W
= {r, ‚àû} ‚à™ S ‚à™ T,5.5 General Frames
309
R = {(r, ‚àû)} ‚à™ {(r, sn ), (sn , sn ), (sn , tn ) | n ‚àà N}.
The set A is deÔ¨Åned as follows: a subset a of W is admissible if either a ‚à© T is
Ô¨Ånite and ‚àû ‚àà a, or a ‚à© T is co-Ô¨Ånite and ‚àû ‚àà a.
We will not give a detailed proof that this h is indeed a general frame. We will
only observe here that for all a ‚àà A, the set mR (a) satisÔ¨Åes mR (a) ‚à© T = ‚àÖ and
‚àû ‚àà mR (a), whence it is admissible as well.
To show that h is reÔ¨Åned, we Ô¨Årst consider differentiation. Let v and w be
different states of W . One of them, say v, must be different from ‚àû. But then
the set {v} is admissible, and w ‚àà {v}. For tightness, assume that Rvw does not
hold, for some states v and w. We will deÔ¨Åne an admissible set a such that w ‚àà a
while v ‚àà mR (a). Now, if w = ‚àû, then the set a = {w} sufÔ¨Åces, so assume that
w = ‚àû. Then clearly, v = r. Again distinguish cases.
First assume that v ‚àà {‚àû} ‚à™ T ; in this case, take a = {‚àû} ‚à™ T , then mR (a) =
{r} ‚à™ S, so indeed, v ‚àà mR (a). The only case that is left is where w = ‚àû and
v = sn for some natural number n. Now consider the set a = ({‚àû} ‚à™ T ) \ {tn }.
Since tn is the only successor of sn , this gives sn ‚àà mR (a).
Finally, we have to show that h is not compact. But this is rather easy; consider
for instance the set of co-Ô¨Ånite subsets of S. This set has the Ô¨Ånite intersection
property, but there is no state in W that belongs to all co-Ô¨Ånite subsets of S.
Operations on general frames
In this subsection we look at the relation between ordinary frames, general frames
and boolean algebras with operators. First, however, we adapt familiar notions
from the theory of Kripke frames to the setting of general frames.
DeÔ¨Ånition 5.71 Let g = (F, A) and g = (F , A ) be two general frames. Assume
 )

that F = (W, R)‚ààœÑ and F = (W  , R
‚ààœÑ . A map Œ∏ : W ‚Üí W is a bounded
morphism between g and g (notation: Œ∏ : g ‚Üí g ) if Œ∏ is a bounded morphism
between the frames F and F such that
Œ∏ ‚àí1 (a ) ‚àà A for all a ‚àà A .
(5.32)
Such a bounded morphism Œ∏ is called an embedding if it is injective and satisÔ¨Åes
for all a ‚àà A there is an a ‚àà A such that Œ∏[a] = Œ∏[W ] ‚à© a .
(5.33)
Here Œ∏[a] is deÔ¨Åned as the set {Œ∏(s) | s ‚àà a}. We write g  g to denote that g
can be embedded in g .
The general frame g is called a bounded morphic image of g (notation: g
g )

if there is a surjective bounded morphism from g to g . Two general frames g and
g are isomorphic if there is a surjective embedding Œ∏ : g ‚Üí g .
Assume that for all i ‚àà I, gi is the general frame (Fi , Ai ); we deÔ¨Åne the disjoint310
5 Algebras and General Frames
union i gi of this family (gi )i‚ààI as the general frame ( i Fi , A) where A consists
of those subsets a ‚äÜ i Wi that satisfy a ‚à© Wi ‚àà Ai for all i ‚àà I.
As a special example of an embedding, consider two general frames g = (F, A)
and g = (F , A ) such that F is a generated subframe of F . Then the identity
inclusion Œπ : W ‚Üí W  is a bounded morphism from F into F , but Œπ is only a
bounded morphism from g to g if a ‚à© W ‚àà A for all a ‚àà A . For Œπ to be an
embedding, condition (5.33) requires that for all a ‚àà A, there is an a ‚àà A such
that a = W ‚à© a ; in other words, every admissible set a ‚àà A must be the ‚ÄòW -part‚Äô
of an admissible set a ‚àà A . Finally, it is not difÔ¨Åcult to see that an isomorphism
between g = (F, A) and g = (F , A ) is just an isomorphism Œ∏ between F and F
such that Œ∏‚àí1 is an isomorphism between the complex algebras with carriers A and
A .
As with Kripke frames, the constructions deÔ¨Åned in DeÔ¨Ånition 5.71 are truth-
preserving. The proof of Proposition 5.72 below is straightforward and left to the
reader.
Proposition 5.72 Let œÑ be a modal similarity type, and œÜ a œÑ -formula.
(i) Let {gi | i ‚àà I} be a family of general frames. Then
every i in I.
(ii) Assume that g  g. Then g  œÜ if g  œÜ.
(iii) Assume that g
g . Then g  œÜ if g  œÜ.
gi  œÜ if gi  œÜ for
Now we deÔ¨Åne a number of operations that enable the construction of general
frames out of Kripke frames or out of BAOs, and conversely. The reader is advised
to recall from earlier sections of this chapter the deÔ¨Ånition of the complex algebra
F+ of a frame F, and the ultraÔ¨Ålter frame A+ of an algebra A.
DeÔ¨Ånition 5.73 Let œÑ be a modal similarity type, and let g = (W, R, A)‚ààœÑ be
a general œÑ -frame. The underlying œÑ -frame of g is given by g = (W, R)‚ààœÑ . It
follows from the closure conditions on A that the structure
g‚àó = (A, ‚à™, ‚àí, ‚àÖ, mR )‚ààœÑ
is a boolean algebra with œÑ -operators; this algebra is called the underlying boolean
algebra with œÑ -operators of g.
Conversely, the full œÑ -frame of a œÑ -frame F = (W, R)‚ààœÑ is given by
F = (F, P(W )).
And Ô¨Ånally, the general ultraÔ¨Ålter frame of a BAO A = (A, +, ‚àí, 0, f)‚ààœÑ is
deÔ¨Åned as
a | a ‚àà A}),
A‚àó = (A+ , {5.5 General Frames
311
where 
a ‚äÜ Uf A is deÔ¨Åned as the set of ultraÔ¨Ålters u such that a ‚àà u:

a = {u ‚àà Uf A | a ‚àà u}.
There are many obvious connections between the operations (¬∑)+ , (¬∑)+ , (¬∑) , (¬∑) ,
(¬∑)‚àó and (¬∑)‚àó . We list a few of these in the next proposition, and invite the reader to
Ô¨Ånd more.
Proposition 5.74 Let œÑ be a modal similarity type, and let F, g and A be a Kripke
œÑ -frame, a general œÑ -frame and a boolean algebra with œÑ -operators, respectively.
Then
(i) (F ) = F,
(ii) (F )‚àó = F+ ,
(iii) (A‚àó ) = A+ ,
(iv) (g ) = g if and only if g is full.
Next we devote our attention to the relation between BAOs and general frames. The
following theorem is a counterpart of Proposition 5.24 for general frames.
Theorem 5.75 Let œÑ be a modal similarity type, and let g and A be a general
œÑ -frame and a boolean algebra with œÑ -operators, respectively. Then for every œÑ -
formula œÜ:
gœÜiffg‚àó |= œÜ ‚âà ,
A |= œÜ ‚âà iffA‚àó  œÜ.
We omit the relatively easy proof of Theorem 5.75. Note however, that the theorem
actually states something stronger than Proposition 5.24, namely that truth is also
preserved when going from an algebra to its associated general frame. The point is
that we may infer from A |= œÜ ‚âà  that A‚àó  œÜ because on A‚àó only admissible
valuations over the Kripke frame A+ are allowed. The implication ‚Äòif A |= œÜ ‚âà ,
then A+  œÜ‚Äô only holds for canonical formulas œÜ (we will come back to this point
in the next section).
The following theorem substantiates our earlier claim that BAOs and descriptive
general frames are really the same mathematical objects.
Theorem 5.76 Let œÑ be a similarity type, and let g and A be a general œÑ -frame
and a boolean algebra with œÑ -operators, respectively. Then
(i) A‚àó is a descriptive general frame,
(ii) (A‚àó )‚àó ‚àº
= A,
‚àó
‚àº
(iii) (g )‚àó = g if and only if g is descriptive.5 Algebras and General Frames
312
Proof. For notational convenience, we assume that œÑ has only one modal operator
, say, of arity n.
(i) This part of the proof is more or less the same as the proof that every canonical
general frame is descriptive (see Proposition 5.69).
(ii) Let A = (A, +, ‚àí, f ) be a boolean algebra with operator. Then A‚àó is a
general frame whose underlying Kripke frame is of the form (Uf A, Qf ), while the
admissible sets are of the form 
a, where a ‚àà A. Hence, the carrier of the algebra
(A‚àó )‚àó consists of all elements 
a, and its operator is of the form mQf . (For the
deÔ¨Ånition of Q and m we refer to DeÔ¨Ånitions 5.40 and 5.21, respectively). Clearly,
it sufÔ¨Åces to show that the map r : A ‚Üí P(Uf A) given by
r : a ‚Üí 
a
is a BAO-isomorphism. But it follows from the proof of Theorem 5.43 that r is an
injective homomorphism, and surjectivity is immediate by the deÔ¨Ånitions.
(iii) The ‚Äòonly if‚Äô direction follows immediately from item (i). For the other
direction, assume that g = (W, R, A) is a descriptive frame. For each state s in W ,
deÔ¨Åne Us to be the set of admissible sets a such that s ‚àà a. We claim that these
sets constitute precisely the set of ultraÔ¨Ålters of g‚àó , that is,
{Us | s ‚àà W } = Uf g‚àó .
(5.34)
The inclusion ‚Äò‚äÜ‚Äô is obvious. For the other inclusion, let u be an arbitrary ultra-
Ô¨Ålter of the BAO g‚àó , or, to be more precise, of the boolean algebra (A, ‚à™, ‚àí, ‚àÖ).
Since ultraÔ¨Ålters are closed under intersection and never contain the empty set, it
follows that u has the Ô¨Ånite intersection property. By compactness, there is a state

s such that s ‚àà u. This implies u ‚äÜ Us ; but since Us is also an ultraÔ¨Ålter of
(A, ‚à™, ‚àí, ‚àÖ), we obtain that u = Us . This proves (5.34).
Now consider the general frame (g‚àó )‚àó . Since its states are the ultraÔ¨Ålters of g‚àó ,
(5.34) implies that the map Œ∏ given by Œ∏ : s ‚Üí Us is a map from the universe W
of g onto the universe Uf g‚àó of (g‚àó )‚àó . Injectivity follows from differentiation of g.
Hence, the map Œ∏ : W ‚Üí Uf g‚àó is a bijection.
We will show that Œ∏ is an isomorphism between general frames. Let R denote
the accessibility relation of  in (g‚àó )‚àó . Unraveling the deÔ¨Ånition of R , we Ô¨Ånd
that for ultraÔ¨Ålters u, u1 , . . . , un we have
(
)
R uu1 . . . un iff ‚àÄa1 , . . . , an ‚àà A
ai ‚àà ui ‚áí mR (a1 , . . . , an ) ‚àà u . (5.35)
Now let s, s1 , . . . , sn be arbitrary points of g. By tightness, we have
Rss1 . . . sn iff
‚àÄa1 , . . . , an ‚àà A
(
)
si ‚àà ai ‚áí s ‚àà mR (a1 , . . . , an ) .
(5.36)
But by deÔ¨Ånition of Œ∏, we have t ‚àà a iff a ‚àà Œ∏(t), for all t ‚àà W . Hence, from5.5 General Frames
313
(5.36) it follows that
Rss1 . . . sn iff
‚àÄa1 , . . . , an ‚àà A
(
)
ai ‚àà Œ∏(si ) ‚áí mR (a1 , . . . , an ) ‚àà Œ∏(s) . (5.37)
But then we may infer from (5.35) and (5.37) that
Rss1 . . . sn iff R Œ∏(s)Œ∏(s1 ) . . . Œ∏(sn ).
In other words, Œ∏ is an isomorphism between the underlying Kripke frames of g
and (g‚àó )‚àó .
Finally, consider an arbitrary admissible set a of g. We will show that Œ∏(a) is
an admissible set of (g‚àó )‚àó . By deÔ¨Ånition of the operation (¬∑)‚àó , a is a member of
the carrier of g‚àó ; hence by deÔ¨Ånition of the operation (¬∑)‚àó , the set 
a := {u ‚àà
Uf (g‚àó ) | a ‚àà u} is an admissible set of (g‚àó )‚àó . We leave it to the reader to verify
that 
a = Œ∏(a) and hence, that a = Œ∏‚àí1 [
a].
As an immediate corollary of Theorems 5.75 and 5.76 we have that every general
frame has an equivalent descriptive general frame.
Theorem 5.77 Let g be a general œÑ -frame for some similarity type œÑ . Then (g‚àó )‚àó
is a descriptive general frame equivalent to g; that is, for every œÑ -formula œÜ:
g  œÜ iff (g‚àó )‚àó  œÜ.
Just as in the case of the basic duality between Kripke frames and BAOs, we can
extend the constructions of DeÔ¨Ånition 5.73 to morphisms between algebras or be-
tween general frames.
DeÔ¨Ånition 5.78 Let œÑ be a modal similarity type, and let g = (W , R, A)‚ààœÑ
 , A )
and g = (W  , R
‚ààœÑ be two general œÑ -frames. Given a bounded morphism

Œ∏ : W ‚Üí W , its dual Œ∏‚àó : A ‚Üí A is deÔ¨Åned by
Œ∏ ‚àó (a ) = Œ∏ ‚àí1 [a ] (= {s ‚àà W | Œ∏s ‚àà a }).
Now let A = (A, +, ‚àí, 0, f )‚ààœÑ and A = (A , + , ‚àí , 0 , f )‚ààœÑ be two boolean
algebras with œÑ -operators, and Œ∑ a map from A to A . Then we deÔ¨Åne the dual Œ∑‚àó
of Œ∑ to be the following map from Uf A to P(A):
Œ∑‚àó (u ) = Œ∑ ‚àí1 [u ] (= {a ‚àà A | Œ∑a ‚àà u }).
For the maps deÔ¨Åned in DeÔ¨Ånition 5.78 we can prove results analogous to Propo-
sitions 5.51 and 5.52.
Proposition 5.79 Let œÑ be a modal similarity type, and let g and h be two general
œÑ -frames, and Œ∏ a map from the universe of g to the universe of h. Then314
5 Algebras and General Frames
(i) If Œ∏ is a bounded morphism, then Œ∏‚àó is a BAO-homomorphism from h‚àó to
g‚àó .
(ii) If Œ∏ : g  h, then Œ∏‚àó : h‚àó
g‚àó .
(iii) If Œ∏ : g
h, then Œ∏‚àó : h‚àó  g‚àó .
Proposition 5.80 Let œÑ be a modal similarity type, and let A and B be two boolean
algebras with œÑ -operators, and Œ∑ a map from A to B. Then
(i) If Œ∑ is a BAO-homomorphism, then Œ∑‚àó is a bounded morphism from B‚àó to
A‚àó .
(ii) If Œ∑ : A  B, then Œ∑‚àó : B‚àó
A‚àó .
(iii) If Œ∑ : A
B, then Œ∑‚àó : B‚àó  A‚àó .
The proofs of Propositions 5.79 and 5.80 are similar to the proofs of Proposi-
tions 5.51 and 5.52. We leave it as an exercise to check where conditions (5.32)
and (5.33) are needed in the proof of Proposition 5.79; see Exercise 5.5.8.
By combining Theorem 5.76 and Propositions 5.79 and 5.80 together, we add
further support to our claim that boolean algebras with operators and descriptive
general frames are really equivalent objects.
Theorem 5.81 Let œÑ be a modal similarity type, and let g and h be two descriptive
general frames, and A and B two boolean algebras with œÑ -operators. Then
(i) g  h iff h‚àó
g‚àó ,
‚àó
(ii) g
h iff h  g‚àó ,
(iii) A  B iff B‚àó
A‚àó ,
(iv) A
B iff B‚àó  A‚àó .
For disjoint unions we cannot obtain an equivalence with a simple algebraic oper-
ation in the spirit of Theorem 5.81. The reason for this is that the disjoint union
of an inÔ¨Ånite family of frames can never be descriptive itself. This does not cast
a shadow on the duality between descriptive general frames and BAOs, it simply
indicates that the disjoint union of descriptive frames as we deÔ¨Åned it in DeÔ¨Åni-
tion 5.71, is not the proper categorical notion of a sum. For that one has to take
the descriptive union (( i gi )‚àó )‚àó of a family (gi )i‚ààI of descriptive frames; see
Exercise 5.5.10.
Topology
The reader familiar with topology will have realized that we are drawing on a
number of topological concepts. Examples are the notions of compactness and
of differentiation (the latter being very similar to topological separation axioms).
Furthermore, given a general frame g = (W, R, A) for the basic similarity type,5.5 General Frames
315
one can consider A as a base for a topology TA . The general frame g is descriptive
iff (W, TA ) is a boolean space with A as the set of clopens, and R is a point-closed
relation; that is, R[s] (deÔ¨Åned as {t ‚àà W | Rst}) is closed for every s in W .
Indeed the whole theory of (descriptive) general frames is permeated with topo-
logical concepts, and an entire chapter could be devoted to the topic. We will
restrict ourselves to a brief discussion of closed sets.
DeÔ¨Ånition 5.82 Let g = (F, A) be a general frame. A subset c of the universe is
called closed if it is the intersection of a (possibly inÔ¨Ånite) collection of admissible
sets, or equivalently, if

c = {a ‚àà A | c ‚äÜ a}.
By way of example, consider the canonical general frame fcŒõ of any normal modal
logic Œõ. Here, an admissible set a is of the form œÜ for some formula œÜ. We could
also say that a represents the formula œÜ, since by the Truth Lemma, a consists of
those states s such that œÜ is true at s. Likewise, a closed set c, being the intersection
of a family {
œÉ | œÉ ‚àà Œ£}, represents the set of formulas Œ£ in fcŒõ . For, we have that
(every formula from) Œ£ holds at a state s iff s ‚àà c.
Proposition 5.83 Let g be a descriptive general frame. Then
(i) Every singleton is closed.
(ii) The collection of closed sets is closed under Ô¨Ånite unions and arbitrary
intersections.
(iii) If c is a closed set, then so is the set R3 [c] (deÔ¨Åned as R3 [c] = {t | ‚àÉs ‚àà
c R3 st}), for every diamond 3.
(iv) For every state s and every sequence Œ≤ of diamonds, the set RŒ≤ [s] is closed.
(v) Let C be a family of closed sets with the Ô¨Ånite intersection property. Then
C has a non-empty intersection.
Proof. Assume that g = (F, A) is a descriptive frame, and that F is the frame
(W, R)‚ààœÑ .
(i) We claim that for every point s ‚àà W :

{s} = {a ‚àà A | s ‚àà a}.
In fact, this claim is nothing but a reformulation of the differentiation condition.

(ii) We only sketch the proof for Ô¨Ånite unions. Suppose that ci = {a ‚àà A |
ci ‚äÜ a}, i ‚àà {0, 1}. We leave it to the reader to verify that

c0 ‚à™ c1 = {a0 ‚à™ a1 | c0 ‚äÜ a0 and c1 ‚äÜ a1 }.

(iii) Assume that c is a closed set, that is, that c = {a ‚àà A | c ‚äÜ a}. Let 3 be
a diamond of œÑ ; we abbreviate R3 by R. We will prove that5 Algebras and General Frames
316
R[c] =

{b ‚àà A | c ‚äÜ lR (b)}.
(5.38)
The left to right inclusion in (5.38) is trivial. For the other inclusion, assume that
t ‚àà R[c] while t ‚àà b whenever c ‚äÜ lR (b). We will derive a contradiction from this.
DeÔ¨Åne
A0 = {a ‚àà A | c ‚äÜ a} ‚à™ {mR (b) | t ‚àà b and b ‚àà A}.
We Ô¨Årst prove that
A0 has the Ô¨Ånite intersection property.
(5.39)
For, suppose that there is a Ô¨Ånite subcollection of A0 with an empty intersection.
This means that there are a1 , . . . , am and b1 , . . . , bm in A such that c ‚äÜ ai for all
i ‚â§ m, t ‚àà bj for all j ‚â§ n and
a1 ‚à© ¬∑ ¬∑ ¬∑ ‚à© am ‚à© mR (b1 ) ‚à© ¬∑ ¬∑ ¬∑ ‚à© mR (bn ) = ‚àÖ.
DeÔ¨Åne a = a1 ‚à© ¬∑ ¬∑ ¬∑ ‚à© am and b = b1 ‚à© ¬∑ ¬∑ ¬∑ ‚à© bn , then we have a, b ‚àà A, c ‚äÜ a,
t ‚àà b and
a ‚à© mR (b) = ‚àÖ
(5.40)
since mR (b) ‚äÜ mR (b1 ) ‚à© ¬∑ ¬∑ ¬∑ ‚à© mR (bn ). But (5.40) implies that a ‚äÜ lR (‚àíb),
whence c ‚äÜ lR (‚àíb). It follows from the assumption that t ‚àà ‚àíb. But t ‚àà ‚àíb
contradicts t ‚àà b. This proves (5.39).
Now since g is a compact frame, (5.39) implies that A0 has a non-empty inter-
section, so there is an s in W with

s ‚àà {a | c ‚äÜ a}
(5.41)
and
s‚àà

{mR (b) | t ‚àà b}.
(5.42)
It follows immediately from (5.41) that s ‚àà c. But also, it follows from (5.42) that
Rst. For suppose otherwise: by tightness of g, there would be a b ‚àà A witnessing
¬¨Rst; that is, t ‚àà b while s ‚àà mR (b). But this clearly contradicts (5.42).
(iv) The reader is asked to supply this proof in Exercise 5.5.11.
(v) Let {ci | i ‚àà I} be a collection of closed sets with the Ô¨Ånite intersection
property. By deÔ¨Ånition of closedness, for every i ‚àà I there is a collection {aij |

j ‚àà Ji } such that ci = j‚ààJi aij . It is rather easy to see that the collection
{aij | i ‚àà I, j ‚àà Ji } has the Ô¨Ånite intersection property. Hence, by compactness,

aij = ‚àÖ.
i‚ààI,j‚ààJi
But then5.5 General Frames

ci =
i‚ààI
 
aij =
i‚ààI j‚ààJi

317
aij = ‚àÖ.
i‚ààI,j‚ààJi
The main result in the next section is the Sahlqvist Completeness Theorem, and
closed sets will play a key role in our proof of it. Phrased in terms of general
frames, canonicity is the following question. Given a descriptive general frame
and a formula œÜ that is valid on it, can we infer that œÜ is valid on the underlying
Kripke frame as well? That is, if we know that any admissible valuation makes œÜ
true everywhere in the frame, does the same hold for an arbitrary valuation? The
role of closed sets in the answer to this question is that we will need to consider
closed valuations (that is, valuations that map variables to closed sets); the cru-
cial observation then will be that such closed valuations behave almost as well as
admissible ones.
Exercises for Section 5.5
5.5.1 Which properties of general frames (for example: reÔ¨Ånedness, fullness,. . . ) are pre-
served under taking generated subframes, bounded morphic images or disjoint unions?
5.5.2 Let f = (F, A) be a reÔ¨Åned general frame. Prove that the following are equivalent:
(a) f is compact,
(b) every ultraÔ¨Ålter of A is of the form {a ‚àà A | s ‚àà a} for some state s.
5.5.3 Prove that a full frame is descriptive if and only if it is Ô¨Ånite.
5.5.4 Let fcŒõ be the canonical general frame for the normal modal logic Œõ. Prove that
fcŒõ  Œõ.
5.5.5 Consider the structure c = (C, F ) of Example 5.63.
(a) Prove that c is a general frame if we view C as a frame for the basic modal similarity
type.
(b) What happens if we view C as a standard frame for the basic tense similarity type?
5.5.6 Consider the structure h deÔ¨Åned in Example 5.67.
(a) Show that h is a general frame.
(b) Show that h is tight but not differentiated.
5.5.7 Let œÑ be a similarity type, and let F, f and g be a œÑ Kripke frame and two general
œÑ -frames, respectively. Prove or disprove the following:
(a) (F ) = F,
(b) g  (g ) ,
(c) g‚àó ‚àº
= f.
= f‚àó only if g ‚àº
5.5.8 Prove Propositions 5.79 and 5.80.318
5 Algebras and General Frames
5.5.9 Given a frame F, let F ‚ó¶ denote the subalgebra of F + that is generated by the atoms
of F+ (that is, by the singleton subsets of the frame). Prove the following:
(a) If œÜ is a canonical formula (as deÔ¨Åned after Open Problem 1), then F  œÜ only if
(F‚ó¶ )+  œÜ.
(b) Show that the converse does not always hold.
5.5.10 Show that the disjoint union of an inÔ¨Ånite family of general frames can never be
descriptive, even if those frames are descriptive. Develop and describe the notion of a
descriptive union (( i gi )‚àó )‚àó of a family (gi )i‚ààI of descriptive frames.
5.5.11 Let g be a descriptive general frame. Prove that for every state s and every sequence
Œ≤ of diamonds, the set R Œ≤ [s] is closed. That is, prove item (iv) of Proposition 5.83.
5.6 Persistence
This section is devoted to the notion of persistence, a generalization of the concept
of canonicity. With the help of this notion we will show that all Sahlqvist formulas
are canonical.
DeÔ¨Ånition 5.84 Let œÑ be a similarity type. Let œÜ be a œÑ -formula, and let X denote
a property (or class) of general frames (as deÔ¨Åned in DeÔ¨Ånition 5.65). Then œÜ
is called X-persistent (or persistent with respect to X), if, for every general œÑ -
frame g in X, g  œÜ only if g  œÜ. Persistence with respect to the classes of
reÔ¨Åned, descriptive and discrete frames is called r-persistence, d-persistence and
di-persistence, respectively.
The best way to understand persistence is as follows. Let g = (W, R, A) be a
general frame, and œÜ a modal formula (in the basic similarity type). First, note
that the implication ‚Äòg  œÜ ‚áí g  œÜ‚Äô is immediate: if V (œÜ) = W for ev-
ery valuation, then certainly V (œÜ) = W for every admissible one. The converse
implication, which will obviously not hold in general, indicates that in order to de-
termine whether œÜ holds in the underlying Kripke frame g = (W, R), it sufÔ¨Åces
to look at admissible valuations only. If this is always the case when we take the
general frame from a given class X of general frames, then we call œÜ X-persistent.
There is also an algebraic interpretation of the notion of X-persistence. This
stems from the observation that given a general frame g, its associated algebra g‚àó
is a subalgebra of the full complex algebra (g )+ of the underlying Kripke frame
g of g. Preservation of validity under taking subalgebras means that (g )+ |= s ‚âà
t ‚áí g‚àó |= s ‚âà t for every equation s ‚âà t; again, the preservation of validity in the
other direction will not always hold. The concept of persistence gives us a way of
describing the special situation (in the sense that g‚àó is a special kind of subalgebra
of (g )+ ) where this ‚Äòupward preservation‚Äô does hold.5.6 Persistence
319
From the discussion of descriptive frames in Section 5.5 it is easy to see that
d-persistence and canonicity are really the same notion (provided that we have a
logical notion of canonicity as deÔ¨Åned after Open Problem 1).
Proposition 5.85 Let œÜ be a modal formula in a similarity type œÑ . Then œÜ is canon-
ical if and only if œÜ is d-persistent.
Example 5.86 As a Ô¨Årst example, we will prove that 2p ‚Üí p is r-persistent. Let
g = (W, R, A) be a reÔ¨Åned frame such that g  2p ‚Üí p. We have to show that
g  2p ‚Üí p. By Sahlqvist correspondence, this is equivalent to showing that
g |= ‚àÄx Rxx.
Suppose, in order to arrive at a contradiction, that there is an irreÔ¨Çexive state s
in g. It follows from tightness that there must exist a set a ‚àà A such that s ‚àà a,
but s ‚àà mR (a). Now consider the valuation V given by V (p) = ‚àía. Clearly V
is admissible, and since s ‚àà lR (‚àía) and s ‚àà ‚àía, we Ô¨Ånd that g, V, s  2p ‚Üí p.
Hence, we have contradicted the assumption that g  2p ‚Üí p.
Example 5.87 The formula 3p ‚Üí 33p is di-persistent, but not r-persistent. For
di-persistence, let g = (W, R, A) be a discrete frame such that g  3p ‚Üí 33p.
Denote the underlying Kripke frame of g by F ‚Äì we have to prove that 3p ‚Üí 33p
is valid in F. Again we use Sahlqvist correspondence, by which we may conÔ¨Åne
ourselves to proving that F |= ‚àÄxx1 (Rxx1 ‚Üí ‚àÉz (Rxz ‚àß Rzx1 )). Let s and s1 be
such that Rss1. Following Example 3.7, we deÔ¨Åne the minimal valuation Vm by
Vm (p) = {s1 }.
Our Ô¨Årst observation is that Vm is admissible, since g is discrete. This means that
we can proceed as in Example 3.7. Our second observation is that
(F, Vm ), s  33p iff F |= ‚àÉz (Rxz ‚àß Rzs1 )[s].
But (F, Vm ), s  33p is immediate by the validity of 3p ‚Üí 33p in g.
To show that the formula 3p ‚Üí 33p is not r-persistent, we consider the reÔ¨Åned
frame h of Example 5.70. It is rather easy to see that h  3p ‚Üí 33p; take
for instance the valuation V given by V (p) = {‚àû}. Then r  3p, but r has no
successors where 3p is true. Hence, r  33p.
On the other hand, we will now show that h  3p ‚Üí 33p. Consider a valuation
V and a state x of h such that (h, V ), x  3p. We have to show that x  33p.
From x  3p it follows that there is a y with Rxy and y  p. The only tricky
case is where x = r and y = ‚àû ‚Äì all the other cases are easily solved by using
the reÔ¨Çexivity of the states in S. But if ‚àû ‚àà V (p) and V (p) is admissible, then
V (p) ‚à© T is a co-Ô¨Ånite set. Hence, there is a state tn such that tn  p. But then
sn  3p and r  33p.320
5 Algebras and General Frames
Convention 5.88 Fix a modal similarity type œÑ and a set of propositional variables
Œ¶. In Section 2.4 we saw that models for this language can also be seen as struc-
tures for the corresponding Ô¨Årst-order language L1œÑ (Œ¶). In this and the following
section we will make good use of this fact; in fact, it will be very convenient to
have a sort of ‚Äòhybrid‚Äô notation, something between modal and Ô¨Årst-order logic.
Let F be a œÑ -frame, V a valuation on F and s a Ô¨Ånite sequence of states in F.
Further, consider a Ô¨Årst-order formula œÅ(x) in L1œÑ (Œ¶). We will write (F, V ), s  œÅ
to denote (F, V ) |= œÅ[s]. Here we assume that [s] is an assignment sending x0 to
s0 , x1 to s1 , and so on.
Example 5.89 Although the formula 31 22 p ‚Üí 23 34 p is d-persistent, it is not
di-persistent. A counterexample to di-persistence is provided by a simple modiÔ¨Å-
cation of the discrete frame c of Example 5.63.
For d-persistence, let g = (W, R, A) be a descriptive frame; deÔ¨Åne F = (W, R).
Assume that the formula holds on g; we will prove that it is also valid on F. By
Sahlqvist correspondence it sufÔ¨Åces to show that
F |= ‚àÄxx1 (R1 xx1 ‚Üí ‚àÄz0 (R3 xz0 ‚Üí ‚àÉz1 (R2 x1 z1 ‚àß R4 z0 z1 ))).
(5.43)
Let s and s1 be states in W such that R1 ss1 . DeÔ¨Åne the minimal valuation Vm by
Vm (p) = {u ‚àà W | R2 s1 u}.
Now assume that Vm is admissible. Then it follows from (F, Vm ), s  31 22 p that
(F, Vm ), s  23 34 p. Hence, every R3 -successor t0 of s has its R4 -successor z1
such that (F, Vm ), t1  p. But by deÔ¨Ånition of Vm , t1  p iff R2 s1 t1 . This would
prove (5.43).
However, the problem is that Vm need not be admissible. Nevertheless, a close
inspection of the ‚Äòproof‚Äô in the preceding paragraph reveals that we only need that
in (F, Vm ) at the pair s, s1 the following formula holds:
(R1 xx1 ‚àß ‚àÄy (R2 x1 y ‚Üí P y)) ‚Üí ‚àÄz0 (R3 xz0 ‚Üí ‚àÉz1 (R4 z0 z1 ‚àß P z1 )). (5.44)
We will not prove (5.44) here; it follows from a far more general claim in the proof
of Theorem 5.91. The two important observations in the proof are that Vm (p) is
a closed set, and that the right-hand side of the formula in (5.44) is the standard
translation of a positive formula.
We will give three theorems concerning persistence. The most important result is
Theorem 5.91 stating that all Sahlqvist formulas are d-persistent and hence, canon-
ical. As a warming-up exercise for its proof, we show that every very simple Sahl-
qvist formula is di-persistent (Theorem 5.90). Finally, Theorem 5.92 states that
every r-persistent formula is elementary; that is, it has a Ô¨Årst-order frame corre-
spondent.5.6 Persistence
321
Theorem 5.90 Every very simple Sahlqvist formula is di-persistent.
Proof. Recall from DeÔ¨Ånition 3.41 that a very simple Sahlqvist formula is of the
form œÜ ‚Üí œà, where
‚Ä¢ œÜ is built up from atoms, using conjunctions and (existential) modal operators,
and
‚Ä¢ œà is positive.
Now let œá ‚â° œÜ ‚Üí œà be such a very simple Sahlqvist formula, and let g = (F, A)
be a discrete general frame such that g  œá. We want to prove that F  œá. From
the discussion in the proof of Theorem 3.42 we know that this is equivalent to the
following, cf. (3.10):
F |= ‚àÄP1 . . . ‚àÄPn ‚àÄx‚àÄx1 . . . ‚àÄxm (REL ‚àß AT ‚Üí POS),
where
REL is a conjunction of Ô¨Årst-order statements of the form Rx0 . . . xn , corre-
sponding to occurrences of (existential) modal operators in œÜ,
AT is a conjunction of translations of atomic formulas (these correspond to the
proposition letters and constants in œÜ), and
POS is the standard translation of the formula œà.
Let s be a Ô¨Åxed but arbitrary sequence of states in F, and deÔ¨Åne valuation Vm by
Vm (p) = {si | P xi is a conjunct of AT }.
It is easy to see that Vm is the minimal valuation U such that (F, U ), s  AT;
in other words, (F, U ), s  AT only if U is an extension of Vm . (Vm is in fact
the semantical version of the minimal substitution that we used in the proof of the
correspondence theoretic part of Sahlqvist‚Äôs Theorem in Chapter 3.)
The key observations to the proof of this theorem are (5.45) and (5.46) below:
Vm is admissible
(5.45)
and
(F, Vm ), s  (REL ‚àß AT) ‚Üí POS iff
(F, V ), s  (REL ‚àß AT) ‚Üí POS for every valuation V .
(5.46)
The assumption that œá is true in every admissible model over F means we must
have that (F, U ), s  (REL ‚àß AT) ‚Üí POS for every admissible valuation U .
Hence, the theorem follows immediately from (5.45) and (5.46).
The proof of (5.45) is rather easy: for every p, Vm (p) is a Ô¨Ånite union of Ô¨Ånitely
many singletons, and, since A contains all singletons and is closed under unions,
each Vm (p) is in A.5 Algebras and General Frames
322
Concerning (5.46), the direction from right to left is of course trivial; for the
other direction, assume that (F, Vm ), s  (REL‚àßAT) ‚Üí POS, and that (F, V ), s 
REL ‚àß AT. From (F, V ), s  AT it follows that V is an extension of Vm . From
(F, V ), s  REL it follows that, regardless of the valuation U , (F, U ), s  REL. In
particular, we have (F, Vm ), s  REL. But then (F, Vm ), s  REL‚àß AT and hence,
(F, Vm ), s  POS. Since V is an extension of Vm , the monotonicity of positive
formulas implies that (F, V ), s  POS.
Theorem 5.91 Every Sahlqvist formula is d-persistent and hence, canonical.
Proof. We will prove the theorem for simple Sahlqvist formulas in a modal sim-
ilarity type containing diamonds only. Recall that such formulas are of the form
œÜ ‚Üí œà where
‚Ä¢ œÜ is built up from constants and boxed atoms (cf. DeÔ¨Ånition 3.45), using con-
junctions and (existential) modal operators only, and
‚Ä¢ œà is positive.
Let œá ‚â° œÜ ‚Üí œà be such a formula, and let g = (F, A) be a descriptive gen-
eral frame such that g  œá. We have to show that œá is valid on the underlying
Kripke frame F of g. Again, by Sahlqvist correspondence this is equivalent to the
following, cf. (3.10):
F |= ‚àÄP1 . . . ‚àÄPn ‚àÄx‚àÄx1 . . . ‚àÄxm (REL ‚àß BOX-AT ‚Üí POS),
(5.47)
where
REL is a conjunction of Ô¨Årst-order statements of the form R3 xi xj (corresponding
to occurrences of diamonds in œÜ),
BOX-AT is a conjunction of formulas of the form ‚àÄy (RŒ≤ xi y ‚Üí P y), correspond-
ing to the occurrences 2Œ≤ p of boxed atoms in œÜ (see DeÔ¨Ånition 3.45), and
POS is the standard translation of the formula œà.
As in the proof of the previous theorem, statement (5.47) itself is equivalent to the
following:
for every s in F: for every valuation V , (F, V ), s  (REL ‚àß BOX-AT ‚Üí POS).
We Ô¨Åx a sequence s of states in F, and deÔ¨Åne a valuation Vm by
Vm (p) =
{RŒ≤ [si ] | the formula ‚àÄy (RŒ≤ xi y ‚Üí P y) occurs in BOX-AT }.
Again, Vm is the minimal valuation U such that (F, U ), s  BOX-AT, and with
equal ease as in the proof of Theorem 5.90 we can show that
(F, Vm ), s  (REL ‚àß BOX-AT) ‚Üí POS iff
(F, V ), s  (REL ‚àß BOX-AT) ‚Üí POS for every valuation V ,
(5.48)5.6 Persistence
323
but ‚Äì and this is different from the previous case ‚Äì Vm need not be admissible now.
Nevertheless, it does hold that
(F, Vm ), s  (REL ‚àß BOX-AT) ‚Üí POS,
(5.49)
but we have to work much harder to prove it. The remainder of the proof is devoted
to establishing (5.49) ‚Äì note that the theorem follows immediately from (5.48) and
(5.49).
We Ô¨Årst deÔ¨Åne the following concepts. For valuations U and V , let U  V
mean that V is an admissible extension of U . (We say that V is an extension of
U if U (p) ‚äÜ V (p) for every proposition letter p.) It is easy to see that the set of
valuations on a given frame is closed under taking argument-wise intersections and
unions.
Recall that a set c ‚äÜ W is closed if it is the intersection of a (possibly inÔ¨Ånite)
set of admissible sets. Now we call a valuation V closed if V (p) is a closed set for
every proposition letter p. It is then not very difÔ¨Åcult to prove that a valuation U is

closed iff U = U V V .
Now (5.49) follows from (5.50) and (5.51) below:
Vm is closed,(5.50)
if U is a closed valuation and Œ≥ a positive formula,

then U (Œ≥) = U V V (Œ≥).(5.51)
and
For, suppose that we have proved (5.50) and (5.51), and assume that
(F, Vm ), s  REL ‚àß BOX-AT.
Let V be an arbitrary admissible valuation such that Vm  V . Then (F, V ), s 
REL ‚àß BOX-AT, so by the assumption, (F, V ), s  POS. If we look up again what
formula POS is, we see that this means s ‚àà V (œà), where œà was the consequent of

the Sahlqvist formula. Since V was arbitrary, this gives s ‚àà Vm V V (œà). But
then (5.50) and (5.51) imply that s ‚àà Vm (œà). Hence, (F, Vm ), s  POS. This
proves (5.49).
It remains to prove (5.50) and (5.51). The Ô¨Årst statement follows from Proposi-
tion 5.83, item (iv), and the fact that Ô¨Ånite unions of closed sets are closed.
For (5.51), we assume (without loss of generality) that Œ≥ is built up from atomic
formulas using ‚àß, ‚à®, 3 and 2. This allows us to give the following inductive proof:
Atomic case. If Œ≥ is a variable p, then it follows immediately (by the closedness

of U ) that U (p) = U V V (p). If Œ≥ is a constant, then U (Œ≥) = V (Œ≥) for every

valuation V (admissible or not), and hence U (Œ≥) = U V V (Œ≥).5 Algebras and General Frames
324
Conjunction. Assume Œ≥ is of the form Œ≥1 ‚àß Œ≥2 . Then U (Œ≥) = U (Œ≥1 ) ‚à© U (Œ≥2 ) =




V (Œ≥1 ) ‚à©
V (Œ≥2 ) =
(V (Œ≥1 ) ‚à© V (Œ≥2 )) =
V (Œ≥).
U V
U V
U V
U V
Disjunction. Assume Œ≥ is of the form Œ≥1 ‚à® Œ≥2 . It is easy to see that U (Œ≥) ‚äÜ

U V V (Œ≥). Then U (Œ≥) = U (Œ≥1 ) ‚à™ U (Œ≥2 ) =




V (Œ≥1 ) ‚à™
V (Œ≥2 ) ‚äÜ
(V (Œ≥1 ) ‚à™ V (Œ≥2 )) =
V (Œ≥).
U V
U V
U V
U V
For the other direction, assume that u ‚àà U (Œ≥). It follows immediately that u ‚àà
U (Œ≥1 ) and u ‚àà U (Œ≥2 ). By the inductive hypothesis, this implies the existence of
admissible valuations V1 and V2 such that U  Vi and u ‚àà Vi (Œ≥i ) (i ‚àà {1, 2}). Now
let V12 be the intersection of the valuations V1 and V2 , that is,
V12 (p) = V1 (p) ‚à© V2 (p)
for every p. It is easy to see that V12 is admissible and that U  V12 . However,
since Œ≥1 and Œ≥2 are positive and hence monotone, we also have V12 (Œ≥1 ) ‚äÜ V1 (Œ≥1 )
and V12 (Œ≥2 ) ‚äÜ V2 (Œ≥2 ). So we Ô¨Ånd that u ‚àà V12 (Œ≥1 ) and u ‚àà V12 (Œ≥2 ), whence

u ‚àà V12 (Œ≥1 ‚à® Œ≥2 ) = V12 (Œ≥). But then U  V12 implies u ‚àà U V V (Œ≥).
Box. Assume that Œ≥ is of the form 2Œ≥ . Then (writing R for R3 ):



U (Œ≥) = lR (U (Œ≥  )) = lR (
V (Œ≥  )) =
lR (V (Œ≥  )) =
V (Œ≥).
U V
U V
U V
Diamond. Finally, assume that Œ≥ is of the form 3Œ≥ . Again, the inclusion U (Œ≥) ‚äÜ

U V V (Œ≥) is rather easy:



U (Œ≥) = mR (U (Œ≥  )) = mR (
V (Œ≥  )) ‚äÜ
mR (V (Œ≥  )) =
V (Œ≥).
U V
U V
U V

The other direction is the hard part of the proof. Assume that u ‚àà U V V (Œ≥).
Thus for every admissible extension V of U , there is a tV such that RutV and
tV ‚àà V (Œ≥  ).
We want to prove that there is a t such that Rut and t ‚àà U (Œ≥ ). By the inductive
hypothesis, this is equivalent to showing that there is a single t such that Rut and
t ‚àà V (Œ≥  ) for every admissible V with U  V . In other words, it is sufÔ¨Åcient to
prove that

R[u] ‚à©
V (Œ≥  ) = ‚àÖ.
(5.52)
U V
We will Ô¨Årst prove that the set
X = {R[u]} ‚à™ {V (Œ≥  ) | U  V } has the Ô¨Ånite intersection property.5.6 Persistence
325
Consider an arbitrary Ô¨Ånite subcollection of X ; without loss of generality, R[u]
is part of it, hence we may assume that we have taken the sets R[u], V1 (Œ≥  ), . . . ,
Vn (Œ≥  ). Let V0 be the valuation given by
V0 (p) = V1 (p) ‚à© ¬∑ ¬∑ ¬∑ ‚à© Vn (p)
for every p. Then obviously we have U  V0 , and so by assumption there is a
state t0 in F such that Rut0 and t0 ‚àà V0 (Œ≥  ). But since Œ≥  is positive and Vi is
an extension of V0 for all i, it follows that V0 (Œ≥  ) ‚äÜ Vi (Œ≥  ) for all i. So t0 ‚àà
R[u] ‚à© V1 (Œ≥  ) ‚à© ¬∑ ¬∑ ¬∑ ‚à© Vn (Œ≥  ). This shows that X has the Ô¨Ånite intersection property.
It follows from Proposition 5.83(iv) that R[u] is closed; hence, item (v) of the
same proposition implies (5.52).
This completes the proof of (5.51), and hence, of Theorem 5.91.
Theorem 5.92 Every r-persistent formula is elementary.
The reader is asked to supply the proof of Theorem 5.92 in Exercise 5.6.4.
Exercises for Section 5.6
5.6.1 Show that if we are working in the basic temporal similarity type, and we conÔ¨Åne
ourselves to bidirectional general frames (that is, those in which the accessibility relations
of the diamonds are each other‚Äôs converse), then every Sahlqvist formula is di-persistent.
5.6.2 Show that the formula 2M ‚àß 4 (see Examples 3.11 and 3.57) is not equivalent to a
Sahlqvist formula. (Hint: use the previous exercise.)
5.6.3 In this exercise we deÔ¨Åne the notion of an ultraproduct of a general frame. Let
{gi | i ‚àà I} be a family of general frames, whereeach g i is given asthe triple (Wi , Ri , Ai ).
Let U be an ultraÔ¨Ålter over I; for elements s ‚àà i‚ààI Wi and a ‚àà  i‚ààI Ai , deÔ¨Åne [[s ‚àà a]]
to be the set {i ‚àà I | si ‚àà ai }. Now deÔ¨Åne, for an arbitrary a U ‚àà U Ai :
(aU )‚ó¶ := {sU | [[s ‚àà a]] ‚àà U }.
(a) Prove
that this is 
a correct deÔ¨Ånition, that is, show that for arbitrary elements s, t ‚àà

W
,
a,
b
‚àà
i
i‚ààI
i‚ààI Ai :
(i) if s ‚àºU t, then [[s ‚àà a]] ‚àà U iff [[t ‚àà a]] ‚àà U ,
(ii) if a ‚àºU b, then [[s ‚àà a]] ‚àà U iff [[s ‚àà b]] ‚àà U .


The ultraproduct U gi is deÔ¨Åned as the structure ( U (Wi , Ri ), AU ), where AU is given
as the set
'
AU := {(aU )‚ó¶ | a ‚àà
Ai }.
i‚ààI

(b) Prove that U gi is a general frame.
(c) Prove that for every modal formula œÜ:
'
gi  œÜ iff {i ‚àà I | gi  œÜ} ‚àà U.
U326
5 Algebras and General Frames
(d) Prove that the ultraproduct of a family of reÔ¨Åned general frames is again a reÔ¨Åned
general frame. How about the other properties of general frames?
5.6.4 In this exercise the reader is asked to supply the proof of Theorem 5.92.
Let œÜ be an r-persistent formula.
(a) Let {Fi | i ‚àà I} be a family of 
frames such that F i  œÜ, for all i ‚àà I, and let U be
an ultraÔ¨Ålter over I. Prove that U Fi  œÜ. (Hint: use Exercise 5.6.3.)
(b) Why is this sufÔ¨Åcient to prove Theorem 5.92? (Hint: use Exercise 3.8.3.)
5.7 Summary of Chapter 5
 The Algebra of Propositional Logic: Both the algebra 2 of truth values and the
class Set of set algebras algebraize classical validity. The class BA of boolean
algebras algebraizes classical theoremhood.
 Stone‚Äôs Representation Theorem: This classical result states that every boolean
algebra can be embedded in the power set algebra of the collection of its ultra-
Ô¨Ålters. It is the key to the algebraic proof of the soundness and completeness
theorem for classical propositional logic.
 Modal Formulas as Terms: Modal similarity types, extended with the boolean
connectives, can be seen as algebraic similarity types. Modal formulas can be
identiÔ¨Åed with algebraic terms.
 Boolean Algebras with Operators (BAOs): BAOs are boolean algebras aug-
mented with a normal additive operator for each modal operator. They are the
abstract algebras used to interpret modal logic.
 The Semantic Approach to Algebraization: Complex algebras are boolean alge-
bras with operators based on the power set algebra of a frame. Complex algebras
are the concrete BAOs that algebraize relational semantics.
 The Axiomatic Approach to Algebraization: Provable equivalence of two formu-
las in a normal modal logic Œõ is a congruence relation on the formula algebra
of the modal language. The Lindenbaum-Tarski Algebra of Œõ is the induced
quotient structure. Such algebras act as algebraic canonical models.
 Completeness and Representation: Modal completeness theorems correspond
to algebraic representation theorems.
 UltraÔ¨Ålter Frames: The ultraÔ¨Ålter frame of a boolean algebra with operators is
a relational structure based on the collection of ultraÔ¨Ålters of the algebra.
 Canonical Embedding Algebras: The complex algebra of the ultraÔ¨Ålter frame
of an algebra A is called the canonical embedding algebra of A.
 The J√≥nsson-Tarski Theorem: This is the fundamental theorem underlying the
algebraization of modal logic. It states that every boolean algebra with operators
can be embedded in the complex algebra of its ultraÔ¨Ålter frame.Notes to Chapter 5
327
 Algebraic Canonicity: A class of algebras is canonical if it is closed under taking
canonical embedding algebras; this concept is closely connected to the logical
notion of canonicity.
 Basic Duality: Bounded morphisms between frames correspond to homomor-
phisms between their complex algebras, and homomorphisms between algebras
give rise to bounded morphisms between their ultraÔ¨Ålter frames. This links
generated subframes to homomorphic images, bounded morphic images to sub-
algebras and disjoint unions to direct products.
 Goldblatt-Thomason Theorem: This can be derived from Birkhoff‚Äôs identiÔ¨Åca-
tion of varieties with equational classes using basic duality arguments.
 Ultraproducts and Canonicity: If K is a class of frames which is closed under
ultraproducts, then the variety VK is canonical.
 General Frames: A general frame combines a frame and a boolean algebra with
operators in one structure. Like boolean algebras with operators, general frames
provide an adequate semantics for normal modal logics. Important properties
of general frames include reÔ¨Ånedness, discreteness and descriptiveness.
 Descriptive Frames and BAOs: There is a full categorical duality between the
categories of descriptive œÑ -frames with bounded morphisms and boolean alge-
bras with œÑ -operators with homomorphic images.
 Persistence: A generalization of the notion of canonicity.
 Sahlqvist‚Äôs Completeness Theorem. All Sahlqvist formulas are d-persistent, and
hence canonical.
Notes
The main aim of algebraic logic is to gain a better understanding of logic by treat-
ing it in universal algebraic terms ‚Äì in fact, the theory of universal algebra was
developed in tandem with that of algebraic logic. Given a logic, algebraic logi-
cians try to Ô¨Ånd a class of algebras that algebraizes it in a natural way. When a
logic is algebraizable, natural properties of a logic will correspond to natural prop-
erties of the associated class of algebras, and the apparatus of universal algebra can
be applied to solve logical problems. For instance, we have seen that represen-
tation theorems are the algebraic counterpart of completeness theorems in modal
logic. The algebraic approach has had a profound inÔ¨Çuence on the development of
logic, especially non-classical logic; readers interested in the general methodology
of algebraic logic should consult Blok and Pigozzi‚Äôs [67] or Andr√©ka et al. [5].
The Ô¨Åeld has a long and strong tradition dating back to the nineteenth century.
In fact, nineteenth century mathematical logic was algebraic logic: to use the ter-
minology of Section 5.1, propositions were represented as algebraic terms, not
logical formulas. Boole is generally taken as the founding father of both proposi-
tional logic and modern algebra ‚Äì the latter because, in his work, terms for the Ô¨Årst328
5 Algebras and General Frames
time refer to objects other than numbers, and operations very different from the
arithmetical ones are considered. The work of Boole was taken up by de Morgan,
Peirce, Schr√∂der and others; their contributions to the theory of binary relations
formed the basis of Tarski‚Äôs development of relational algebra. In the Historical
Overview in Chapter 1 we mentioned MacColl, the Ô¨Årst logician in this tradition to
treat modal logic. A discussion of the nineteenth century roots of algebraic logic is
given by Anellis and Houser in [10].
However, when the quantiÔ¨Åcational approach to logic became Ô¨Årmly established
in the early twentieth century, interest in algebraic logic waned, and it was only
the inÔ¨Çuence of a relatively small number of researchers such as Birkhoff, Stone,
Tarski, and Rasiowa and Sikorski [370, 371], that ensured that the tradition was
passed on to the present day. The method of basing an algebra on a collection
of formulas (or equivalence classes of formulas), due to Lindenbaum and Tarski,
proved to be an essential research tool. This period also saw the distinction between
logical languages and their semantics being sharpened; an algebraic semantics for
non-classical logics was provided by Tarski‚Äôs matrix algebras. But the great suc-
cess story of algebraic logic was its treatment of classical propositional logic in
the framework of boolean algebras, which we sketched in Section 5.1. Here, the
work of Stone [425] was a milestone: not only did he prove the representation the-
orem for boolean algebras (our Theorem 5.16), he also recognized the importance
of topological notions for the area (something we did not discuss in the text). This
enabled him to prove a duality theorem permitting boolean algebras to be viewed
as essentially the same objects as certain topologies (now called Stone spaces).
Stone‚Äôs work has inÔ¨Çuenced many Ô¨Åelds of mathematics, as is witnessed by John-
stone [248].
McKinsey and Tarski [324] drew on Stone‚Äôs work in order to prove a representa-
tion theorem for so-called closure algebras (that is, S4-algebras); this result signif-
icantly extended McKinsey‚Äôs [322] which dealt with Ô¨Ånite closure algebras. How-
ever, when it comes to the algebraization of modal logics, the reader is now in a
position to appreciate the full signiÔ¨Åcance of the work of J√≥nsson and Tarski [255].
Although modal logic is not mentioned in their paper, the authors simultaneously
invented relational semantics, and showed (via their representation theorem) how
this new relational world related to the algebraic one. Both Theorem 5.43 from
the present chapter and important results on canonicity, overlapping with our The-
orem 5.91, are proved here. It is also obvious from their terminology (for instance,
the use of the words ‚Äòclosed‚Äô and ‚Äòopen‚Äô for certain elements of the canonical em-
bedding algebra) that hidden beneath the surface of the paper lies a duality theory
that extends Stone‚Äôs result to cover operators on boolean algebras.
For many years after the publication of the J√≥nsson-Tarski paper, research in
modal logic and in BAO theory pretty much took place in parallel universes. In
algebraic circles, the work of J√≥nsson and Tarski was certainly not neglected. TheNotes to Chapter 5
329
paper Ô¨Åtted well with a line of work on relation algebras. These were introduced
by Tarski [427] to be to binary relations what boolean algebras are to unary ones;
the concrete, so-called representable relation algebras have, besides the boolean
repertoire, operations for taking the converse of a relation and the composition
of two relations, and as a distinguished element, the identity relation. (From the
perspective of our book, the class RRA of representable relation algebras is nothing
but the variety generated by the complex algebras of the two-dimensional arrow
frames; see Example 5.57. In fact, one of the motivations behind the introduction of
arrow logic was to give a modal account of the theory of relation algebras.) Much
attention was devoted to Ô¨Ånding an analog of Stone‚Äôs result for boolean algebras:
that is, a nice equational characterization of the representable relation algebras.
But this nut turned out to be hard to crack. Lyndon [304] showed that the axioms
that Tarski had proposed did not sufÔ¨Åce, and Monk [334] proved that the variety
does not even have a Ô¨Ånite Ô¨Årst-order axiomatization. Later work showed that
equational axiomatizations will be very complex (Andr√©ka [6]) and not in Sahlqvist
form (Hodkinson [230] and Venema [446]), although Tarski proved that RRA is
a canonical variety. As a positive result, a nice game-theoretical characterization
was given by Hirsch and Hodkinson [225]. But these Notes can only provide a lop-
sided account of one aspect of the theory of relation algebras; for more, the reader
is referred to J√≥nsson [251, 252], Maddux [306] or Hirsch and Hodkinson [226].
One last remark on relation algebras: it is a very powerful theory. In fact, as Tarski
and Givant show in [428], one can formalize all of set theory in it.
Tarski and his students developed other branches of algebraic logic as well: for
example, the theory of cylindric algebras. The standard reference here is Henkin,
Monk and Tarski [218]. Cylindric algebras (and also the polyadic algebras of Hal-
mos [202]), are boolean algebras with operators that were studied as algebraic
counterparts of Ô¨Årst-order logic. For an introductory survey of these and other al-
gebras of relations we refer the reader to N√©meti [341]; modal logic versions of
these algebras are discussed in Section 7.5.
But in modal circles, the status of algebraic methods was very different. Indeed,
with the advent of relational semantics for modal logic in the 1960s, it seemed that
algebraic methods were to be swept away: model theoretic tools seemed to be the
route to a brave new modal world. (Bull‚Äôs work was probably the most impor-
tant exception to this trend. For example, his theorem that all normal extensions
of S4.3 are characterized by classes of Ô¨Ånite models was proved using algebraic
arguments.) Indicative of the spirit of the times is the following remark made by
Lemmon in his two part paper on algebraic semantics for modal logic. After thank-
ing Dana Scott for ideas and stimulus, he remarks:
. . . I alone am responsible for the ugly algebraic form into which I have cast
some of his elegant semantics. [295, page 191]330
5 Algebras and General Frames
Such attitudes only seemed reasonable because J√≥nsson and Tarski‚Äôs work had been
overlooked by the leading modal logicians, and neither J√≥nsson nor Tarski had
drawn attention to its modal signiÔ¨Åcance. Only when the frame incompleteness
results (which began to appear around 1972) showed that not all normal modal
logics could be characterized in terms of frames were modal logicians forced to
reappraise the utility of algebraic methods.
The work of Thomason and Goldblatt forms the next major milestone in the
story: Thomason [433] not only contains the Ô¨Årst incompleteness results and uses
BAOs, it also introduced general frames (though similar, language dependent, struc-
tures had been used in earlier work by Makinson [308] and Fine [127]). Thomason
showed that general frames can be regarded as simple set theoretic representations
of BAOs, and notes the connection between general frames and Henkin models for
second-order logic (we brieÔ¨Çy noted this link in Chapter 3.2). In [435], Thomason
developed a duality between the categories of frames with bounded morphisms and
that of complete and atomic modal algebras with homomorphisms that preserve in-
Ô¨Ånite meets. It was Goldblatt, however, who did the most inÔ¨Çuential work: in [184]
the full duality between the categories of modal algebras with homomorphisms and
descriptive general frames with bounded morphisms is proved, a result extending
Stone‚Äôs. Independently, Esakia [123] came up with such a duality for closure al-
gebras. Goldblatt generalized his duality to arbitrary similarity types in [186]; a
more explicitly topological version can be found in Sambin and Vaccaro [398].
Ever since their introduction in the seventies, general frames, a nice compromise
between algebraic and the relational semantics, have occupied a central place in
the theory of modal logic. Kracht [276, 279] developed an interesting calculus of
internal descriptions which connects the algebraic and Ô¨Årst-order side of general
frames. Zakharyaschev gave an extensive analysis of transitive general frames in
his work on canonical formulas ‚Äì see the Notes to Chapter 4 for further informa-
tion.
The Ô¨Årst proof of the canonicity of Sahlqvist formulas, for the basic modal sim-
ilarity type, was given by Sahlqvist [396], although many particular examples and
less general classes of Sahlqvist axioms were known to be canonical. In particu-
lar, J√≥nsson and Tarski proved canonicity, not only for certain equations, but also
for various boolean combinations of suitable equations. This result overlaps with
Sahlqvist‚Äôs in the sense that canonicity for simple Sahlqvist formulas follows from
it, but on the other hand, Sahlqvist formulas allowing properly boxed atoms in
the antecedent do not seem to fall under the scope of the results in J√≥nsson and
Tarski [255]. Incidentally, Sahlqvist‚Äôs original proof is well worth consulting: it is
non-algebraic, and very different from the one given in the text. Our proof of the
Sahlqvist Completeness Theorem is partly based on the one given in Sambin and
Vaccaro [399].
Recent years have seen a revived interest in the notion of canonicity. De RijkeNotes to Chapter 5
331
and Venema [387] deÔ¨Åned the notion of a Sahlqvist equation and generalized the
theory to arbitrary similarity types. J√≥nsson became active in the Ô¨Åeld again;
in [254] he gave a proof of the canonicity of Sahlqvist equations by purely algebraic
means, building on the techniques of his original paper with Tarski. Subsequent
work of Gehrke, J√≥nsson and Harding (see for instance [169, 168]) generalized
the notion even further by weakening the boolean base of the algebra to that of a
(distributive) lattice. Ghilardi and Meloni [171] proved canonicity of a wide class
of formulas using a different representation of the canonical extension of algebras
with operators. Whereas the latter lines of research tend to separate the canonicity
of formulas from correspondence theoretic issues, a reverse trend is visible in the
work of Kracht (already mentioned) and Venema [449]. The latter work shows that
for some non-Sahlqvist formulas there is still an algorithm generating a Ô¨Årst-order
formula which is now not equivalent to the modal one, but does deÔ¨Åne a property
for which the modal formula is canonical.
The applications of universal algebraic techniques in modal logic go much fur-
ther than we could indicate in this chapter. Various properties of modal logics have
been successfully studied from an algebraic perspective; of the many examples we
only mention the work of Maksimova [310] connecting interpolation with amalga-
mation properties. Also, most work by Blok, Kracht, Wolter and Zakharyaschev on
mapping the lattice of modal logics makes essential use of algebraic concepts such
as splitting algebras; a good starting point for information on this line of research
would be Kracht [279].
Most of the results that we present in Sections 5.4 and 5.5 are simpliÔ¨Åed ver-
sions of results in Goldblatt [184]. The proof of the Goldblatt-Thomason theorem
given in this chapter (as opposed to the model-theoretic one given in Section 3.8)
treats it as a corollary of Birkhoff‚Äôs Theorem [53] identifying varieties with equa-
tional classes; our proof is essentially the original proof of Goldblatt and Thoma-
son [188]. The proof of Theorem 5.56 is a generalization and algebraization by
Goldblatt [186] of results due to Fine [132] and van Benthem [41]. The Open
Problems 1 and 2 seem to have been formulated Ô¨Årst in Fine [132]; readers who
would like to try and solve the second one should deÔ¨Ånitely consult Goldblatt [180].
The now standard terminology concerning properties of general frames ‚Äì reÔ¨Åned,
descriptive, and so on ‚Äì is due to Thomason [433], Goldblatt [184] and Fine [130].
An exception, as far as we know, is the notion of discreteness, which did not play
a role until Venema [444], where our Theorem 5.90 was proved. The generaliza-
tion of canonicity to the notion of persistence stems from Goldblatt [185], and the
proof that r-persistent formulas are elementary (Theorem 5.92) was Ô¨Årst given by
Lachlan [291].6
Computability and Complexity
In this chapter we investigate the computability and complexity of normal modal
logics. In particular, we examine the computability of satisÔ¨Åability problems (given
a modal formula œÜ and a class of models M, is it computable whether œÜ is M-
satisÔ¨Åable?) and validity problems (given a modal formula œÜ and a class of models
M, is it computable whether œÜ is valid on M?). When the answer is ‚Äòyes‚Äô, we
probe further: how complex is the problem ‚Äì in particular, what resources of time
(that is, computation steps) or space (that is, memory) are needed to carry out the
required computations? When the answer is ‚Äòno‚Äô, we pose a similar question: how
uncomputable is the problem? There are vast differences in the complexities of
modal satisÔ¨Åability problems: some are no worse than the satisÔ¨Åability problem
for propositional calculus, while others are highly undecidable.
This chapter has two main parts. The Ô¨Årst, consisting of the Ô¨Åve sections on the
basic track, introduces the basic ideas and discusses modal (un-)decidability. Three
techniques for proving decidability are discussed (Ô¨Ånite models, interpretations in
monadic second-order theories of trees, and quasi-models and mosaics) and unde-
cidability is approached via tiling problems. In the second part, consisting of the
last three sections of the chapter, we examine the complexity of some key modal
satisÔ¨Åability problems. These sections are on the advanced track, but the initial
part of each of them should be accessible to all readers.
Basic ideas about computability and complexity are reviewed in the Ô¨Årst section,
and further background information can be found in Appendix C. Throughout the
chapter we assume we are working with countable languages.
Chapter guide
Section 6.1: Computing SatisÔ¨Åability (Basic track). We discuss the key concepts
assumed throughout the chapter: satisÔ¨Åability and validity problems, and
how to compute them on Turing machines.
Section 6.2: Decidability via Finite Models (Basic track). We discuss the use of
3326.1 Computing SatisÔ¨Åability
333
Ô¨Ånite models for proving decidability results. Three basic theorems are
proved, and many of the logics discussed in Chapter 4 are shown to be
decidable.
Section 6.3: Decidability via Interpretations (Basic track). Another way of prov-
ing modal decidability results is via interpretations in powerful decidable
theories such as monadic second-order theories of trees. This technique
is useful for showing the decidability of logics without the Ô¨Ånite model
property.
Section 6.4: Decidability via Quasi-models and Mosaics (Basic track). For log-
ics lacking the Ô¨Ånite model property it may also be possible to prove de-
cidability results by computing with more abstract kinds of Ô¨Ånite structure;
quasi-models and mosaics are important examples of such structures.
Section 6.5: Undecidability via Tiling (Basic track). In this section we show just
how easily undecidable ‚Äì and even highly undecidable ‚Äì modal logics can
arise. We do so by introducing an important proof method: tiling argu-
ments.
Section 6.6: NP (Advanced track). This section introduces the concept of NP al-
gorithms, illustrates the modal content of this idea using some simple ex-
amples, and then proves Hemaspaandra‚Äôs Theorem: every normal logic
extending S4.3 is NP-complete.
Section 6.7: PSPACE (Advanced track). The key complexity class for the basic
modal language is PSPACE, the class of problems solvable in polynomial
space. We give a PSPACE algorithm for the satisÔ¨Åability problem for K,
and prove Ladner‚Äôs Theorem: every normal logic between K and S4 is
PSPACE-hard.
Section 6.8: EXPTIME (Advanced track). We show that the satisÔ¨Åability prob-
lem for PDL is EXPTIME-complete. EXPTIME-hardness is shown by
reduction from a tiling problem, and the EXPTIME algorithm introduces
an important technique called elimination of Hintikka sets.
6.1 Computing SatisÔ¨Åability
The work of this chapter revolves around satisÔ¨Åability and validity problems. Here
is an abstract formulation.
DeÔ¨Ånition 6.1 (SatisÔ¨Åability and Validity Problems) Let œÑ be a modal similarity
type, œÜ be a œÑ -formula and M a class of œÑ -models. The M-satisÔ¨Åability problem is
to determine whether or not œÜ is satisÔ¨Åable in some model in M. The M-validity
problem is to determine whether or not œÜ is true in all models in M; that is, whether
or not M  œÜ. (We call this the validity problem because we are mostly interested334
6 Computability and Complexity
in cases where M is the class of all models over some class of frames.) The M-
validity and M-satisÔ¨Åability problem are each other‚Äôs duals.
In fact, as far as discussions of computability (or non-computability) are concerned,
we are free to talk in terms of either satisÔ¨Åability or validity problems.
Lemma 6.2 Let œÑ be a modal similarity type, and suppose that M is a class of
œÑ -models. Then there is an algorithm for solving the M-satisÔ¨Åability problem iff
there is an algorithm for solving the M-validity problem.
Proof. As ¬¨œÜ is not satisÔ¨Åable in M iff M  œÜ, given an algorithm for M-satis-
Ô¨Åability, we can test for the validity of œÜ by giving it the input ¬¨œÜ. In a similar
fashion, an algorithm for M-validity can be used to test for M-satisÔ¨Åability.
This argument does not give us any interesting information about the relative com-
plexity of dual satisÔ¨Åability and validity problems; and indeed, they may well be
different.
How do the themes of this chapter relate to the normal modal logics introduced
in Section 1.6 and discussed in Chapters 4 and 5? Clearly we should investigate
the following two problems.
DeÔ¨Ånition 6.3 Let œÑ be a modal similarity type, Œõ be a normal modal logic in a
language for œÑ , and œÜ a œÑ -formula. The problem of determining whether or not œÜ is
Œõ-consistent is called the Œõ-consistency problem, and the problem of determining
whether or not Œõ  œÜ is called the Œõ-provability problem.
Note that Œõ-consistency and Œõ-provability problems are satisÔ¨Åability and validity
problems in disguise. In particular, if Œõ is a normal modal logic, and M is any
class of models such that Œõ = ŒõM , then the Œõ-consistency problem is the M-
satisÔ¨Åability problem, and the Œõ-provability problem is the M-validity problem. As
every normal modal logic is determined by at least one class of models (namely, the
singleton class containing its canonical model; see Theorem 4.22), we are free to
think of consistency and provability problems in terms of satisÔ¨Åability and validity
problems. We do so in this chapter, and to emphasize this we usually call the Œõ-
consistency problem the Œõ-satisÔ¨Åability problem, and the Œõ-provability problem
the Œõ-validity problem.
Our discussion so far has given an abstract account of the problems we will ex-
plore, and most of our results will be stated, proved, and discussed at this level. But
what does it mean to have an algorithm for solving (say) a validity problem? And
what does it mean to talk about the complexity of (say) a satisÔ¨Åability problem?
After all, computation is the Ô¨Ånitary manipulation of Ô¨Ånite structures ‚Äì but both
formulas and models are abstract set-theoretical objects. To show that our abstract6.1 Computing SatisÔ¨Åability
335
account really makes sense, we need to choose a well-understood method of com-
putation and show that formulas and models can be represented in a way that is
suited to our method.
We have chosen Turing machines (Appendix C) as our fundamental model of
computation. The most relevant fact about Turing machines for our purposes is
that they compute by manipulating Ô¨Ånite strings of symbols; hence we need to
represent models and formulas as symbol strings. As far as mere computability is
concerned, the key demand is that these symbol string representations be Ô¨Ånite. For
complexity analyses more is required: representations must also be efÔ¨Åcient. Let
us discuss these requirements.
Clearly modal formulas can be represented as Ô¨Ånite strings over a Ô¨Ånite set of
symbols: proposition letters can be represented by a single symbol (say, p) fol-
lowed by (the representation of) a number. Thus, instead of working with an inÔ¨Å-
nite collection of primitive symbols we could work with (say) p1, p10, p11, p100
and so on, where the numeric tail is represented in binary. Fine ‚Äì but what about
models? Models are set-theoretic entities of the form (W, R, V ), and each com-
ponent may be inÔ¨Ånite. However, the difÔ¨Åculty is more apparent than real. For a
start, when evaluating a formula œÜ in some model, the only relevant information in
the valuation is the assignments made to proposition letters actually occurring in
œÜ (see Exercise 1.3.1). Thus, instead of working with V , we can work with the Ô¨Å-
nite valuation V  which is deÔ¨Åned on the (Ô¨Ånite) language consisting of exactly the
proposition letters in œÜ, and which agrees with V on these letters. Secondly, much
of our work will revolve around models based on Ô¨Ånite frames (or more generally,
the frames of Ô¨Ånite character deÔ¨Åned below).
We already know quite a lot about Ô¨Ånite models and their logics. For a start,
in Section 2.3 we introduced two techniques for building Ô¨Ånite models (selection
and Ô¨Åltration) and deÔ¨Åned the Ô¨Ånite model property for the basic modal language.
In Section 3.4 we introduced the Ô¨Ånite frame property (again, for the basic modal
language) and proved Theorem 3.28: a normal modal logic has the Ô¨Ånite frame
property iff it has the Ô¨Ånite model property. Since then we have learned what a
normal modal logic in a language of arbitrary similarity type is (DeÔ¨Ånition 4.13),
so let us now deÔ¨Åne the Ô¨Ånite frame property and the Ô¨Ånite model property for
modal languages of arbitrary similarity type, and generalize Theorem 3.28.
DeÔ¨Ånition 6.4 Let œÑ be a modal similarity type. A frame of type œÑ has Ô¨Ånite char-
acter if it contains Ô¨Ånitely many states, and Ô¨Ånitely many non-empty relations. If
Œõ is a normal modal logic in a language for œÑ , and F is a class of œÑ -frames of Ô¨Ånite
character, and Œõ = ŒõF , then Œõ is said to have the Ô¨Ånite frame property (f.f.p.) with
respect to F. If Œõ = ŒõF for some class of œÑ -frames F of Ô¨Ånite character, then Œõ has
the Ô¨Ånite frame property.
A class of œÑ -models M is Ô¨Ånitely based if every model in M is based on a œÑ -336
6 Computability and Complexity
frame of Ô¨Ånite character. If Œõ is a normal modal logic in a language for œÑ , and
M is a class of Ô¨Ånitely based œÑ -models, and Œõ = ŒõM , then Œõ has the Ô¨Ånite model
property (f.m.p.) with respect to M. If Œõ = ŒõM for some class of of Ô¨Ånitely based
œÑ -models M, then Œõ has the Ô¨Ånite model property.
A few remarks may be helpful. First, the concept of Ô¨Ånite character is a natural way
of coping with similarity types containing inÔ¨Ånitely many relations. Second, note
that the way the Ô¨Ånite frame property is deÔ¨Åned here (where we simply insist that
Œõ = ŒõF ) is somewhat simpler than that used in DeÔ¨Ånition 3.23 (where we insisted
that F  Œõ, and for every formula œÜ such that œÜ ‚àà Œõ there is some F ‚àà F such that
œÜ is falsiÔ¨Åable on F). It is easy to see that these deÔ¨Ånitions are equivalent. Finally,
a class of frames of Ô¨Ånite character (or indeed, a class of Ô¨Ånite frames) may well be
a proper class. Nonetheless, up to isomorphism, there are only denumerably many
frames in any such class; hence, if Œõ has the Ô¨Ånite frame property, it has the Ô¨Ånite
frame property with respect to a denumerably inÔ¨Ånite set of frames, and we take
this for granted without further comment throughout the chapter.
Given this deÔ¨Ånition, it is straightforward to generalize Theorem 3.28.
Theorem 6.5 Let œÑ be a modal similarity type. Any normal modal logic in a lan-
guage for œÑ has the Ô¨Ånite model property iff it has the Ô¨Ånite frame property.
Proof. This is a matter of verifying that the proof of Theorem 3.28 extends to
arbitrary similarity types; see Exercise 6.1.1.
There are many ways to represent a frame of Ô¨Ånite character, together with a val-
uation V  deÔ¨Åned on Ô¨Ånitely many proposition letters, as a Ô¨Ånite symbol string.
While any such Ô¨Ånitization is sufÔ¨Åcient for discussions of computability, we need
to exercise more care when it comes to complexity. Complexity theory measures
the difÔ¨Åculty of problems in terms of the resources required to solve them ‚Äì and
these are measured as a function of the size of the input. A highly inefÔ¨Åcient rep-
resentation of the input can render such resource measures vacuous, so we must be
careful not to smuggle in sources of inefÔ¨Åciency. For the complexity classes we
will be dealing with, this is pretty much a matter of common sense, but the follow-
ing point should be made explicit: we must not represent the numeric subscripts
on propositional variables and states in unary notation.
The point is this. Even binary representations (which are longer than the more
familiar decimal representations) are exponentially more compact than unary ones.
For example, the representation of the number 64 in unary is a string of 64 con-
secutive ones, whereas its representation in binary is 1000000. If we represent our
subscripts in unary, we are using a highly inefÔ¨Åcient representation of the problem.
For this reason we will regard modal formulas (for the basic modal language)
as strings over the alphabet {p, 0, 1, (, ), ‚àß, ¬¨, 3}, and proposition letters will6.1 Computing SatisÔ¨Åability
337
be represented by strings consisting of p followed by the binary representation of
a number (without leading zeroes). Similarly, we will regard models as strings
over the alphabet {w, p, 0, 1, ;, , }. A state in a model will be represented by
w followed by the binary representation of a number (without leading zeroes), and
the representation of proposition letters (which we need to encode the valuation)
will be as just described. A string representing a model will have the following
form:
*
w1 ; . . . ; wn ;
wi ; wj ; . . . ; wk ; wl ;
+
px ; wr ; . . . ; ws ; . . . ; py ; wt ; . . . ; wu  ,
where 1 ‚â§ i, j, k, l, r, s, t, u ‚â§ n. Such triples represent models in the obvious
way: the Ô¨Årst component gives the states, the second the relation, and the third the
valuation. The subscripted ws and ps are metavariables over our representations of
states and proposition letters, respectively. We assume that our representations of
models contain no repetitions in any of the three components, and that they satisfy
obvious well-formedness conditions (in particular, the third component represents
a function, thus we cannot have the same representation py appearing as the Ô¨Årst
item in different tuples). Here is a simple example (though to keep things readable
we have represented the numbers in decimal):
p
t
t q

I
@
@
t
p
A model
*
w1 ; w2 ; w3 ;
w1 ; w2 ; w1 ; w3 ;
+
p1 ; w1 ; w2 ; p2 ; w3  .
Its representation
Such representations open the door to all the standard concepts of computability
theory and computational complexity. For a start, it now makes sense to describe
sets of formulas (including normal modal logics), sets of models, and sets of frames
as being recursively enumerable (r.e.), or as being recursive. Saying that a set is
r.e. means that it is possible to write a Turing machine that will successively output
all and only its elements. Saying that a set is recursive means that it is possible to
write a Turing machine which, when given any input, will perform a Ô¨Ånite number
of computation steps, halt, and then correctly tell us whether the input represents
a member of the set or not. (In short, recursive sets are those for which we can
decide membership using a terminating computation.)
Furthermore, it is clearly possible to program a Turing machine so that when it
is presented with (the representations of) a formula, a model, and a point, it will
evaluate (the representation of) the formula in (the representation of) the model at
(the representation of) the point. Admittedly it would be rather painful to write out338
6 Computability and Complexity
such a Turing machine in detail ‚Äì but it is straightforward to write a program to
carry out this task in most high-level programming languages; hence, by Church‚Äôs
Thesis (see Appendix C), it is possible to write a Turing machine to do the job as
well. Thus it makes perfectly good sense to talk about writing Turing machines
which test for the satisÔ¨Åability or validity of a formula on a class of Ô¨Ånitely based
models and to inquire about the complexity of such problems.
Apart from asking the reader to generalize the above representation schema to
cover modal languages of arbitrary similarity type (see Exercise 6.1.2) we will not
discuss the issue of representation further. In most of what follows we talk as if the
abstract deÔ¨Ånition of satisÔ¨Åability and validity problems given earlier was the focus
of our computational investigations. For example, we will often call |œÜ| the size
of the input formula; strictly speaking, it is the size of its representation. Nor do
we mention Turing machines very often. The results of this chapter rest on the fact
that there is an efÔ¨Åcient representation which enables us to compute satisÔ¨Åability
and validity problems; for many purposes we can ignore the details.
Exercises for Section 6.1
6.1.1 Prove Theorem 6.5. That is, show that for any modal similarity type œÑ , any normal
modal logic in a language for œÑ has the Ô¨Ånite model property if and only if it has the Ô¨Ånite
frame property. This is simply a matter of verifying that the proof of Theorem 3.28 extends
to arbitrary similarity types ‚Äì but note that there will be a gap in your proof if you have not
yet proved the Filtration Theorem for modal languages of arbitrary similarity type.
6.1.2 Modify the representation schema for models given above so that it can represent
any Ô¨Ånitely based model of any modal similarity type.
6.1.3 Show that if Œõ is the normal modal logic generated by an r.e. set of formulas, then Œõ
itself is an r.e. set. (The reader unfamiliar with this type of proof may Ô¨Ånd it useful to look
at the proof of Lemma 6.12 below.)
6.2 Decidability via Finite Models
Call a normal modal logic Œõ decidable if the Œõ-satisÔ¨Åability (or equivalently: Œõ-
validity) problem is decidable, and undecidable if it is not. How should we estab-
lish decidability results? A lot depends on our ‚Äòaccess‚Äô to the logic. For example,
we may know Œõ purely semantically: it is given as the logic of some class of
frames of interest. However, we may also have a syntactic handle on Œõ; in partic-
ular, we may know that it is the logic generated by some set of axioms. Whether
Œõ is semantically or syntactically speciÔ¨Åed, establishing that it has the Ô¨Ånite model
property is a useful Ô¨Årst step towards proving decidability, for if we can prove this,
two plausible strategies for establishing decidability suggest themselves, as we will
now explain.6.2 Decidability via Finite Models
339
‚Ä¢ Decidability for semantically speciÔ¨Åed logics: informal argument. Suppose
we only have a semantic speciÔ¨Åcation of Œõ, but that we have been able to prove
that Œõ possesses a strong form of the Ô¨Ånite model property: not only does Œõ
have the f.m.p. with respect to some set of models, but for any formula œÜ there
is a computable function f such that f (|œÜ|) is an upper bound on the size of
these models needed to satisfy œÜ. Write a Turing machine that takes œÜ as input,
generates all the Ô¨Ånite models belonging to this set up to size f (|œÜ|), and tests for
the satisÔ¨Åability of œÜ on these models. Because œÜ is Œõ-satisÔ¨Åable iff it is satisÔ¨Åed
in a Œõ-model of size at most f (|œÜ|), and because the machine systematically
examines all these models, our machine decides Œõ-satisÔ¨Åability.
‚Ä¢ Decidability for syntactically speciÔ¨Åed logics: informal argument. Suppose Œõ
is given axiomatically, and we have been able to show that Œõ has the f.m.p. with
respect to some set of models M. First, construct a Turing machine that makes
use of the axiomatization to recursively enumerate the Œõ-validities. Second, con-
struct a Turing machine that recursively enumerates all the Ô¨Ånite models in M.
Given two such machines we can effectively test the Œõ-validity of any formula
œÜ: if œÜ is valid it will eventually be generated by the Ô¨Årst machine; if it is not,
we will eventually be able to falsify it on a model generated by the second. One
of the machines must eventually settle œÜ‚Äôs fate, and thus decide Œõ-validity.
Such arguments underly most applications of the Ô¨Ånite model property to decidabil-
ity. We have deliberately phrased both arguments rather loosely; the fundamental
goal of this section is to explore the underlying ideas more carefully, and formulate
them rigorously. Our investigation will yield three main theorems. The Ô¨Årst is a
precise formulation of the argument for semantically speciÔ¨Åed logics. The second
and third are distinct reformulations of the argument for syntactically speciÔ¨Åed log-
ics. We will consider a number of applications of these theorems, and will put both
of the methods introduced in Section 2.3 for constructing Ô¨Ånite models (namely
Ô¨Åltration and selection) to work.
Let us begin by scrutinizing the Ô¨Årst of the above arguments. This revolves
around a strong form of the Ô¨Ånite model property.
DeÔ¨Ånition 6.6 (Strong Finite Model Property) Let Œõ be a normal modal logic,
M a set of Ô¨Ånitely based models such that Œõ = ŒõM , and f a function mapping nat-
ural numbers to natural numbers. Œõ has the f (n)-size model property with respect
to M if every Œõ-consistent formula œÜ is satisÔ¨Åable in a model in M containing at
most f (|œÜ|) states.
Œõ has the strong Ô¨Ånite model property with respect to M if there is a computable
function f such that Œõ has the f (n)-size model property with respect to M. Œõ has
the polysize model property with respect to M if there is a polynomial p such that
Œõ has the p(n)-size model property with respect to M.340
6 Computability and Complexity
Œõ has the f (n)-size model property (respectively, strong Ô¨Ånite model property,
polysize model property) if there is a set of Ô¨Ånitely based models M such that
Œõ = ŒõM and Œõ has the f (n)-size model property (respectively, strong Ô¨Ånite model
property, polysize model property) with respect to M.
If a logic Œõ has the polysize model property, any Œõ-satisÔ¨Åable formula is satisÔ¨Åable
not just on a Ô¨Ånite model, but a genuinely small model. Even this very strong form
of the f.m.p does not guarantee decidability: as the reader is asked to prove in
Exercise 6.2.4, there are uncountably many normal modal logics which possess the
polysize model property but have undecidable satisÔ¨Åability problems.
In view of this result, the Ô¨Årst informal argument sketch is clearly inadequate ‚Äì
but where does its deÔ¨Åciency lie? It makes the following (false) assumption: that
for any set of models, and any natural number n, it is possible to generate all and
only the models in M of size at most n. This assumption is warranted only if M
is a recursive set (that is, only if a Turing machine can decide exactly which Ô¨Ånite
models belong to M). But this is the only shortcoming of the informal argument.
Theorem 6.7 If Œõ is a normal modal logic that has the strong Ô¨Ånite model property
with respect to a recursive set of models M, then Œõ is decidable.
Proof. First, observe that for any natural number n it is possible to generate all
distinct (representations of) models in M that have size at most n: we simply need
to write a machine that generates all distinct (representations of) models that have
size at most n, tests each model (representation) as it is generated to see whether
it belongs to M (this is the key point: we can effectively test for membership in
M precisely because M is a recursive set) and then outputs exactly those models
(representations) which do belong to M. (From now on we drop all mention of
representations, and will speak simply of ‚Äògenerating all models‚Äô or ‚Äògenerating all
models up to size n‚Äô, and so on.)
So, given œÜ, we use this machine to generate all models of the appropriate set up
to size f (|œÜ|), and test whether œÜ is satisÔ¨Åable on any of the models it produces.
If œÜ is satisÔ¨Åable on at least one of them, it is Œõ-satisÔ¨Åable; if not, it is not Œõ-
satisÔ¨Åable, for Œõ has the strong f.m.p. with respect to M.
Theorem 6.7 is an important result. If we are to apply it, how do we establish that a
logic has the strong Ô¨Ånite model property? Unfortunately, no fully general answer
to this question is known ‚Äì nonetheless, both Ô¨Åltration and selection can be useful.
We start by illustrating the utility of Ô¨Åltrations.
Corollary 6.8 K, T, KB, K4, S4, S5, Kt , Kt 4.3 and Kt Q are decidable.
Proof. First, all these logics have the f.m.p. with respect to the expected sets of
models; for example, K4 has the f.m.p. with respect to the set of Ô¨Ånite transitive6.2 Decidability via Finite Models
341
models, and Kt Q has the f.m.p with respect to the Ô¨Ånite dense unbounded weak
total orders (that is, the Ô¨Ånite DUWTO frames; see Theorem 4.41). The easiest
way to prove this is to use Ô¨Åltrations. In Section 2.3 we deÔ¨Åned Ô¨Åltrations for
both the basic modal language and the basic temporal language. Given a model M
that satisÔ¨Åes a formula œÜ at some state, by Ô¨Åltrating M through the set of all œÜ‚Äôs
subformulas we obtain a Ô¨Ånite model Mf that satisÔ¨Åes œÜ. Of course, we need to be
careful that Mf has all the right properties; for example, if M was a K4-model, we
want Mf to be a K4-model as well. By and large this is straightforward, though the
reader will need to think a little about how to handle density; see Exercise 6.2.1.
Such Ô¨Åltration arguments actually establish the strong f.m.p. for these logics. If
we form Mf by Ô¨Åltrating M through the subformulas of œÜ, then Mf has at most
2|œÜ| nodes, thus we have a computable (though, unfortunately, exponential) upper
bound on the size of satisfying models for all these logics; see Section 2.3.
It remains to check that the relevant sets of Ô¨Ånite models are recursive. Checking
for membership in these sets boils down to checking that the models possess (vari-
ous combinations of) such properties as reÔ¨Çexivity, transitivity, trichotomy, and so
on. It is clearly possible to devise algorithms to test for the relevant properties,
hence (by Church‚Äôs thesis) we can program a Turing machine to do so. Thus The-
orem 6.7 applies, and all these logics are decidable.
Filtration is a widely used technique for showing that logics have the strong Ô¨Ånite
model property, but it has limitations. Suppose we are working with a modal lan-
guage containing n unary modal operators (n > 0) and no others. Let Fn1 be the set
of frames for this language such that for each F ‚àà Fn1 , the relation corresponding
to each modality is a partial function, let Mn1 be the set of models built over Fn1 ,
and let Kn Alt1 be its logic. Now, Kn Alt1 has the strong Ô¨Ånite model property, but
there is no obvious way of using Ô¨Åltrations to show this; see Exercise 6.2.3.
However ‚Äì at least in the present case ‚Äì it is straightforward to use selection, the
other method of building Ô¨Ånite models discussed in Section 2.3, to establish the
strong Ô¨Ånite model property.
Corollary 6.9 Kn Alt1 is decidable.
Proof. We argue as follows. Suppose M is in Mn1 and M, w  œÜ. Let M be the
model that is identical to M save possibly that any relations in M not correspond-
ing to modal operators in œÜ are empty. Clearly M is also in Mn1 and M , w  œÜ.
Let m be the degree of œÜ (that is, the maximal depth of nested modalities; see DeÔ¨Å-
nition 2.28). Let M be the submodel of M formed by selecting all and only those
nodes reachable from w in m or fewer steps. Clearly M is in Mn1 and M , w  œÜ.
Moreover, because each relation is a partial function, M has only Ô¨Ånitely many
nodes: indeed, it can contain at most tm + 1 nodes, where t is the number of dis-342
6 Computability and Complexity
tinct types of modality that occur in œÜ. Hence Kn Alt1 has the strong Ô¨Ånite model
property with respect to Mn1 .
It is clear that the set of Ô¨Ånitely based Mn1 models is recursive, for testing whether
a Ô¨Ånite model M belongs to it essentially boils down to checking that each of M‚Äôs
(Ô¨Ånitely many non-empty) transition relations is a partial function. Decidability
follows by Theorem 6.7.
Selection is not as general a method as Ô¨Åltration ‚Äì but it can be useful, especially
when working with non-transitive models. As we will see when we discuss NP-
completeness, selection is a natural way of turning a Ô¨Ånite model (perhaps pro-
duced via a Ô¨Åltration) into a truly small (that is, polysize) model.
Theorem 6.7, together with such methods as Ô¨Åltration and selection, can be a
useful tool for establishing modal decidability results, for it does not require us to
have an axiomatization. Very often we do have an axiomatization at our disposal,
and it is natural to ask whether (and how) we can make use of it to help establish
decidability. This is what the second informal argument attempts to do. The key
idea it embodies is the following: if a logic is both axiomatizable and has the Ô¨Ånite
model property with respect to some (recursively enumerable) set of models M,
then we should be able to prove decidability. This is an important idea that can be
developed in two different ways, depending on the kind of axiomatization we have,
and what we know about the computational properties of M.
When we discussed completeness in Chapter 4, we viewed axiomatizations very
abstractly: we simply said that if Œõ was a normal modal logic, Œ£ a set of modal
formulas, and KŒ£ (the smallest normal logic generated by Œ£) equaled Œõ, then Œ£
was an axiomatization of Œõ. To give computational content to the phrase ‚Äògener-
ated by‚Äô we need to impose restrictions on Œ£, for under the deÔ¨Ånition just given
every normal logic Œõ generates itself. This is too abstract to be useful here, so we
will introduce various notions of axiomatizability that offer more computational
leverage.
DeÔ¨Ånition 6.10 A logic Œõ is Ô¨Ånitely axiomatizable if it has a Ô¨Ånite axiomatization
Œ£; it is recursively axiomatizable if it has a recursive axiomatization Œ£; and it is
axiomatizable if it has a recursively enumerable axiomatization Œ£.
Although it will not play a major role in what follows, there is a neat result called
Craig‚Äôs Lemma that readers should know: every axiomatizable logic is recursively
axiomatizable. So the following lemma is essentially Craig‚Äôs Lemma for modal
logic:
Lemma 6.11 If Œõ is axiomatizable, then Œõ is recursively axiomatizable.
So, given a computationally reasonable notion of axiomatizability, the idea of using
axiomatizations to generate validities is correct. But how do we use this fact to turn6.2 Decidability via Finite Models
343
the informal argument into a theorem? Here is the most obvious way: demand that
M be an r.e. set. As the following lemma shows, this ensures that we can recursively
enumerate the formulas that are not valid on M.
Lemma 6.12 If M is a recursively enumerable set of Ô¨Ånite models, then the set of
formulas falsiÔ¨Åable in M is recursively enumerable.
Proof. As M is an r.e. set, we can construct a machine M1 to generate all its ele-
ments, and clearly we can construct a machine M2 that generates all the formulas.
So, construct a machine M3 that operates as follows: it calls on M1 to generate a
model, and on M2 to generate a formula, and then stores both the model and the
formula. It then tests all stored formulas on all stored models (M3 is not going to
win any prizes for efÔ¨Åciency) and outputs any of the stored formulas it can falsify
on some stored model. At any stage there are only Ô¨Ånitely many stored formulas
and models, hence this testing process terminates. When the testing process is Ô¨Ån-
ished, M3 calls on M1 and M2 once more to generate another model and formula,
stores them, performs another round of testing, and so on ad inÔ¨Ånitum.
Suppose œÜ is falsiÔ¨Åable on some model M in M. At some Ô¨Ånite stage both œÜ
and M will be stored by M3, hence œÜ will eventually be tested on M, falsiÔ¨Åed,
and returned as output. This means that the set of formulas falsiÔ¨Åable on M is
recursively enumerable.
Theorem 6.13 If Œõ is an axiomatizable normal modal logic that has the Ô¨Ånite
model property with respect to an r.e. set of models M, then Œõ is decidable.
Proof. It is not difÔ¨Åcult to see that Œõ, being axiomatizable, is recursively enumer-
able. But the set of formulas not in Œõ is also r.e. for Œõ = ŒõM and the set of formulas
that are not M-valid is r.e. by the previous lemma. Any formula œÜ must eventually
turn up on one of these enumerations, hence Œõ is decidable.
As an application, we will show that the minimal propositional dynamic logic is
decidable.
Corollary 6.14 PDL is decidable.
Proof. By Theorem 4.91, PDL is complete with respect to the set of all regular
PDL-models. The axioms of PDL clearly form a recursive set, so trivially they
form a recursively enumerable set, thus to be able to apply the Theorem 6.13 it
only remains to show that PDL has the Ô¨Ånite model property with respect to an r.e.
set of models.
This follows easily from our completeness proof for PDL. Recall that we proved
completeness by constructing, for any consistent formula œÜ, a Ô¨Ånite model P that
satisÔ¨Åed œÜ. This gives us what we want, modulo the following glitch: although344
6 Computability and Complexity
P contains only Ô¨Ånitely many nodes, it may contain inÔ¨Ånitely many non-empty
relations, thus it may not be of Ô¨Ånite character and thus (strictly speaking) our
completeness proof does not establish that PDL has the Ô¨Ånite model property. This
is a triviality: for any formula œÜ, only Ô¨Ånitely many of the relations on P are
relevant to the satisÔ¨Åability of œÜ, namely those that actually occur in œÜ. Let RœÜ be
the smallest set that contains all the relations in P corresponding to modalities in
œÜ and is downward closed under the usual relation constructors (that is, if RœÄ;œÄ ‚àà
RœÜ then so are RœÄ and RœÄ , and analogously for relations deÔ¨Åned by union and
transitive closure). Note that RœÜ is Ô¨Ånite. Let P be the model that is identical
to P save that all the relations not in RœÜ are empty; we call P a reduced model.
Clearly P is a Ô¨Ånitely based model that satisÔ¨Åes œÜ. This shows that PDL has the
Ô¨Ånite model property.
The set of reduced models is a recursive set, since checking that a Ô¨Ånite model is
a reduced model boils down to showing that the relations corresponding to non-
basic modalities really are generated out of simpler relations via composition,
union, or transitive closure, and this is obviously something we can write a program
to do. Hence, the relevant models are recursively enumerable, thus the conditions
of Theorem 6.13 are satisÔ¨Åed, and PDL is decidable.
We can also show that PDL is decidable by appealing to Theorem 6.7. As we have
just seen, our completeness proof for PDL gives us the Ô¨Ånite model property for
PDL ‚Äì but in fact it even gives us the strong Ô¨Ånite model property. To see this,
recall that for any consistent œÜ, we constructed P out of atoms, that is, maximal
consistent subsets of the Fischer-Ladner closure of {œÜ}. As there are at most 2c|œÜ|
such atoms for some constant c, we have a computable upper bound on the size of
the models needed to satisfy œÜ. We noted in the proof of Corollary 6.14 that the
relevant Ô¨Ånite models (the reduced models) form a recursive set, hence we have
established everything we need to apply Theorem 6.7.
Theorem 6.13 is a fundamental one and is useful in practice. It does not make
use of axiomatizations in a particularly interesting way: it uses them merely to
enumerate validities. To apply the theorem we need to know that the set of relevant
Ô¨Ånite models is recursively enumerable. We often have much stronger syntactic
information at our disposal: we may know that a logic is Ô¨Ånitely axiomatizable.
Our next theorem is based on the following observation: if a logic with the f.m.p.
is Ô¨Ånitely axiomatizable, we can use the axiomatization not only to recursively
enumerate the validities, but to help us enumerate the non-validities as well.
Theorem 6.15 If Œõ is a Ô¨Ånitely axiomatizable normal modal logic with the Ô¨Ånite
model property, then Œõ is decidable.
Proof. As in the proof of Theorem 6.13, we can use the axiomatization to recur-6.2 Decidability via Finite Models
345
sively enumerate Œõ, so if we can show that the set of formulas not in Œõ is also r.e.
we will have proved the theorem.
By Theorem 6.5, if Œõ has the Ô¨Ånite model property it also has the Ô¨Ånite frame
property, thus there is some set of Ô¨Ånite frames F such that Œõ = ŒõF . Hence,
if œÜ ‚àà Œõ, œÜ is falsiÔ¨Åable in some model based on a frame in F. Obviously all
such frames must validate every axiom of Œõ, hence if œÜ ‚àà Œõ, œÜ is falsiÔ¨Åable in
some model based on a frame that validates the Œõ axioms. Now for the crucial
observation: we can write a machine M which decides whether or not a Ô¨Ånite
frame validates the Œõ axioms, for as Œõ has only Ô¨Ånitely many axioms, each frame
can be checked in Ô¨Ånitely many steps. With the help of M , we can recursively
enumerate the formulas falsiÔ¨Åable in some F-based model, but these are just the
formulas which do not belong to Œõ. It follows that Œõ is decidable.
Can Theorem 6.15 be strengthened by replacing its demand for a Ô¨Ånite axiomati-
zation with a demand for a recursive axiomatization? No ‚Äì in Exercise 6.2.5 we
give an example of an undecidable recursively axiomatizable logic KUX with the
Ô¨Ånite model property; the result hinges on Craig‚Äôs Lemma.
Theorem 6.15 has many applications, for many common modal and tense logics
have the f.m.p. and are Ô¨Ånitely axiomatizable. For example, Theorem 6.15 yields
another proof that K, T, KB, K4, S4, S5, Kt , Kt 4.3, and Kt Q are decidable, for
all these logics were shown to be Ô¨Ånitely axiomatizable in Chapter 4, and we saw
above that they all have the (strong) Ô¨Ånite model property. However, a more inter-
esting application follows from our work on logics extending S4.3 in Section 4.9.
Corollary 6.16 Every normal logic extending S4.3 is decidable.
Proof. By Bull‚Äôs Theorem (Theorem 4.96) every normal logic extending S4.3 has
the Ô¨Ånite model property, and by Theorem 4.101 every normal logic extending
S4.3 is Ô¨Ånitely axiomatizable. Hence the result is an immediate corollary of Theo-
rem 6.15.
Corollary 6.16 completes the main discussion of the section. To summarize what
we have learned so far, in Theorems 6.7, 6.13, and 6.15 we have results that pin
down three important situations in which the Ô¨Ånite model property implies decid-
ability ‚Äì and indeed, most modal decidability results make use of one of these three
theorems.
Exercises for Section 6.2
6.2.1 Provide full proof details for Corollary 6.8. Pay particular attention to showing that
Kt Q has the f.m.p. with respect to the Ô¨Ånite DUWTO-frames (see Theorem 4.41). Filtra-
tions generally do not preserve density, so how do we know that this Ô¨Åltration is dense?
(Hint: trichotomy.)346
6 Computability and Complexity
6.2.2 Show that if Œõ is a Ô¨Ånitely axiomatizable normal modal logic with the Ô¨Ånite model
property, then Œõ has the Ô¨Ånite frame property with respect to a recursive set of frames.
6.2.3 In this exercise we ask you to show that there is no method of Ô¨Åltrating a partial
function that guarantees that the resulting relation is again a partial function.
Consider the model M = (N, S, V ) where S is the successor relation on the set N of
natural numbers, and V makes the proposition letter p true at precisely the even numbers.
Let Œ£ be the set {3¬¨p, 3p, ¬¨p, p}. Prove that no Ô¨Åltration of M through Œ£ is based on a
frame in which S f is a partial function.
6.2.4 In this exercise we ask the reader to prove that there are uncountably many undecid-
able normal modal logics with the polysize model property.
Let Fsuc be the set of all Ô¨Ånite frames (W, R) such that W = {0, . . . , k} (for some
k ‚àà œâ) and for all distinct m and n in W , Rnm iff m = n + 1. (Note that this deÔ¨Ånition
permits reÔ¨Çexive points. Indeed, any frame in this set is uniquely determined by its size and
which points, if any, are reÔ¨Çexive.) Then, for each j ‚àà œâ deÔ¨Åne F j to be the set containing:
(1) all the irreÔ¨Çexive frames in F suc ; (2) all the frames in F suc whose last point is reÔ¨Çexive;
and (3) the (unique) F suc frame containing j + 1 nodes such that 0 is the only reÔ¨Çexive
point; call this frame F j . Now deÔ¨Åne, for any non-empty I ‚äÜ œâ, F I as the set i‚ààI Fi ; let
ŒõI be its logic.
DeÔ¨Åne œÜj to be the formula p ‚àß 3p ‚àß 3(¬¨p ‚àß 3 j‚àí1 2 ‚ä•).
(a) Prove that œÜj is satisÔ¨Åable in Fi iff i = j.
(b) Prove that if œÜ is F i -satisÔ¨Åable, then it is satisÔ¨Åable on a frame in F i that contains
at most m + 2 points, where m is the number of modalities in œÜ.
(c) Prove that if I and J are distinct (non-empty) subsets of œâ then there is a formula
that is satisÔ¨Åable in FI but not in FJ .
(d) Prove that each Œõ I has the polysize model property.
(e) Prove that there can only be countably many decidable logics. (This step is actually
the easiest one: after all, how many distinct Turing machines can there be?)
(f) Conclude that there are uncountably many undecidable normal modal logics with
the polysize model property.
6.2.5 Let X be an r.e. subset of the natural numbers that is not recursive; assume that
0 ‚àà X but 1 ‚àà X. Then KU X is the smallest normal modal logic containing the following
formulas:
(U1)
(U2)
(U3)
(U4)k
3(3p ‚àß 3q) ‚Üí 33(p ‚àß q),
3(p ‚àß 2 ‚ä•) ‚àß 3(q ‚àß 2 ‚ä•) ‚Üí 3(p ‚àß q),
3(p ‚àß 3) ‚àß 3(q ‚àß 3) ‚Üí 3(p ‚àß q),
(32 ‚ä• ‚àß33) ‚Üí 2k 3, where k ‚àà X.
Note that by Craig‚Äôs Lemma KU X has a recursive axiomatization.
(a) Use Sahlqvist‚Äôs Correspondence and Completeness Theorems to Ô¨Ånd a Ô¨Årst order
deÔ¨Ånable class U of frames for which KU X is sound and complete.
(b) Prove that KUX has the Ô¨Ånite model property.
(c) Show that KUX is undecidable.
(Hint: prove that any formula U4 j with j not in X, is not satisÔ¨Åable in U.)6.3 Decidability via Interpretations
347
6.3 Decidability via Interpretations
For all its usefulness, decidability via Ô¨Ånite models has a number of limitations.
One is absolute: as we will shortly see, there are decidable logics that lack the
Ô¨Ånite model property. Another is practical: it may be difÔ¨Åcult to establish the Ô¨Ånite
model property, for although Ô¨Åltration or selection work in many cases, no univer-
sal approach is known. Thus we need to become familiar with other techniques
for establishing decidability, and in this section we introduce an important one:
decidability via interpretations, and in particular, interpretations in SnS.
A general strategy for proving a problem decidable is to effectively reduce it to
a problem already known to be decidable. But there are many decidable problems;
which of them can help us prove modal decidability results? We would like to Ô¨Ånd
a decidable problem, or class of problems, to which modal satisÔ¨Åability problems
can be reduced in a natural manner. Moreover, we would like the approach to be as
general as possible: not only should a large number of modal satisÔ¨Åability problems
be so reducible, but the required reductions should be reasonably uniform.
A suitable group of problems is the satisÔ¨Åability problem for SnS (where n ‚àà œâ
or n = œâ), the monadic second-order theory of trees of inÔ¨Ånite depth, where each
node has n successors. Because these problems are themselves satisÔ¨Åability prob-
lems ‚Äì and indeed, satisÔ¨Åability problems for monadic second-order languages, the
kinds of language used in correspondence theory ‚Äì it can be relatively straight-
forward to reduce modal satisÔ¨Åability to SnS satisÔ¨Åability. Moreover, the various
reductions share certain core ideas; for example, analogs of the standard translation
play a useful role. The method can also be used for strong modal languages, such
as languages containing the until operator U ; see Exercise 2.2.4.
In this section we introduce the reader to such reductions (or better, for reasons
which will become clear, interpretations). We Ô¨Årst introduce the theories SnS,
note some examples of their expressivity, and state the crucial decidability results
on which subsequent work depends. We then illustrate the method of interpreta-
tions with two examples. First, we prove that KvB, a logic lacking the Ô¨Ånite model
property, is decidable. As KvB is characterized by a single structure (namely, a
certain general frame) this example gives us a relatively straightforward introduc-
tion to the method. We then show how the decidability of S4 can be proved via
interpretation. The result itself is rather unexciting ‚Äì we already know that S4 has
the Ô¨Ånite model property and is decidable (see Corollary 6.8) ‚Äì but the proof is im-
portant and instructive. S4 is most naturally characterized as the logic of transitive
and reÔ¨Çexive frames, but this is a characterization in terms of an uncountable class
of structures. How can this characterization be ‚Äòinterpreted‚Äô in SnS? In fact, it can
be done rather naturally, and the ideas involved open the doors to a wide range of
further decidability results.
Let us set about deÔ¨Åning SnS. If A is some Ô¨Åxed set (our alphabet), then A‚àó is348
6 Computability and Complexity
the set of all Ô¨Ånite sequences of elements of A, including the null-sequence Œª. We
introduce the following apparatus:
(i) DeÔ¨Åne an ordering ‚â§ on A‚àó by x ‚â§ y if y = xz for some z ‚àà A‚àó . Clearly
this ‚Äòinitial-segment-of‚Äô relation is a partial order. If x ‚â§ y and x = y we
write x < y.
(ii) Suppose A is totally ordered by a relation <A . Then we deÔ¨Åne * to be the
lexicographic ordering of A‚àó induced by <A . That is, x * y if and only if
x ‚â§ y, or x = zau and y = zbv where a, b ‚àà A and a <A b. Note that *
totally orders A‚àó .
(iii) For any a ‚àà A we deÔ¨Åne ra : A‚àó ‚Üí A‚àó , the a-th successor function, by
ra (x) = xa.
DeÔ¨Ånition 6.17 (SnS) For any n such that n is a natural number, or n = œâ, let
Tn be {i ‚àà œâ | i < n}‚àó . The structure Nn is (Tn , ri , ‚â§, *)i<n , where * is the
lexicographic ordering induced by <œâ , the usual ordering of the natural numbers.
Nn is called the structure of n successor functions. (Note that all these structures
are countably inÔ¨Ånite.)
The monadic second-order theory of n successor functions is the monadic sec-
ond-order theory of Nn in the monadic second-order language of appropriate signa-
ture (we spell out the details of this language below); this theory is usually referred
to as SnS.
Let us spell out the intuitions underlying this machinery. First, note that each
structure Nn really is an inÔ¨Ånite tree where each node has n immediate succes-
sors (or daughters, in standard tree terminology). For example, consider N1 ; that
is ({0}‚àó , r0 , ‚â§, *). This is the inÔ¨Ånite tree in which each node has exactly one
daughter; that is, it is simply an isomorphic copy of the natural numbers in their
usual order. Next, consider N2 , that is ({0, 1}‚àó , r0 , r1 , ‚â§, *). This is the full bi-
nary tree (that is, the inÔ¨Ånite tree in which every node has exactly two daughters).
An initial segment of N2 is shown in Figure 6.1. Note that Œª is the root node of
the tree depicted in Figure 6.1, and that r0 and r1 are the Ô¨Årst daughter and second
daughter relations, respectively. Further, note that ‚â§ has a natural tree-geometric
interpretation: it is simply the dominates relation. That is, x ‚â§ y iff it is possible
to reach x by moving upwards in the tree from y. Similarly, * is the dominates-or-
to-the-left-of relation. The tree-like nature of these models plays an important role
in the work that follows, and must be properly understood. In particular, the reader
should check that Nœâ really is an inÔ¨Ånite tree in which every node has œâ daughters.
So much for the structures ‚Äì what about the theories? Each of the theories
SnS is a monadic second-order theory in the appropriate language. For exam-
ple, the monadic second-order language appropriate for talking about N2 contains
two function symbols for talking about r0 and r1 (we will be economical with our6.3 Decidability via Interpretations
349
Œª
@
0
 A

A

A
00
01
..
..
.
.
@
@
@
1
 A

A

A
10
11
..
..
.
.
Fig. 6.1. An initial segment of N 2
notation and use r0 and r1 for these symbols) and two binary predicate symbols
for talking about ‚â§ and * (we use ‚â§ and * for this purpose). In addition, the
language contains a denumerably inÔ¨Ånite set of individual variables x, y, z, . . . , a
denumerably inÔ¨Ånite set of predicate (or set) variables P , Q, S, . . . , that range over
subsets of the domain, and the usual quantiÔ¨Åers and boolean operators. The syntax
and semantics of the language is standard; see Appendix A for further discussion
of monadic second-order logic.
Using these languages, we can say many useful things about Nn . First, note that
although we did not include a primitive equality predicate, an equality predicate is
deÔ¨Ånable over Nn :
x = y iff x * y ‚àß y * x.
Next, note that we can deÔ¨Åne a unary predicate symbol ROOT that is true only of
the root node Œª:
ROOT(x) iff ¬¨‚àÉy (y < x).
(6.1)
We can deÔ¨Åne the unary higher-order predicate ‚ÄòP is a Ô¨Ånite set.‚Äô Recall that a
total ordering R on a set S is a well-ordering if every non-empty subset of S has
an R-least element; it is a standard observation that S is well-ordered by R iff S
contains no inÔ¨Ånitely descending R-chains. It follows that a subset P of Tn is Ô¨Ånite
iff it is well-ordered by both * and its converse, for such a set contains no inÔ¨Ånitely
descending *-chains and no inÔ¨Ånitely ascending *-chains.
F INITE (P ) iff
(6.2)
‚àÄQ ((‚àÉx Qx ‚àß ‚àÄy (Qy ‚Üí P y)) ‚Üí ‚àÉu (Qu ‚àß ‚àÄw (Qw ‚Üí u * w))
‚àß ‚àÉv (Qv ‚àß ‚àÄw (Qw ‚Üí w * v))).
(That is, P is Ô¨Ånite if every non-empty subset of P has a *-Ô¨Årst and a *-last350
6 Computability and Complexity
element.) In short, monadic second-order logic is an extremely powerful language
for talking about trees ‚Äì which makes the following result all the more remarkable.
Theorem 6.18 (Rabin) For any natural number n, or n = œâ, SnS is decidable.
That is, for any n, it is possible to write a Turing machine which, when given
a monadic second-order formula (in the language of appropriate signature), cor-
rectly decides whether or not the formula is satisÔ¨Åable in Nn . The proof of this
beautiful result is beyond the scope of this book; we refer the reader to the Notes
for discussion and references.
Given a modal logic Œõ, how can we use the fact of SnS-decidability to estab-
lish Œõ-decidability? Suppose Œõ = ŒõM for some class of countable models M.
The essence of the interpretation method is to attempt to construct, for any modal
formula œÜ, a monadic second-order formula Sat-Œõ(œÜ) that does three things.
‚Ä¢ It must encode the information in œÜ; this is usually achieved by using some
variant of the standard translation.
‚Ä¢ It must deÔ¨Åne a set of substructures of Nn (for some choice of n) which are
isomorphic copies of the models in M.
‚Ä¢ It must bring the two previous steps together. That is, Sat-Œõ(œÜ) must be con-
structed so that it is satisÔ¨Åable in Nn iff (the translation of) œÜ is satisÔ¨Åable in (a
deÔ¨Ånable substructure of Nn that is isomorphic to) a model in M ‚Äì that is, iff œÜ
is Œõ-satisÔ¨Åable.
If such a formula Sat-Œõ(œÜ) can be constructed, the ramiÔ¨Åcations for modal decid-
ability are clear: as SnS is decidable, we can decide whether or not Sat-Œõ(œÜ) is
satisÔ¨Åable on Nn . As this is equivalent to deciding the Œõ-satisÔ¨Åability of œÜ, we will
have established that Œõ is decidable.
As our Ô¨Årst example of the method in action, we will prove the decidability of
KvB. We met this logic brieÔ¨Çy in Exercise 4.4.2; it is the logic of a certain general
frame J. The domain J of J consists of N ‚à™ {œâ, œâ + 1} (that is, the set of natural
numbers together with two further points), and the relation R is deÔ¨Åned by Rxy iff
x = œâ + 1 and y < x or x = œâ + 1 and y = œâ. The frame (J, R) is shown in
Figure 6.2. A, the collection of subsets of J admissible in J, consists of all X ‚äÜ J
such that either X is Ô¨Ånite and œâ ‚àà X, or X is co-Ô¨Ånite and œâ ‚àà X.
As the reader was asked to show in Exercise 4.4.2, KvB is incomplete; that is, there
is no class of frames F such that KvB = ŒõF . By Theorem 6.5 it follows that KvB
lacks the Ô¨Ånite model property. Even though it lacks the Ô¨Ånite model property, KvB
is decidable, and we will demonstrate this via an interpretation in S2S.
Theorem 6.19 KvB is decidable.6.3 Decidability via Interpretations
vv
01
351
vœâ + 1


 

a



a
a
 a
a
a


)


=

?

v. . .
v
œâ
2
Fig. 6.2. The frame underlying J. Note that œâ + 1 is related only to œâ
Proof. Let us make two initial assumptions; we will shortly show that both as-
sumptions are correct. First, let us suppose that J = (J, R, A) can be isomorphi-
cally embedded in N2 . We will refer to this isomorphic copy as J; no confusion
should arise because of this double usage. Furthermore, let us suppose that this
isomorphic image is deÔ¨Ånable in the monadic second-order language for N2 . That

 y) and A(P
 ) (containing 1 free indi-
is, suppose that there are formulas J(x),
R(x,
vidual variable x, 2 free individual variables x and y, and 1 free predicate variable
P , respectively) such that
J

= {t ‚àà T2 | N2 |= J(x)[t]},
 y)[t, t ]},
R = {(t, t ) ‚àà T2 √ó T2 | N2 |= R(x,
 )[U ]}.
A = {U ‚äÜ T2 | N2 |= A(P
Given these assumptions, it is easy to reduce the satisÔ¨Åability problem for the gen-
eral frame to the satisÔ¨Åability problem for S2S. First, with the help of the formula
 we can deÔ¨Åne a translation T from the modal language into the second-order
R,
language:
Tx (p) = P x,
Tx (¬¨œÜ) = ¬¨Tx (œÜ),
Tx (œÜ ‚àß œà) = Tx (œÜ) ‚àß Tx (œà),
 ‚àß Ty (œÜ)).
Tx (3œÜ) = ‚àÉy (Rxy
 replacing the use
Note that Tx is just the standard translation with the formula R
of a Ô¨Åxed relation symbol. We leave it as an exercise to show that for any modal
formula œÜ (built out of proposition letters p1 , . . . , pn ):
((J, R, A), V ), w  œÜ iff N2 |= Tx (œÜ)[w, V (p1 ), . . . , V (pn )].
(6.3)
(See Exercise 6.3.1; the notation [w, V (p1 ), . . . , V (pn )] means assign the state w
to the free variable x, and assign the subset V (pi ) to the predicate variable Pi .)
For any modal formula œÜ, let Sat-KvB(œÜ) be the following monadic second-order
sentence:
 1 ) ‚àß ¬∑ ¬∑ ¬∑ ‚àß A(P
 n ) ‚àß J(x)
 ‚àß Tx (œÜ)).
‚àÉP1 . . . ‚àÉPn ‚àÉx (A(P6 Computability and Complexity
352
It follows that œÜ is satisÔ¨Åable in (J, R, A) iff N2 |= Sat-KvB(œÜ). Thus ‚Äì given our
two initial assumptions ‚Äì we have effectively reduced the satisÔ¨Åability problem
for KvB to the S2S-satisÔ¨Åability problem, for œÜ is satisÔ¨Åable on J iff Sat-KvB(œÜ)
belongs to S2S, and by Rabin‚Äôs result it is possible to decide the latter.
Hence, to complete the proof that KvB is decidable, it only remains to show that
our assumptions were justiÔ¨Åed; that is, to show that J really does have a deÔ¨Ånable
isomorphic image in N2 . Given the expressive power at our disposal, this is actu-
ally rather easy to do. We will make use of the general predicates =, ROOT, and
F INITE deÔ¨Åned in (6.1) and (6.2). In addition, we will use
x <1 y iff r1 (x) ‚â§ y ‚àß ¬¨‚àÉz(x ‚â§ z ‚àß r0 (z) ‚â§ y).
Note that x <1 y means that x is a proper initial subsequence of y such that y
extends x by a Ô¨Ånite sequence of 1s ‚Äì or, in terms of tree geometry, it is possible to
move down from x to y by using only the ‚Äòsecond daughter‚Äô relation.
We will now deÔ¨Åne an isomorphic image of J in N2 . First, we can deÔ¨Åne the
numeric part of the underlying frame as follows:
N (x) iff ROOT (x) ‚à® ‚àÉy (ROOT (y) ‚àß y <1 x).
The isomorphism involved should be clear: the natural number zero is taken to be
the empty sequence, and the positive integer n is taken to be the sequence of n 1s.
Next, we will represent œâ by 0, and œâ + 1 by 00. DeÔ¨Åning these choices is easy:
O MEGA (x) iff ‚àÉy (ROOT (y) ‚àß x = r0 (y)),
O MEGA +1(x) iff ‚àÉy (ROOT (y) ‚àß x = r0 (r0 (y))).
 as follows:
Putting it all together, we deÔ¨Åne the required predicates J and R
J(x) = N x ‚à® O MEGA (x) ‚à® O MEGA +1(x),
 y) = (N y ‚àß (y <1 x ‚à® O MEGA (x))) ‚à® (O MEGA (y) ‚àß O MEGA +1(x)).
R(x,
Clearly these two formulas deÔ¨Åne a subset of the tree domain isomorphic to (J, R).
Thus it merely remains to deÔ¨Åne A, the class of allowable valuations. With the help
of the F INITE predicate, this is straightforward.
 ) iff
A(P

‚àÄx (P x ‚Üí J(x))
‚àß ((F INITE (P ) ‚àß ‚àÄz (O MEGA (z) ‚Üí ¬¨P z)) ‚à®
 ‚àß ¬¨P x) ‚Üí (F INITE (Q) ‚àß ‚àÄz (O MEGA (z) ‚Üí ¬¨Qz)))).
‚àÄQ‚àÄx (Qx ‚Üî (Jx
In short, a deÔ¨Ånable isomorphic image of J really does live inside N2 . We conclude
that KvB is decidable.
While the above result is a nice introduction to decidability via interpretation, in
one respect it is rather misleading. KvB is characterized by a single structure (and6.3 Decidability via Interpretations
353
a rather simple one at that) thus we only had to deÔ¨Åne a single isomorphic image,
and were able to do this fairly straightforwardly using S2S. However, as we saw
in Chapter 4, it is usual to characterize logics in terms of a class of structures;
for example, S4 is usually characterized as the logic of the class of reÔ¨Çexive and
transitive models. Do class-based characterizations mesh well with the idea of
decidability via interpretations? Classes of models may contain uncountable struc-
tures ‚Äì and only countable structures can be isomorphically embedded in Nn . And
why should we expect to be able to isomorphically embed even countable models
in inÔ¨Ånite trees?
Two simple observations clear the way. First, in many important cases, only
the countable structures in characterizing classes are required. Second, there is
a standard method for converting a model into a tree-based model, namely the
unraveling method studied in Chapters 2 and 4. Taken together, these observations
enable us to view the classes of structures characterizing many important logics
as a collection of deÔ¨Ånable substructures of Nœâ . We will illustrate the key ideas
involved by proving the decidability of S4 via interpretation in SœâS.
As a Ô¨Årst step, we claim that S4 is sound and strongly complete with respect to
the class of countable reÔ¨Çexive and transitive models. We could prove this directly
(for example, using the step-by-step method discussed in Section 4.6) but it also
follows from the following general observation. (Recall that for the duration of this
chapter, we are only working with countable languages.)
Theorem 6.20 If Œõ is a normal logic that is sound and strongly complete with re-
spect to a Ô¨Årst-order deÔ¨Ånable class of models M, then Œõ is also sound and strongly
complete with respect to the class of all countable models in M.
Proof. Left as Exercise 6.3.3.
Lemma 6.21 S4 is sound and strongly complete with respect to the class of count-
able (reÔ¨Çexive and transitive) trees.
Proof. By Theorems 4.29 and 6.20, S4 is sound and strongly complete with respect
to the class of countable reÔ¨Çexive, transitive models; that is, every S4-consistent
set of sentences Œ£ is satisÔ¨Åable on such a model M = (W, R, V ) at some point w.
 = (W
 , R,
 V
 ) be the unraveling of M
Now, (as in the proof of Theorem 4.54) let M
‚àó
‚àó
‚àó


around w, and let M be (W , R , V ), where R is the reÔ¨Çexive transitive closure
 this model is a reÔ¨Çexive transitive tree that veriÔ¨Åes Œ£ at its root. Moreover,
of R;
it is a countable model, for its nodes are all the Ô¨Ånite sequences of states in M that
start at w, and as M is countable, there are only countably many such sequences.
The result follows.
Corollary 6.22 S4 is decidable, and its decidability can be proved via interpreta-
tions.354
6 Computability and Complexity
Proof. Let us call a subset of Nœâ an initial subtree if it contains Œª and is closed
under the inverse of ‚â§ (that is, if y belongs to the subset, and x ‚â§ y, then x
belongs to the subset). If S is such a subtree, then ‚â§S denotes the restriction of
 , R)
 be the unraveling of some
‚â§ to S. Now for the key observation. Let (W
countable S4-frame (W, R) around a point w, and let R‚àó be the reÔ¨Çexive transitive
 Then (W
 , R‚àó ) is isomorphic to a pair (S, ‚â§S ) for some initial subtree
closure of R.
S. To see this, note that we can inductively construct an isomorphism f from
 , R‚àó ) to some initial subtree as follows. First, we stipulate that f maps the root
(W
 , R‚àó ) to Œª. Next, suppose that for some u ‚àà W
 , f (u) has been deÔ¨Åned to be
of (W



m. Now, {s ‚àà W | uRs} is a countable set as W is countable, so we can enumerate
its elements. Then, if s is the i-th element in this enumeration, we stipulate that
f (s) = ri (m). (That is, the successor of u that is i-th in our enumeration is mapped
to the i-th successor of m.) In short, Nœâ is ‚Äòwide enough‚Äô to accommodate a copy
of every branch through a tree-like S4 model in a very obvious way. In fact, it is
precisely because the required isomorphisms are so simple that we have elected to
work with Nœâ .
With this observed, the interpretation is easy to deÔ¨Åne. First, we deÔ¨Åne a predi-
cate I SUBTREE (S), which picks out the initial subtrees of Nœâ :
I SUBTREE (S) iff ‚àÉy (ROOT (y) ‚àß Sy) ‚àß ‚àÄz‚àÄu ((Sz ‚àß u ‚â§ z) ‚Üí Su).
Second, we deÔ¨Åne a predicate ‚â§S that deÔ¨Ånes the restriction of ‚â§ to a subset S of
Nœâ by
x ‚â§S y iff Sx ‚àß Sy ‚àß x ‚â§ y.
Third, we deÔ¨Åne a translation T œâ from the basic modal language to the monadic
second-order language for Nœâ . Like the translation T we used when proving the
decidability of KvB this translation is a simple variant of the standard translation.
In fact, it is identical to T save in the clause for modalities, which is given by:
œâ
œâ
Tx,S
(3œÜ) = ‚àÉy (x ‚â§S y ‚àß Ty,S
(œÜ)).
Note that as well as containing the free individual variable x, the translation of 3œÜ
contains a free set variable S; when written in full the above expression becomes:
œâ
œâ
Tx,S
(3œÜ) = ‚àÉy (Sx ‚àß Sy ‚àß x ‚â§ y ‚àß Ty,S
(œÜ)).
We need the free variable here because we are not working with one Ô¨Åxed isomor-
phic image (as we were when proving the decidability of KvB). Rather, we have
a separate relation for each initial subtree, and the presence of the free variable
allows all our deÔ¨Ånitions to be relativized in the appropriate way.
It simply remains to put it all together. Suppose œÜ is a modal formula constructed
out of the proposition letters p1 , . . . , pn . DeÔ¨Åne Sat-S4(œÜ) to be the following6.3 Decidability via Interpretations
sentence:
355

‚àÉS‚àÉP1 . . . ‚àÉPn ‚àÉx I SUBTREE (S) ‚àß
œâ
‚àÄz (P1 z ‚Üí Sz) ‚àß ¬∑ ¬∑ ¬∑ ‚àß ‚àÄz (Pn z ‚Üí Sz) ‚àß Sx ‚àß Tx,S
(œÜ) .
Recall that T œâ (œÜ) contains free occurrences of S and x; these become bound in this
sentence. Bearing this in mind, it is clear that this sentence asserts the existence of
an initial subtree S of Nœâ , a collection of n subsets Pi of this subtree, and a state
x in the subtree, that satisfy the translation of œÜ. That is, it asserts the existence
of a tree-like S4 model for the (translation of) œÜ, and we have reduced the S4-
satisÔ¨Åability problem to the SœâS-satisÔ¨Åability problem.
This completes our discussion of interpretations in SnS ‚Äì though we should imme-
diately admit that we have barely scratched the surface of the method‚Äôs potential:
Rabin‚Äôs theorem is very strong, the ideas underlying it make contact with many
branches of mathematics, and it has become a fundamental tool in many branches
of logic and theoretical computer science. Nonetheless, our discussion has un-
earthed themes relevant to modal logic: the importance of establishing complete-
ness results with respect to classes of countable structures, the use of unraveling
to produce tree-like models, and the particular utility of Nœâ in allowing reasonably
straightforward isomorphic embeddings. These three ideas enable a wide range of
modal decidability results to be proved via interpretations.
One Ô¨Ånal remark: while SnS is important, it is certainly not the only logical sys-
tem in which modal logics can be interpreted. Many fragments of classical logic,
or theories in classical logics, are known to be decidable, and offer opportunities
for proving modal decidability results. Indeed we have already met a (very simple)
example. We pointed out in Section 2.4 that the basic modal language translates
into the 2 variable fragment of classical logic, (see Proposition 2.49), from which it
immediately follows that K (and some simple extensions such as T) are decidable.
Moreover, on occasions it can be useful to interpret a modal logic in another modal
logic already known to be decidable. See the Notes for further discussion.
Exercises for Section 6.3
6.3.1 We claimed that the general frame for KvB is isomorphically embedded in the tree
 deÔ¨Ånes the accessibility relation of this isomorphic image. Check this
domain, and that R
claim, and show that
((W, R, A), V ), w  œÜ iff N2 |= Tx (œÜ)[w, V (p1 ), . . . , V (pn )],
for any modal formula œÜ (see (6.3)).
6.3.2 Show by interpretation in S2S that both the tense logic of the natural numbers, and
the tense logic of the integers, are decidable. Now add the until operator U to your language
(this operator was deÔ¨Åned in Chapter 2 in Exercise 2.2.4). Are the logics of the natural
numbers and the integers in this richer language still decidable?6 Computability and Complexity
356
6.3.3 Prove Theorem 6.20. That is, show that if Œõ is a normal logic that is sound and
strongly complete with respect to a Ô¨Årst-order deÔ¨Ånable class of models M, then Œõ is also
sound and strongly complete with respect to the class of all countable models in M. (Hint:
use the standard translation and the Downward L√∂wenheim-Skolem Theorem.)
6.4 Decidability via Quasi-models and Mosaics
In this section we will show that such familiar techniques as Ô¨Åltration can be em-
ployed to prove decidability, even for logics lacking the Ô¨Ånite model property. The
key move is simply to think more abstractly: instead of trying to work with Ô¨Ånite
models themselves, we will work with Ô¨Ånite structures which encode information
about models.
Quasi-models for KvB
For our Ô¨Årst example we will re-examine the logic KvB, which we proved de-
cidable in the previous section via interpretation in S2S. Recall that KvB is the
logic of a single general frame J whose universe J is N ‚à™ {œâ, œâ + 1}, and whose
accessibility relation is R. Also recall that KvB is an incomplete logic, which im-
plies that it does not have the Ô¨Ånite model property. Nonetheless, we can establish
the decidability of KvB using a Ô¨Åltration argument. We cannot use Ô¨Åltration to
build a Ô¨Ånite KvB model (no such model exists), but we can use it to build a Ô¨Ånite
quasi-model.
Consider a model M = (J, R, V ), where V is an admissible valuation for J.
What kind of Ô¨Åltration seems natural for this structure? If it were not for the point
œâ + 1, it is obvious that we would go for the transitive Ô¨Åltration. Very well then
‚Äì let us adopt the following procedure: Ô¨Årst delete the point œâ + 1, then take the
transitive Ô¨Åltration of the remainder of the frame, and Ô¨Ånally glue a copy of the
point œâ + 1 back on to the resulting Ô¨Ånite structure. Of course, we know that this
will not result in a Ô¨Ånite KvB model; but hopefully it will yield something from
which we can construct a KvB model.
First we need the notion of a closure of a set of sentences. We will not Ô¨Åltrate
through arbitrary subformula-closed sets of sentences; rather, we will insist on
working with sets of sentences that are closed under single negations as well.
DeÔ¨Ånition 6.23 (Closed Sets and Closures) A set of formulas Œ£ is said to be
closed if it is closed under subformulas and single negations. That is, if œÉ ‚àà Œ£ and
Œ∏ is a subformula of œÉ, then Œ∏ ‚àà Œ£; and moreover if œÉ ‚àà Œ£, and œÉ is not of the
form ¬¨Œ∏, then ¬¨œÉ ‚àà Œ£.
If Œì is a set of formulas, then Cl(Œì ), the closure of Œì , is the smallest closed set
of formulas containing Œì . Note that if Œì is Ô¨Ånite then so is Cl(Œì ). If Œì = {œÜ},6.4 Decidability via Quasi-models and Mosaics
357
where œÜ is any modal formula, then we usually write Cl(œÜ) for Cl({œÜ}) and call
this set the closure of œÜ.
Advanced track readers should note that they have already met a more elaborate
version of this idea when we proved the completeness of PDL: any Fischer-Ladner
closed set (see DeÔ¨Ånition 4.79) is closed in the sense of the previous deÔ¨Ånition.
Now for quasi-models. Let œÜ be some basic modal formula. A KvB quasi-
model for œÜ is a pair Q = (F, Œª) where:
(i) F = (Q, S) is a Ô¨Ånite frame, containing two distinct distinguished points
called c and ‚àû, that satisÔ¨Åes conditions F1‚ÄìF5 below; and
(ii) Œª is a function mapping states of F to subsets of Cl(œÜ) that satisÔ¨Åes the
conditions L0‚ÄìL3 below. We call Œª a labeling.
Let us Ô¨Årst consider the conditions F1‚ÄìF5. These are very simple, and should be
checked against Figure 6.2. If you read c as ‚Äòco-Ô¨Ånite‚Äô and view this element as the
quasi-model‚Äôs analog of œâ, and view ‚àû as the analog of œâ + 1, the resemblance
between Ô¨Ånite frames fulÔ¨Ålling these conditions and the frame (J, R) should be
clear.
(F1) On Q \ {‚àû}, S is trichotomous and transitive,
(F2) Scw iff w = ‚àû,
(F3) Swc iff w = c or w = ‚àû,
(F4) S‚àûw iff w = c, and
(F5) Sw‚àû for no w in Q.
Note that c is reÔ¨Çexive. Intuitively, the Ô¨Åltration process described above squashes
œâ down into a cluster.
There are also conditions on the labeling. One of these conditions is that every
label should be a Hintikka set. This is an important concept, and one we will use
again later in this chapter.
DeÔ¨Ånition 6.24 (Hintikka Sets) Let Œ£ be a subformula closed set of formulas.
A Hintikka set H over Œ£ is a maximal subset of Œ£ that satisÔ¨Åes the following
conditions:
(i) ‚ä• ‚àà H.
(ii) If ¬¨œÜ ‚àà Œ£, then ¬¨œÜ ‚àà H iff œÜ ‚àà H.
(iii) If œÜ ‚àß œà ‚àà Œ£, then œÜ ‚àß œà ‚àà H iff œÜ ‚àà H and œà ‚àà H.
It is important to realize that Hintikka sets also satisfy conditions such as the fol-
lowing: if œÜ ‚à® œà ‚àà Œ£, then œÜ ‚à® œà ‚àà H iff œÜ ‚àà H or œà ‚àà H. This is because in
this book we deÔ¨Åne ‚à® (and also ‚Üí, ‚Üî, and ) in terms of ‚ä•, ¬¨, and ‚àß (see DeÔ¨Å-
nition 1.12). Hintikka sets need not be satisÔ¨Åable (the reader is asked to construct358
6 Computability and Complexity
a non-satisÔ¨Åable Hintikka set in Exercise 6.4.2) but items (i) and (ii) above guar-
antee that they contain no blatant propositional contradictions. If a Hintikka set
is satisÔ¨Åable we call it an atom. Note that both the MCSs used to build canonical
models, and the special atoms used to prove the completeness of PDL are examples
of (consistent) Hintikka sets.
We are now ready for the quasi-model labeling conditions:
(L0) œÜ ‚àà Œª(w) for some w ‚àà Q,
(L1) Œª(w) is a Hintikka set, for each w ‚àà Q,
(L2) for all 3œà ‚àà Cl(œÜ), 3œà ‚àà Œª(w) iff œà ‚àà Œª(v) for some v with Swv,
(L3) if 3œà ‚àà Œª(w), then œà ‚àà Œª(v) for some v with Swv and not Svw.
We take the size of a quasi-model (Q, S, Œª) to be the size of its universe Q.
Lemma 6.25 Let œÜ be a formula in the basic modal language. Then œÜ is satisÔ¨Åable
in J if and only if there is a quasi-model for œÜ, of size at most 2|œÜ| .
Proof. We leave it to the reader to prove the left to right direction; this is simply a
matter Ô¨Ålling in the details of the ‚Äòdelete œâ + 1, Ô¨Åltrate, glue œâ + 1 back on‚Äô strategy
sketched above (the Ô¨Åltration must be made through Cl(œÜ)) and the upper bound
on the size of the quasi-model follows as in any Ô¨Åltration argument. So let us look
at the right to left direction.
Let Q = (Q, S, Œª) be a quasi-model for œÜ, let c and ‚àû be the distinguished
points of the quasi-model, and let Q0 denote the set Q \ {‚àû}. We now deÔ¨Åne an
equivalence relation ‚àº0 on Q0 by
w ‚àº0 v iff w = v or (Swv and Svw).
This really is an equivalence relation, and a more-or-less familiar one at that: the
equivalence class wÃÑ containing a reÔ¨Çexive point w is simply the cluster that w be-
longs to (see DeÔ¨Ånition 4.55), while the equivalence class wÃÑ containing an irreÔ¨Çex-
ive point w is simply {w}. The equivalence classes on Q0 are naturally ordered by
the relation + deÔ¨Åned as follows:
wÃÑ + vÃÑ iff Swv and not Svw.
It follows from F1 that + is a strict total ordering. Now consider an enumeration
q0 , q1 , . . . , qN of the elements of Q0 , such that q Ô¨Årst enumerates all elements of
the leftmost equivalence class, then all elements of its rightmost neighbor, and so
on. We may extend this enumeration to a map f : J ‚Üí Q by putting
‚éß
‚é® qw if w ‚â§ N ,
f (w) =
c
if w > N or w = œâ,
‚é©
‚àû if w = œâ + 1.
It is straightforward to check that for all w, v in J, Rwv implies Sf (w)f (v).6.4 Decidability via Quasi-models and Mosaics
359
Consider, for instance, the case where w = œâ; Rwv implies that v = n for some
natural number n. But then f (w) = c and f (v) ‚àà Q0 , so Sf (w)f (v) follows from
F2. The other cases are left to the reader. What we have shown is that
f is a homomorphism mapping (J, R) onto (Q, S).
(6.4)
Now consider the following valuation V on (J, R):
V (p) = {w ‚àà J | p ‚àà Œª(f (w))}.
It is easy to see that V is admissible in the general frame J: if œâ ‚àà V (p) then by
deÔ¨Ånition of V , n ‚àà V (p) for all n > N , so V (p) is co-Ô¨Ånite.
Hence, in order to prove the lemma, it is sufÔ¨Åcient to show that œÜ holds some-
where in the model (J, V ); but this follows from L0 and the following claim:
for all œà ‚àà Cl(œÜ), and all w ‚àà J: J, V, w  œà iff œà ‚àà Œª(f (w)).
(6.5)
We will prove this claim by induction on the complexity of œà. The base case, where
œà is a propositional variable, holds by deÔ¨Ånition of V , and the induction step for
the boolean connectives is trivial since Œª labels with Hintikka sets only. Hence,
the only interesting case is where œà is of the form 3œá. Note that the inductive
hypothesis applies to œá and that œá ‚àà Cl(œÜ) since the set is closed under taking
subformulas.
First assume that J, V, w  3œá. There is a state v with Rwv and v  œá.
By the fact that f is a homomorphism it is immediate that Sf (w)f (v), while the
inductive hypothesis implies that œá ‚àà Œª(f (v)). From this and L2 it follows that
3œá ‚àà Œª(f (w)).
Now suppose, in order to prove the other direction of (6.5), that 3œá ‚àà Œª(f (w)).
We have to show that J, V, w  3œá. Distinguish the following cases:
(i) w = œâ + 1. From this it follows that f (w) = ‚àû, so from L2 and the fact
(F4) that c is the only successor of ‚àû, it follows that œá ‚àà Œª(c). Hence from
c = f (œâ) and the inductive hypothesis it follows that œâ  œá. But then it is
immediate that œâ + 1  3œá.
(ii) w = œâ + 1. By L3 we may assume the existence of an element q ‚àà Q
satisfying Sf (w)q, not Sqf (w) and œá ‚àà Œª(q). It is obvious from Sf (w)q
and F 5 that q = ‚àû. Let v be a pre-image of q; from q = ‚àû it follows
that v = œâ + 1. Since R is trichotomous on J \ {œâ + 1}, we have Rvw
or w = v or Rwv. The Ô¨Årst two options are impossible: Rvw would imply
Sf (v)f (w), while w = v is incompatible with the fact that Sf (v)f (w) but
not Sf (w)f (v). Hence, we Ô¨Ånd that Rwv; but the induction hypothesis
gives v  œá, so indeed we have w  3œá.
This Ô¨Ånishes the proof of (6.5) and hence, of the lemma.360
6 Computability and Complexity
Theorem 6.26 The logic KvB is decidable.
Proof. By Lemma 6.25 it sufÔ¨Åces to show that it is decidable whether there is a
quasi-model for œÜ of size not exceeding 2|œÜ| . But this is easy to see: we Ô¨Årst
make a Ô¨Ånite list of all triples (Q, S, Œª) such that |Q| ‚â§ 2|œÜ| , S ‚äÜ Q √ó Q and
Œª : Q ‚Üí P(Cl(œÜ)); we then check for each member of this list whether it is a
quasi-model for œÜ. And clearly it is possible to write a terminating program which
does this.
The important lesson is that in order to prove decidability of a logic, not only Ô¨Ånite
models are useful: rather, any Ô¨Ånite structure that encodes a model is potentially
valuable. Now, the Ô¨Ånite structure employed in the previous example was still very
much like a model ‚Äì as our name ‚Äòquasi-model‚Äô indicates ‚Äì but in the general case
one can push the idea much further. The satisÔ¨Åability of œÜ does not need to be
witnessed by a Ô¨Ånite model for œÜ, or indeed by anything that looks very much like
a model; all we need is a Ô¨Ånite toolkit which contains the instructions needed to
construct a model for œÜ. The concept of a mosaic develops this line of thought.
Mosaics for the tense logic of the naturals
Consider the frame N = (N, <) with < the standard ordering of the natural num-
bers, and let Kt N be its tense logic. Kt N does not have the Ô¨Ånite model property
(see Exercise 6.4.1), but it is decidable, as we will now show using mosaics.
We use the following terminology and notation. For a given formula œÜ in the
basic temporal similarity type, let Cl(œÜ) denote the smallest set containing œÜ, P 
and F  which is closed under taking subformulas and single negations (cf. 4.79).
DeÔ¨Ånition 6.27 (Bricks) A brick is a pair b = (Œ¶, Œõ) such that Œ¶ and Œõ are
Hintikka sets satisfying
(B0) if F œà or œà belongs to Œõ, then F œà ‚àà Œ¶,
(B1) if P œà or œà belongs to Œ¶, then P œà ‚àà Œõ.
(B2) F  ‚àà Œõ.
A brick is called small if it satisÔ¨Åes, in addition:
(B3) if F œà ‚àà Œ¶, then either œà or F œà is in Œõ,
(B4) if P œà ‚àà Œõ, then either œà or P œà is in Œ¶.
What we are really interested in are sets of bricks satisfying certain saturation con-
ditions. A brick set B is a saturated set of bricks for œÜ (in short: a œÜ-SSB) if it
satisÔ¨Åes
(S0) for some (Œ¶, Œõ) ‚àà B, ¬¨P  ‚àà Œ¶ and œÜ ‚àà Œõ ‚à™ Œ¶,
(S1) for all (Œ¶, Œõ) ‚àà B, if F œà ‚àà Œõ then there is a (Œõ, Œì ) ‚àà B with œà ‚àà Œì ,6.4 Decidability via Quasi-models and Mosaics
361
(S2) for all (Œ¶, Œõ) ‚àà B there is a path of small bricks leading from Œ¶ to Œõ.
Here we say that a path of (small) bricks from Œ¶ to Œõ is a sequence (Œ¶0 , Œõ0 ), . . . ,
(Œ¶n , Œõn ) (n ‚â• 0) of (small) bricks such that Œ¶ = Œ¶0 , Œõ = Œõn and Œõi = Œ¶i+1
for all i < n. Finally, we simply deÔ¨Åne the size of an SSB B to be the number of
bricks in B.
The best way of grasping the intuitive meaning of these notions is by reading the
proof of the next lemma.
Lemma 6.28 If œÜ is satisÔ¨Åable in N, then there is a œÜ-SSB of size at most 22|œÜ| .
Proof. Assume that we have a valuation V on N such that œÜ is satisÔ¨Åed in the
model (N, V ). For any number n, let Œìn denote the truth set of n:
Œìn = {œà ‚àà Cl(œÜ) | N, V, n  œà}.
DeÔ¨Åne B as the set
B = {(Œìn , Œìm ) | n < m},
and call a brick sequential if it is of the form (Œìn , Œìn+1 ) for some number n. We
claim that B is a saturated set of bricks for œÜ.
We Ô¨Årst show that all elements of B are indeed bricks. Let (Œìn , Œìm ) with n < m
be an arbitrary element of B. For B0, assume that F œà or œà belongs to Œìm for some
m > n; we have to prove that F œà ‚àà Œìn . But from the assumption it easily follows
that N, V, k  œà for some k ‚â• m, and transitivity of the ordering gives k > n. So
it holds that N, V, n  œà, immediately yielding, as required, that F œà ‚àà Œìn . B1 is
proved in a similar way, and B2 is trivial to show.
It is likewise straightforward to prove the saturation conditions. For example,
in order to prove S0, let k be the point where œÜ is true, and consider the brick
(Œì0 , Œìn0 ) if n0 > 0, or the brick (Œì0 , Œì1 ) in case n0 = 0. It is immediate from
the deÔ¨Ånitions and assumptions that ¬¨P  ‚àà Œì0 and œÜ ‚àà Œì0 ‚à™ Œì1 . Proving S2
is straightforward from the observation that sequential bricks are small, and to see
why that is the case, take an arbitrary sequential brick (Œìn , Œìn+1 ). We only discuss
B3: assume that F œà ‚àà Œìn . By deÔ¨Ånition, N, V, n  F œà, so there must be some
m > n with m  œà. Note that either m = n + 1 or m > n + 1; in the Ô¨Årst case,
we obtain œà ‚àà Œìn+1 , in the second, F œà ‚àà Œìn+1 . In either case we have B3.
Finally, the collection {Œìn | n ‚àà N} is a subset of the power set of Cl(œÜ),
whence its cardinality does not exceed 2|œÜ| ; but then the size of B can be at most
(2|œÜ| )2 = 22|œÜ| .
We now show that we have recorded enough information in the deÔ¨Ånition of a
saturated set of bricks for œÜ to construct an N-based model for œÜ.
Lemma 6.29 If there is a œÜ-SSB, then œÜ is satisÔ¨Åable in N.362
6 Computability and Complexity
Proof. Assume that B is a saturated set of bricks for œÜ. We will use these bricks to
build, step by step, the required model for œÜ. As usual, in each Ô¨Ånite stage of the
construction we are dealing with a Ô¨Ånite approximation of this model: a history is a
pair (L, Œª) such that L is a natural number and Œª is a function on the set {0, . . . , L}
to the set of Hintikka sets. Such a history (L, Œª) is supposed to satisfy the following
constraints:
(H0) ¬¨P  ‚àà Œª(0),
(H1) for all m with m < L, (Œª(m), Œª(m + 1)) is a small brick.
We leave it to the reader to verify that any history (L, Œª) has the following proper-
ties:
(H2) if F œà ‚àà Œª(n) for some n < L, then there is some m with n < m ‚â§ L and
œà ‚àà Œª(m), or otherwise F œà ‚àà Œª(L),
(H3) if P œà ‚àà Œª(n) for some n ‚â§ L, then there is some m with m < n and
œà ‚àà Œª(m).
The importance of the properties H2 and H3 is that they show that the only essential
shortcomings of a history (regarded as a Ô¨Ånite approximation of a model) are of the
form ‚ÄòF œà ‚àà Œª(L), and there is no witness for this fact; that is, no m > L such that
œà ‚àà Œª(m).‚Äô
Of course, we are not going to use histories in isolation; we say that one history
(L , Œª ) is an extension of another history (L, Œª), notation: (L, Œª)  (L , Œª ), if
L < L , while Œª and Œª agree on the domain of Œª. The crucial extension lemma of
the step-by-step construction is given in the following claim:
Every history (L, Œª) with F œà ‚àà Œª(L)
has an extension (L , Œª ) such that œà ‚àà Œª (L ).
(6.6)
To prove (6.6), let (L, Œª) be a history and œà a formula such that F œà ‚àà Œª(L). It
follows from H1 that (Œª(L ‚àí 1), Œª(L)) is a brick, so by S1 there is a brick (Œ¶, Œõ)
in B such that Œ¶ = Œª(L) and œà ‚àà Œõ. We now use S2 to Ô¨Ånd a path of small bricks
(Œ£0 , Œ£1 ), (Œ£1 , Œ£2 ), . . . , (Œ£k‚àí1 , Œ£k ), such that Œ£0 = Œ¶ and Œ£k = Œõ. Obviously
we are going to ‚Äòglue‚Äô this path to the old history, thus creating a new history
(L , Œª ). To be precise, L is deÔ¨Åned as L = L + k, while Œª is given by
Œª (n) =
Œª(n) if n ‚â§ L,
Œ£i
if n = L + i.
With this deÔ¨Ånition (L , Œª ) satisÔ¨Åes the condition of (6.6).
Using (6.6), by a standard step-by-step construction one can deÔ¨Åne a sequence
(L0 , Œª0 )  (L1 , Œª1 )  . . . of histories such that ¬¨P  ‚àà Œª0 (0) and œÜ ‚àà Œª0 (0) ‚à™
Œª(L0 ), while for each i and each formula F œà ‚àà Œªi (Li ) there is a j > i and a
number Li < m ‚â§ Lj such that œà ‚àà Œªj (m). This sequence of nested histories will6.4 Decidability via Quasi-models and Mosaics
363
be our guideline for the deÔ¨Ånition of a valuation on N. Note that for all formulas
œà and all i and n, we have that
if n ‚â§ Li , then œà ‚àà Œªi (n) iff œà ‚àà Œªj (n) for all j ‚â• i.
In other words, the histories always agree where they are deÔ¨Åned; this fact will be
used below without explicit comment.
Now consider the following valuation V on N:
V (p) = {n ‚àà N | p ‚àà Œªi (n) for some i}.
We are now ready to prove the crucial claim of this lemma.
For all œà ‚àà Cl(œÜ) and all n: N, V, n  œà iff œà ‚àà Œªi (n) for some i.
(6.7)
Obviously, (6.7) will be proved by induction on œà. The base step and the boolean
cases of the induction step are straightforward and we leave them to the reader; we
concentrate on the modal cases.
First assume that œà is of the form F œá. For the direction from left to right,
assume that N, V, n  F œá. There must be a number m > n with m  œá; so by the
inductive hypothesis, there is an i with œá ‚àà Œªi (m). It is easy to show (by backward
induction and H1) that this implies F œá ‚àà Œªi (k) for all k with n ‚â§ k < m.
For the other direction, assume that F œá ‚àà Œªi (n) for some i. It follows from H2
that there is either a number m with n < m ‚â§ Li and œá ‚àà Œªi (m), or otherwise
F œá ‚àà Œªi (Li ). In the Ô¨Årst case we use the inductive hypothesis to establish that
m  œá and hence, n  F œá. Hence, assume that we are in the other case: F œá ‚àà
Œªi (Li ). Now our sequence of histories is such that this implies the existence of a
history (Lj , Œªj ) with j > i and such that œá ‚àà Œªj (m) for some m with Li , m ‚â§ Lj .
It follows from the inductive hypothesis that m  œá; thus the truth deÔ¨Ånition gives
us that n  F œá.
Now assume that œà is of the form P œá. The direction from left to right is as in
the previous case. For the other direction, assume that P œá ‚àà Œªi (n) for some i; it
follows by H3 that there is an m < n with œá ‚àà Œªi (m). The inductive hypothesis
yields that M, V, m  œá, so by the truth deÔ¨Ånition we get n  F œá.
Theorem 6.30 Kt N is decidable.
Proof. Immediate by Lemmas 6.28 and 6.29, and the obvious fact that it is decid-
able whether there is a œÜ-SSB of size at most 22|œÜ| .
A wide range of modal satisÔ¨Åability problems can be studied in using quasi-models
and mosaics. Indeed, such methods are not only useful for establishing decidability
results, they can be used to obtain complexity results as well; see the Notes for
further references.6 Computability and Complexity
364
Exercises for Section 6.4
6.4.1 Prove that K t N does not have the Ô¨Ånite model property.
6.4.2 Give an example of an unsatisÔ¨Åable Hintikka set. (Hint: work with the closure of
{2(p ‚àß q), ¬¨2p, ¬¨2q}.)
6.4.3 Extend our proof of the decidability of the tense logic of the natural numbers to a
similarity type including the next time operator X. The semantics of this operator is given
by
(N, V ), n  XœÜ iff (N, V ), n + 1  œÜ.
6.4.4 Let F2 be the class of frames for the basic modal similarity type in which every point
has exactly two successors. Use a mosaic argument to prove that this class has a decidable
satisÔ¨Åability problem.
6.4.5 In this exercise we consider a version of deterministic PDL in which every program
is interpreted as a partial function ‚Äì at least, in the intended semantics. The syntax of this
language is given by
œÜ
œÄ
::= p | ‚ä• | ¬¨œÜ | œÜ1 ‚àß œÜ2 | œÄœÜ (p a proposition letter),
::= a | œÄ1 ; œÄ2 | if(œÜ, œÄ1 , œÄ2 ) | repeat(œÄ, œÜ) (a an atomic program).
In a regular model M for this language, each relation R a is a partial function, and the com-
posed programs obtain the obvious interpretation. That is, R œÄ1 ;œÄ2 is the relational compo-
sition of RœÄ1 and RœÄ1 ; Rif (œÜ,œÄ1 ,œÄ2 ) st holds if either M, s  œÜ and R œÄ1 st or else M, s  œÜ
and RœÄ2 st. Finally, we have R repeat(œÄ,œÜ) st if there is a path sRœÄ t1 RœÄ t2 . . . RœÄ tn = t of
length n ‚â• 1 from s to t such that t = t n is the Ô¨Årst ti where œÜ holds.
(a) Prove that in a regular model, each program œÄ is interpreted as a partial function.
(b) Prove that the class of regular models has a decidable theory over this language.
(Hint: use bricks of the form (Œ¶, Œõ, Œ†) where Œ¶ and Œõ are Hintikka sets and Œ† is
a set of programs closed under some natural conditions associating a unique ‚ÄòÔ¨Årst‚Äô
atomic program with the brick. Also, make sure that any formula œÄœÜ ‚àà Œ¶ induces
a unique formula of the form aœÜ  ‚àà Œ¶.)
6.5 Undecidability via Tiling
There are lots of undecidable modal logics; indeed, even uncountably many with
the polysize model property (see Exercise 6.2.4). Moreover, there are undecid-
able modal logics which in many other ways are rather well-behaved (we saw an
example in Exercise 6.2.5). Nice as they are, these examples do not really make
clear just how easily undecidable modal logics can arise, nor how serious the un-
decidability can be. This is especially relevant if we are working with the richer
modal languages (such as PDL) typically used in computer science and other appli-
cations, and the Ô¨Årst goal of this section is to show that natural (and on the face of it,
straightforward) ideas can transform simple decidable logics into undecidable (or
even highly undecidable) systems. While the examples are interesting in their own
right, this section has a second goal: to introduce the concept of tiling problems.6.5 Undecidability via Tiling
365
Given a modal satisÔ¨Åability problem S, to prove that S is undecidable we must
reduce some known undecidable problem U to S. But which problems are the
interesting candidates for reduction? Unsurprisingly, there is no single best answer
to this question. As with decidability proofs, proving undecidability is something
of an art: it can be very difÔ¨Åcult, and there is no substitute for genuine insight
into the satisÔ¨Åability problem. Certain problems lend themselves rather naturally
to modal logic, and tiling problems are a particularly nice example.
What is a tiling problem? In essence, a jigsaw puzzle. A tile T is simply a 1 √ó 1
square, Ô¨Åxed in orientation, each side of which has a color. We refer to these four
colors as right(T ), left(T ), up(T ), and down(T ). Figure 6.3 depicts an example.
(We have used different types of shading to represent the different colors.)
@
@
@
@
ssss
ssss
@ ssssss @
@ ssssss @
@
@
@s
@
@
ss
sss@
@
@
@
@
s
@
@ s s s@
@
@
@
Fig. 6.3. Six distinct tile types
Six tiles are shown in Figure 6.3. Note that if we rotated the third tile 180
degrees clockwise, it would look just like the fourth tile, and that if we rotated the
Ô¨Årst tile 180 degrees clockwise it would look just like the sixth tile. We ignore
such similarities. (This is what we meant when we said that tiles are ‚ÄòÔ¨Åxed in
orientation.‚Äô) That is, the diagram shows six distinct types of tile.
Now for a simple tiling problem:
Is it possible to arrange tiles of the type just shown on a 2 √ó 4 grid in such a
way that adjacent tiles have the same color on the common side?
A little experimentation shows that this is possible. A solution is given in Fig-
ure 6.4.
ssss
@ ssssss @
@
@
@
@s
@
@
ss
ssss@
@
@
@
s
s
s
@
@
@
@
sssssss
@
@ sss
@
@
@s
@
@
@
s ss
@
@
@
ssss@
s@
s
@
@
@
Fig. 6.4. A 2 √ó 4 tiling
This simple idea of pattern-matching underlying tiling problems gives rise to a
family of problems which can be used to analyze computational complexity and
demonstrate undecidability. This is the general form that tiling problems take:366
6 Computability and Complexity
Given a Ô¨Ånite set of tile types T , can we cover a certain part of Z √ó Z in such
a way that adjacent tiles have the same color on the common edge? (Below,
covering a grid with tiles so that adjacent colors match will be called ‚Äòtiling.‚Äô)
Some tiling problems impose additional constraints on what counts as a successful
tiling (we will shortly see an example) and some are formulated as games to be
played between two players (we will see an example at the end of this chapter).
To spell this out somewhat, we might describe our previous example as an in-
stance of the 2 √ó 4 tiling problem. That is, we were given a Ô¨Ånite set of tile types
(six, to be precise), asked to tile a 2 √ó 4 grid, and no further constraints were im-
posed. In the remainder of this section, we are going to make use of two much
harder tiling problems. The Ô¨Årst is the:
N √ó N tiling problem. Given a Ô¨Ånite set of tile types T , can T tile N √ó N?
Here is a simple instance of this problem: can we tile N √ó N using the six tile types
shown? Of course! We need simply ‚Äòslot-together‚Äô copies of our solution to the
2 √ó 4 problem.
In general, however, the N √ó N tiling problem is hard, and in fact it is known to
be undecidable. Indeed, this problem is Œ†10 -complete; that is, it is a paradigmatic
example of ‚Äòordinary undecidability.‚Äô (See Appendix C for further discussion of
degrees of undecidability.) We will not prove this result here ‚Äì see the Notes for
references ‚Äì but it is really quite straightforward: think of each row of tiles as
encoding Turing machine tapes and states, and the matching process as governing
the state transitions.
The second problem we will use is the:
N √ó N recurrent tiling problem. Given a Ô¨Ånite set of tile types T , which
includes some distinguished tile type T1 , can T tile N √ó N in such a way that
T1 occurs inÔ¨Ånitely often in the Ô¨Årst row?
As an easy example, note that our previous six tile types recurrently tile N √ó N
when either the Ô¨Årst, the third, the fourth, or the sixth tile type is distinguished.
Now our new problem is just the N √ó N tiling problem with an additional con-
straint imposed ‚Äì but what a difference this constraint makes! Not only is this
problem undecidable, it is Œ£11 -complete (again, see Appendix C).
We will prove two modal undecidability results with the aid of these problems.
Both examples are based around a natural variant of Deterministic Propositional
Dynamic Logic, with intersection replacing choice and iteration as program con-
structors; we call this variant KR. We obtain our undecidability results as follows.
First we enrich KR with the global modality. As we will show, the combination of
the intersection construct with the global modality is a powerful one: it is possible
to give an extremely straightforward reduction of the N √ó N tiling problem. We6.5 Undecidability via Tiling
367
then enrich KR with a modality called the master modality. This is also a natural
operator ‚Äì indeed, perhaps more natural than the global modality. As a very easy
reduction from the N √ó N recurrent tiling problem reveals, the resulting system is
highly undecidable.
Intersection and the global modality
Our Ô¨Årst example vividly illustrates how easily undecidability can arise. We are
going to mix two simple ingredients together, both of which are decidable, and
show that the result has an undecidable satisÔ¨Åability problem.
The Ô¨Årst ingredient is a variant of DPDL, with intersection replacing choice and
iteration as program constructors. Recall from Example 1.15 that DPDL is simply
PDL interpreted over deterministic PDL structures (that is, PDL structures in which
the relations Ra corresponding to atomic programs a are partial functions). Further,
recall from Example 1.26 that modalities built with the intersection constructor
(that is, modalities of the form œÄ1 ‚à© œÄ2 ) are interpreted by the relation RœÄ1 ‚à© RœÄ2 ,
where RœÄ1 is the relation corresponding to œÄ1  and RœÄ2 the relation corresponding
to œÄ2 .
In what follows we will not use the entire language; instead we will work with a
fragment (called KR) which consists of all formulas without occurrences of ‚àó and
‚à™. That is, KR contains precisely the following formulas œÜ:
œÜ ::= p | ‚ä• | ¬¨œÜ | œÜ1 ‚àß œÜ2 | œÄœÜ
œÄ ::= a | œÄ1 ; œÄ2 | œÄ1 ‚à© œÄ2
(p a proposition letter),
(a an atomic program).
The KR language is rather simple: essentially it allows us to state whether or not
different sequences of (deterministic) programs terminate in the same state when
executed in parallel. Note that (over deterministic PDL structures) a selection argu-
ment immediately shows that KR has a decidable satisÔ¨Åability problem. Over deter-
ministic structures, every modal operator in KR is interpreted by a partial function.
(This is because all atomic programs are modeled by partial functions, and the only
program constructors we have at our disposal are composition and intersection.) It
follows that if a sentence œÜ from KR is satisÔ¨Åable in a deterministic model, then it
is satisÔ¨Åable in a Ô¨Ånite deterministic model; the proof is essentially the same as that
of Corollary 6.9.
The second ingredient is even simpler. We are going to add the global modality
A to our fragment. This is an interesting operator that we are going to discuss
in detail in Section 7.1; for present purposes we only need to know two things
about it. First, it is interpreted as follows: M, w  AœÜ if for all v in M we have
M, v  œÜ. Thus, as its name suggests, the global modality is a modal operator
which allows us to express global facts. Second, A has a decidable satisÔ¨Åability368
6 Computability and Complexity
problem. (To see this, simply observe that A is an S5 operator, and we know that
S5 is decidable.) Thus, on its own, A is pretty harmless.
But what happens when we add A to KR? The resulting language called KRA can
talk about computations in a very natural (and very powerful) way. For example,
A(a ‚Üí œà)
expresses that in every state of a computation, œà is a precondition for the program
a to have a terminating execution. As we will now show, KRA has crossed the
border into undecidability.
Theorem 6.31 Assume that the language has at least two atomic programs. Then
the satisÔ¨Åability problem for KRA is undecidable. To be precise, it is Œ†10 -hard.
Proof. We show this by reducing the N √ó N tiling problem to the KRA satisÔ¨Åability
problem; the undecidability (and Œ†10 -hardness) of the satisÔ¨Åability problem will
follow from the known undecidability (Œ†10 -hardness) of the N √ó N tiling problem.
Recall that the N√óN tiling problem asks: given a Ô¨Ånite set of tile types T , can T
tile N √ó N? Putting this more formally: does there exist a function t : N √ó N ‚Üí T
such that
right (t(n, m)) = left(t(n + 1, m)),
up(t(n, m)) = down(t(n, m + 1))?
We will reduce N √ó N tiling to the satisÔ¨Åability problem as follows. Let T =
{T1 , . . . , Tk } be the given set of tile types. We will construct a formula œÜT such
that
T tiles N √ó N iff œÜT is satisÔ¨Åable.
(6.8)
If we succeed in constructing such a formula it follows that the KRA-satisÔ¨Åability
problem is undecidable. (For suppose it was decidable. Then we could solve the
N √ó N tiling problem as follows: given T , form œÜT , and use the putative KRA-
satisÔ¨Åability algorithm to check for satisÔ¨Åability. By (6.8) this would solve the
tiling problem ‚Äì which is impossible.)
The construction of œÜT proceeds in three steps. First, we show how to use KRA
to demand ‚Äògridlike‚Äô models. Second, we show how to use KRA to demand that a
tiling exists on this ‚Äògrid.‚Äô Finally we prove (6.8).
Step 1. Forcing the grid. The basic idea is to let the nodes in M mimic the nodes
in N √ó N, and to use two relations Rr and Ru to mimic the ‚Äòto-the-right‚Äô and the
‚Äòup‚Äô functions of N √ó N. To get the gridlike model we want, we simply demand
that Rr and Ru commute:
œÜgrid := A(r ; u) ‚à© (u ; r).6.5 Undecidability via Tiling
369
This says that everywhere in the model it is possible to make a ‚Äòto-the-right transi-
tion followed by an up transition‚Äô and an ‚Äòup transition followed by a to-the-right
transition,‚Äô and both these transition sequences lead to the same point. (Note that
this is all we need to say, since by assumption Rr and Ru are partial functions.)
Step 2. Tiling the model. We will ‚Äòtile the model‚Äô by making use of proposition
letters t1 , . . . , tk which correspond to the tile types in T . The basic idea is simple:
we want ti to be true at a node w iff a tile of type Ti is placed on w. Of course, not
any placement of tiles will do: we want a genuine tiling. But the following three
demands ensure this:
(i) Exactly one tile is placed at each node:
‚éõ
‚éû
k

œÜ1 := A ‚éù ti ‚àß
¬¨(ti ‚àß tj )‚é† .
i=1
1‚â§i<j‚â§k
(ii) Colors match going right:
‚éõ‚éû
œÜ2 := A ‚éù(ti ‚àß rtj )‚é† .
right (Ti )=left (Tj )
(iii) Colors match going up:
‚éõ‚éû
œÜ3 := A ‚éù(ti ‚àß utj )‚é† .
up(Ti )=down (Tj )
Putting this together, we deÔ¨Åne œÜT := œÜgrid ‚àß œÜ1 ‚àß œÜ2 ‚àß œÜ3 .
Step 3. Proving the equivalence. We now show that (6.8) holds. Assume Ô¨Årst
that t : N √ó N ‚Üí T is a tiling of N √ó N. Construct a satisfying model for œÜT as
follows:
W
= {wn,m | n, m ‚àà N},
Rr = {(wn,m , wn+1,m ) | n, m ‚àà N},
Ru = {(wn,m , wn,m+1 ) | n, m ‚àà N},
V (ti ) = {wn,m | n, m ‚àà N and t(n, m) = Ti }.
Clearly, œÜT holds at any state w of M.
For the converse, let M be a model such that M, w0  œÜT . It follows from
M, w0  œÜgrid that there exists a function f : N √ó N ‚Üí W such that f (0, 0) = w0 ,
Rr f (n, m)f (n + 1, m) and Ru f (n, m)f (n, m + 1). DeÔ¨Åne the tiling t : N √ó N ‚Üí
T by
t(n, m) = Ti iff M, f (n, m)  ti .
By œÜ1 , t is well-deÔ¨Åned and total. Moreover, if t(n, m) = Ti and t(n+1, m) = Tj ,370
6 Computability and Complexity
then Rr f (n, m)f (n + 1, m), and both M, f (n, m)  ti and M, f (n + 1, m) 
tj . Given that w0 satisÔ¨Åes œÜ2 , we conclude that right(Ti ) = left(Tj ). Similarly,
because of œÜ3 , if t(n, m) = Ti and t(n, m + 1) = Tj , then up(Ti ) = down(Tj ).
Thus, T tiles N √ó N.
The above proof clearly depends on having two deterministic atomic programs at
our disposal. But what happens if we only have one? It should be clear that then
‚à© cannot do any interesting work for us, and in fact the language has a decidable
satisÔ¨Åability problem; see Exercise 6.5.1.
We now know that KRA-satisÔ¨Åability is undecidable (given more than one atomic
program) but how undecidable is it? In particular can we also prove a Œ†10 upper
bound to match the Œ†10 -hardness result? (That is, can we show that we are dealing
with a case of ‚Äòordinary undecidability‚Äô?) To prove this, it sufÔ¨Åces to show that the
validities of KRA form an r.e. set. Now we could do this by devising a recursive
axiomatization of the KRA-validities, but by making use of a general lemma from
correspondence theory we can establish the result more straightforwardly.
Lemma 6.32 If K is a class of frames deÔ¨Åned by a Ô¨Årst-order formula, then its
modal logic is recursively enumerable.
Proof. Assume that the Ô¨Årst-order formula Œ± deÔ¨Ånes K, where Œ± is built using only
relation symbols of arity 2 or higher, and identity. Then, a modal formula œÜ is valid
on K iff it is valid on all frames in K iff
Œ± |= ‚àÄx‚àÄP1 . . . ‚àÄPn ST x (œÜ),
(6.9)
where P1 , . . . , Pn are unary predicate symbols corresponding to the proposition
letters in œÜ. As the predicate variables P1 , . . . , Pn do not occur in Œ±, (6.9) is
equivalent to Œ± |= ‚àÄx ST x (œÜ). But this is an ordinary Ô¨Årst-order implication,
which is an r.e. notion. Hence, modal validity on K is an r.e. notion as well.
Theorem 6.33 Assume that our language has at least two, but at most Ô¨Ånitely
many atomic programs. Then the satisÔ¨Åability problem for KRA is Œ†10 -complete.
Proof. The Œ†10 lower bound is given by the encoding of the N √ó N tiling problem
in the proof of Theorem 6.31. For the Œ†10 upper bound we show that the validity
problem for KRA is r.e. The standard translations for the constructors ; and ‚à© are
given in Section 2.4; both are Ô¨Årst-order. (Recall that the ‚àó constructor is the only
part of PDL that takes us out of Ô¨Årst-order logic.) The standard translation for A is
obvious (and clearly Ô¨Årst-order):
ST x (AœÜ) = ‚àÄy ST y (œÜ).
Thus ‚Äì assuming we are working with a language of KRA that contains at most6.5 Undecidability via Tiling
371
Ô¨Ånitely many atomic programs ‚Äì the required class of frames is deÔ¨Åned by

‚àÄxyz (RŒ± xy ‚àß RŒ± xz ‚Üí y = z).
Œ± atomic
Hence, by Lemma 6.32, the modal logic of the class of frames for KRA is r.e. as
required.
Intersection and the master modality
Our next example illustrates how easily high undecidability can arise. Once again,
we will enrich the KR language, but this time with the master modality. As we will
see, the resulting language KR[‚àó] has a Œ£11 -complete satisÔ¨Åability problem.
Like the global modality, the master modality [‚àó] is a tool for expressing general
constraints in the object language, but it works rather differently. A formula of
the form [‚àó]œÜ is true at a node w iff œÜ is true at all nodes reachable by any Ô¨Ånite
sequence of atomic transitions from w. Formally,

‚àó
w  [‚àó]œÜ iff v  œÜ for all v such that (w, v) ‚àà
Ra
.
a atomic
That is, [‚àó] explores the reÔ¨Çexive transitive closure of the union of all the relations
used to interpret the atomic programs. If we only have Ô¨Ånitely many atomic pro-
grams a1 , . . . , an , the master modality is simply shorthand for the PDL modality
[(a1 ‚à™¬∑ ¬∑ ¬∑‚à™an )‚àó ]. From a computational perspective, this modality is arguably even
more natural than the global modality: it is a way of looking at what must happen
throughout the space of possible computations. (It has other natural interpretations
as well. For example, if we interpret our basic modalities as in multi-agent epis-
temic logic ‚Äì that is, [a]œÜ means ‚Äòagent a knows that œÜ‚Äô ‚Äì then [‚àó] is the ‚Äòcommon
knowledge‚Äô operator.)
But, for all its naturalness, the master modality can be extremely dangerous.
Let us see what happens when we add it to KR. First, observe that KR[‚àó] must
be undecidable. (There is nothing new to prove here; simply observe that if we
systematically replace every occurrence of A in the proof of Theorem 6.31 by
[‚àó], the argument still goes through.) But can we prove a matching Œ†10 upper
bound? We certainly cannot appeal to Lemma 6.32; while the global modality
was essentially Ô¨Årst-order, the master modality is not. (As with the ‚àó constructor
of PDL, its natural correspondence language is inÔ¨Ånitary; see Section 2.4.) And
indeed, any attempt to recursively enumerate the validities of KR[‚àó] is bound to
fail.
Theorem 6.34 The satisÔ¨Åability problem for KR[‚àó] is highly undecidable. To be
precise, it is Œ£11 -hard.372
6 Computability and Complexity
Proof. We show this by reducing the recurrent tiling problem to the KR[‚àó]-satisÔ¨Åa-
bility problem; the Œ£11 -hardness of the satisÔ¨Åability problem will follow from the
known Œ£11 -hardness of the recurrent tiling problem.
Recall that the recurrent tiling problem asks: given a Ô¨Ånite set of tile types T ,
which includes some distinguished tile type T1 , can T tile N √ó N in such a way that
T1 occurs inÔ¨Ånitely often in the Ô¨Årst row? Putting this more formally: does there
exist a function t : N √ó N ‚Üí T such that
right(t(n, m)) = left(t(n + 1, m)),
up(t(n, m)) = down(t(n, m + 1)),
{n | t(n, 0) = T1 }
is inÔ¨Ånite?
We reduce N √ó N recurrent tiling to KR[‚àó]-satisÔ¨Åability as follows. Let T =
{T1 , . . . , Tk } be the set of tile types. We will deÔ¨Åne a formula œÜT ,T1 such that
T and T1 recurrently tile N √ó N iff œÜT ,T1 is satisÔ¨Åable.
(6.10)
Most of the real work was done in the proof of Theorem 6.31. Let us simply
take the earlier encoding œÜT and replace every occurrence of A with [‚àó]. Call the
result œÜ‚àóT . This formula reduces the N √ó N tiling problem to the KR[‚àó]-satisÔ¨Åability
problem.
To reduce the recurrent tiling problem, it remains to ensure that our distin-
guished tile T1 occurs inÔ¨Ånitely often on the Ô¨Årst row. As t1 is the proposition
letter corresponding to T1 , this means we want to force t1 to be true at nodes of the
form t(n, 0) for inÔ¨Ånitely many n. To do this, we will introduce a new proposition
letter Ô¨Årst-row and then deÔ¨Åne:
œÜrec := Ô¨Årst-row ‚àß [‚àó][u]¬¨Ô¨Årst-row ‚àß [‚àó](Ô¨Årst-row ‚Üí r‚àó(Ô¨Årst-row ‚àß t1 )).
Suppose that œÜrec is satisÔ¨Åed at some point w0 of a grid-like model. It follows that
Ô¨Årst-row is satisÔ¨Åed at w0 ; that Ô¨Årst-row can only be satisÔ¨Åed at points reachable
by a Ô¨Ånite number of Rr transitions from w0 ; and that for inÔ¨Ånitely many distinct
natural numbers n, w0  rn (Ô¨Årst-row ‚àß t1 ).
So, let œÜT ,T1 be the conjunction of œÜ‚àóT and œÜrec . Then (6.10) holds.
To conclude this section, two general remarks. First, the examples in this section
were clearly chosen to make the undecidability proofs run as smoothly as possible.
In particular, our examples hinged on the use of ‚à© to force the existence of the
grid. What happens if we are working in languages without this constructor? That
is, how widely applicable is this method for proving undecidability?
Suppose we are working with an arbitrary modal language, and we want to es-
tablish the undecidability of its satisÔ¨Åability problem. If we abstract from the proof
of Theorem 6.31, we see that there is one ingredient that will always be needed
to make similar arguments go through: sufÔ¨Åcient ‚Äòglobal‚Äô expressive power. This6.6 NP
373
power may arise directly through the presence of additional operators, or it may
arise indirectly through special features of the class of models under consideration,
but one way or another we will need it. On the other hand, we do not need the ‚à©
constructor; Exercise 6.5.2 is a nice example.
Second, we have discussed tiling problems as if they were useful only for estab-
lishing different grades of undecidability. In fact, they can also be used to analyze
the complexity of decidable problems: for example, there are NP-hard, PSPACE-
hard, and EXPTIME-hard tiling problems (see the Notes for further references).
At the end of this chapter we will use a 2-player tiling problem to show that the
satisÔ¨Åability problem for PDL is EXPTIME-hard.
Exercises for Section 6.5
6.5.1 Show that KRA-satisÔ¨Åability is decidable if we have only one atomic program at our
disposal. (This result can be proved via a Ô¨Ånite model property argument.)
6.5.2
(i) Show that the satisÔ¨Åability problem of the following ‚Äòtiling‚Äô logic Tile 1 is
undecidable. Tile 1 is a normal modal logic with three diamonds u, r and 3,
deÔ¨Åned by the following (Sahlqvist) axioms:
up ‚Üí [u]p and rp ‚Üí [r]p,
rup ‚Üí [u]rp,
33p ‚Üí 3p,
up ‚Üí 3p and rp ‚Üí 3p.
(6.11)
(ii) Now use this logic plus the standard translation to conclude that the three variable
fragment of Ô¨Årst-order logic (without function symbols, but possibly with equality)
is undecidable.
(iii) Let Tile2 be obtained from Tile 1 by omitting axiom (6.11). Show that Tile 2
is still undecidable. (Hint: Reduce the satisÔ¨Åability problem of Tile 1 to that of
Tile2 .)
(iv) Conclude that Ô¨Årst-order logic with three variables, but without equality is unde-
cidable.
(v) Use a similar tiling logic to show that Ô¨Årst-order logic with one variable, two unary
function symbols, and only unary predicate symbols is undecidable. (Hint: adjust
the standard translation so that it exploits the unary function symbols directly.)
6.6 NP
The interpretation method (and in particular, interpretations in SnS) is a powerful
and widely applicable way of proving decidability. Nevertheless, it has disadvan-
tages. Reducing the satisÔ¨Åability problems of what are often rather simple modal
logics to SnS is using a sledgehammer to crack a nut. The decision problem for
SnS is non-elementary. This means that the time required to decide whether an374
6 Computability and Complexity
arbitrary formula œÜ is decidable cannot be bounded by any Ô¨Ånite tower of expo-
nentials of the form
. . 2|œÜ|
2.
2
.
The use of Ô¨Åltrations to establish decidability is open to similar objections. A
Ô¨Åltration is typically 2|œÜ| in the size of the input formula. But it is not feasible to
enumerate all the models up to this size even for quite small values of |œÜ|. And
even a nondeterministic Turing machine, which could ‚Äòguess‚Äô a Ô¨Åltration in one
move (see Appendix C and the discussion below), would still be faced with the
immensely costly task of checking that œÜ was true on this huge structure (to use
the terminology discussed in Appendix C, Ô¨Åltrations typically offer us NEXPTIME
algorithms). Indeed, of the three decidability techniques discussed so far, only
the mosaic method (which ‚Äòdeconstructs‚Äô models locally) respects what is special
about modal logic; and as we will learn in Section 7.4, the mosaic method can be
used to give essentially optimal satisfaction algorithms.
But this is jumping ahead. In this section and the three that follow, we will
use concepts drawn from computational complexity theory to present a more Ô¨Åne-
grained analysis of modal satisÔ¨Åability. This analysis is interesting for two reasons.
First, by making use of only three central complexity classes (NP, PSPACE and
EXPTIME), we will be able to present a classiÔ¨Åcation of modal satisÔ¨Åability that
covers many important logics. Secondly, in many cases the techniques involved
have a distinctly modal Ô¨Çavor: essentially, the work boils down to a reÔ¨Åned analysis
of the Ô¨Ånite model property.
We begin our analysis with the class NP, the class of problems solvable using
nondeterministic polynomial time algorithms. We Ô¨Årst review the central ideas
underlying this complexity class and their import for modal satisÔ¨Åability problems.
Then, using examples from multi-modal and tense logic, we show how simple
selection arguments can be used to prove NP-completeness results. Finally, we
apply the same method to prove a more general result: every normal modal logic
extending S4.3 has an NP-complete satisÔ¨Åability problem.
When a problem P is said to be complete with respect to a complexity class C,
two things are being claimed. The Ô¨Årst is that P belongs to C; that is, there is an
algorithm using only the resources permitted by C that solves P. For example, if
C = NP this means that there exists a non-deterministic polynomial time algorithm
for solving P. The second claim is that P is C-hard; that is, any other problem in
C is polynomial time reducible to P.
Now, as far as the satisÔ¨Åability problem for normal modal logics is concerned,
NP-hardness is a triviality: all (consistent) normal modal logics have NP-hard sat-
isÔ¨Åability problems. The point is this. The classic NP-hard problem is the satis-
Ô¨Åability problem for propositional logic. But as every normal modal logic is an6.6 NP
375
extension of propositional logic, every (consistent) normal modal logic has a satis-
Ô¨Åability problem at least as hard as that for propositional logic. Thus ‚Äì for the class
NP ‚Äì our work is somewhat simpliÔ¨Åed: we are simply looking for normal modal
logics whose satisÔ¨Åability problem belongs to NP.
What sort of problems belong to NP? Many problems decompose naturally into
the following two steps: a search for a solution followed by a veriÔ¨Åcation of
the solution. In general, search is expensive, but by thinking in terms of non-
deterministic algorithms we can abstract away from this expense: if a solution
exists, such an algorithm will Ô¨Ånd it in one non-deterministic step. (If necessary,
consult Appendix C for further discussion.) This abstraction leaves us free to con-
centrate on the veriÔ¨Åcation step, and leads us to isolate the class NP: a problem be-
longs to NP iff it has the above general proÔ¨Åle (that is, a non-deterministic choice of
a solution followed by a veriÔ¨Åcation) and moreover the veriÔ¨Åcation step is tractable
(that is, solvable in polynomial time).
How do such ideas bear on modal satisÔ¨Åability? The key idea we need is em-
bodied in the following lemma.
Lemma 6.35 Let œÑ be a Ô¨Ånite similarity type. Let Œõ be a consistent normal modal
logic over œÑ with the polysize model property with respect to some class of models
M. If the problem of deciding whether M ‚àà M is computable in time polynomial
in |M|, then Œõ has an NP-complete satisÔ¨Åability problem.
Proof. As noted above, the NP-hardness of the problem is immediate, so it remains
to prove the existence of an algorithm in NP that solves Œõ-satisÔ¨Åability. Given œÜ,
non-deterministically choose a model M whose size is polynomial in the size of œÜ.
Because M is polysize in |œÜ|, we can check in time polynomial in |œÜ| whether M
veriÔ¨Åes œÜ. For the special case of the basic modal language, this may be seen as
follows.
Let ||M|| denote the sum of the number of states in M and the number of pairs
in M‚Äôs binary relation RM. Let œà1 , . . . , œàk be an enumeration of the subformulas
of œÜ, in increasing length. So œàk = œÜ and if œài is a subformula of œàj , then i < j.
Notice that k ‚â§ |œÜ|. One can show by induction on m that we can mark each state
w in M with œàj or ¬¨œàj , for j = 1, . . . , m, depending on whether or not œàj is
true at w in time O(m ¬∑ ||M||). The only non-trivial case is if œàm+1 = 3œàj , for
some j < m + 1. But in that case we mark w with 3œàj if some v with Rwv is
marked with œàj . By our induction hypothesis, every state is already marked with
œàj or ¬¨œàj , this step can be carried out in time O(||M||). Since M is polysize in
|œÜ|, so is ||M||. Hence, checking whether M satisÔ¨Åes œÜ can indeed be done in time
polynomial in |œÜ|.
Finally, then, because membership in M is decidable in time polynomial in |M|,376
6 Computability and Complexity
and |M| is polynomial in |œÜ|, we can check in time polynomial in |œÜ| that M is in
M.
Where did we use the assumption that œÑ is a Ô¨Ånite similarity type in the proof
of Lemma 6.35? Essentially, it allows us to check whether M veriÔ¨Åes œÜ in time
polynomial in |œÜ| and in |M|. The key point is this: when working with a Ô¨Åxed
Ô¨Ånite similarity type, we are actually working within a Ô¨Ånite-variable fragment,
say with l variables. This allows us to restrict our attention to only Ô¨Ånitely many
relations of arity at most l in M. While the total number of tuples in all relations in
M may be huge, it is nonetheless independent of œÜ; see Exercise 6.6.2 for further
elaborations.
Note that the second demand ‚Äì that M-membership be polynomial time decid-
able ‚Äì is vital. As the reader was asked to show in Exercise 6.2.4, the polysize
model property alone is insufÔ¨Åcient to ensure decidability, let alone the existence
of a solution in NP. However, for many important logics this property can be estab-
lished by appealing to the following standard result.
Lemma 6.36 If F is a class of frames deÔ¨Ånable by a Ô¨Årst-order sentence, then the
problem of deciding whether F belongs to F is decidable in time polynomial in the
size of F.
Proof. Left as Exercise 6.6.1.
We will show that many normal modal logics are NP-complete. The proofs revolve
around one central idea: the construction of polysize models by the selection of
polynomially many points from some given satisfying model.
For our Ô¨Årst example, we return to the multi-modal language containing n unary
modal operators discussed earlier (see Corollary 6.9). Recall that Fn1 is the class of
frames for this language in which each relation is a partial function, Mn1 is the class
of models built over Fn1 , and Kn Alt1 is its logic.
Theorem 6.37 Kn Alt1 has an NP-complete satisÔ¨Åability problem.
Proof. We already showed that this logic has the strong f.m.p., but the selection
argument we used generated models exponential in size of the input formula. A
simple reÔ¨Ånement of the method shows that Kn Alt1 actually has the polysize model
property.
Given a formula œÜ of this language and a model M = (W, R, V ) we deÔ¨Åne a
selection function s as follows:
s(p, w) = {w},
s(¬¨œÜ, w) = s(œÜ, w),
s(œÜ ‚àß œà, w) = s(œÜ, w) ‚à™ s(œà, w),6.6 NP
377
s(œà, w ).
s(aœà, w) = {w} ‚à™
{w  |Ra ww  }
Intuitively, s(œÜ, w) selects the nodes actually needed when evaluating œÜ in M at w
‚Äì and indeed, it follows by induction on the structure of œÜ that for all nodes w of
M, and all formulas œÜ
M, w  œÜ iff M s(œÜ, w), w  œÜ.
It is clear that M s(œÜ, w) ‚àà Mn1 . So let us look at the size of the new model. If
M ‚àà Mn1 , we claim that |s(œÜ, w)| ‚â§ |œÜ|+ 1. To see this, note that only occurrences
of modalities in œÜ cause new nodes to be adjoined to s(œÜ, w). This adjunction of
points is carried out in the fourth clause of the inductive deÔ¨Ånition for s, which tells
us to adjoin every state w such that Ra ww . Because M ‚àà Mn1 , every relation Ra
is a partial function; hence if such a w exists, it is unique. In short, Kn Alt1 has
the polysize model property: simply counting the number of occurrences of modal
operators in œÜ and adding one gives us an upper bound on the size of the domain
of the required satisfying model.
By Lemma 6.36, membership in Kn Alt1 is decidable in polynomial time, for this
is a class of frames deÔ¨Ånable by a Ô¨Årst-order sentence ‚Äì namely the conjunction of
sentences that say that each of the n relations is a partial function.
The result follows by Lemma 6.35.
The argument for Kn Alt1 shows the selection method in its simplest form: given
any model for œÜ we build a new polysize model for œÜ by making a suitable selection
of polynomially many points. This simple form of argumentation is applicable to a
number of logics, a particularly noteworthy example being S5. Given any S5 model
for œÜ, it is possible to select m + 1 points from this model (where m is the number
of modality occurrences in œÜ) which sufÔ¨Åce to construct a new S5 model for œÜ,
and the NP-completeness of S5 follows straightforwardly. We leave the details as
Exercise 6.6.4 and turn our attention to a modiÔ¨Åcation of the point selection method
frequently needed in practice: a detour via Ô¨Ånite models.
Both Kn Alt1 and S5 are very simple logics; in neither case is it difÔ¨Åcult to deter-
mine which points should be selected. In other cases, we may not be so fortunate.
Suppose we are trying to show that a logic Œõ has the polysize model property, and
we already know that Œõ has the f.m.p. Then, instead of trying to select points from
an arbitrary model, we are free to select points from a Ô¨Ånite model, or even a point-
generated submodel of a Ô¨Ånite model. This often gives us an easy way of zooming
in on the crucial points. In particular, when we are working with models based
on Ô¨Ånite orderings it makes sense to talk of choosing points that are maximal (or
minimal) in the frame ordering that satisfy some subformula; such extremal points
are often the vital ones. As an example of such an argument, let us consider Kt 4.3,
the temporal logic of linear frames (in the basic temporal language).378
6 Computability and Complexity
Theorem 6.38 Kt 4.3 has an NP-complete satisÔ¨Åability problem.
Proof. We will Ô¨Årst show that Kt 4.3 has the polysize model property. Let œÜ be
a formula of the basic temporal language that is satisÔ¨Åable on a Kt 4.3 model.
As Kt 4.3 has the f.m.p. with respect to the class of weak total orders (see Def-
inition 4.37 and Corollary 6.8), there is a Ô¨Ånite weakly totally ordered model
M = (T, ‚â§, V ) containing a node t such that M, t  œÜ. We now build a poly-
size model for œÜ by selecting points from M.
Let F œà1 , . . . , F œàk and P Œ∏1 , . . . , P Œ∏l be all subformulas of œÜ of the form F œà
and P Œ∏, respectively, that are satisÔ¨Åed in M. For each formula F œài choose a point
ui such that M, ui  œài and ui is a maximal point in the ‚â§-ordering with this
property. Similarly, for each formula P Œ∏j choose a point vj satisfying Œ∏j that is
minimal in the ‚â§-ordering with respect to this property. Let M (= (T  , ‚â§ , V  ))
be M {t, u1 , . . . , uk , v1 , . . . , vl }. As ‚â§ is a weak total ordering of T , ‚â§ is
a weak total ordering of T  . Furthermore, the number of nodes in M does not
exceed m + 1, where m is the number of modalities in œÜ, thus M is a polysize
model in the correct class. It remains to show that M , t  œÜ, but this follows
straightforwardly by induction on the structure of œÜ.
As the class of weak total orders is deÔ¨Ånable using a Ô¨Årst-order sentence, the NP-
completeness of Kt 4.3 follows from Lemma 6.36 and the polysize model property
that we have just established.
We are ready to prove a general complexity result for the basic modal language: all
normal logics extending S4.3 have an NP-complete satisÔ¨Åability problem. Recall
from our discussion of Bull‚Äôs Theorem in Section 4.9 that an S4.3 frame is a frame
that is rooted, transitive, and connected (‚àÄxy (Rxy ‚à® Ryx)); note that all such
frames are reÔ¨Çexive. Bull‚Äôs Theorem tells us that all normal modal logics extending
S4.3 have the Ô¨Ånite frame property with respect to a class of S4.3 frames. By
making a suitable selection from models based on such frames, we can prove that
every such logic has the polysize model property. Then, by using the fact that every
normal logic extending S4.3 has a negative characterization in terms of Ô¨Ånite sets of
Ô¨Ånite frames (Theorem 4.103), we will be able to prove that all these satisÔ¨Åability
problems are NP-complete.
First we need the following lemma; it is really just Lemma 4.98, which linked
bounded morphisms and covering lists, stated in purely modal terms.
Lemma 6.39 Let F and G be two Ô¨Ånite S4.3 frames. Then the following two state-
ments are equivalent:
(i) There exists a surjective bounded morphism from F to G.
(ii) G is isomorphic to a subframe of F that contains a maximal point of F.
Proof. First suppose that f is a surjective bounded morphism from F to G. Let6.6 NP
379
! consist of wmax together with exactly
wmax be a maximal point in F, and let W
‚àí1
one maximal world in f [v] for every point v of G such that v = f (wmax ). Then
=F W
! is the subframe we want.
F
! is a subset of the points in F, such that W
! contains
Conversely, suppose that W
! is isomorphic to G. We claim that the following
a maximal point wmax , and F W
! : f (w) = w, for w ‚àà W
! ; and if
deÔ¨Ånes a bounded morphism from F onto F W
! , then f (w) is a minimal world w
! such that Rww
w ‚àà W
 ‚ààW
 (that is, for any



w , if Rww then Rww
 ). Note that such a minimal world must always exist, since
! , thus f is well-deÔ¨Åned. (In short, f maps ‚Äòmissing points‚Äô to succes-
wmax ‚àà W
sors that are as close as possible. We used the same idea to deÔ¨Åne the bounded
morphism in the proof of Bull‚Äôs Theorem.) Clearly f is surjective. So suppose
Rww . Since Rw f (w ) and R is transitive, we have Rwf (w ). By deÔ¨Ånition,
! such that Rwf (w), thus Rf (w)f (w ) and f sat-
f (w) is a minimal element in W
isÔ¨Åes the forth condition on bounded morphisms. Finally, suppose Rf (w)f (w ).
As Rwf (w), by the transitivity of R we have Rwf (w ). Since f (f (w )) = f (w ),
the back condition for bounded morphisms is also satisÔ¨Åed and we have shown that
! is a bounded morphic image of F. As F W
! is isomorphic to G, G is a
F W
bounded morphic image of F as well.
We now show that any normal modal logic extending S4.3 has the polysize model
property.
Lemma 6.40 Let Œõ be a normal modal logic such that S4.3 ‚äÜ Œõ. Any formula œÜ
that is satisÔ¨Åable on a frame for Œõ is satisÔ¨Åable on a frame for Œõ that contains at
most m + 2 states, where m is the number of occurrences of modal operators in œÜ.
Proof. Suppose œÜ is satisÔ¨Åable on a frame for Œõ. By Bull‚Äôs Theorem, Œõ has the
Ô¨Ånite frame property, thus there is a Ô¨Ånite model based on a Œõ-frame that satisÔ¨Åes
œÜ at some point w0 . Let M be the submodel of this model that is generated by
w0 . Clearly M, w0  œÜ, and as formation of generated submodels preserves modal
validity, M is based on a frame for Œõ.
Now we select points. Let 3œà1 , . . . , 3œàk be all the 3-subformulas of œÜ that are
satisÔ¨Åed at w0 . For each 1 ‚â§ i ‚â§ k, select a point wi that is maximal with respect
to the property of satisfying œài . These are the points needed to ensure that œÜ is
satisÔ¨Åed in the polysize model at w0 , but if we select only w0 and these points, we
have no guarantee that we have constructed a Œõ-frame. However, as we will now
see, we can guarantee this if we glue on a maximal point. So, let wk+1 be such a
point and deÔ¨Åne
! := M {w0 , w1 , . . . , wk , wk+1 }.
M
! contains at most m + 2 points, where m is the number of modal operators in œÜ.
M
!
Moreover, it is based on a Œõ-frame. To see this, note that the frame underlying M380
6 Computability and Complexity
is a subframe of the frame underlying M that satisÔ¨Åes the requirements of item (ii)
! Such
of Lemma 6.39; hence there is a surjective bounded morphism from M to M.
!
morphisms preserve modal validity, thus as M is a Œõ-model, so is M.
! w0  œÜ. We prove by induction for all subformulas
It remains to ensure that M,
œà of œÜ, and all i such that 0 ‚â§ i ‚â§ k, that
! wi  œà.
M, wi  œà iff M,
The only interesting step is for formulas of the form 3œà. Suppose that M, wi 
3œà (thus œà = œàj for some 1 ‚â§ j ‚â§ k). Since M is point-generated by w0
and transitive, it follows that Rw0 wi , hence M, w0  3œà. We chose wj to be a
world maximal with respect to the property of satisfying œàj , hence Rwi wj . By the
! wj  œàj . Hence M,
! wi  3œà. The converse implication
induction hypothesis, M,
is left to the reader.
Theorem 6.41 (Hemaspaandra‚Äôs Theorem) Every normal modal logic extending
S4.3 has an NP-complete satisÔ¨Åability problem.
Proof. Lemma 6.40 established the polysize model property for Œõ, so it remains to
check that membership for Œõ-frames can be decided in polynomial time. How can
we show this? Recall Theorem 4.103:
For every normal modal logic Œõ extending S4.3 there is a Ô¨Ånite set N of Ô¨Ånite
S4.3 frames with the following property: for any Ô¨Ånite frame F, F  Œõ iff F
is an S4.3 frame and there does not exist a bounded morphism from F onto
any frame in N.
This gives us a possible strategy: given any frame F, check whether it is an S4.3
frame, and whether there is a surjective bounded morphism onto any frame in N.
Now, as S4.3 frames are Ô¨Årst-order deÔ¨Ånable, by Lemma 6.36 the Ô¨Årst part can be
performed in polynomial time. But what about the second? First, note that because
N is a Ô¨Åxed Ô¨Ånite set, we need only ensure that the task of checking whether there
is a bounded morphism from F to a Ô¨Åxed frame G can be performed in polynomial
time. But the naive strategy of examining all the functions from F to G is com-
pletely unsuitable: the number of such functions is |G||F| , which is exponential in
the size of F. However, applying Lemma 6.39, we see that the task can be sim-
! of worlds in F such that
pliÔ¨Åed: we only need to check whether there is a set W
! is isomorphic to G and W
! contains a maximal world. Thus we need to
F W
|G|
check less than |F| embeddings. But this number is polynomial in the size of F,
for G is Ô¨Åxed. By Lemma 6.35, NP-completeness follows.
The results of this section tell us something about the complexity of validity prob-
lems. The complement of NP is called co-NP. As a formula œÜ is not Œõ-satisÔ¨Åable
iff ¬¨œÜ is Œõ-valid, it follows that an NP-completeness result for Œõ-satisÔ¨Åability tells6.7 PSPACE
381
us that Œõ-validity is co-NP complete (see Appendix C for further discussion). It is
standardly conjectured that NP = co-NP, thus the validity and satisÔ¨Åability prob-
lems for these logics probably have different complexities.
Exercises for Section 6.6
6.6.1 Prove Lemma 6.36. That is, show that if F is a class of frames deÔ¨Ånable by a Ô¨Årst-
order sentence, then the problem of deciding whether F belongs to F is decidable in time
polynomial in the size of F.
6.6.2 Explain why the argument given in the proof of Lemma 6.35 may break down when
we lift the restriction to Ô¨Ånite similarity types. In particular, examine the situation when
the similarity type contains modal operators of arbitrarily high arities.
6.6.3 Extend the proof of Theorem 6.38 to show that K t Q has the polysize model prop-
erty, and is NP-complete.
6.6.4 Use a selection of points argument to show that S5 has the polysize model property,
and is NP-complete.
6.6.5 Show that if we restrict attention to a Ô¨Åxed Ô¨Ånite set of proposition letters Œ¶, then the
satisÔ¨Åability problem for S5 is decidable in linear time. (Hint: if Œ¶ is Ô¨Ånite, the number of
models we have to check to determine whether a given formula œÜ is satisÔ¨Åed in them, is
independent of œÜ.)
6.7 PSPACE
PSPACE, the class of problems solvable by a deterministic Turing machine us-
ing only polynomial space, is the complexity class of most relevance to the basic
modal language. As we will see, some important modal satisÔ¨Åability problems
belong to PSPACE, and many modal logics have PSPACE-hard satisÔ¨Åability prob-
lems. This suggests that modal satisÔ¨Åability problems are typically tougher than
the satisÔ¨Åability problem for propositional calculus, for it is standardly conjectured
that PSPACE-hard problems are not solvable in NP.
The work of this section revolves around trees. We Ô¨Årst show that K lacks the
polysize model property by forcing the existence of binary-tree-based models using
short formulas. We then take a closer look at K-satisÔ¨Åability and show that it is in
PSPACE. The proof also shows that every K-satisÔ¨Åable formula is satisÔ¨Åable on a
tree-based model of polynomial depth. We then put all this work together to prove
Ladner‚Äôs Theorem: every normal logic between K and S4 has a PSPACE-hard
satisÔ¨Åability problem.6 Computability and Complexity
382
Forcing binary trees
The NP-completeness results of the previous section were proved using polysize
model property arguments. So, before going any further, we will show that K does
not have the polysize model property. We do so by showing that K can force the
existence of binary trees. Many of the ideas introduced here will be reused in the
proof of Ladner‚Äôs Theorem.
For any natural number m, we are going to devise a satisÔ¨Åable formula œÜB (m)
with the following properties:
(i) the size of œÜB (m) is polynomial (indeed, quadratic) in m, but
(ii) when œÜB is satisÔ¨Åed in any model M at a node w0 , then the submodel of
M generated by w0 contains an isomorphic copy of the binary tree of depth
m.
As the binary branching tree of depth m contains 2m nodes, the size of the smallest
satisfying model of œÜB (m) is exponential in |œÜB (m)|. Thus we will have shown
that small formulas can force the existence of large models.
We will deÔ¨Åne these formulas by mimicking truth tables. For any natural number
m, œÜB (m) will be constructed out of the following variables: q1 , . . . , qm , and p1 ,
. . . , pm . The qi s play a supporting role. They will be used to mark the level (or
depth) in the model; that is, they will mark the number of upward steps that need to
be taken to reach the satisfying node. But any satisfying model for œÜB (m) will give
rise to a full truth table for p1 , . . . , pm : every possible combination of truth values
for p1 , . . . , pm will be realized at some node, and hence any model for œÜB (m) must
contain at least 2m nodes.
That is the basic idea. To carry it out, we Ô¨Årst deÔ¨Åne two macros: Bi , and
S(pi , ¬¨pi ). For i = 0, . . . , m ‚àí 1, Bi is deÔ¨Åned as follows:
Bi := qi ‚Üí (3(qi+1 ‚àß pi+1 ) ‚àß 3(qi+1 ‚àß ¬¨pi+1 )) .
(6.12)
Given that we are going to use the qi s to mark the levels, the effect of Bi should be
clear: it will force a branching to occur at level i, set the value of pi+1 to true at
one successor at level i + 1, and set pi+1 to false at another.
Our other macro is closely related. For i = 0, . . . , m ‚àí 1, S(pi , ¬¨pi ) is deÔ¨Åned
as follows:
S(pi , ¬¨pi ) := (pi ‚Üí 2pi ) ‚àß (¬¨pi ‚Üí 2¬¨pi ).
(6.13)
This formula sends the truth values assigned to pi and its negation one level down.
The idea is that once Bi has forced a branching in the model by creating a pi+1
and a ¬¨pi+1 successor, S(pi+1 , ¬¨pi+1 ) ensures that these newly set truth values
are sent further down the tree; ultimately we want them to reach the leaves.
We are ready to deÔ¨Åne œÜB (m). It is the conjunction of the formulas listed in
Figure 6.5. Note that œÜB (m) has the required effect. The Ô¨Årst conjunct, q0 , ensures6.7 PSPACE
(i) q0
(ii) 2(m) (qi ‚Üí
(iii) B0 ‚àß 2B1
(iv)

i=j ¬¨qj )
383
(0 ‚â§ i ‚â§ m)
2
‚àß 2 B2
‚àß 23 B3
‚àß ¬∑ ¬∑ ¬∑ ‚àß 2m‚àí1 Bm‚àí1
2S(p1 , ¬¨p1 ) ‚àß 22 S(p1 , ¬¨p1 ) ‚àß 23 S(p1 , ¬¨p1 ) ‚àß ¬∑ ¬∑ ¬∑ ‚àß 2m‚àí1 S(p1 , ¬¨p1 )
‚àß 22 S(p2 , ¬¨p2 ) ‚àß 23 S(p2 , ¬¨p2 ) ‚àß ¬∑ ¬∑ ¬∑ ‚àß 2m‚àí1 S(p2 , ¬¨p2 )
‚àß 23 S(p3 , ¬¨p3 ) ‚àß ¬∑ ¬∑ ¬∑ ‚àß 2m‚àí1 S(p3 , ¬¨p3 )
..
.
‚àß 2m‚àí1 S(pm‚àí1 , ¬¨pm‚àí1 )
Fig. 6.5. The formula œÜ B (m)
that any node that satisÔ¨Åes œÜB (m) is marked as having level 0. The effect of (ii) is
to ensure that no two distinct level marking atoms qi and qj can be true at the same
node (at least, this will be the case all the way out to level m, which is all we care
about). To see this, recall that 2(m) œÜ is shorthand for œÜ ‚àß 2œÜ ‚àß 22 œÜ ‚àß ¬∑ ¬∑ ¬∑ ‚àß 2m œÜ.
Thus our level markers are beginning to work as promised.
But the real work is carried out by (iii) and (iv). Because of the preÔ¨Åxed blocks
of 2 modalities, the Bi macros in (iii) force m successive levels of branching;
and each such branching ‚Äòsplits‚Äô the truth value of one of the pi s. Then, again
because of the preÔ¨Åxed 2 modalities, (iv) uses the S(pi , ¬¨pi ) macro to send each
of these newly split truth values all the way down to the m-th level. In short,
(iii) creates branching, and (iv) preserves it. It is worthwhile sitting down with a
pencil and paper to check the details. If you do, it will become clear that œÜB (m) is
satisÔ¨Åable, and that any satisfying model for œÜB (m) must contain a submodel that
is isomorphic to the binary branching tree of depth m. It follows that any model of
œÜB (m) must contain at least 2m nodes, as we claimed.
In spite of its appearance, œÜB (m) is indeed a small formula. To see this, consider
what happens when we increment m by 1. The answer is: not much. For example
(iii) simply gains an extra conjunct, becoming
2B0 ‚àß 22 B1 ‚àß 23 B2 ‚àß ¬∑ ¬∑ ¬∑ ‚àß 2m‚àí1 Bm‚àí1 ‚àß 2m Bm .
Similarly, each row in (iv) gains an extra conjunct (as does the next empty row)
thus we gain a new column containing m formulas. The biggest change occurs in
(ii). If you write (ii) out in full, you will see that it gains an extra row, and an extra
column, and an extra atomic symbol in each embedded conjunct, and this means
that |œÜB (m)| increases by O(m2 log m) (that is, slightly faster than quadratically).
This is negligible compared with the explosion in the size of the smallest satisfying
model: this doubles in size every time we increase m by one.384
6 Computability and Complexity
Theorem 6.42 K lacks the polysize model property.
That is, K lacks a property enjoyed by all the NP-complete logics examined in
the previous section, and there is no obvious way of using NP guess-and-check
algorithms to solve K-satisÔ¨Åability. What sort of algorithms will work?
A PSPACE algorithm for K
We will now deÔ¨Åne a PSPACE-algorithm called Witness whose successful termi-
nation guarantees the K-satisÔ¨Åability of the input. It may seem surprising that we
can do this. After all, we have just seen that there are satisÔ¨Åable formulas œÜB (m)
whose smallest satisfying model contains 2m nodes. What happens if we give
œÜB (m) as input to Witness? Will it be forced to use an exponential amount of
space to determine the satisÔ¨Åability of œÜB (m)? The answer is: no. Witness will
take an exponential amount of time to terminate on difÔ¨Åcult input, but it uses space
efÔ¨Åciently. As we will see, if a formula œÜ is satisÔ¨Åable in some model, it is sat-
isÔ¨Åable in a tree-based model of polynomial depth. While some formulas require
models with exponentially many nodes, we can always Ô¨Ånd a shallow satisfying
model: the length of each branch is polynomial in |œÜ|. Witness tests for the exis-
tence of shallow models, and does so one branch at a time. It does not need to keep
track of the entire model, and hence can be made to run in PSPACE.
Witness is essentially an abstract tableaux system for K: it explores spaces of
Hintikka sets (see DeÔ¨Ånition 6.24). Recall that Hintikka sets need not be satisÔ¨Åable,
and that we call satisÔ¨Åable Hintikka sets atoms. Witness will take two Ô¨Ånite sets
of formulas H and Œ£ as input, and determine whether or not H is an atom over
Œ£. It does so by looking at the demands that H makes and recursively calculating
whether all these demands can be met. The following deÔ¨Ånition makes the idea of
a demand precise (compare DeÔ¨Ånition 4.62, and recall our convention concerning
single negations from DeÔ¨Ånition 4.79):
DeÔ¨Ånition 6.43 Suppose H is a Hintikka set over Œ£, and 3œà ‚àà H. Then the
demand that 3œà creates in H (notation: Dem(H, 3œà)) is
{œà} ‚à™ {‚àºŒ∏ | ¬¨3Œ∏ ‚àà H}.
We use H3œà to denote the set of Hintikka sets over Cl(Dem(H, 3œà)) that contain
Dem(H, 3œà). (Recall that for any set of sentences Œ£, Cl(Œ£) denotes the closure
of Œ£; see DeÔ¨Ånition 6.23.)
Remark 6.44 Suppose that A is an atom over Œ£, and that 3œà ‚àà A. As A is
satisÔ¨Åable, so is Dem(A, 3œà). From this it follows that there is at least one atom
in A3œà that contains Dem(A, 3œà). For suppose M, w  Dem(A, 3œà). Let Œ® be6.7 PSPACE
385
the set of all formulas satisÔ¨Åed in M at w. Then Œ® ‚à© Cl(Dem(A, 3œà)) is an atom
over Cl(Dem(A, 3œà)) that contains Dem(A, 3œà).
Furthermore, as the reader can easily ascertain, for any formula œÜ, œÜ is satisÔ¨Åable
iff there is an atom A over Cl(()œÜ) that contains œÜ.
DeÔ¨Ånition 6.45 Suppose H and Œ£ are Ô¨Ånite sets of formulas such that H is a
Hintikka set over Œ£. Then H ‚äÜ P(Œ£) is a witness set generated by H on Œ£ if
H ‚àà H and
(i) if I ‚àà H, then for each 3œà ‚àà I, there is a J ‚àà I3œà such that J ‚àà H,
(ii) if J ‚àà H and J = H then for some n > 0 there are I0 , . . . , I n ‚àà H such
that H = I 0 , J = I n , and for each 0 ‚â§ i < n there is some formula
i .
3œà ‚àà I i such that I i+1 ‚àà I3œà
The degree of a Ô¨Ånite set of formulas Œ£ is simply the maximum of the degrees of
the formulas contained in Œ£; that is, deg(Œ£) = max{deg(œÜ) | œÜ ‚àà Œ£}.
For all choices of H and Œ£, any witness set H generated by H on Œ£ must be Ô¨Ånite,
for H ‚äÜ P(Œ£), which is a Ô¨Ånite set. Further, observe that if I, J ‚àà H and J ‚àà I3œà
then the degree of J is strictly less than that of I. Moreover, observe that item (ii)
of the previous deÔ¨Ånition is essentially a ‚Äòno junk‚Äô condition: if J belongs to H, it
is there because it is generated by some other elements of H, and ultimately by H
itself.
Lemma 6.46 Suppose that H and Œ£ are Ô¨Ånite sets of formulas such that H is a
Hintikka set over Œ£. Then H is an atom iff there is a witness set generated by H
on Œ£.
Proof. For the left to right direction we proceed by induction on the degree of Œ£.
Let deg(Œ£) = 0, and suppose H is an atom. Trivially, H = {H} is a witness set
generated by H. For the inductive step, suppose the required result holds for all
pairs H  and Œ£  such that H  is an atom of Œ£ and deg(Œ£  ) < n. Let H be an atom
of Œ£ such that deg(Œ£) = n. Then, as we noted in Remark 6.44, for all 3œà ‚àà H
there exists at least one atom Iœà in H3œà . As the degree of Cl(Dem(H, 3œà)) < n,
for all 3œà ‚àà H, the inductive hypothesis applies and every such atom Iœà generates
a witness set I œà on Cl(Dem(H, 3œà)). DeÔ¨Åne
H = {H} ‚à™
Iœà.
3œà‚ààH
Clearly H is a witness set generated by H on Œ£.
For the right to left direction, we will show that if H is a witness set on Œ£
generated by H, then H can be satisÔ¨Åed in a model (F, V ) where F is a Ô¨Ånite tree
of depth at most deg(H). This is stronger than the stated result, and later it will386
6 Computability and Complexity
help us understand why K-satisÔ¨Åability is solvable in PSPACE. Assume we have
a countably inÔ¨Ånite set of new entities W = {w0 , w1 , w2 , w3 , . . .} at our disposal.
We will use (Ô¨Ånitely many) elements of W to build a model for H, using a Ô¨Ånitary
version of the step-by-step method discussed in Section 4.6. This model will be a
tree, thus showing once again that K has the tree model property.
DeÔ¨Åne W0 = {w0 }, R0 = ‚àÖ, f0 (w0 ) = H. Suppose Wn , Rn and fn have been
deÔ¨Åned. If for all w ‚àà Wn such that 3œà ‚àà fn (w) there exists a w ‚àà Wn such that
(i) œà ‚àà fn (w ) and (ii) fn (w ) ‚àà fn (w)3œà , then halt the step-by-step construction.
Otherwise, if there is a w ‚àà Wn such that 3œà ‚àà fn (w), while for no w ‚àà Wn are
these two conditions satisÔ¨Åed, then carry on to stage n + 1 and deÔ¨Åne:
Wn+1 = Wn ‚à™ {wn+1 },
Rn+1 = Rn ‚à™ {(w, wn+1 )},
fn+1 = fn ‚à™ {(wn+1 , I)},
where I ‚àà H is such that I ‚àà fn (w)3œà . Note that because H is a witness set it
will always be possible to Ô¨Ånd such an I.
This step-by-step procedure halts after Ô¨Ånitely many steps since each I ‚àà H
contains only Ô¨Ånitely many formulas of the form 3œà (thus ensuring that the tree
we are constructing is Ô¨Ånitely branching), and whenever Rn ww , then
deg(fn (w )) < deg(fn (w))
(thus ensuring that the tree is not only Ô¨Ånite, but shallow: it has depth at most
deg(H)). Let m be the stage at which it halts, and deÔ¨Åne F to be (Wm , Rm ). To
construct the desired model for H, it only remains to deÔ¨Åne a suitable valuation
V , and we do this as follows: choose V to be any function from Œ£ to P(Wm )
satisfying w ‚àà V (p) iff p ‚àà fm (w), for all p ‚àà Œ£. Let M = (F, V ). Exercise 6.7.1
asks the reader to show that M, w0  H; an immediate consequence is that H is
an atom.
Two remarks. The above proof shows that every atom is satisÔ¨Åable in a shallow
tree-based model ‚Äì a fact which will prove to be important below. Second, we now
have a syntactic criterion ‚Äì namely the existence or non-existence of witness sets
‚Äì for determining whether a Hintikka set is K-satisÔ¨Åable. (In short, we have just
proved a completeness result.) Moreover, the criterion is intuitively computable:
witness sets are simple Ô¨Ånite structures, thus it seems reasonable to expect that we
can algorithmically test for their existence. And indeed we can.
We now deÔ¨Åne the Witness algorithm. This takes as input two Ô¨Ånite sets of
formulas H and Œ£ and returns the value true if and only if there is a witness set
generated by H on Œ£.
*function Witness(H, Œ£) returns boolean*6.7 PSPACE
387
begin
if H is a Hintikka set over Œ£
and for each subformula 3œà ‚àà H there is a set of formulas
I ‚àà H3œà such that Witness(I, Cl(Dem(H, 3œà)))
then return true
else return false
end
Note that Witness is an intuitively acceptable algorithm ‚Äì and hence (by Church‚Äôs
thesis) implementable on a Turing machine. Checking that H is a Hintikka set
over Œ£ involves ascertaining that Œ£ is subformula closed, and that H satisÔ¨Åes the
properties demanded of Hintikka sets; these tasks involve only simple syntactic
checking. Moreover, both the ‚Äòand for each subformula . . . there is‚Äô clause and the
recursive call to Witness are clearly computable: the Ô¨Årst involves search through
a Ô¨Ånite space, while the recursive call performs the same tasks on input of lower
degree. Thus Witness is indeed an algorithm. Moreover, it is correct: if H and Œ£
are Ô¨Ånite sets of formulas, then Witness(H, Œ£) returns true iff H is a Hintikka set
over Œ£ that generates a witness set in Œ£. This follows by induction on the degree
of Œ£. The right to left direction is easy, while the left to right direction is similar
to the proof of Lemma 6.46; see Exercise 6.7.2.
We are now ready for the main result.
Theorem 6.47 K-satisÔ¨Åability is in PSPACE.
Proof. It follows from Lemma 6.46 and the correctness of Witness that for any
formula œÜ, œÜ is satisÔ¨Åable iff there is an H ‚äÜ Cl(()œÜ) such that œÜ ‚àà H and
Witness(H, Cl(()œÜ)) returns the value true. Thus, if we can show that Witness
can be given a PSPACE implementation, we will have the desired result. We will
implement Witness on a non-deterministic Turing machine. Given any formula
œÜ, this machine will non-deterministically pick a Hintikka set H in Cl(()œÜ) that
contains œÜ, and run Witness(H, Cl(()œÜ)). It will be easy to show that this machine
runs in non-deterministic PSPACE (that is, NPSPACE). But then it follows by an
appeal to Savitch‚Äôs Theorem (PSPACE = NPSPACE; see Appendix C) that the
required PSPACE implementation exists.
So how do we implement Witness on a non-deterministic Turing machine? The
key points are the following:
(i) All sets of formulas used in the execution of the program are subsets of
Cl(()œÜ), and we can represent any such subset by using pointers to the con-
nectives and proposition letters in œÜ‚Äôs representation: a pointer to a propo-
sition letter will mean that the letter belongs to the subset, and a pointer to
a connective means that the subformula built using that connective belongs388
6 Computability and Complexity
to it. Thus encoding a subset of Cl(()œÜ) requires only space O(|œÜ|) (that
is, space of the order of the size of œÜ).
(ii) The ‚Äòand for each subformula 3œà ‚àà H‚Äô part can be handled by treating
each subformula in turn. As any subformula can be represented using a
pointer to œÜ‚Äôs representation, we can cycle through all possible subformu-
las, using only polynomial space, by cycling through these pointers. More-
over, as we are using a non-deterministic Turing machine, the ‚Äòthere is a set
of formulas . . . ‚Äô clause can be implemented by making non-deterministic
choices. Note that, even though H3œà is a set of sets of formulas, it is a
rather trivial task to verify whether I belongs to H3œà , given the deÔ¨Ånition
of H3œà .
(iii) To enable recursive calls to be made, we implement a stack on our Turing
machine. To perform the recursion, we copy the formula œÜ onto the stack
and point to proposition letters and connectives to indicate the subsets of
interest.
So, suppose we run Witness on input H and Œ£. The crucial point that must be
investigated is whether the recursive calls to Witness cause a blow-up in space
requirements. From items (i), (ii) and (iii) it is clear that at each level of recur-
sion we use space O(|œÜ|). How long does it take for the recursion to bottom out?
Note that after deg(œÜ) recursive calls, Œ£ = ‚àÖ. That is, the depth of recursion is
bounded by deg(œÜ) and hence by |œÜ|. Thus, when we implement Witness on a
non-deterministic Turing machine the total amount of space required is O(|œÜ|2 ),
hence the algorithm runs in NPSPACE. Thus, by Savitch‚Äôs Theorem, we conclude
that K-satisÔ¨Åability is in PSPACE.
The appeal to Savitch‚Äôs Theorem in the above proof can be avoided: Witness can
be implemented on a deterministic Turing machine. This involves replacing the
non-deterministic choice used in item (iii) by a brute force search through subsets
of Cl(()œÜ) that uses only polynomial space, and the reader is asked to do this in
Exercise 6.7.4. But the above proof illustrates why Savitch‚Äôs Theorem is so useful
in practice: by freeing us to think in terms of non-deterministic computations, it
reduces the required bookkeeping to a minimum.
Let us try and pin down the key intuition underlying Theorem 6.47. K lacks
the polysize model property, but in spite of this the K-satisÔ¨Åability problems can
be determined in PSPACE. Why? The key lies in the proof of Lemma 6.46 which
showed that every atom is satisÔ¨Åable in a shallow Ô¨Ånite tree-based model. Such
models make it easy to visualize the explorations that Witness makes as it tests
the satisÔ¨Åability of œÜ: it just works out what each branch of such a model must
contain. While the size of the entire model may be exponential in |œÜ| it is not
necessary to keep track of all this information. The locally relevant information is
simply the information on each branch ‚Äì and we know that the tree has depth at6.7 PSPACE
389
most deg(œÜ) + 1. In short, Witness exploits the fact that only shallow tree-based
models are needed to determine K-satisÔ¨Åability.
PSPACE algorithms have been devised for a number of well-known logics in-
cluding T, K4 and S4, the temporal counterparts of K, T, K4 and S4, and multi-
modal K, T, K4, S4 and S5. While proofs of these results are essentially reÔ¨Åne-
ments of the proof of Theorem 6.47, some are rather tricky. The reader who does
Exercise 6.7.3, which asks for a PSPACE algorithm for K4, will Ô¨Ånd out why. In
some cases alternative methods are preferable; see the Notes for pointers.
Ladner‚Äôs Theorem
We are ready to prove the major result of the section: every normal modal logic
between K and S4 is PSPACE-hard, and hence (assuming PSPACE = NP) the
satisÔ¨Åability problems for all these logics are tougher than the satisÔ¨Åability problem
for propositional logic. We prove this by giving a polynomial time reduction of
the validity problem for prenex quantiÔ¨Åed boolean formulas to all these modal
satisÔ¨Åability problems. The reduction boils down to forcing the existence of certain
tree-based models, and we will be able to reuse much of our previous work.
DeÔ¨Ånition 6.48 The set of quantiÔ¨Åed boolean formulas is the smallest set X con-
taining all formulas of propositional calculus such that if Œ≤ ‚àà X and p is a proposi-
tion letter, then both ‚àÄp Œ≤ and ‚àÉp Œ≤ ‚àà S. The quantiÔ¨Åers range over the truth values
1 (true) and 0 (false), and a quantiÔ¨Åed boolean formula without free variables is
valid if and only if it evaluates to 1.
A quantiÔ¨Åed boolean formula is said to be in prenex form if it is of the form
Q1 p1 ¬∑ ¬∑ ¬∑ Qm pm Œ∏(p1 , . . . , pm );
here Q is either ‚àÄ or ‚àÉ, and Œ∏(p1 , . . . , pm ) is a formula of propositional logic. We
will refer to such prenex formulas as QBFs.
The problem of deciding whether a QBF containing no free variables is valid is
called the QBF-validity problem, and it is known to be PSPACE-complete.
We are going to deÔ¨Åne a polynomial time translation fL from QBFs to modal
formulas, and prove that it has the following two properties:
(i) If Œ≤ is a QBF-validity, then fL (Œ≤) is S4-satisÔ¨Åable.
(ii) If fL (Œ≤) is K-satisÔ¨Åable, then Œ≤ is a QBF-validity.
These two properties ‚Äì together with the known PSPACE-hardness of the QBF-
validity problem ‚Äì will lead directly to the desired theorem.
Let us think about what is involved in evaluating a QBF. We start by peeling off
the outermost quantiÔ¨Åer. If it is of the form ‚àÉp we choose one of the truth values
1 or 0 and substitute for the newly freed occurrences of p. On the other hand, if it390
6 Computability and Complexity
is of the form ‚àÄp we must substitute both 1 and 0 for the newly freed occurrences
of p. In this fashion, we work our way successively through the preÔ¨Åxed list of
quantiÔ¨Åers until we reach the matrix, a formula of propositional logic.
We are essentially generating a tree. This tree consists of the root node, and then
‚Äì working inwards along the quantiÔ¨Åer string ‚Äì each existential quantiÔ¨Åer extends
it by adding a single branch, and each universal quantiÔ¨Åer extends it by adding
two branches. Indeed, we are even generating an annotated tree: we can label
each node with the substitution it records. For example, corresponding to the QBF
‚àÄp‚àÉq (p ‚Üî ¬¨q) we have the following annotated tree:
1/q
0/p
tt 0/q
66
tt
@
I
@
@ t

1/p
The information in such annotated trees ‚Äì we will call them quantiÔ¨Åer trees ‚Äì will
play a crucial role. For a start, QBF-validity is witnessed by certain quantiÔ¨Åer
trees: Œ≤ is a QBF-validity if and only if there is a quantiÔ¨Åer tree for Œ≤ such that the
substitutions it records ensure that the matrix evaluates to 1. Moreover, quantiÔ¨Åer
trees give us a bridge between the QBF world and the modal world: fL (Œ≤) will be
a modal formula that describes the structure of a quantiÔ¨Åer tree evaluating Œ≤.
We deÔ¨Åne the translation fL by modifying the way we forced the existence of
binary trees in the proof of Theorem 6.42, and we will reuse the macros Bi and
S(pi , ¬¨pi ) deÔ¨Åned on page 382 in (6.12) and (6.13), respectively.
DeÔ¨Ånition 6.49 Given any QBF Œ≤ = Q1 p1 ¬∑ ¬∑ ¬∑ Qm pm Œ∏(p1 , . . . , pm ), choose new
propositional variables q0 , . . . , qm . Then fL (Œ≤) is the conjunction of the formulas
displayed in Figure 6.6.
The idea underlying fL is this: for any QBF Œ≤, fL (Œ≤) describes the peel-off-
quantiÔ¨Åers-and-substitute evaluation process for Œ≤. (That is, it describes how we
generate a quantiÔ¨Åer tree for Œ≤.) Moreover, it does so using ideas we have met
already: note that (i), (ii) and (iv) are exactly the same formulas we used when
forcing the existence of binary trees.
In fact, the major difference between these formulas and our earlier work lies in
the word binary. Here we do not always want binary branching: we only want it
when we encounter the quantiÔ¨Åer ‚àÄ. Thus, instead of the earlier (iii) which forced
branching all the way down to level m, we have the pair of formulas (iiia) and
(iiib). (iiia) guarantees that if qi is true and i < m then there is a next level qi+1 ;
which simply amounts to saying that if i < m then we have not yet peeled off6.7 PSPACE
(i) q0
(ii) 2(m) (qi ‚Üí

i=j ¬¨qj )
391
(0 ‚â§ i ‚â§ m)
(m)
(iiia) 2 (qi ‚Üí 3qi+1 ) (0 ‚â§ i < m)

(iiib) {i|Qi =‚àÄ} 2i Bi
(iv) 2S(p1 , ¬¨p1 ) ‚àß 22 S(p1 , ¬¨p1 ) ‚àß 23 S(p1 , ¬¨p1 ) ‚àß ¬∑ ¬∑ ¬∑ ‚àß 2m‚àí1 S(p1 , ¬¨p1 )
‚àß 22 S(p2 , ¬¨p2 ) ‚àß 23 S(p2 , ¬¨p2 ) ‚àß ¬∑ ¬∑ ¬∑ ‚àß 2m‚àí1 S(p2 , ¬¨p2 )
‚àß 23 S(p3 , ¬¨p3 ) ‚àß ¬∑ ¬∑ ¬∑ ‚àß 2m‚àí1 S(p3 , ¬¨p3 )
..
.
‚àß 2m‚àí1 S(pm‚àí1 , ¬¨pm‚àí1 )
(v) 2m (qm ‚Üí Œ∏)
Fig. 6.6. The formula f L (Œ≤)
all the quantiÔ¨Åers and a new level will be necessary. But it does not force binary
branching. The task of forcing binary branching, when necessary, is left to (iiib).
Note that this formula is simply a selection of conjuncts from our earlier (iii). There
is only one other difference: (v) insists that after m quantiÔ¨Åers have been peeled
off, the propositional matrix Œ∏ must be true.
Clearly, fL (Œ≤) is polysize in |Œ≤|, thus this translation causes no blowup in space
requirements.
Theorem 6.50 (Ladner‚Äôs Theorem) If Œõ is a normal modal logic such that K ‚äÜ
Œõ ‚äÜ S4, then Œõ has a PSPACE-hard satisÔ¨Åability problem. Moreover, Œõ has a
PSPACE-hard validity problem.
Proof. Fix a modal logic Œõ with K ‚äÜ Œõ ‚äÜ S4. We are going to prove that fL is a
(polynomial time) reduction from the QBF-validity problem to the Œõ-satisÔ¨Åability
problem. The crucial step in this proof is summarized in the following two state-
ments:
if Œ≤ is a QBF-validity, then fL (Œ≤) is satisÔ¨Åable on a frame for S4,(6.14)
if fL (Œ≤) is satisÔ¨Åed in a K-model then Œ≤ is a QBF-validity.(6.15)
and
From these two statements the desired result follows immediately. For suppose Œ≤
is a QBF-validity. Then by (6.14) fL (Œ≤) is S4-satisÔ¨Åable and hence Œõ-satisÔ¨Åable.
Conversely, if fL (Œ≤) is Œõ-satisÔ¨Åable then it is also K-satisÔ¨Åable, and by (6.15)
Œ≤ is a QBF-validity. Thus Œõ-satisÔ¨Åability is PSPACE-hard. That the Œõ-validity392
6 Computability and Complexity
problem is also PSPACE-hard follows immediately from the fact that PSPACE =
co-PSPACE.
It remains to prove (6.14) and (6.15). For (6.14), assume that Œ≤ is a QBF-validity.
Generate a quantiÔ¨Åer tree witnessing the validity of Œ≤; if Œ≤ is valid, such a tree
must exist. This tree gives rise to an S4-model for fL (Œ≤) as follows. First, take
the transitive and reÔ¨Çexive closure of the ‚Äòdaughter-of‚Äô relation of the tree; this
gives us the S4-frame we require. Then make the variable qi true precisely at the
nodes of level i; pi is to be made true at a node of level j ‚â• i iff the substitution
connected to that node, or its predecessor at level i returns the value 1 for pi . (For
nodes at level j < i it does not matter what truth value we choose for pi .) It is
straightforward to check that the formula fL (Œ≤) is true in this model at the root of
the tree; see Exercise 6.7.5.
For (6.15), suppose that Œ≤ is a QBF of quantiÔ¨Åer depth m, and that fL (Œ≤) is
K-satisÔ¨Åable. Note that deg(fL (Œ≤)) = m, hence from the proof of Lemma 6.46
we know that fL (Œ≤) holds at the root r of a tree-based model M = (T, R, V ) of
depth at most m. Using clauses (iiia) and (iiib) of the deÔ¨Ånition of fL (Œ≤), it is
easily veriÔ¨Åed that we may cut off branches from this tree such that in the resulting
tree, a node at level i < m has either one or two successors. This number is one
iff Qi+1 = ‚àÉ. And if Qi+1 = ‚àÄ, then one of the successors satisÔ¨Åes pi+1 and the
other one, ¬¨pi+1 . But then this reduced tree model is a quantiÔ¨Åer tree witnessing
the validity of Œ≤.
Among other things, Ladner‚Äôs Theorem tells us that K, T, K4 and S4 all have
PSPACE-hard satisÔ¨Åability problems. It follows that the temporal counterparts
of K, T, K4 and S4, and multi-modal K, T, K4, and S4, are PSPACE-hard too,
for they contain the unimodal satisÔ¨Åability problems as a special case. Hence, as
PSPACE algorithms are known for these logics, they all have PSPACE-complete
satisÔ¨Åability problems. As PSPACE = co-PSPACE, these logics have PSPACE-
complete validity problems too.
Exercises for Section 6.7
6.7.1 Show that in the model M constructed in the proof of Lemma 6.46, M, w 0  H.
6.7.2 We claimed that Witness is a correct algorithm. That is, if H and Œ£ are Ô¨Ånite sets of
formulas, then Witness(H, Œ£) returns true iff H is a Hintikka set over Œ£ that generates a
witness set in Œ£. Prove this.
6.7.3 Adapt the Witness algorithm so that it decides K4 satisÔ¨Åability correctly. (Hint:
since you cannot consider smaller and smaller Hintikka sets (why not?) make use of lists
of Hintikka sets, rather than the single Hintikka sets used in the proof for K, and show that
the length of such lists can always be kept polynomial.)
6.7.4 Show how to avoid the use of Savitch‚Äôs Theorem in the proof of Theorem 6.47. That6.8 EXPTIME
393
is, show that the Witness function can be implemented on a deterministic Turing machine.
(Hint: implement the ‚Äòand for each subformula . . . there is‚Äô clause by cycling through all
possible subsets of Cl(()œÜ). This cycling process has a simple implementation using only
space O(|œÜ|): generate all binary strings of length |œÜ|, and decide of each whether or not
it encodes a subset of Cl(œÜ).)
6.7.5 Supply the missing details in the proof of Ladner‚Äôs Theorem.
6.7.6 Show that the satisÔ¨Åability problem for bimodal S5 is PSPACE-hard.
6.7.7 In this exercise we examine the effects of bounding the number of proposition letters
and of restricting the degree of formulas.
(a) Show that for any Ô¨Åxed k, the satisÔ¨Åability problem for K with respect to a language
consisting of all formulas whose degree is at most k, is NP-complete.
(b) Show that, in contrast, the satisÔ¨Åability problem for S4 remains PSPACE-complete
for languages consisting of all formulas of degree at most k (k ‚â• 2).
(c) Now suppose that Œ¶, the set of proposition letters, is Ô¨Ånite. Show that for any Ô¨Åxed
k, the satisÔ¨Åability problems for K and S4 with respect to a language consisting of
all formulas whose degree is at most k, is decidable in linear time.
6.8 EXPTIME
EXPTIME, the class of problems deterministically solvable in exponential time, is
an important complexity class for many modal languages. In particular, when a
modal language has operators [a] and [a‚àó ] which explore a relation Ra and its re-
Ô¨Çexive transitive closure (Ra )‚àó , its satisÔ¨Åability problem is likely to be EXPTIME-
hard, which means that the worst cases are computationally intractable. As such
operator pairs are important in many applications, we need to understand the com-
plexity theoretic issues they give rise to. In this section we examine the satisÔ¨Åability
problem for PDL; our discussion illustrates some key themes and introduces some
useful techniques.
Forcing exponentially deep models
By Corollary 6.14 we know that PDL has a decidable satisÔ¨Åability problem ‚Äì but
just how difÔ¨Åcult is it? Clearly it is PSPACE-hard, for each basic modality [a]
is a K operator, and we saw in the previous section (Theorem 6.50) that K has a
PSPACE-hard satisÔ¨Åability problem. But can we prove a matching PSPACE upper
bound?
We used a tableaux-like algorithm called Witness to show that K-satisÔ¨Åability
was solvable in PSPACE. Witness traded on the following insight: while a K-
consistent formula œÜ may require a satisfying model of size 2|œÜ| , it is always possi-
ble to build a satisfying tree model of this size in which each branch has less than
|œÜ| nodes. Witness tests for K-satisÔ¨Åability by building such trees one branch6 Computability and Complexity
394
at a time; as each branch is polynomial in the size of the input, Witness runs in
PSPACE. However, as we will now show, even small fragments of PDL are strong
enough to force the existence of exponentially deep models.
Proposition 6.51 For every natural number n there is a satisÔ¨Åable PDL formula Œ∫n
of size O(n2 ) such that every model which satisÔ¨Åes Œ∫n contains an Ra -path con-
taining 2n distinct nodes. Moreover, Œ∫n contains occurrences of only two modali-
ties [a] and [a‚àó ], where a is an atomic program.
Proof. We will show how to count using this PDL-fragment. Given a natural num-
ber n, we select n distinct proposition letters q1 , . . . , qn . Using 1 for true, and 0
for false, the list of truth values [V (qn , w), . . . , V (qi , w), . . . , V (q1 , w)] is the n-bit
binary encoding of a natural number. We take V (q1 , w) to be the least signiÔ¨Åcant
digit, and V (qn , w) to be the most signiÔ¨Åcant.
We now construct a formula Œ∫n which, when satisÔ¨Åed at some state w0 , forces
the (n-bit representation of) zero to hold at w0 , and forces the existence of a path
of distinct successors of w0 which correctly count from 0 to 2n‚àí1 in binary. For
example, if n = 2, the model will contain a path of length 4 from w0 to w3 , and as
we move along this path we will successively encounter the following truth value
lists: [0, 0], [0, 1], [1, 0], [1, 1].
To do the encoding, we need to know what happens when we add 1 to a binary
number m. First suppose that the least signiÔ¨Åcant bit of m is 0; for example,
suppose that m is 010100. When we add 1 we obtain 010101; that is, we Ô¨Çip the
least signiÔ¨Åcant digit to 1 and leave everything else unchanged. We can force this
kind of incrementation in PDL as follows:
‚éõ
‚éû

INC0 := ¬¨q1 ‚Üí ‚éù[a]q1 ‚àß
((qj ‚Üí [a]qj ) ‚àß (¬¨qj ‚Üí [a]¬¨qj )‚é† .
j>1
This guarantees that the value of q1 changes to 1 at any successor state, while the
truth values of all the other qj s remain unchanged.
Now suppose that the least signiÔ¨Åcant digit of m is 1. For example, suppose that
m is 01011. When we add 1 we obtain 01100. We can describe this incrementation
as follows. First, we locate the longest unbroken block of 1s containing the least
signiÔ¨Åcant digit and Ô¨Çip all these 1s to 0s. Second, we Ô¨Çip the following digit from 0
to 1 (we have to ‚Äòcarry one‚Äô). Finally, we leave all remaining digits unchanged. The
following formula forces this kind of incrementation when the longest unbroken
block of 1s containing the least signiÔ¨Åcant digit has length i, where 0 < i < n:
INC1 (i) :=
‚éõ
‚éù¬¨qi+1 ‚àß
i

j=1
‚éû
qj ‚é† ‚Üí‚éõ
‚éù[a](qi+1 ‚àß
6.8 EXPTIME
i


¬¨qj ‚àß
j=1
‚éû
395
((qk ‚Üí [a]qk ) ‚àß (¬¨qk ‚Üí [a]¬¨qk ))‚é† .
k>i+1
We can now deÔ¨Åne the required formula Œ∫n :
‚àó

‚àó
(¬¨qn ‚àß ¬∑ ¬∑ ¬∑ ‚àß ¬¨q1 ) ‚àß [a ]a ‚àß [a ] INC0 ‚àß
n‚àí1


INC1 (i) .
i=1
The Ô¨Årst conjunct of Œ∫n initializes the counting at 0, the second guarantees that
there will always be successor states, while the third guarantees that incrementation
is carried out correctly. Clearly Œ∫n is of size O(n2 ) and uses only the allowed
modalities.
Proposition 6.51 is suggestive. It does not prove that no PSPACE algorithm is pos-
sible, but it does tend to conÔ¨Årm our suspicions that PDL-satisÔ¨Åability is computa-
tionally difÔ¨Åcult. And indeed it is. The remainder of the chapter is devoted to prov-
ing the following result: the PDL-satisÔ¨Åability problem is EXPTIME-complete.
The proof methods we use are important in their own right and well worth master-
ing: we will prove EXPTIME-hardness by reduction from the two person corridor
tiling game, and demonstrate the existence of an EXPTIME algorithm using elim-
ination of Hintikka sets.
EXPTIME-hardness via tiling
In Section 6.5 we used tiling problems to prove two undecidability results. We
remarked that tiling problems were also useful for proving complexity results, and
in this section we give an example. We will describe the two person corridor tiling
game and use it to prove the EXPTIME-hardness of PDL-satisÔ¨Åability; we make
use of notation and ideas introduced in our discussion of undecidability.
As with our earlier tiling problems, the two person corridor tiling game involves
placing tiles on a grid so that colors match, but there are some extra ingredients.
There are two players, and we assume that there is a third person present ‚Äì the
referee ‚Äì who starts the game correctly and keeps it Ô¨Çowing smoothly. The referee
will give the players a Ô¨Ånite set {T1 , . . . , Ts } of tile types; the players will use tiles
of these types to attempt to tile a grid so that colors match. In addition, the referee
will set aside two special tile types: T0 and Ts+1 . T0 is there solely to mark the
boundaries of the corridor (we think of the boundaries as having some distinctive
color, say white), while Ts+1 is a special winning tile, whose role will be described
later.
At the start of play, the referee places n initial tiles I1 , . . . , In in a row. To the
left of I1 and to the right of In he places copies of the white tile T0 . That is, the
following sequence of tiles is the initial position:396
6 Computability and Complexity
I1
I2
...
In‚àí1
In
This is the Ô¨Årst row of the corridor. The white tiles in column 0 and column n + 1
mark the boundaries of the corridor. Columns 1 through n are the corridor proper.
Actually, we may as well stipulate that the referee immediately Ô¨Ålls in columns 0
and n + 1 with the special boundary-marking white tile. That is, the players are
going to be playing into the grid inside the following n-column corridor:
..
..
.
.
I1
I2
...
In‚àí1
In
Now the players are ready to start. There are two players, Eloise and Abelard. The
players take turn placing tiles in the corridor, and it is always Eloise who moves
Ô¨Årst. The rules for tile placement are strict: the corridor has to be Ô¨Ålled in from
the bottom, from left to right. For example, after Eloise has placed her Ô¨Årst tile the
corridor will look like this:
..
..
.
.
T
I1
I2
...
In‚àí1
In
When Abelard replies, he must place his tile immediately to the right of tile T .
When the players have completed tiling a row, they start tiling the next one, starting
at column 1. In short, the players have no choice about where to place a tile,
only about which type of tile they will place there. The player‚Äôs choice of tiles is
subject to the usual color-matching rules of tiling, and any tile placed in column
0 or column n has to match the white of the corridor tile. (For example, in the
previous diagram, it must be the case that left(T ) = white.)
When do the players win or lose? As follows. If after Ô¨Ånitely many rounds a
tiling is constructed in which the special winning tile Ts+1 is placed in column 1,
Eloise wins. Otherwise (that is, if one of the players cannot make a legal move and
Ts+1 is not in column 1, or if the game goes on inÔ¨Ånitely long) Abelard wins.
Now for the EXPTIME-complete problem: given a game, does Eloise have a6.8 EXPTIME
397
winning strategy in that game? That is, can she win the game no matter what
Abelard does? It is useful to think of winning strategies in terms of game trees.
For any game, a game tree for that game records all possible responses Abelard
can make to Eloise‚Äôs moves. (Note that we do not insist that game trees encode all
of Eloise‚Äôs options; but it is vital that game trees record all of Abelard‚Äôs options.)
Note that Abelard has only Ô¨Ånitely many possible responses, for there are only
Ô¨Ånitely many tile types. Clearly, if Eloise has a winning strategy in a game, then
there is a game tree that describes that strategy: such a tree spells out exactly what
she has to do, and takes all Abelard‚Äôs possible responses into account.
Now that we know about game trees, let us think about winning strategies for
Eloise. In fact, we can recursively characterize this concept. We Ô¨Årst deÔ¨Åne the
notion of a winning position for Eloise in a game tree:
(i) Whenever the winning tile Ts+1 is placed in column 1, that position is a
winning position for Eloise.
(ii) In case Eloise is to move in position x, then x is a winning position for
Eloise if there exists a move to a winning position for Eloise.
(iii) In case Abelard is to move in position x, then x is a winning position for
Eloise if Abelard can make a move and all his moves lead to a winning
position for Eloise.
We now say that Eloise has a winning strategy iff there is a game tree such that
the root of the game tree is a winning position for her. The problem of determin-
ing whether Eloise has a winning strategy is called the two person corridor tiling
problem, which is known to be EXPTIME-complete (see the Notes for references).
Theorem 6.52 The satisÔ¨Åability problem for PDL is EXPTIME-hard.
Proof. We show this by reducing the two person corridor tiling problem to the
PDL satisÔ¨Åability problem. We will view a game tree as a rooted regular PDL
model with one atomic transition Rm which codes one move of the game. Given
an instance T = (n, {T0 , . . . , Ts+1 }) of the two person corridor tiling game (here
n is the width of the corridor, and the Ti are the tile types), we will show how to
create a formula œÜT such that
(i) If Eloise has a winning strategy, œÜT is satisÔ¨Åable at the root of some game
tree for T (viewed as a regular PDL model).
(ii) If œÜT is satisÔ¨Åable, then Eloise has a winning strategy in the game T ; in
fact, she will be able to read off her winning strategy by following a path
through the satisfying model (starting at the point that satisÔ¨Åes œÜT ).
(iii) The formula œÜT can be computed in time polynomial in n and s.
The formula œÜT contains two kinds of information: it fully describes the structure398
6 Computability and Complexity
of the game tree, and states necessary and sufÔ¨Åcient conditions for Eloise to win.
The Ô¨Årst part boils down to using PDL to describe the initial conÔ¨Åguration, that
players move alternately, that colors match, and so on; this is a little tedious, but
straightforward. Stating necessary and sufÔ¨Åcient conditions for Eloise to win in-
volves Ô¨Ånding PDL formulas that capture the recursive characterization of winning
strategies, and prevent the game from running for inÔ¨Ånitely many moves; this is the
interesting part of the proof.
We use the following proposition letters to construct œÜT :
(i) t0 , t1 , . . . , ts , and ts+1 . These will be used to represent the tiles. We will
often write t0 as white.
(ii) eloise. This will be used to indicate that Eloise has the next move. Its
negation will indicate that Abelard has the next move.
(iii) pos1 , . . . , posn . We use posi to indicate that in the current round, a tile is to
be placed in column i.
(iv) coli (t), for all 0 ‚â§ i ‚â§ n + 1 and all t ‚àà {t0 , t1 , . . . , ts , ts+1 }. These will
be used to indicate that the tile previously placed in column i is of type t.
(v) win. This means that the current position is a winning position for Eloise.
In addition, we make use of the modalities [m] and m (‚Äòafter every possible
move‚Äô and ‚Äòafter some possible move‚Äô respectively) and [m‚àó ], which can be read
as ‚Äòafter every possible sequence of moves.‚Äô
So let us describe the structure of the game tree. The following formula records
the situation at the start of play:
eloise ‚àß pos1 ‚àß col0 (white) ‚àß col1 (tI1 ) ‚àß ¬∑ ¬∑ ¬∑ ‚àß coln (tIn ) ‚àß coln+1 (white).
The Ô¨Årst conjunct says that Eloise has to make the Ô¨Årst move, while the second
says that she has to place her tile in column 1. The remaining conjuncts simply say
that the tiles previously placed in all columns are those of the initial conÔ¨Åguration.
(Of course, these were not placed by the players but by the referee.) That is, they
say that columns 1 through n contain the initial tiles I1 , . . . , In , and that there is a
white corridor tile on each side.
We now write down a series of formulas which regulate the way that further play
takes place. (Note that all these conditions are preceded by the [m‚àó ] modality, thus
ensuring that they continue to hold after any Ô¨Ånite sequence of moves.) We start
by giving the desired meaning to posi and coli (t).
‚Ä¢ Tiles always have to be placed in one of columns 1 through n:
[m‚àó ](pos1 ‚à® ¬∑ ¬∑ ¬∑ ‚à® posn ),
and indeed, in exactly one of these columns:
[m‚àó ](posi ‚Üí ¬¨posj )
(1 ‚â§ i = j ‚â§ n).6.8 EXPTIME
399
‚Ä¢ In every column i, at least one tile type was previously placed:
[m‚àó ](coli (t0 ) ‚à® ¬∑ ¬∑ ¬∑ ‚à® coli (ts+1 ))
(0 ‚â§ i ‚â§ n + 1).
‚Ä¢ In every column i, at most one tile type was previously placed:
[m‚àó ](coli (tu ) ‚Üí ¬¨coli (tv ))
(0 ‚â§ i ‚â§ n + 1 and 0 ‚â§ u = v ‚â§ s + 1).
‚Ä¢ Moreover, the referee has already placed white tiles in columns 0 and n + 1:
[m‚àó ](col0 (white) ‚àß coln+1 (white)).
‚Ä¢ In the course of play, tiles are placed left to right (Ô¨Çipping back to column 1
when a row has been completed):
[m‚àó ]((pos1 ‚Üí [m]pos2 ) ‚àß (pos2 ‚Üí [m]pos3 ) ‚àß ¬∑ ¬∑ ¬∑ ‚àß (posn ‚Üí [m]pos1 )).
‚Ä¢ In columns where no tile is placed, nothing changes when a move is made:
[m‚àó ](¬¨posi ‚Üí ((coli (tu ) ‚Üí [m]coli (tu )) ‚àß (¬¨coli (tu ) ‚Üí [m]¬¨coli (tu )).
(Here 0 ‚â§ i ‚â§ n + 1 and 0 ‚â§ u ‚â§ s + 1.)
With these preliminaries behind us, we can now describe the structure of the game
tree.
‚Ä¢ First of all, players alternate:
[m‚àó ]((eloise ‚Üí [m]¬¨eloise) ‚àß (¬¨eloise ‚Üí [m]eloise)).
‚Ä¢ Next, both players make legal moves; that is, they only place tiles which cor-
rectly match adjacent tiles. It will be helpful to deÔ¨Åne the following ternary
relation of ‚Äòcompatibility‚Äô between propositional variables:
C(t , t, t ) iff right(T  ) = left(T ) and down(T ) = up(T  ),
where T , T  and T are the tiles that correspond to the propositional variables t,
t and t respectively. That is, C(t , t, t ) holds iff the tile T can be placed to the
right of tile T  and above tile T  . With the aid of this relation we can formulate
the Ô¨Årst constraint on tile placement as follows:
(
)
[m‚àó ] posi ‚àß coli‚àí1 (t ) ‚àß coli (t ) ‚Üí [m] {coli (t) | C(t , t, t )} .

(Here 0 ‚â§ i ‚â§ n, and, by convention, ‚àÖ = ‚ä•.)
‚Ä¢ However this constraint is not quite enough; it only ensures matching to the left
and downwards. We also need to ensure that tiles placed in column n match the
white corridor tile to their right, and we can do this as follows:
(
)
[m‚àó ] posn ‚Üí [m] {coln (t) | right(T ) = white} .
(Here t is the proposition letter corresponding to tile T .)400
6 Computability and Complexity
‚Ä¢ Next, we need to ensure that all of Abelard‚Äôs possible responses are encoded in
the model:
(
)

[m‚àó ] ¬¨eloise ‚àß pos i ‚àß coli (t ) ‚àß coli‚àí1 (t ) ‚Üí {mcoli (t) | C(t , t, t )} .

(Here 1 ‚â§ i < n, and, by convention, ‚àÖ = .)
That completes our description of the game tree. So let us turn to our other task:
ensuring that Eloise indeed has a winning strategy. We will do this with the help of
our recursive characterization of winning strategies, thus the Ô¨Årst step is easy; we
simply state that the initial position is a winning position for Eloise:
win.
Next, we spell out the recursive conditions:
[m‚àó ] (win ‚Üí (col1 (ts+1 ) ‚à® (¬¨eloise ‚àß m ‚àß [m]win) ‚à® (eloise ‚àß mwin))).
We are almost there ‚Äì but we do not have quite enough. If a game does not ter-
minate, Abelard wins, so we need to rule out this possibility. Now, any inÔ¨Ånite
branch must involve repetition of rows. Indeed, if N = ns+2 , then if a game runs
N moves, repetition must have occurred.
Repetitions do not help Eloise: if she can win, she can do so in fewer than
N moves. So we are simply going to insist that games run fewer than N moves
‚Äì and we can do this with the help of the PDL counter deÔ¨Åned in the proof of
Proposition 6.51. To use the notation of that proof, we make use of propositional
variables q1 , . . . , qn , all initially set to zero, and increment the counter by 1 at every
move. If the counter reaches N (that is, if all these propositional variables are true
in some successor state) then the game has gone on too long and Abelard wins.
The following formula encodes this observation:
[m‚àó ]((counter = N ) ‚Üí [m]¬¨win).
Let œÜT be the conjunction of all these formulas. We must now verify the three
claims made about œÜT at the start of the proof.
First we need to show that if Eloise has a winning strategy, then there is a game
tree such that œÜT is satisÔ¨Åable at the root of the game tree viewed as a PDL model. If
Eloise has a winning strategy, then she can win in at most N moves. If M is the PDL
model corresponding to this at-most-N move strategy, then it is straightforward to
check that œÜT is satisÔ¨Åed at the root of M.
The second claim is more interesting: we need to show that if M, w  œÜT , then
Eloise has a winning strategy in the game T ‚Äì and that her winning strategy is
encoded in M. So suppose there is such a model. Imagine Eloise facing Abelard
across the playing board and consulting this model to choose her moves. As œÜT is
satisÔ¨Åed at w, win is satisÔ¨Åed at w (remember that the initial position is marked as6.8 EXPTIME
401
winning), hence eloise ‚àß mwin, the third disjunct of our recursive characteriza-
tion of winning strategy, is true at w too. Eloise simply needs to pick a successor
state in the model marked as winning to see which tile to place. In short, she plays
the move described in the model, and continues doing so in subsequent rounds.
Though this guarantees that Eloise can keep moving to winning positions, can
she actually win the game after Ô¨Ånitely many moves? Yes! In fact she can win
in at most N moves. For suppose the N -th move has just been played (that is,
counter = N has just become true). As Eloise has always been moving to winning
positions, the N -th position is also winning, which means that one of the following
formulas is satisÔ¨Åed there:
‚Ä¢ col1 (ts+1 ), or
‚Ä¢ ¬¨eloise ‚àß m ‚àß [m]win, or
‚Ä¢ eloise ‚àß mwin.
As the counter has reached N , [m]¬¨win is satisÔ¨Åed too. This means there are no
further winning positions, and so the second and third disjuncts are false. Hence
col1 (ts+1 ) is satisÔ¨Åed: the winning tile was placed in the Ô¨Årst column in the previ-
ous round. Thus Eloise has already won.
It remains to check that œÜT is polynomial in n and s. The only point that requires
comment is that we can encode N . Encoding any natural number m ‚â• 2 in binary
requires at most lg(m) + 1 bits (lg denotes the logarithm to base 2). So encoding
N takes at most lg(ns+2 ) = (s + 2) lg(n) ‚â§ (s + 2)n bits, which is polynomial
in n and s. Thus we have reduced the two person corridor tiling problem to the
satisÔ¨Åability problem for PDL, hence the latter is EXPTIME-hard.
As the previous proof makes clear, the EXPTIME-hardness of PDL largely stems
from the fact that it contains a pair of modalities, one for working with a relation
Rm and the other for reÔ¨Çexive transitive closure (Rm )‚àó ; this is what enabled us
to force exponentially deep models, and to code the corridor tiling problem. Now,
this is not the entire story, for there are logics containing such modality pairs whose
satisÔ¨Åability problem is in PSPACE: one example is the modal logic of the frame
(N, S, <), in a language with two diamonds s and <. Here N is the set of
natural numbers, S is the successor-of relation, and < is the usual ordering of
N. And an even more expressive language ‚Äì one involving the until operator U
‚Äì has a PSPACE-complete satisÔ¨Åability problem over (N, S, <); see the Notes for
references.
Despite this, the following is a reliable rule of thumb: when working with a
modal language containing a pair of modalities for working with a relation and its
transitive closure, suspect EXPTIME-hardness. Do not begin your investigations
by looking for a PSPACE-algorithm, unless you are working with a class of frames402
6 Computability and Complexity
that allows little or no branching. And as this section has demonstrated, an elegant
way of proving EXPTIME-hardness is via the two person corridor tiling game.
Elimination of Hintikka sets
By Theorem 6.52 there are instances of the PDL-satisÔ¨Åability problem which will
require exponentially many steps to solve. As yet we have no matching upper
bound. In fact, so far the best solution to PDL-satisÔ¨Åability we have is the fol-
lowing non-deterministic algorithm: given a formula œÜ, let Œ£ be the set of all œÜ‚Äôs
subformulas, form the collection of all Hintikka sets in Œ£, non-deterministically
choose a model of size at most 2c|œÜ| , and check œÜ on this model. By the decidabil-
ity result for PDL (Corollary 6.14), if œÜ is satisÔ¨Åable, it is satisÔ¨Åable in a model of
at most this size, hence PDL-satisÔ¨Åability is solvable in NEXPTIME.
As we will now show, the EXPTIME-hardness result of the previous section can
be matched by an EXPTIME algorithm. Like the PSPACE Witness algorithm de-
veloped in the previous section, the EXPTIME algorithm for PDL is based around
the idea of Hintikka sets. Here is how we deÔ¨Åne this notion for PDL.
DeÔ¨Ånition 6.53 (Hintikka set for PDL) Let Œ£ be a set of PDL formulas and
¬¨FL(Œ£) the closure under single negations of its Fischer-Ladner closure (see DeÔ¨Å-
nition 4.79). A Hintikka set over Œ£ is any maximal subset of ¬¨FL(Œ£) that satisÔ¨Åes
the following conditions:
(i) If ¬¨œÜ ‚àà ¬¨FL(Œ£), then ¬¨œÜ ‚àà H iff œÜ ‚àà H.
(ii) If œÜ ‚àß œà ‚àà ¬¨FL(Œ£), then œÜ ‚àß œà ‚àà H iff œÜ ‚àà H and œà ‚àà H.
(iii) If œÄ1 ; œÄ2 œÜ ‚àà ¬¨FL(Œ£), then œÄ1 ; œÄ2 œÜ ‚àà H iff œÄ1 œÄ2 œÜ ‚àà H.
(iv) If œÄ1 ‚à™ œÄ2 œÜ ‚àà ¬¨FL(Œ£), then œÄ1 ‚à™ œÄ2 œÜ ‚àà H iff œÄ1 œÜ or œÄ2 œÜ ‚àà H.
(v) If œÄ‚àó œÜ ‚àà ¬¨FL(Œ£), then œÄ ‚àó œÜ ‚àà H iff œÜ ‚àà H or œÄœÄ‚àó œÜ ‚àà H.
We denote the set of all Hintikka sets over Œ£ by Hin(Œ£).
The Ô¨Årst clause of DeÔ¨Ånition 6.53 ensures the maximality of Hintikka sets: if H ‚àà
Hin(Œ£) then there is no H ‚àà Hin(Œ£) such that H ‚äÇ H  . So, when the effect
of clause (ii) is taken into account, we see that Hintikka sets are maximal subsets
of ¬¨FL(Œ£) that contain no blatant propositional inconsistencies. Hintikka sets for
PDL are a generalization of something we met in Chapter 4, namely atoms (see
DeÔ¨Ånition 4.80). Clearly At(Œ£) ‚äÜ Hin(Œ£); indeed, At(Œ£) contains precisely the
PDL-consistent Hintikka sets.
We use Hintikka sets as follows. We deÔ¨Åne a model M0 that is built out of
Hin(Œ£). We then iteratively eliminate Hintikka sets from this model, thus forming
a sequence of ever smaller models. This process is deterministic, and terminates
after at most exponentially many steps yielding a model M. We will then show
that a PDL formula œÜ is satisÔ¨Åable iff it is satisÔ¨Åable in M.6.8 EXPTIME
403
Elimination of Hintikka sets:
Base case. Let Œ£ be a Ô¨Ånite set of PDL formulas, and let Œ† be the set of
programs that occur in Œ£. DeÔ¨Åne W 0 to be Hin(Œ£). For all basic programs
a, and all H, H  ‚àà W 0 , deÔ¨Åne a binary relation Q0a by HQ0a H  iff for every
œÜ ‚àà H  , if aœÜ ‚àà ¬¨FL(Œ£) then aœÜ ‚àà H. For all other programs œÄ ‚àà
Œ†, deÔ¨Åne Q0œÄ to be the usual inductively deÔ¨Åned PDL relations, and let F0
be (W 0 , Q0œÄ )œÄ‚ààŒ† . DeÔ¨Åne V 0 by V 0 (p) = {H ‚àà W 0 | p ‚àà H}, for all
propositional variables p. Finally, let M0 be (F0 , V 0 ).
Inductive step. Suppose that n ‚â• 0 and that Fn = (W n , QnœÄ )œÄ‚ààŒ† and Mn =
(Fn , V n ) are deÔ¨Åned. Say that H ‚àà W n is demand-satisÔ¨Åed iff for all œÄ ‚àà Œ†,
and all formulas œà, if œÄœà ‚àà H then there is an H ‚àà W n such that HQnœÄ H 
and œà ‚àà H  . Then deÔ¨Åne:
(i) W n+1 = {H ‚àà W n | H is demand-satisÔ¨Åed}.
(ii) Qn+1
is QnœÄ ‚à© (W n+1 √ó W n+1 ), and Fn+1 is (W n+1 , Qn+1
œÄ
œÄ )œÄ‚ààŒ† .
n+1
n
n+1
n+1
n+1
n+1
(iii) V
is V
W
, and M
is (F
,V
).
As Hin(Œ£) is Ô¨Ånite and W n+1 ‚äÜ W n , then for some m ‚â• 0 this inductive
process stops creating new structures. (That is, for all j ‚â• m, Mj = Mm .)
DeÔ¨Åne F (= (W, QœÄ )œÄ‚ààŒ† ) to be Fm and deÔ¨Åne M (= (F, V )) to be Mm .
The reader should contrast this use of Hintikka sets with the way we used them in
our discussion of PSPACE. The Witness algorithm carefully builds sequences of
ever smaller Hintikka sets using only PSPACE resources. In sharp contrast to this,
the Ô¨Årst step of Elimination of Hintikka sets forms all possible Hintikka sets (and
there are exponentially many), and subsequent steps Ô¨Ålter out the useless ones.
Theorem 6.54 The satisÔ¨Åability problem for PDL is solvable in deterministic ex-
ponential time.
Proof. Given a PDL formula œà, we will test for its satisÔ¨Åability as follows. Letting
Œ£ be the set of all œà‚Äôs subformulas, we form Hin(Œ£) and perform elimination of
Hintikka sets. This process terminates yielding a model M = (W, QœÄ , V )œÄ‚ààŒ† . We
will shortly prove the following claim, for all formulas œÜ ‚àà Œ£:
œÜ is satisÔ¨Åable iff œÜ ‚àà H for some H ‚àà W.
(6.16)
If we can prove this claim, the theorem follows. To see this, note that the number
of Hintikka sets over Œ£ is exponential in the size of œà, and the process of con-
structing Mn+1 out of Mn is a deterministic process that can be performed in time
polynomial in the size of the model, and hence elimination of Hintikka sets is an
EXPTIME algorithm.
So it remains to establish (6.16). For the right to left direction, we will show that
if œÜ ‚àà H for some H ‚àà W , then M itself satisÔ¨Åes œÜ at H. Indeed, we will show404
6 Computability and Complexity
that for all œÜ ‚àà ¬¨FL(Œ£) and all H ‚àà W , M, H  œÜ iff œÜ ‚àà H. This proof is by
induction. The clause for propositional symbols is clear, and the step for boolean
combinations follows using clauses (i) and (ii) in the deÔ¨Ånition of Hintikka sets.
For the step involving the modal operators we need the following subclaim:
for all œÄœá ‚àà ¬¨FL(Œ£), œÄœá ‚àà H iff
for some H  ‚àà W we have QœÄ HH  and œá ‚àà H  .
(6.17)
The left to right direction of (6.17) is immediate from the construction of M, for at
the end of the elimination process only the demand-satisÔ¨Åed Hintikka sets remain.
The right to left direction follows by induction on the structure of œÄ; we demon-
strate the base case and the step for modalities constructed using ‚àó. Suppose that
for some basic program a there are Hintikka sets H and H such that HQa H  and
œá ‚àà H  . As we built the relation Qa by a sequence of eliminations and restrictions,
it follows that if HQa H  then HQ0a H  ‚Äì and hence it follows by deÔ¨Ånition that
aœá ‚àà H  . Next, suppose that for some program œÄ‚àó there are Hintikka sets H and
H  such that HQœÄ‚àó H  and œá ‚àà H  . But this means there is a Ô¨Ånite sequence
H = H0 QœÄ H1 . . . Hn‚àí1 QœÄ Hn = H  .
As œá ‚àà H  it follows by the deÔ¨Ånition of Hintikka sets that œÄ‚àó œá ‚àà H  = Hn ,
so inductively we Ô¨Ånd that œÄœÄ‚àó œá ‚àà Hn‚àí1 ; hence, by the deÔ¨Ånition of Hintikka
sets, œÄ‚àó œá ‚àà Hn‚àí1 . Again, by induction on œÄ it follows that œÄœÄ‚àó œá ‚àà Hn‚àí2 ,
whence œÄ‚àó œá ‚àà Hn‚àí2 since this set if Fischer-Ladner closed. By repeating this
argument we obtain that œÄ‚àó œá ‚àà H0 = H. This establishes the inductive proof of
(6.17), which in turn completes the inductive proof of the right to left direction of
(6.16).
The fastest way to prove the left to right direction of (6.16) is to make use of
ideas developed when proving the completeness of PDL in Chapter 4. Recall that
we deÔ¨Åned P, the PDL model over Œ£, to be (At(Œ£), {RœÄŒ£ }œÄ‚ààŒ† , V Œ£ ). Here At(Œ£)
is the set of all atoms over Œ£, V Œ£ is the natural valuation, and RœÄŒ£ is deÔ¨Åned as
follows: for any two atoms A and B, and any basic program a, ARaŒ£ B holds iff
 ‚àß aB
 is consistent. We deÔ¨Åned RœÄ for arbitrary programs by closing these
A
basic relations under composition, union, and reÔ¨Çexive transitive closure in the
usual way.
Now, we Ô¨Årst claim that for all programs œÄ, RœÄŒ£ ‚äÜ Q0œÄ . To see this, Ô¨Årst observe
that as At(Œ£) ‚äÜ Hin(Œ£), all atoms A and B are in W 0 . So suppose ARaŒ£ B.
 ‚àß aB
 is consistent, by the maximality of Hintikka sets we have that
Then, as A
for all œÜ ‚àà B, if aœÜ ‚àà ¬¨FL(Œ£) then aœÜ ‚àà A, that is, AQ0œÄ B. Thus for
all atomic programs, the desired inclusion holds. But the relations RœÄ and Q0œÄ
corresponding to arbitrary programs œÄ are generated out of Ra and Q0a in the usual
way, hence the inclusion follows for all programs.
The importance of this observation is the following consequence: atoms can6.8 EXPTIME
405
never be discarded in the process of elimination of Hintikka sets. This follows
from the Existence Lemma for PDL (Lemma 4.89), which states that for all atoms
A, and all formulas œÄœà ‚àà ¬¨FL(Œ£), if œÄœà ‚àà A, there is an atom B such that
ARœÄŒ£ B and œà ‚àà B. As all atoms belong to W 0 , and as RœÄŒ£ ‚äÜ Q0œÄ , it follows
that every atom in W 0 is demand-satisÔ¨Åed. Moreover, this demand satisÔ¨Åability
depends only on the presence of other atoms. It follows that Hintikka elimination
cannot get rid of atoms; that is, At(Œ£) ‚äÜ W .
But now the left to right direction of (6.16) follows easily. Suppose that œÜ is
satisÔ¨Åable. Then œÜ is PDL-consistent, which means it belongs to at least one atom
in Œ£. This atom will survive the elimination process, and we have the result.
This establishes the result we wanted: an EXPTIME algorithm for deciding the
satisÔ¨Åability problem for PDL. One question may be bothering some readers: what
is the relationship between the models M and P in the proof of Theorem 6.54?
Let us consider the matter. In the proof, we observed that all atoms survive the
Hintikka elimination process. In fact, only atoms can survive. (To see this, simply
observe that if some inconsistent Hintikka set H survived the Hintikka process,
then by (6.16), every formula in H would be satisÔ¨Åed in M at H. But as M is a
regular model, this is impossible.) Hence M, like P, is a model built over the set
of atoms. Moreover, we showed in the course of proving the previous theorem that
every relation in P is a subrelation of the corresponding relation in M. It follows
that P is a submodel of M.
Actually, we can say a little more. Recall from Exercise 4.8.4 that P is isomor-
phic to a certain Ô¨Åltration. In fact, M is isomorphic to a Ô¨Åltration over the same
set of sentences. Which Ô¨Åltration? We leave this as an exercise for the reader; see
Exercise 6.8.4.
Exercises for Section 6.8
6.8.1 Enrich the basic modal language with the global modality A. (This was deÔ¨Åned in
Section 6.5.) Show that the satisÔ¨Åability problem for the enriched language over the class
of all frames is EXPTIME-hard.
6.8.2 As in the previous exercise, enrich the basic modal language with the global modality
A. Use elimination of Hintikka sets to show that the satisÔ¨Åability problem for the enriched
language over the class of all frames is solvable in EXPTIME.
6.8.3 In this exercise we investigate the complexity of deterministic PDL.
(a) Change the PDL-hardness proof so that it works for deterministic PDL. How many
programs do you need? Are two programs sufÔ¨Åcient?
(b) Encode with just one functional program that a model has an exponential deep path.
Use this to describe n-corridor tiling. What can you conclude?
(c) So by now we might have a suspicion that with only one program, the satisÔ¨Åability
problem for deterministic PDL might be in PSPACE. But how to prove that? The406
6 Computability and Complexity
best way is to Ô¨Ånd a proof in the literature which can be used almost immediately.
What are the crucial features of functional PDL with one program? Think of a tem-
poral logic which has precisely these same features. Can you interpret functional
PDL into that temporal logic, using some kind of translation function? If so, what
is the complexity of that function? What can you conclude?
6.8.4 Determine the exact relationship between the models P and M discussed following
the proof of Theorem 6.54.
6.8.5 PDL has an EXPTIME-complete satisÔ¨Åability problem. Suppose we add the global
modality to the language. What is the complexity of the resulting satisÔ¨Åability problem?
6.9 Summary of Chapter 6
 Decidability and Undecidability: A logic is called decidable if its satisÔ¨Åability
problem (or equivalently, its validity problem) is decidable. Otherwise it is
called undecidable.
 Decidability via the Finite Model Property: While possession of the Ô¨Ånite model
property does not guarantee decidability, Ô¨Ånite models can be used to prove
decidability given some extra information about the models or the logic. The
decidability of many of the more important modal logics, including PDL, can
be established using such arguments.
 Decidability via Interpretations: Another important technique for establishing
decidability is via interpretation in decidable logical theories, most notably the
monadic second-order theories of countable Ô¨Ånitely- or œâ-branching trees. If a
modal logic is complete with respect to a class of models that can be viewed
as monadic second-order deÔ¨Ånable substructures of such a tree, its decidability
follows.
 Quasi-Models and Mosaics: Even when a modal logic lacks the Ô¨Ånite model
property, it is sometimes possible to prove decidability using Ô¨Ånite represen-
tations of the information contained in satisfying models. Quasi-models and
mosaics are such representations.
 Undecidability: Undecidability arises easily in modal logic. Moreover, not all
undecidable modal logics have the simplest degree of undecidability; many are
highly undecidable.
 Tiling Problems: Tiling problems can be used to classify the difÔ¨Åculty of both
decidable and undecidable problems. The simple geometric ideas underlying
them make them a useful tool for investigating modal satisÔ¨Åability problems.
 The Modal SigniÔ¨Åcance of NP: Only modal logics with the polysize model prop-
erty with respect to particularly simple classes of structures can be expected to
have satisÔ¨Åability problems in NP. Some important logics, such as the normal
logics extending S4.3, fall into this category.Notes to Chapter 6
407
 The Modal SigniÔ¨Åcance of PSPACE: Assuming that PSPACE = NP, most
modal satisÔ¨Åability problems are not solvable in NP, but are at least PSPACE-
hard. For example, every normal logic between K and S4 has a PSPACE-hard
satisÔ¨Åability problem. Explicit PSPACE algorithms are known for some of these
logics.
 The Modal SigniÔ¨Åcance of EXPTIME: Modal languages containing a modal-
ity r and a matching reÔ¨Çexive transitive closure modality r‚àó  often have
EXPTIME-hard satisÔ¨Åability problems. The two person corridor tiling game
is an attractive tool for proving modal EXPTIME-hardness results, and elimina-
tion of Hintikka sets is a standard way of deÔ¨Åning EXPTIME algorithms.
Notes
Finite models have long been used to establish decidability, both in modal logic and
elsewhere. Arguments based on Ô¨Ånite axiomatizability together with the f.m.p. are
widely used (Theorem 6.15); this approach traces back to Harrop [213]. Also pop-
ular is the use of the strong Ô¨Ånite model property; our formulation (Theorem 6.7) is
based on Goldblatt‚Äôs [177]. The fact that a recursive axiomatization together with
the f.m.p. with respect to a recursively enumerable class of models guarantees de-
cidability (Theorem 6.13) seems to have Ô¨Årst been made explicit in Urquhart [440].
The main point of Urquhart‚Äôs article is to prove the result we presented as Exer-
cise 6.2.5: there is a normal modal logic which is recursively axiomatizable, and
has the f.m.p., but is undecidable. This shows that the use of Ô¨Ånite axiomatizations
in the statement of Theorem 6.15 cannot be replaced by recursive axiomatizations,
and Urquhart states Theorem 6.13 as the correct generalization. Exercise 6.2.4
is due to Hemaspaandra (n√©e Spaan); see Spaan [419]. For Craig‚Äôs Lemma, see
Craig [98].
The original proof of Rabin‚Äôs Tree Theorem may be found in Rabin [368]. Rabin
shows that the decidability of SnS for n > 2 or n = œâ is reducible to the decidabil-
ity of S2S, and the bulk of his paper is devoted to proving that S2S is decidable.
Rabin‚Äôs paper is demanding, and simpler proofs have subsequently been found;
for an up to date survey of Rabin‚Äôs Theorem and related material, see Gecseg and
Steinby [167] and Thomas [432]. Rabin‚Äôs Theorem was applied in modal logic al-
most immediately: Fine [127] used it to prove decidability results in second-order
modal logic (that is, modal logic in which it is possible to bind propositional vari-
ables), and Gabbay [145, 146, 147] applied it to a wide range of modal logics in
many different languages. Gabbay, Hodkinson, and Reynolds [156] is a valuable
source on the subject.
Two kinds of variations on Rabin‚Äôs Tree Theorem are relevant to our readers.
First, the weak monadic second-order theory of n successor functions (WSnS)
constrains the set variables to range over Ô¨Ånite sets only. The decidability of WSnS408
6 Computability and Complexity
‚Äì which is due to Thatcher and Wright [429] and Doner [113] ‚Äì is based on a close
correspondence between formulas in WSnS and Ô¨Ånite automata; any relation œÜ
deÔ¨Ånable in WS2S can also be deÔ¨Åned by a tree automaton AœÜ that encodes the
satisfying assignments to the formula in the labels on the nodes of the tree that it
accepts. The MONA system [220] implements this decision procedure. Despite
the non-elementary worst-case complexity of WS2S, MONA works well in prac-
tice on a large range of problems; Basin and Klarlund [29] offer empirical evidence
and an analysis of why this is the case. At the time of writing there are no exper-
imental results evaluating the performance of tools such as MONA on logics such
as propositional dynamic logic. Muller et al. [338] use reductions to WS2S to
explain why many temporal and dynamic logics are decidable in EXPTIME.
A second variation is important when working with expressive modal languages
(for example, those containing the until operator U ) over highly restricted classes
of models (for example, models isomorphic to the real numbers in their usual or-
der). It may be necessary to appeal to stronger results about speciÔ¨Åc classes of
structures; Burgess and Gurevich [80] and Gurevich and Shelah [201] are essential
reading here.
Prenex normal form fragments of Ô¨Årst-order logic are deÔ¨Åned using strings over
{‚àÉ, ‚àÉ‚àó , ‚àÄ, ‚àÄ‚àó }; for instance, ‚àÉ‚àÄ‚àó represents the class of Ô¨Årst-order formulas in
prenex normal form where the quantiÔ¨Åer preÔ¨Åx starts with an existential quanti-
Ô¨Åer and is followed by a (possibly empty) sequence of universal quantiÔ¨Åers. The
decidability of prenex normal form fragments seems to have been studied at least
since the early 1920s, which is when Skolem showed that ‚àÄ‚àó ‚àÉ‚àó is undecidable. In
1928, Bernays and Sch√∂nÔ¨Ånkel gave a decision procedure for the satisÔ¨Åability of
‚àÉ‚àó ‚àÄ‚àÉ‚àó sentences. G√∂del, Kalm√°r and Sch√ºtte, independently in 1931, 1933 and
1934 respectively, discovered decision procedures for the satisÔ¨Åability of ‚àÉ‚àó ‚àÄ2 ‚àÉ‚àó
sentences. In 1933, G√∂del showed that ‚àÄ3 ‚àÉ‚àó sentences form a reduction class for
satisÔ¨Åability (that is, arbitrary Ô¨Årst-order satisÔ¨Åability problems can be reduced to
such satisÔ¨Åability problems). More recently, Kahr in 1962 proved the undecidabil-
ity of ‚àÄ‚àÉ‚àÄ. Consult B√∂rger et al. [71] for references and an encyclopedic account of
prenex normal form fragments. For recent work on the relevance of such fragments
to modal logic, see Hustadt [237].
That the two-variable fragment of any Ô¨Årst-order language is decidable is rel-
evant to a number of modal decidability problems. The Ô¨Årst decidability result
for this fragment (without equality) was obtained by Scott [401]; Mortimer [337]
established decidability of the two-variable fragment with equality. In contrast,
for k ‚â• 3, the k-variable fragment is undecidable. Consult Gr√§del, Kolaitis, and
Vardi [195] for complexity results, and Gr√§del, Otto, and Rosen [196] for related
results.
But perhaps the most natural way to reduce a modal logic is ‚Äì to another modal
logic! Such reductions are far likelier to yield not only decidability results, butNotes to Chapter 6
409
information about complexity as well. Embeddings of temporal logic into the basic
modal language were Ô¨Årst studied by Thomason in the mid 1970s (see, for example,
[437]). The approach has gained a new lease of life recently ‚Äì important results on
the approach can be found in Kracht and Wolter [282] and Kracht [279].
Our use of quasi-models and mosaics has its roots in the work of Zakharyaschev
and others. In particular, Zakharyaschev and Alekseev [468] use such arguments
to show that all Ô¨Ånitely axiomatizable normal logics extending K4.3 are decidable,
and Wolter [457] uses them to show that all Ô¨Ånitely axiomatizable tense logics
extending Kt 4.3 are decidable too.
The mosaic method for proving decidability of a logic stems from N√©meti [340]
who proved that various classes of relativized cylindric algebras have a decidable
equational theory. It has since been used for a wide range of logics, often with a
multi-dimensional Ô¨Çavor; see for instance Marx and Venema [320], Mikul√°s [329],
Reynolds [377], Wolter and Zakharyaschev [462], Wolter [460], or the references
in our Notes on the guarded fragment in Chapter 7. With hindsight, even G√∂del‚Äôs
proof of the decidability of the satisÔ¨Åability problem for the ‚àÄ2 ‚àÉ‚àó prenex sentences
can be called a mosaic style proof as well; see the very clear exposition in the
monograph [71]. Mosaics can also be used to investigate modal complexity theory;
see Marx [316] for further details.
Constructing speciÔ¨Åc examples of undecidable modal logics is not trivial, and
Thomason [434] contains the earliest explicit example of an undecidable normal
logic in the basic modal language that we know of. Undecidable logics can be
constructed in a variety of ways. Urquhart‚Äôs [440] deÔ¨Ånition of ŒõU (see Exer-
cise 6.2.5) is neat, if abstract. For undecidable logics in the basic modal language
constructed by detailed simulation of a concrete model of computation (namely,
Minsky machines), see Chagrov and Zakharyaschev [88, Chapter 16].
We have chosen to focus on tiling problems (or domino problems, as they are
sometimes called). These were introduced in Wang [453] and have since been
used in a variety of forms to prove undecidability and complexity results. Proofs
that the N √ó N tiling problem is undecidable can be found in Berger [52], Robin-
son [389], and Lewis and Papadimitriou [301]. Two important papers on tiling
are Harel [210, 211]: these demonstrate the Ô¨Çexibility of the method as a tool for
measuring the complexity of logics. Harel uses tiling to give an intuitive account
of highly undecidable (and in particular, Œ£11 -complete) problems, and these two
papers are probably the best starting point for readers interested in learning more.
The logic KR used in the text to illustrate the tiling method is a notational variant
of Kasper Rounds logic, which is used in computational linguistics to analyze the
notion of feature structure uniÔ¨Åcation. Decidability and complexity results for (var-
ious versions of) Kasper Rounds logic can be found in Kasper and Rounds [266]
and Blackburn and Spaan [61]; the latter is the source for Theorems 6.31 and 6.34.
A wide range of related results can be found in the literature (see for example410
6 Computability and Complexity
Harel [209], Halpern and Vardi [206], and Passy and Tinchev [358]). Even in quite
modest languages, asserting something about all paths through a model can lead to
extremely high complexity; for a deeper understanding of why this is so, we refer
the reader to Harel [210, 211], and to Harel, Kozen and Tiuryn [212].
As to complexity-theoretic classiÔ¨Åcations of modal satisÔ¨Åability and validity
problems, Ladner [292] is one of the earliest analyses; this classic paper is the
source of Ladner‚Äôs Theorem and much else besides ‚Äì it is required reading! Hal-
pern and Moses [205] is an excellent introduction to the decidability and complex-
ity of multi-modal languages. We strongly recommend this article to our readers ‚Äì
especially those who are encountering complexity theoretic ideas for the Ô¨Årst time.
But to return to the results in this chapter, the NP-completeness of S5 was proved
in Ladner [292]. Ono and Nakamura [348] is the source of Theorem 6.38; in
that paper it is also shown that the complexity of the satisÔ¨Åability problems in
the language with F and P with respect to the following Ô¨Çows of time are all
NP-complete: linear transitive Ô¨Çows of time without endpoints, and dense linear
transitive Ô¨Çows of time without endpoints (see Exercise 6.6.3). Hemaspaandra‚Äôs
Theorem, that all normal modal logics extending S4.3 are NP-complete, may be
found in Spaan [419] and Hemaspaandra [215]. As an aside, the satisÔ¨Åability
problem for the Ô¨Çow of time (N, ‚â§) in the language with just F was shown to be
NP-complete by Sistla and Clarke [415]; the satisÔ¨Åability problem is also shown
to be NP-complete for formulas using F and the so-called nexttime operator. NP-
complete modal-like logics were also investigated in the area of description logic;
see below for references. Many NP-completeness results make use of Lemma 6.36,
that frame membership is decidable in polynomial time for Ô¨Årst-order deÔ¨Ånable
frame classes (see in Exercise 6.6.1). This is a standard result in Ô¨Ånite model the-
ory, and you can Ô¨Ånd a proof in Ebbinghaus and Flum [118].
The key results on PSPACE come from Ladner [292]. Ladner Ô¨Årst establishes
the existence of PSPACE algorithms for K, T, and S4. His proof of the PSPACE-
completeness of K is like that given in the text, save that Ladner uses ‚Äòconcrete
tableaux‚Äô (that is, his algorithm speciÔ¨Åes how to construct the required atoms)
rather than ‚Äòabstract tableaux‚Äô (which factor out the required boolean reasoning).
Concrete tableaux are also used by Halpern and Moses [205] to construct PSPACE
algorithms for multi-modal versions of K, S4 ‚Äì and indeed S5; as they show, log-
ics containing two S5 modalities are PSPACE-hard. This paper gives a very clear
exposition of how to use tableaux systems to establish decidability and complexity
results. The abstract tableaux systems used in this chapter are based on the work of
Hemaspaandra [420, 419, 215]. In the description logic community, tableaux sys-
tems are often called constraint systems [115]; description logics (also known as
concept languages or terminological logics) are essentially multi-modal languages,
equipped with additional operators to facilitate the representation of knowledge,
with global constraints (the so-called TBox), or with means to reason about indi-Notes to Chapter 6
411
viduals and properties (the so-called ABox). Unlike the modal logic community, in
the description logic community considerable attention has been paid to reasoning
tasks other than satisÔ¨Åability or validity checking, such as subsumption checking,
instance checking, and reasoning in the presence of a background theory [114].
In the text (page 401) we also mentioned the fact that, over the natural num-
bers (with < and the successor function S), the temporal logic with the until op-
erator has a PSPACE-complete satisÔ¨Åability problem; this result is due to Sistla
and Clarke [415]. In the same paper, the authors also show that the satisÔ¨Åability
problem for (N, <) is PSPACE-complete for each of the following systems: F
and X; U (until); U , S (since), X; and the extended temporal logic ETL due to
Wolper [456].
The effect of bounding the number of proposition letters and the degree of modal
formulas has been studied by Halpern [203]. In addition to the results mentioned
in Exercises 6.6.5 and 6.7.7, he shows that the PSPACE-completeness results of
Ladner and Halpern and Moses hold for multi-modal versions of K, T, S4, S5, even
with a single proposition letter in the language. If we restrict to a Ô¨Ånite degree, the
satisÔ¨Åability problem is NP-complete for all the logics considered, but S4; if we
impose both restrictions, the complexity goes down to linear time in all cases.
The EXPTIME-hardness of PDL (Theorem 6.52) is due to Fischer and Lad-
ner [135], who explicitly construct a PDL formula which simulates the actions of
a linear space bounded alternating Turing machine. The (simpler) proof given in
the text stems from Chlebus [93], which establishes the EXPTIME hardness of the
two person corridor tiling game (via a reduction from alternating Turing machines)
and uses it to provide a new proof of EXPTIME hardness for PDL. Another proof
of this via two person corridor tiling can be found in van Emde Boas [120]; the
recursive formulation of the game halting condition is due to Marx.
The existence of an EXPTIME algorithm for PDL, and the method of eliminat-
ing Hintikka sets, comes from Pratt [363]. Other applications of the method can
be found in multi-modal logics of knowledge equipped with a common knowledge
operator (see Halpern and Vardi [206], or Fagin et al. [125]); in computational
tree logic (CTL; see Emerson [121]); in expressive description logics (see Donini
et al. [115]); and in work on the global modality (see Marx [316] or Spaan [419]).
One important approach to the analysis of modal complexity has not been dis-
cussed in this chapter: the use of Ô¨Ånite automata. The theory of automata has
been a subject of research since the 1960s (B√ºchi [72], Thatcher and Wright [429],
Rabin [368]). Especially relevant to temporal and dynamic logics has been a resur-
gence of interest in Ô¨Ånite automata on inÔ¨Ånite objects in the 1980s and 1990s; see
Gecseg and Steinby [167], Hayashi [214], and Thomas [431, 432]. A wide variety
of automata have been studied, and complexity results for their acceptance prob-
lems are known. It is often possible to analyze the complexity of modal satisÔ¨Åabil-
ity problems by reducing them to acceptance problems for automata. For example,412
6 Computability and Complexity
general automata-theoretic techniques for reasoning about relatively simple logics
using B√ºchi tree automata have been described by Vardi and Wolper [442].
We conclude on a more general note. In this chapter we have focused mainly on
satisÔ¨Åability and validity problems ‚Äì what about the decidability and complexity of
other reasoning tasks? For a start, the global satisÔ¨Åability problem (whether there
is a model which satisÔ¨Åes a formula at all its points) is important in many applica-
tions and quite different from the (local) satisÔ¨Åability problem discussed here. The
discussion of the global modality in Section 6.5 and Exercise 6.8.1 has given the
reader some of the Ô¨Çavor of such problems; for more, see Marx [316]. Other rea-
soning tasks that are closely related to the global satisÔ¨Åability problem, are often
studied in the area of description logic mentioned before; see De Giacomo [106]
or Areces and de Rijke [15].
Furthermore, there is a great deal of interest in building practical systems that
evaluate formulas (not necessarily modal ones) in models; this Ô¨Åeld is known as
model checking. Many interesting problems can be usefully viewed as model
checking problems, and representations which enable evaluation to be performed
efÔ¨Åciently ‚Äì even when the models contain a very large number of states ‚Äì have
been developed. For an intuitive, modally oriented, introduction to the basic ideas,
see Halpern and Vardi [207]. For further pointers to the model checking literature,
see [326, 95, 96, 239].
Third, it is interesting to inquire into the decidability or otherwise of a wide range
of metalogical properties of logics. One such result was mentioned in Section 3.7:
Chagrova‚Äôs Theorem tells us that it is undecidable whether a Ô¨Årst-order property
of frames can be deÔ¨Åned by a modal formula. And many other questions along
these lines can be raised (for example: is it decidable whether a new proof rule
is admissible in a given logic?). The best sources for further information on such
topics are Chagrov and Zakharyaschev [88, Chapters 16 and 17] and Kracht [279].
Another line of results that we should mention here is work on the following ques-
tion: given two (Ô¨Ånite) models M and N, how hard is it to decide whether they are
bisimilar? Ponse et al. [360] contains a number of valuable starting points for such
questions.7
Extended Modal Logic
As promised in the preface, this chapter is the party at the end of the book. We
have chosen six of our favorite topics in extended modal logic, and we are going
to tell you a little about them. There is no point in offering detailed advice here:
simply read these introductory remarks and the following Chapter Guide and turn
to whatever catches your fancy.
Roughly speaking, the chapter works its way from fairly concrete to more ab-
stract. A recurrent theme is the interplay between modal and Ô¨Årst-order ideas. We
start by introducing a number of important logical modalities (and learn that we
have actually been using logical modalities all through the book). We then exam-
ine languages containing the since and until operators, and show that Ô¨Årst-order
expressive completeness can be used to show modal deductive completeness. We
then explore two contrasting strategies, namely the strategy underlying hybrid logic
(import Ô¨Årst-order ideas into modal logic, notably the ability to refer to worlds) and
the strategy that leads to the guarded fragment of Ô¨Årst-order logic (export the modal
locality intuition to classical logic). Following this we discuss multi-dimensional
modal logic (in which evaluation is performed at a sequence of states), and see that
Ô¨Årst-order logic itself can be viewed as modal logic. We conclude by proving a
Lindstr√∂m Theorem for modal logic.
Chapter guide
Section 7.1: Logical Modalities (Basic track). Logical modalities have a Ô¨Åxed in-
terpretation in every model. We introduce two of the most important (the
global modality, and the difference operator) and brieÔ¨Çy discuss Boolean
Modal Logic (a system which contains an entire algebra of diamonds).
Section 7.2: Since and Until (Basic track). We introduce the since and until op-
erators (and their stronger cousins, the Stavi connectives), discuss the ex-
pressive completeness results they give rise to, and use expressive com-
pleteness to prove deductive completeness.
413414
7 Extended Modal Logic
Section 7.3: Hybrid Logic (Basic track). Hybrid languages are modal languages
which can refer to worlds. They do so using atomic formulas called nom-
inals which are true at exactly one world in any model. We introduce the
basic hybrid language and discuss its completeness theory.
Section 7.4: The Guarded Fragment (Advanced track). As is clear from the stan-
dard translation, modal operators perform a ‚Äòguarded‚Äô form of quantiÔ¨Åca-
tion across states. What happens when this idea is exported to Ô¨Årst-order
logic and generalized? This section provides some answers.
Section 7.5: Multi-Dimensional Modal Logic (Advanced track). By viewing as-
signments as possible worlds and quantiÔ¨Åers as diamonds, one can treat
Ô¨Årst-order logic itself as a modal formalism. In fact, orthodox Tarskian
semantics for Ô¨Årst-order logic provides a prime example of multi-dimen-
sional modal logic: formulas are evaluated at a sequence of points.
Section 7.6: A Lindstr√∂m Theorem for Modal Logic (Advanced track). As a fa-
mous theorem due to Lindstr√∂m tells us, any logic satisfying complete-
ness, compactness, and L√∂wenheim-Skolem is essentially Ô¨Årst-order logic.
Is there an analogous abstract characterization of modal logic?
7.1 Logical Modalities
Pure Ô¨Årst-order logic has a signiÔ¨Åcant expressive weakness: it is not strong enough
to express the concept of equality in arbitrary structures. But because equality is
such an important relation, logicians introduce a special binary relation symbol
(namely =) and stipulate that it denotes the equality relation. As the interpretation
of = is Ô¨Åxed, and as the relation it denotes is so fundamental, the equality symbol
is called a logical predicate.
Logical modalities trade on the same idea. Are there important relations which
ordinary modal languages cannot express? Very well then: let us add new modali-
ties and stipulate that they be interpreted by the relation in question. In this section
we will discuss two of the most important logical modalities: the global modality
(which is interpreted by the relation W √ó W ) and the difference operator (which
is interpreted by =, the inequality relation). We will also make a few remarks
about Boolean Modal Logic (BML), a system containing an entire family of logical
modalities.
But before going any further, let us get one thing absolutely clear: we have
been using logical modalities all through the book. Here is the simplest example.
Suppose we are working with the basic modal language. Now, for many purposes
we may be happy simply using 3 to talk about the relation R ‚Äì but sometimes
we may want to talk about RÀá, the converse of R, as well. Now, we know (see
Exercise 2.1.2) that this cannot be done in the basic modal language, so we have
to add a new backward-looking modality as a primitive; doing so, of course, gives7.1 Logical Modalities
415
us the basic temporal language. But note: we do not have to bring in the concept
of time to justify this extension. If a binary relation R is important, its converse is
likely to be too ‚Äì so it is simply common sense to consider adding a diamond for
RÀá. In short, the ‚Äòtemporal operator‚Äô P is really a logical modality.
The other important example is PDL. To motivate PDL we told a story about pro-
grams and transition systems ‚Äì but a more abstract motivation is not only possible,
it is more satisfying. The point is this. As soon as we Ô¨Åx a collection of relations
RŒ± , regular algebra is staring us in the face: we can combine these relations using
union and composition, and form transitive closures. Any model containing the
initial RŒ± relations implicitly contains many other interesting relations as well ‚Äì
so it is natural to add extra modalities to deal with them explicitly, and doing so
yields PDL. As this example shows, we can go way beyond the idea of adding a
single new logical modality: we can add an entire algebra of diamonds. We will
see another example of this when we discuss BML.
The global modality
Throughout the book we have emphasized the locality of modal logic, and for
many purposes local languages are ideal. For example, suppose we are working
with a modal language for talking about computer networks, and in this language œÜ
means Server 1 is active and œà means Server 2 is active. Then
we can check whether the network makes it possible for Server 1 to be active
by checking whether œÜ is satisÔ¨Åable, and we can check whether it is possible for
Server 2 to be inactive by testing for the satisÔ¨Åability of ¬¨œà.
But suppose we want to know if whenever Server 1 is active, then so is
Server 2. There is no obvious way to test this. Testing for the satisÔ¨Åability
of œÜ ‚Üí œà does not answer this question: if œÜ ‚Üí œà is satisÔ¨Åable, this only means
that there is a state where either œÜ is false or œà is true. We want to know whether
every state that makes œÜ true is also a state that makes œà true. This is clearly a
global query. What are we to do?
Here is an elegant answer: enrich the language with the global modality. To
keeps things simple, suppose we are working in the basic modal language over
some Ô¨Åxed choice of proposition letters; to simplify our notation, let us call this
language ML(3). We will now add a second diamond, written E, and call the
resulting language ML(3, E). The interpretation of E is Ô¨Åxed: in any model M =
(W, R, V ), E must be interpreted using the relation W √ó W . That is:
M, w  EœÜ iff there is a u ‚àà W such that M, u  œÜ.
Thus E scans the entire model for a state that satisÔ¨Åes œÜ. Its dual AœÜ := ¬¨E¬¨œÜ has
the following interpretation:
M, w  AœÜ iff M, u  œÜ, for all u ‚àà W .416
7 Extended Modal Logic
That is, AœÜ asserts that œÜ holds at all points in the model. In effect, A brings the
metatheoretic notion of global truth in a model down into the object language: for
any model M, and any formula œÜ, we have that M  œÜ iff AœÜ is satisÔ¨Åable in M.
We will call E the global diamond, and A the global box. When it is irrelevant
whether we mean E or its dual, we will simply say global modality.
It should now be clear how to handle the computer network problem: to test
whether Server 2 is active whenever Server 1 is, we test the satisÔ¨Åability
not of œÜ ‚Üí œà, but of A(œÜ ‚Üí œà). This query has exactly the global force required.
Well ‚Äì this looks appealing. But what are the properties of this (obviously richer)
new language? Maybe introducing the global modality destroys the properties that
make model logic attractive in the Ô¨Årst place! We have made an important change,
and we need to take a closer look at the consequences.
Now, we could begin by discussing the sublanguage ML(E) ‚Äì but this is not
very interesting (it is easy to see that E is just an S5 modality). Anyway (as our
server example shows) the main reason for adding logical modalities is to have
them available as additional tools. So the real question is: what does ML(3, E)
offer that ML(3) does not? The most obvious answer is expressivity. Let us Ô¨Årst
consider expressivity at the level of frames:
(R = W 2 )
Ep ‚Üí 3p,
(R = ‚àÖ)
E3,
(‚àÉx‚àÄy ¬¨Rxy)
E2 ‚ä•,
(‚àÄx‚àÉy Ryx)
p ‚Üí E3p,
(|W | = 1)
Ep ‚Üí p,
n+1

(|W | ‚â§ n)
i=j E(pi ‚àß pj ),
i=1 Epi ‚Üí
(R is trichotomous) (p ‚àß 2q) ‚Üí A(q ‚à® p ‚à® 3p),
(RÀá is well-founded) A(2p ‚Üí p) ‚Üí p.
None of the frame classes listed is deÔ¨Ånable in ML(3), but (as we ask the reader
to check in Exercise 7.1.1) the ML(3, E) formulas to their right do deÔ¨Åne the
corresponding property.
Where does this extra frame expressivity come from? From trivializing the no-
tion of generated submodel (generating on W √ó W always yields W √ó W ) and
rendering inapplicable the notion of disjoint union (for any disjoint frames (W, R)
and (W  , R ), (W √ó W )  (W  √ó W  ) = (W  W  ) √ó (W  W  )). By insisting that
E be interpreted using W √ó W , we have trashed two of the classic modal preser-
vation results and thereby bought ourselves more expressivity. How much more?
For Ô¨Årst-order deÔ¨Ånable frame classes, the answer is elegant:
Theorem 7.1 A Ô¨Årst-order deÔ¨Ånable class of frames is deÔ¨Ånable in ML(3, E) iff it
is closed under taking bounded morphic images, and reÔ¨Çects ultraÔ¨Ålter extensions.7.1 Logical Modalities
417
This is exactly the Goldblatt-Thomason Theorem ‚Äì minus closure under disjoint
unions and generated subframes.
There is also a gain of expressivity at the level of models (the server example
makes this clear, and we already know from Section 2.1 that the global modality
is not deÔ¨Ånable in the basic modal language). Moreover, we can measure the gain
using our old friends: bisimulations. It is an easy exercise to adapt the deÔ¨Ånition of
bisimulation for the basic modal language to ML(3, E), and a rather more demand-
ing one to prove a bisimulation-based characterization result for the language. The
reader is asked to attend to these matters in Exercises 7.1.3 and 7.1.4.
What about completeness? The set of valid ML(3, E) formulas can be axioma-
tized as follows. Take the minimal normal logic in 3 and E (that is, apply DeÔ¨Åni-
tion 4.13 to this two-diamond similarity type), and add the following axioms:
(reÔ¨Çexivity)
(symmetry)
(transitivity)
(inclusion)
p ‚Üí Ep,
p ‚Üí AEp ,
EEp ‚Üí Ep,
3p ‚Üí Ep.
Note that the Ô¨Årst three axioms are the familiar T, B, and 4 axioms (written in E
and A rather than 3 and 2). We discussed inclusion in Example 1.29(iv). We will
call this logic Kg .
Theorem 7.2 Kg is strongly complete with respect to the class of all frames.
This theorem says that to lift the minimal logic K (for the basic modal language)
to ML(3, E), we need merely treat the global modality as a normal operator that
satisÔ¨Åes four further axioms. In fact, we can lift any canonical ML(3) logic in
this way. If KŒì is a normal modal logic in ML(3), let Kg Œì be the normal modal
logic in ML(3, E) obtained by treating E as a normal operator and adding the four
axioms listed above. Then:
Theorem 7.3 Let Œì be a set of ML(3) formulas, and let F be the class of frames
that Œì deÔ¨Ånes. If KŒì is canonical, then Kg Œì is strongly complete with respect to
F.
Proof. Let M = (W, R3 , RE , V ) be the canonical model for Kg Œì. Note that as
KŒì ‚äÜ Kg Œì, we have that (W, R3 ) belongs to F, for KŒì is canonical. Indeed,
any generated subframe of (W, R3 ) belongs to F, for validity in the basic modal
language is closed under generated subframes.
Given a Kg Œì-consistent set of sentences Œ£, use Lindenbaum‚Äôs Lemma to ex-
pand it to a Kg -MCS Œ£ + . By the Canonical Model Theorem, M, Œ£+  Œ£. Now,
(reÔ¨Çexivity), (symmetry), and (transitivity) are canonical formulas, thus RE is an
equivalence relation. And although there is no guarantee that RE is W √ó W , this418
7 Extended Modal Logic
 , R , V ) be the submodel of M generated by
is easy to correct: let M = (W  , R3
E
 = W  √ó W  , so we have the global relation
Œ£ + using the RE -relation. Then RE
we need. Furthermore, because of inclusion, R3 ‚äÜ RE , thus M is also a gen-
erated submodel of M with respect to R3 , hence M , Œ£ +  Œ£. It only remains
 ) is in F, hence the result follows.
to observe that (by our initial remarks) (W , R3
(Theorem 7.2 is the special case in which Œì = ‚àÖ.)
Example 7.4 Suppose we are working with ML(3) over transitive frames (so the
relevant logic is K4, which is canonical). Now, we may want to state global con-
straints on models, or insist that certain information holds somewhere or other, and
of course we can do this if we add the global modality. But how do we obtain a
complete logic for transitive frames in the enriched language?
Simply enrich K4 by treating the global modality as a normal operator and
adding the (reÔ¨Çexivity), (transitivity), (symmetry), and (inclusion) axioms. Doing
so yields Kg 4, and by the theorem just proved this logic is strongly complete with
respect to the class of transitive frames.
What about decidability and complexity? We brieÔ¨Çy met the global modality in
Section 6.5, and we saw that its global reach makes it possible to force the existence
of gridlike models. This led to undecidability results for languages containing
several diamonds, and it is not difÔ¨Åcult to adapt these arguments to Ô¨Ånd frame
classes with decidable ML(3) logics and undecidable ML(3, E) logics (we give
such an example in Exercise 7.1.5). Moreover, although undecidability does not
strike over the class of all frames, Kg is probably more complex than K, for Kg
has an EXPTIME-complete satisÔ¨Åability problem (the reader was asked to prove
this in Exercises 6.8.1 and 6.8.2) while K is PSPACE-complete (see Section 6.7).
On the other hand, there is a rather nice transfer result concerning the Ô¨Åltration
method: if we can prove the decidability of an ML(3) logic by using Ô¨Åltrations to
establish the strong Ô¨Ånite frame property, then we can also do so after adding the
global modality. For example, it follows that the logic Kg 4 (see Example 7.4) is
decidable. We will state and prove a stronger version of this result when we discuss
the difference operator.
All in all, the global modality is a strikingly natural extension of modal logic ‚Äì
and at Ô¨Årst glance this seems surprising. How can something so obviously global
blend so well with the locality of modal logic? Basically, because the enriched
language still takes an internal perspective on relational structure. Although we
now have a global operator at our disposal, we still place formulas inside models
and evaluate them at a particular state. To put it another way, the intuition that
a modal formula is an automaton scanning accessible states is remarkably robust:
even if we add a special automaton programmed to regard all states as accessible,
we retain much of the characteristic Ô¨Çavor of ordinary modal logic.7.1 Logical Modalities
419
A lot more could be said about the global modality. For a start, it is natural
when viewed from an algebraic perspective (it gives rise to discriminator vari-
eties). Moreover, the global modality can be added to many richer modal systems,
including PDL and the hybrid and multi-dimensional logics discussed later in the
chapter, often without raising the computational complexity (for example PDL is
EXPTIME-complete, and adding E does not change this). But for more informa-
tion the reader will have to consult the Notes and Exercises, for it is time to discuss
an even more powerful logical modality.
The difference operator
At the bottom of every toolbox lies a heavy cast-iron hammer. It is not the sort
of tool we use every day ‚Äì for delicate jobs it is inappropriate, and we may feel
slightly embarrassed about using it at all. Still, there will always come a time when
something simply will not budge, and then we Ô¨Ånd ourselves reaching for it. Think
of the difference operator as that hammer.
Once again, we will start with ML(3). We will add a second diamond D, the
difference operator, and call the resulting language ML(3, D). The interpretation
of D is Ô¨Åxed: in any model M = (W, R, V ), D must be interpreted using the
inequality relation =. That is:
M, w  DœÜ iff there is a u = w such that M, u  œÜ.
Thus the difference operator scans the entire model looking for a different state that
satisÔ¨Åes œÜ. Its dual D := ¬¨D¬¨œÜ has the following interpretation
M, w  DœÜ iff M, u  œÜ for all u = w.
In what follows we discuss ML(3, D), but the sublanguage ML(D) is quite inter-
esting in its own right, and we ask the reader is asked to explore it in Exercise 7.1.6.
Using the difference operator, we can deÔ¨Åne the global modality: EœÜ := œÜ‚à®DœÜ.
Thus all our earlier examples of frame classes deÔ¨Ånable in ML(3, E) are deÔ¨Ånable
in ML(3, D) too. But ML(3, D) can deÔ¨Åne even more:
(irreÔ¨Çexivity) 3p ‚Üí Dp,
(antisymmetry) (p ‚àß ¬¨Dp) ‚Üí 2(3p ‚Üí p),
(‚àÉxy (x = y)) D,


(|W | > n)
A( 1‚â§i‚â§n pi ) ‚Üí E 1‚â§i‚â§n (pi ‚àß Dpi ).
None of these frame classes is closed under bounded morphic images hence (by
Theorem 7.1) none of them is deÔ¨Ånable in ML(3, E); but it is easy to see that the
listed ML(3, D) formulas successfully capture them. Incidentally, we have already
seen that ML(3, E) can deÔ¨Åne |W | ‚â§ n, thus as ML(3, D) can deÔ¨Åne |W | > n,
the difference operator can count states, at least as far as frames are concerned; in420
7 Extended Modal Logic
Exercise 7.1.7 we ask the reader to investigate whether it can count over models as
well. Furthermore, note the p ‚àß ¬¨Dp antecedent in the deÔ¨Ånition of antisymmetry.
This is only true when p is true at exactly one state in the model: in effect we are
using the power of D to force p to act as ‚Äòname‚Äô for a state; we will put this power
to good use shortly.
What about completeness? The set of valid ML(3, D) formulas can be axioma-
tized as follows. Take the minimal normal logic in 3 and D, and add the following
axioms:
(symmetry)
p ‚Üí DDp,
(pseudo-transitivity) DDp ‚Üí (p ‚à® Dp),
(D-inclusion)
3p ‚Üí p ‚à® Dp.
We will call this logic Kd . Now, it is not particularly difÔ¨Åcult to prove the com-
pleteness of Kd (we ask the reader to do so in Exercise 7.1.8) ‚Äì but it is harder
than with Kg (we have to do more than simply take a generated submodel) and the
result does not extend to stronger logics so easily (there is no obvious analog of
Theorem 7.3). It is also easy to Ô¨Ånd frame incompleteness results, indeed we can
even Ô¨Ånd them in the sublanguage ML(D)! Things are not looking too good . . . .
Enter the hammer. When we discussed rules for the undeÔ¨Ånable (Section 4.7) we
learned that proof rules which rely on ‚Äònames‚Äô can lead to general frame complete-
ness results. And as we noted above, the difference operator is powerful enough
to simulate state names, thus we can formulate the following rule of proof (the
D-rule):
 (p ‚àß ¬¨Dp) ‚Üí Œ∏
.
Œ∏
(Here p is a proposition letter that does not occur in Œ∏. The intuitions underlying
this rule are analogous to those underlying the IRR rule discussed in Section 4.7,
and we will leave it to the reader to verify that it preserves validity.) And now for
a remarkable result. The D-rule neatly meshes with our earlier work on Sahlqvist
formulas to yield one of the most general completeness results known in modal
logic, the D-Sahlqvist theorem.
Here we only formulate a version in the basic temporal language. Consider the
language with operators F , P and D; let, for a set Œ£ of axioms in this logic, Ktd Œ£
be the normal modal logic generated by the axioms of basic temporal logic, the
D-axioms and D-rule given above, and the formulas in Œ£.
Theorem 7.5 Let Œ£ be a collection of Sahlqvist formulas in the basic temporal
language. Then Ktd Œ£ is strongly sound and complete with respect to the class of
bidirectional frames deÔ¨Åned by (the Ô¨Årst-order frame correspondents of) the axioms
in Œ£.7.1 Logical Modalities
421
Proof. We will prove weak completeness only. The Ô¨Årst step of the proof is to
prove the existence of a collection W of maximal consistent sets such that
(i) each Œì in W contains a name, that is, a formula of the form œÜ ‚àß ¬¨DœÜ,
(ii) for each Œì in W and each formula F œà ‚àà Œì , there is a Œî in W such that Œì
and Œî are in the canonical accessibility relation RFc for F ; and, likewise,
for the operators P and D.
c Œì Œî.
(iii) for each pair of distinct points Œì and Œî in W we have RD
All of this can be proved in the style of Proposition 4.71.
c is the inequality relation on W .
It easily follows from (i) and (iii) above that RD
But then the model on W given by V (p) = {Œì ‚àà W | p ‚àà Œì } is named; that
is, for every point in the model there is a formula which is true only at this point,
see DeÔ¨Ånition 4.76. However, condition (ii) allows us to prove a Truth Lemma
which implies that all axioms of the logic are true throughout the model. But then
it follows from Theorem 4.77 that the Sahlqvist axioms are valid on the underlying
frame as well.
The pinch of Theorem 7.5 lies in the fact that the Ô¨Årst-order frame correspondents
it mentions use inequality for the ‚Äòrelation symbol‚Äô referring to the accessibility
relation of D. This means that we can automatically axiomatize frame properties
like irreÔ¨Çexivity or antisymmetry. The reader may doubt the usefulness of this:
surely, the logic of the class of irreÔ¨Çexive frames is identical to the logic of the class
of all frames? True, but this may change when we consider irreÔ¨Çexivity in addition
with other properties. Conditions like irreÔ¨Çexivity, undeÔ¨Ånable in themselves, may
nevertheless have ‚Äòside effects‚Äô so to speak. What we mean is that there are frame
classes K such that the logic of K differs from the logic of the irreÔ¨Çexive frames in
K. In such cases the above theorem can be of tremendous help.
In a surprisingly large number of cases we Ô¨Ånd ourselves in the situation that
over a certain class of frames, the difference operator is deÔ¨Ånable in the underlying
modal language. For example, over the class of strict linear orders, the temporal
formula F p ‚à® P p holds at a point if and only if p holds at a different point. In
general, we say that a formula Œ¥(p) acts as D on a frame F if F  Œ¥(p) ‚Üî Dp; if
Œ¥(p) acts as the difference operator on every frame in a class K then we say that Œ¥
deÔ¨Ånes D over K.
DeÔ¨Ånability of the difference operator is of great use for axiomatizability, as the
following result shows. For a formula Œ¥(p), let KtŒ¥ Œ£ be the ‚ÄòŒ¥‚Äô-version of Ktd ,
that is, the logic in the language without the D-operator obtained by replacing, in
all axioms and derivation rules of Ktd , every formula DœÜ with Œ¥(œÜ).
Theorem 7.6 Let Œ£ be a collection of Sahlqvist formulas. Then KtŒ¥ Œ£ is strongly
sound and complete with respect to the class of those bidirectional frames on which
Œ£ is valid and on which Œ¥ acts as the difference operator.422
7 Extended Modal Logic
In the section on multi-dimensional modal logic we will see an application of this
theorem; for a proof, we refer the reader to Exercise 7.1.9. We will examine another
name-driven proof rule (called PASTE) in detail when we discuss hybrid logic. First
we turn to decidability issues concerning the difference operator.
ML(3, D) is a strong language. As it can deÔ¨Åne the global modality, Kd must
have an EXPTIME-hard satisÔ¨Åability problem (in fact, the problem is EXPTIME-
complete; see Exercise 7.1.10) and it is even easier to Ô¨Ånd undecidable logics
than in ML(3, E). Nonetheless, decidability is often retained. In particular, if
the ML(3) logic of a class of frames can be proved decidable by using a Ô¨Åltration
argument to establish the strong Ô¨Ånite frame property, then the ML(3, D) logic of
that same frame class can be proved decidable in the same way. Let us prove this.
DeÔ¨Ånition 7.7 Let Œõ be a logic, and let F be a class of frames for Œõ. We say that
Œõ admits Ô¨Åltrations on F if for any model M which is based on a frame in F, and
for any Ô¨Ånite subformula closed set Œ£ of ML(3) formulas, there is a Ô¨Åltration Mf
of M through Œ£ which is based on a frame in F.
Theorem 7.8 Suppose that F is a class of frames, and that ŒõF (the set of all
ML(3)-formulas valid on F) admits Ô¨Åltrations on F. Then the logic ŒõdF (the set
of all ML(3, D)-formulas valid on F) has the strong Ô¨Ånite frame property with
respect to F.
Proof. Let Œæ be an ML(3, D)-formula satisÔ¨Åable in a model M = (W, R, V ) of
which the underlying frame (W, R) is in F. We want to show that Œæ is satisÔ¨Åable in
an F-frame of bounded size.
Let Œ£ be the set of subformulas of Œæ. First consider the relation Œ£ which
holds between two points if they satisfy the same formulas in Œ£. As the points of
our Ô¨Ånite model we would like to take the equivalence classes of this relation but
this would not work out well (it is instructive to see how the proof of the Ô¨Åltration
lemma fails in the inductive step of the difference operator). The key idea of the
proof of the theorem is to solve this problem by splitting each equivalence class in
two parts ‚Äì unless the original class is a singleton. To achieve this we add a new
proposition letter d to the language and we make d true at exactly one point of each
equivalence class. We would then like to Ô¨Åltrate the new model according to the
equivalence relation Œ£‚à™{d} .
There is still a problem, however: we can only guarantee that the underlying
frame of the Ô¨Åltrated model is in F if we Ô¨Åltrate through a set of ML(3) formulas.
But Œ£ may contain formulas with occurrences of D. In order to get rid of these, we
employ a little technical trick. For every formula of the form Dœà in Œ£, choose a
distinct propositional variable qœà that does not occur in any formula in Œ£. Let V  be
the valuation that differs from V , if at all, only in that V  (qœà ) = {w | M, w  Dœà}
and that V  (d) is as indicated above. Let M be the model (W  , R , V  ).7.1 Logical Modalities
423
Now deÔ¨Åne the set Œ£ as follows. It is not difÔ¨Åcult to see that for every œÜ ‚àà
Œ£ there is a unique ML(3) formula œÜ such that œÜ can be obtained from œÜ by
replacing in œÜ every proposition letter qœà by Dœà. Put
Œ£  = {œÜ | œÜ ‚àà Œ£} ‚à™ {d, qœà | Dœà ‚àà Œ£}.
Observe that the formulas in Œ£ are D-free and that Œ£ is subformula closed. The
model M is (or can be seen as) an ML(3)-model satisfying
M, s  œÜ iff M , s  œÜ
(7.1)
for all formulas œÜ in Œ£. Let Œ£  hold between two points iff they satisfy the
same formulas in Œ£ ; it is easy to see that every Œ£ -equivalence class |s| splits
into either one or two Œ£  -equivalence classes, depending on whether |s| has one
or more elements.
In any case, it follows from the assumption in the theorem that there is a Ô¨Åltration
Mf through Œ£ which is based on a frame in F. Note that by deÔ¨Ånition, the points
of Mf are the Œ£  -equivalence classes. We claim that this model Mf satisÔ¨Åes
the following property for all ML(3, D)-formulas œÜ in Œ£ and all states s in M:
M, s  œÜ iff Mf , |s|  œÜ.
(7.2)
From this, the theorem is almost immediate.
The proof of (7.2) proceeds by a formula induction of which we omit the stan-
dard inductive steps concerning the boolean operators; the clauses for 3 are fairly
easy as well ‚Äì but note that for one direction, one needs (7.1). For the case that
œÜ is of the form Dœà we also omit the easy right to left direction of (7.2). For the
other direction, suppose that M, s  Dœà. Then there is a point s = s such that
M, s  œà. If |s| and |s | are distinct then we are Ô¨Ånished, so suppose otherwise.
But from s Œ£  s it follows on the one hand that M, s  d iff M, s  d, and
on the other hand, that s and s belong to the same Œ£ -equivalence class. Since
we chose exactly one point in each Œ£ -class to satisfy d, this means that neither
s nor s can be this special point. Hence, there must be another point s in this
Œ£ -equivalence class which does make d true. From s Œ£ s it follows that
M, s  œà, so by the inductive hypothesis we have that Mf , |s |  œà. But |s | is
distinct from |s| since d holds at s and not at s. This gives that Mf , |s|  Dœà, as
required.
How does decidability follow? Any logic Œõ that admits Ô¨Åltrations on F has the
strong Ô¨Ånite frame property with respect to F ‚Äì so if F is recursive we can apply
Theorem 6.7 and conclude that ŒõF is decidable. But then by the result just proved,
we know that ŒõdF also has the strong Ô¨Ånite frame property with respect to F, so we
can apply the model enumeration idea underlying the proof of Theorem 6.7 to for-
mulas of the richer languages. As D is always interpreted by the inequality relation,7 Extended Modal Logic
424
and as this relation is obviously computable on Ô¨Ånite structures, the decidability of
ŒõdF follows.
A great deal more could be said about the difference operator (in particular,
bisimulations are easily adapted to cope with D, and a bisimulation-based charac-
terization result is forthcoming; see Exercises 6.8.1 and 6.8.2) but it is time to take
a brief look at a system containing a whole family of logical modalities.
Boolean Modal Logic
As we have remarked, as soon as we Ô¨Åx a collection of relations RŒ± , we can form
the regular algebra over this base; building an algebra of diamonds corresponding
to these leads to PDL. But an even more obvious algebra demands attention: we can
also form the boolean algebra over base relations RŒ± . Why not deÔ¨Åne an algebra
of diamonds corresponding to 1, ‚àí, ‚à©, and ‚à™? Doing so leads to Boolean Modal
Logic (BML).
We deÔ¨Åne the language of BML as follows. As with PDL, we Ô¨Åx a set of primitive
relation symbols a, b, c, . . . , and in addition a distinguished relation symbol 1.
From these we build complex relations using the relation constructors ‚àí, ‚à© and
‚à™: that is, if Œ± and Œ≤ are relation symbols, then so are ¬¨Œ±, Œ± ‚à© Œ≤, and Œ± ‚à™ Œ≤.
BML is the modal language containing a diamond Œ± for each relation symbol Œ±.
In principle we can interpret BML on any model of appropriate similarity type ‚Äì
that is triples M = (W, {RŒ± | Œ± is a relation symbol }, V ) ‚Äì but most such models
are inappropriate. We are only interested in boolean models, the models in which
R1 = W √ó W , and such that, for all relation symbols Œ± and Œ≤, R‚àíŒ± = RŒ± (that
is, (W √ó W ) \ RŒ± ), RŒ±‚à©Œ≤ = RŒ± ‚à© RŒ≤ , and RŒ±‚à™Œ≤ = RŒ± ‚à™ RŒ≤ .
BML is an expressive language ‚Äì for a start, it contains the global modality ‚Äì and
it may seem that we have bitten off more than we can chew. While the ‚à™ constructor
is well-behaved (in particular F  Œ± ‚à™ Œ≤p ‚Üî Œ±œÜ ‚à® Œ≤p iff RŒ±‚à™Œ≤ = RŒ± ‚à™ RŒ≤ ),
the ‚à© constructor is difÔ¨Åcult to work with. However, as we will now see, with the
help of the ‚àí constructor we can get an exact grip on the relations of interest.
First we deÔ¨Åne the following operator (often called window): for any relation
symbol Œ±:
[|Œ±|]œÜ := [‚àíŒ±]¬¨œÜ.
That is:
M, w  [|Œ±|]œÜ iff ‚àÄu (M, u  œÜ ‚áí RŒ± wu).
Window is an extremely natural operator ‚Äì once you have seen it, you wonder how
you ever managed without it (see the Notes for various interpretations). But what
concerns us here is the following result: window allows very smooth deÔ¨Ånitions of
the relations we are interested in.7.1 Logical Modalities
425
Proposition 7.9 Let F be a frame (W, {RŒ± | Œ± is a relation symbol }). Then:
(i) F  [‚àíŒ±]p ‚Üî [|Œ±|]¬¨p iff RŒ± ‚äÜ RŒ± ,
(ii) F  [Œ±]¬¨p ‚Üî [| ‚àí Œ±|]p iff RŒ± ‚äÜ RŒ± ,
(iii) F  [|Œ± ‚à© Œ≤|]p ‚Üî [|Œ±|]p ‚àß [|Œ≤|]p iff RŒ±‚à©Œ≤ = RŒ± ‚à© RŒ≤ .
Proof. We prove the third claim. The right to left direction is trivial. For the left
to right direction, assume that F  [|Œ± ‚à© Œ≤|]p ‚Üî [|Œ±|]p ‚àß [|Œ≤|]p. We need to show
that RŒ±‚à©Œ≤ = RŒ± ‚à© RŒ≤ . To see that RŒ±‚à©Œ≤ ‚äÜ RŒ± ‚à© RŒ≤ , suppose that RŒ±‚à©Œ≤ wu, and
let V be any valuation on F such that V (p) = {u}. Then (F, V ), w  [|Œ± ‚à© Œ≤|]p.
As F  [|Œ± ‚à© Œ≤|]p ‚Üî [|Œ±|]p ‚àß [|Œ≤|]p we have (F, V ), w  [|Œ±|]p ‚àß [|Œ≤|]p. But u is the
only point satisfying p, hence RŒ± wu and RŒ≤ wu. A similar argument shows that
RŒ± ‚à© RŒ≤ ‚äÜ RŒ±‚à©Œ≤ .
In a sense, the relations are divided into two kingdoms: the ordinary [Œ±] modalities
govern relations built with ‚à™, the window modalities [|Œ±|] govern the relations built
with ‚à©, and the ‚àí constructor acts as a bridge between the two realms. Moreover
the bridging function of ‚àí also Ô¨Ånds expression in a new rule of proof, BR. Unlike
the other additional rules discussed in this book, BR is not name-driven:
 [Œ±]p ‚Üí ([Œ≤]p ‚Üí [Œ≥]p)
 [Œ±]p ‚Üí ([|Œ≥|]¬¨p ‚Üí [|Œ≤|]¬¨p)
(BR)
While it is possible to prove a completeness result for BML without using BR, its
use leads to an elegant axiomatization, for it enables us to thread negations through
the structured modalities.
A Ô¨Ånal surprise is in store. In Theorem 6.31 we showed that the fragment con-
taining the ‚à© constructor and the global modality was undecidable over determin-
istic frames. Nonetheless, the minimal logic in BML actually turns out to be de-
cidable. All in all, BML is a fascinating system. For more information, see the
Notes.
Exercises for Section 7.1
7.1.1 We listed numerous frame conditions deÔ¨Ånable in ML(3, E) and ML(3, D) which
were not deÔ¨Ånable in ML(3). Show that these deÔ¨Ånability claims are correct.
7.1.2 Show that ML(3, E) validity is preserved under bounded morphisms and reÔ¨Çects
ultraÔ¨Ålter extensions. (That is, show the easy direction of the Goldblatt-Thomason style
result for ML(3, E) stated in Theorem 7.1.) Can you prove the (far more demanding)
converse?
7.1.3 Extend the standard translation to the global modality and the difference opera-
tor. Extend the notion of bisimulation for the basic modal language to ML(3, E) and
ML(3, D), and show that your deÔ¨Ånition leads to an invariance result.426
7 Extended Modal Logic
7.1.4 Building on the previous exercise, characterize the expressivity of ML(3, E) and
ML(3, D) over models.
7.1.5 Let 2-3 be the class of frames (W, R) such that every state has 2 R-successors, and
3 R-successors of R-successors. First show that the satisÔ¨Åability problem in ML(3) over
2-3 is decidable (note: this can not be proved using a Ô¨Åltration argument). Then show that
the satisÔ¨Åability problem in ML(3, E) over 2-3 is undecidable. (It may be helpful to note
that this exercise is related to Exercise 6.5.2.)
7.1.6 Show that a class of frames is deÔ¨Ånable in ML(D) if and only if it is deÔ¨Ånable in
the Ô¨Årst-order language over = (that is, the Ô¨Årst-order language of equality). What is the
complexity of the satisÔ¨Åability problem for ML(D)?
7.1.7 Clearly we can deÔ¨Åne in ML(3, D) an operator Q with the following satisfaction
deÔ¨Ånition: for any model M, any state w in M, and any formula œÜ, M, w |= QœÜ iff there is
exactly one state u in M such that M, u |= QœÜ. But it is also possible to deÔ¨Åne modalities
Q2 œÜ, Q3 œÜ, Q4 œÜ, and so on, that are satisÔ¨Åed when œÜ holds at precisely Q n states (n ‚â• 2)
in the model?
7.1.8 Show that K d is complete with respect to the class of all frames. (No need to try
anything fancy here ‚Äì just Ô¨Åddle with the canonical model.)
7.1.9 Prove Theorem 7.6. That is, let Œ£ be a collection of Sahlqvist formulas in the basic
modal language. Show that K tŒ¥ Œ£ is strongly sound and complete with respect to the
class of those frames on which Œ£ is valid and on which Œ¥ acts as the difference operator.
(Hint: use an auxiliary logic K tŒ¥ Œ£+ in the temporal language expanded with the difference
operator. Simply deÔ¨Åne this logic as having both the D and the Œ¥ versions of the D-axioms
and rules. Now Ô¨Årst use Theorem 7.5 to prove that this logic is sound and strongly complete
with respect to the class of Œ£-frames on which Œ¥ acts as the difference operator. Then,
prove that KtŒ¥ Œ£+ is conservative over K tŒ¥ Œ£; that is, show that for every purely temporal
formula œÜ, we have that œÜ belongs to K tŒ¥ Œ£ iff it belongs to K tŒ¥ Œ£+ .)
7.1.10 Use an elimination of Hintikka sets argument to show that the K d satisÔ¨Åability
problem is solvable in EXPTIME.
7.2 Since and Until
The modal operators considered in previous chapters all have satisfaction deÔ¨Åni-
tions involving only existential or only universal quantiÔ¨Åers. In this section we
look at a popular temporal logic whose operators are based on modalities with
more complex satisfaction deÔ¨Ånitions: S (since) and U (until). The main rea-
son for considering these modalities is, again, to achieve an increase in expressive
power. We will Ô¨Årst give some examples demonstrating why the increased expres-
sivity is useful. We will then learn that (over Dedekind complete frames) we have
actually achieved expressive completeness: any expression in the Ô¨Årst-order corre-
spondence language (in one free variable) has an equivalent in the modal language
in S and U . Finally, we will show that this (Ô¨Årst-order) expressive completeness
leads to (modal) deductive completeness.7.2 Since and Until
427
Basic deÔ¨Ånitions
The basic operators needed for temporal reasoning seem to be F and P . These
allow us to say things like ‚ÄòSomething good will happen‚Äô and ‚ÄòSomething bad has
happened.‚Äô


q?



p
?
-
P q, F p
But in several application areas this is not enough. For example, in the semantics of
concurrent programs one often needs to be able to express properties of executions
of programs that have the general format ‚ÄòSomething good is going to happen, and
until that time nothing bad will happen.‚Äô Or, more concretely: p will be the case,
and until that time q will hold:



p
. . . . . . . . .q. . . . . . . . . . ?
-
U (p, q)
Such properties are sometimes called guarantee properties in the computational
literature. To state them, the binary until operator U can be used; its satisfaction
deÔ¨Ånition reads:
t  U (œÜ, œà) iff
there is a v > t such that v  œÜ and for all s with t < s < v: s  œà.
The mirror image of U is the since operator S:
t  S(œÜ, œà) iff
there is a v < t such that v  œÜ and for all s with v < s < t: s  œà.
That is the basic idea ‚Äì but before going further, let us make our discussion a
little more precise. The set of S, U -formulas is built up from a collection Œ¶ of
proposition letters, the usual boolean connectives, and the binary operators S and
U . The mirror image of a formula œÜ is obtained by simultaneously substituting S
for U and U for S in œÜ.
S, U -formulas are interpreted on frames of the form F = (T, <), where T is a
set of time points and < is a binary relation on T . U looks forwards along <, and
S looks backwards. We use the notation (T, <) for frames (rather than our usual
(T, R)) because here we are primarily interested in the temporal interpretation of
S and U . In fact, will be working with frames (T, <) such that < is a Dedekind
complete order ‚Äì more on this below. To emphasize our interest in the temporal7 Extended Modal Logic
428
interpretation, we will often refer to frames as Ô¨Çows of time. As usual, a valuation
is a function assigning subsets of T to the proposition letters in the language.
How does the language in S and U relate to the basic temporal language? First,
observe that F and P are deÔ¨Ånable in the language with S and U : we can deÔ¨Åne
F œÜ := U (œÜ, ), P œÜ := S(œÜ, ), GœÜ := ¬¨F ¬¨œÜ and HœÜ := ¬¨P ¬¨œÜ. Thus the
language with S and U is at least as strong as the basic temporal language. In fact,
it is strictly stronger. For a start, we saw in Exercise 2.2.4 that the basic temporal
language could not deÔ¨Åne U . Moreover, as the following proposition shows, even
if we restrict attention to models based on the real numbers, the basic temporal
language still is not strong enough to deÔ¨Åne U .
Proposition 7.10 U is not deÔ¨Ånable over (R, <) using F and P .
Proof. We will give two models that agree on all formulas in the language with
F and P only, but that can be distinguished using the until operator. Consider the
following model M1 based on the reals:

p q p
.....
‚àí3 ‚àí2
p
p
. . . . . .q. . . . .
‚àí1
0
1
0  U (p, q)
p q p
.....
2
3
p q p
.....
4
5
-
So, V1 (p) = {r | r ‚àà Z}, and V1 (q) = {0} ‚à™ {r | ‚àÉn ‚àà N (‚àí2n ‚àí 1 < r <
‚àí2n)} ‚à™ {r | ‚àÉn ‚àà N (2n < r < 2n + 1)}.
Next, consider the model M2 given by the following picture:

p q p
.....
‚àí3 ‚àí2
. . . . . .q. . . . .
‚àí1
0
1
0  U (p, q)
p q p
.....
2
3
p q p
.....
4
5
-
We leave it to the reader to show that the models M1 and M2 agree on all for-
mulas in F and P , but that M1 , 0  U (p, q), whereas M2 , 0  U (p, q) (see
Exercise 7.2.1).
So the temporal language in S and U is expressive ‚Äì but just how expressive is
it? To answer such questions we need a correspondence language and a standard
translation of S and U into the correspondence language. Let Œ¶ be a collection of
proposition letters, and let L1< (Œ¶), or simply L1< , be the Ô¨Årst-order language with
unary predicate symbols corresponding to the proposition letters in Œ¶, and with =
and < as binary relation symbols. We use L1< (x) to denote the set of L1< formulas
having one free variable x. Note: this is the familiar correspondence language for
the basic temporal language, except that we are using < rather than R as the binary
relation symbol.7.2 Since and Until


t
œà


h
g
œÜ

. . . ‚Üê ¬¨œà
429

-
s
Fig. 7.1. The Stavi connectives
The standard translation ST x for the until operator U is
ST x (U (œÜ, œà)) = ‚àÉz (x < z ‚àß ST z (œÜ) ‚àß ‚àÄy (x < y < z ‚Üí ST y (œà))).
The standard translation of S is the mirror image of that of U . Observe that we need
3 variables to specify the translation of since and until! We only needed 2 variables
to specify the translation of the basic modal operators (see Proposition 2.49).
Let K be a class of models, ML a modal or temporal language, and L a classical
language. Then ML is expressively complete over K, if every L1< (x)-formula has
an equivalent (over K) in the modal language ML. The study of expressive com-
pleteness is an important theme in temporal logics with since and until because of
the following remarkable result: the language with S and U is expressively com-
plete over the class of all Dedekind complete Ô¨Çows of time (we will deÔ¨Åne this
class shortly). Moreover, below we will deÔ¨Åne an even richer temporal language
that is expressively complete for the class of all linear Ô¨Çows of time. In the remain-
der of this section we will brieÔ¨Çy explain these expressive completeness results,
and use them to obtain a deductive completeness result for since and until over
well-ordered Ô¨Çows of time.
Further preliminaries
A Ô¨Çow of time is called Dedekind complete if every subset with an upper bound has
a least upper bound. The standard examples are the reals (R, <) and the natural
numbers (N, <). A Ô¨Çow of time is well-ordered if every non-empty subset has a
smallest element; the canonical example here is (N, <).
To arrive at our goal of axiomatizing the well-ordered Ô¨Çows of time, we make a
detour through a still richer temporal language built using the Stavi connectives.
DeÔ¨Ånition 7.11 (The Stavi Connectives) To introduce the Stavi connectives we
need the notion of a gap. A gap of a frame F = (T, <) is a proper subset g ‚äÇ T
which is downward closed (that is, t ‚àà g and s < t implies s ‚àà g), and which
does not have a supremum. One can think of a gap as a hole in a Dedekind-
incomplete Ô¨Çow of time; see Figure 7.1 Now, U  (œÜ, œà) holds at a point t if the
situation depicted in the above Ô¨Ågure holds; that is, if430
7 Extended Modal Logic
(i) there are a point s and a gap g such that t ‚àà g and s ‚àà
/ g;
(ii) œà holds between t and g;
(iii) œÜ holds between s and g; and
(iv) ¬¨œà is true arbitrarily soon after g.
S  (œÜ, œà) is the mirror image of U  (œÜ, œà).
The above informal second-order deÔ¨Ånition (we quantify over gaps, and hence
over sets) can be replaced by a Ô¨Årst-order deÔ¨Ånition; see Exercise 7.2.2.
Theorem 7.12 (Expressive Completeness)
(i) U , S are complete over Dedekind complete Ô¨Çows of time.
(ii) U , S, U  , S  are complete over all linear Ô¨Çows of time.
Next, we need a complete axiom system for the class of linear Ô¨Çows of time:
DeÔ¨Ånition 7.13 Consider the following collection of axioms:
(A1a) G(p ‚Üí q) ‚Üí (U (p, r) ‚Üí U (q, r))
(A2a) G(p ‚Üí q) ‚Üí (U (r, p) ‚Üí U (r, q))
(A3a) p ‚àß U (q, r) ‚Üí U (q ‚àß S(p, r), r)
(A4a) U (p, q) ‚àß ¬¨U (p, r) ‚Üí U (q ‚àß ¬¨r, q)
(A5a) U (p, q) ‚Üí U (p, q ‚àß U (p, q))
(A6a) U (q ‚àß U (p, q), q) ‚Üí U (p, q)
(A7a) U (p, q) ‚àß U (r, s) ‚Üí
U (p ‚àß r, q ‚àß s) ‚à® U (p ‚àß s, q ‚àß s) ‚à® U (q ‚àß r, q ‚àß s)
(Aib) the mirror images of (A1a)‚Äì(A7a)
(D)
(F  ‚Üí U (, ‚ä•)) ‚àß (P  ‚Üí S(, ‚ä•))
(L)
H‚ä• ‚à® P H‚ä•
(W)
F p ‚Üí U (p, ¬¨p)
(N)
D ‚àß L ‚àß F
Axioms (D), (L), (W), and (N) are discussed in Lemma 7.14 and Exercise 7.2.3
below. As to the other axioms, (A1a) and (A2a) can be viewed as counterparts of
the familiar distribution or K axiom 2(p ‚Üí q) ‚Üí (2p ‚Üí 2q). (A3a) captures
the fact that U and S explore relations that are each other‚Äôs converse. (A4a) and
(A5a) connect the current and the future point (at which something good is going
to happen) on the one hand with the points in between on the other hand. (A6a)
expresses transitivity of the Ô¨Çow of time, and, Ô¨Ånally, (A7a) forces the Ô¨Çow of time
to be linearly ordered.
Lemma 7.14 Let F be a linear Ô¨Çow of time. Then
(i) F |= D iff F is a discrete ordering.7.2 Since and Until
431
(ii) F |= W ‚àß L iff F is a well-ordering.
(iii) F |= W ‚àß N iff F ‚àº
= (N, <).
The proof of Lemma 7.14 is left as Exercise 7.2.3.
Next, we deÔ¨Åne three axiom systems: B, BW, and BN. The set of axioms of B
consists of all classical tautologies, (A1a)‚Äì(A7a), and (A1b)‚Äì(A7b). BW extends
B with W, and BN extends BW with N. All three derivation systems have modus
ponens, temporal generalization, and uniform substitution as derivation rules:
(MP) If  œÜ and  œÜ ‚Üí œà, then  œà.
(TG) If  œÜ, then  GœÜ and  HœÜ.
(SUB) If  œÜ, then  [œà/p]œÜ.
A model M is called an X-model if it has M |= œÜ for all X-theorems œÜ, where
X ‚àà {B, BW, BN}.
For future use we state the following axiomatic completeness result:
Theorem 7.15 For all sets of S, U -formulas Œ£ and formulas œÜ: Œ£ B œÜ iff Œ£ |=B
œÜ.
We need one more preliminary result, on deÔ¨Ånable properties. By Exercise 7.2.4,
well-foundedness is a condition on linear frames which cannot be expressed in Ô¨Årst-
order logic: it involves an essential second-order quantiÔ¨Åcation over all subsets of
the universe. However, to arrive at our expressive completeness result we can get
by with less, namely the condition that every Ô¨Årst-order deÔ¨Ånable non-empty subset
must have a smallest element; one can show that deÔ¨Ånably well-ordered models are
sufÔ¨Åciently similar to genuine well-ordered models.
The following deÔ¨Ånition and lemma capture what we need.
DeÔ¨Ånition 7.16 Let Œ± be a Ô¨Årst-order formula in L1< (x), M = (T, <, V ) a model
for L1< . DeÔ¨Åne XŒ± to be the set deÔ¨Åned by Œ±, that is, XŒ± := {t ‚àà T | M |= Œ±[t]}.
Then, M is called deÔ¨Ånably well-ordered if for all Œ±(x) ‚àà L1< , the set XŒ± has a
smallest element.
Two L1< -models M1 and M2 are called n-equivalent, notation M1 ‚â°nFOL M2 ,
if for all Ô¨Årst-order sentences Œ± ‚àà L1< of quantiÔ¨Åer depth at most n, M1 |= Œ± iff
M2 |= Œ±.
Proviso. For the remainder of this section we will assume that our collection of
proposition letters Œ¶ is Ô¨Ånite. This is not an essential restriction, but it simpliÔ¨Åes
some of the arguments below (see Exercise 7.2.5 for a way of circumventing the
assumption).
Lemma 7.17 Let n ‚àà N. Then every deÔ¨Ånably well-ordered linear model is n-
equivalent to a fully well-ordered model.432
7 Extended Modal Logic
Proof. Let M = (T, <, V ) be a deÔ¨Ånably well-ordered linear model. For a, b ‚àà T
such that b < a, deÔ¨Åne [b, a) = {t ‚àà T | b ‚â§ t < a}, and (‚àû, a) = {t ‚àà T | t <
a}. Obviously, we can view such sets ‚Äì with the ordering and valuation induced by
M ‚Äì as linear L1< -models in their own right. DeÔ¨Åne
Z := {a ‚àà T | ‚àÄb < a ([b, a) has a well-ordered n-equivalent)}.
By Exercise 7.2.6 there are only Ô¨Ånitely many Ô¨Årst-order formulas Œ±(x, y) of quan-
tiÔ¨Åer depth at most n, say Œ±1 (x, y), . . . , Œ±m (x, y). Let Œ≤1 (x, y), . . . , Œ≤k (x, y) ‚àà
{Œ±1 (x, y), . . . , Œ±m (x, y)} be such that if M |= Œ≤i (x, y)[ab] then [b, a) has a well-
ordered n-equivalent. Then Z is deÔ¨Åned by the formula
‚éõ
‚éû
Œ±(x) := ‚àÄy ‚éùy ‚â§ x ‚Üí
Œ≤(x, y)‚é† .
i‚â§k
As a consequence, T \ Z (the complement of Z in M) is deÔ¨Ånable as well. We
will now show that T \ Z is empty. For, suppose otherwise. Then Z must have
a smallest element a (as M is deÔ¨Ånably well-ordered). Distinguish the following
cases:
(i) a is the Ô¨Årst element of T ,
(ii) a has an immediate successor, and
(iii) there exists an ascending sequence (bŒæ )Œæ<Œª , which is coÔ¨Ånal in [b, a) and
such that b0 = b. (That is, b0 = b, bi < bj whenever i < j, and for all
c ‚àà [b, a) there exists a bi > c.)
It is easy to see that the Ô¨Årst two cases lead to contradictions. As to the third
case, since a is the minimal element of T \ Z, all bŒæ are in Z. So, by deÔ¨Ånition,
every interval [bŒæ , bŒæ+1 ) has a well-ordered n-equivalent MŒæ . By Exercise 7.2.7
,
the lexicographic sum Œæ<Œª MŒæ is well-ordered and an n-equivalent to [b, a). But
then a ‚àà Z ‚Äì a contradiction.
Therefore T \ Z = ‚àÖ, and hence Z = T , so every interval [b, a) of T has an
n-equivalent well-ordered model. By using Exercise 7.2.7 again, we see that M
must have a well-ordered n-equivalent, as required.
Completeness via completeness
With the above preliminaries out of the way, we are now in a position to use the
expressive completeness result recorded in Theorem 7.12 to arrive at an axiomatic
completeness result for BW over well-ordered Ô¨Çows of time.
We need the following lemma:
Lemma 7.18 Every linear BW-model is deÔ¨Ånably well-ordered.7.2 Since and Until
433
Proof. Let M be a linear model satisfying all instances of the BW-theorems. We
will prove that every non-empty L1< -deÔ¨Ånable subset of T has a smallest element
via detour using the Stavi connectives S and U  .
Let X be a non-empty L1< -deÔ¨Ånable subset of T . By Theorem 7.12(ii) it follows
that X has a deÔ¨Åning formula œÜ in the language with S, U , S , U  . If we can show
that œÜ does in fact belong to the sublanguage with S and U , then we are done,
because then we can use the validity of the axioms W and L to show that there
must be a minimal element in X.
It sufÔ¨Åces to show that every formula in the language with S, U , S , U  is equiv-
alent to an S, U -formula over M. To this end we argue by induction of formulas in
the richer language. The only non-trivial case is for formulas of the form U (œÜ, œà)
(and their mirror images), where œÜ and œà are already assumed to be equivalent to
S, U formulas by the induction hypothesis. So assume M, t  U (œÜ, œà). Then
there is a gap g after t such that (i) œà holds everywhere between t and g, and (ii) œà
is false arbitrarily soon after g. Now (i) implies that M, t  F œà, so by the validity
of the W axiom in M it follows that M, t  U (¬¨œà, œà), which contradicts (ii).
Theorem 7.19 BW is (weakly) complete for the class of all well-ordered Ô¨Çows of
time.
Proof. Let œÜ be a BW-consistent formula. Construct a maximal BW-consistent set
Œî with œÜ ‚àà Œî. As BW extends B, Œî must also be B-consistent. By Theorem 7.15
there exists a linear model M = (T, <, V ) in which Œî is satisÔ¨Åable. Clearly, for
every S, U -formula œà, the formula HW(œà) ‚àß W(œà) ‚àß GW(œà) is in Œî, where
W(œà) is the W axiom instantiated for œà. Thus M is a BW-model, and hence, by
Lemma 7.18 it is deÔ¨Ånably well-ordered.
Now, for the Ô¨Ånal step, let n be the quantiÔ¨Åer rank of ST (œÜ). By Lemma 7.17
there is a well-ordered model M that is (n + 1)-equivalent to M. Therefore,
M |= ‚àÉx ST (œÜ)(x), and we are done.
Using Theorem 7.19 it is easy to obtain a further completeness result, for the tem-
poral logic of the natural numbers.
Theorem 7.20 BN is weakly complete for (œâ, <), the natural numbers with their
standard ordering.
The proof of Theorem 7.20 is left as Exercise 7.2.8.
Exercises for Section 7.2
7.2.1 Supply the missing details for the proof of Proposition 7.10.
7.2.2 Give a Ô¨Årst-order deÔ¨Ånition for the Stavi connectives introduced in DeÔ¨Ånition 7.11 ‚Äì
you may assume that we are working on linear Ô¨Çows of time.434
7 Extended Modal Logic
7.2.3 Prove Lemma 7.14. That is, show that D deÔ¨Ånes discrete orderings, that W ‚àß L
deÔ¨Ånes well-orderings, and that W‚àßN picks out the natural numbers in their usual ordering
up to isomorphism.
7.2.4 Show that well-foundedness is a condition on linear frames which cannot be ex-
pressed in Ô¨Årst-order logic.
7.2.5 Throughout this section we assumed that the collection of proposition symbols that
we are working with is Ô¨Ånite. Show that this assumption can be lifted.
7.2.6 Show that, over a Ô¨Ånite vocabulary, there are only Ô¨Ånitely many non-equivalent Ô¨Årst-
order formulas Œ±(x, y) of quantiÔ¨Åer depth at most n.
7.2.7 Show that the lexicographic sum of a collection of structures that are well-ordered
and n-equivalent to a given structure M, is again well-ordered and n-equivalent to M.
7.2.8 Prove Theorem 7.20: show that BN is weakly complete for (œâ, <), the natural num-
bers with their standard ordering.
7.3 Hybrid Logic
An oddity lurks at the heart of modal logic: although states are the cornerstone
of modal semantics, they are not directly reÔ¨Çected in modal syntax. We evaluate
formulas inside models, at some state, and use the modalities to scan accessible
states. But modal syntax offers no grip on the states themselves: it does not let us
name them, and it does not let us reason about state equality. Modal syntax and
semantics dance to different tunes.
For many applications, this is a drawback. As we mentioned in Example 1.17,
both feature and description logics can be viewed as modal logics ‚Äì or at least,
they can up to a point. Real feature logics contain mechanisms for asserting that
two sequences of transitions lead to the same state, and description logics allow
us to name and reason about individuals. Such capabilities (which are crucial)
take us beyond the kinds of modal language we have considered so far. Similarly,
it is often important to reason about what is going on at particular times, and the
temporal formalisms used in artiÔ¨Åcial intelligence usually provide expressions such
as Holds(i, œÜ), asserting that the information œÜ holds at the time named by i, to
make this possible. The modal logics considered so far contain no analogs of these
important tools.
In their simplest form, hybrid languages are modal languages which put this
right. Hybrid languages treat states as Ô¨Årst class citizens, and they do so in a par-
ticularly simple way. The key idea is simply to sort the atomic formulas, and to
use one sort of atom ‚Äì the nominals ‚Äì to refer to states. Because this mechanism
is so simple, many of the attractive properties of modal logic (such as robust de-
cidability) are unaffected. Indeed, in certain respects hybrid logics are arguably7.3 Hybrid Logic
435
better-behaved than their ordinary modal counterparts: their completeness theory
is particularly straightforward, and they are proof theoretically natural.
In this section we examine one of the simplest hybrid languages: a two-sorted
system with names for states. To build such a language, take a basic modal lan-
guage (built over propositional variables p, q, r, and so on) and add a second sort
of atomic formula. These new atoms are called nominals, and are typically writ-
ten i, j and k. Both types of atom can be freely combined to form more complex
formulas in the usual way. For example,
3(i ‚àß p) ‚àß 3(i ‚àß q) ‚Üí 3(p ‚àß q)
is a well-formed formula. And now for the key idea: insist that each nominal be
true at exactly one state in any model. Thus a nominal names a state by being
true there and nowhere else. This simple idea gives rise to richer logics. Note,
for example, that the previous formula is valid: if the antecedent is satisÔ¨Åed at a
state w, then the unique state named by i must be accessible from w, and both p
and q must be true there. And note that the use of the nominal i is crucial: if we
substituted the ordinary propositional variable r for i, the resulting formula could
be falsiÔ¨Åed.
Actually, what we call the basic hybrid language offers more than this: it also
enables us to build formulas of the form @i œÜ, where i is a nominal. The composite
symbol @i is called a satisfaction operator, and it has the following interpretation:
@i œÜ is true at any state in a model if and only if œÜ is satisÔ¨Åed at the (unique) state
named by i (so @i œÜ is analogous to Holds(i, œÜ)). Satisfaction operators play an
important role in hybrid proof theory.
Our discussion of basic hybrid logic is largely conÔ¨Åned to a single topic: the
link between frame deÔ¨Ånability and completeness. We will show that when pure
formulas are used as axioms they always yield systems which are complete with
respect to the class of frames they deÔ¨Åne. Now, a pure formula is simply a formula
whose only atoms are nominals, so in effect this result tells us that frame complete-
ness is automatic for axioms constructed solely out of names. Our discussion will
center on a proof rule called PASTE which is related to the IRR rule discussed in
Section 4.7 and the D-rule of Section 7.1.
The basic hybrid language
Given a basic modal language built over propositional variables Œ¶ = {p, q, r, . . .},
let Œ© = {i, j, k, . . .} be a nonempty set disjoint from Œ¶. The elements of Œ© are
called nominals; they are a second sort of atomic formula which will be used to
name states. We call Œ¶ ‚à™ Œ© the set of atoms and deÔ¨Åne basic hybrid language (over
Œ¶ ‚à™ Œ©) as follows:
œÜ ::= i | p | ‚ä• | ¬¨œÜ | œÜ ‚àß œà | 3œÜ | @i œÜ.7 Extended Modal Logic
436
For any nominal i, the symbol @i is called a satisfaction operator. Note that, syn-
tactically speaking, the basic hybrid language is simply a multimodal language (the
modalities being 3 and all the @i ), whose atomic symbols are subdivided into two
sorts. If a formula contains no propositional variables (that is, if its only atoms
are nominals) we call it a pure formula. In what follows we assume that we are
working with a Ô¨Åxed basic hybrid language L in which both Œ¶ and Œ© are countably
inÔ¨Ånite.
The basic hybrid language is interpreted on models. As usual, a model M is
a triple (W, R, V ), where (W, R) is a frame, and V is a valuation. But although
the deÔ¨Ånition of a frame is unchanged, we want nominals to act as names, so we
will insist that a valuation V on a frame (W, R) is a function with domain Œ¶ ‚à™ Œ©
and range P(W ) such that for all i ‚àà Œ©, V (i) is a singleton subset of W . That
is, as usual, we place no restrictions on the interpretation of ordinary propositional
variables, but we insist that a valuation makes each nominal true at a unique state.
We call the unique state w that belongs to V (i) the denotation of i under V . We
interpret the basic hybrid language by adding the following two clauses to the sat-
isfaction deÔ¨Ånition for the basic modal language:
M, w  i iff w ‚àà V (i),
M, w  @i œÜ iff M, d  œÜ where d is the denotation of i under V .
As usual, M  œÜ means that œÜ is true at all states in M, F  œÜ means that œÜ is
valid on the frame F, and  œÜ means that œÜ is valid on all frames.
Note that a formula of the form @i j expresses the identity of the states named
by i and j. Further, note that a formula of the form @i 3j says that the state named
by i has as an R-successor the state named by j.
Although it allows us to refer to states, and talk about state equality, the basic
hybrid language is very much a modal language. Nominals name, but they are sim-
ply a second sort of atomic formula. Moreover, satisfaction operators are normal
modal operators: note that for every nominal i,  @i (œÜ ‚Üí œà) ‚Üí (@i œÜ ‚Üí @i œà),
is valid; and if  œÜ, then  @i œÜ.
Moreover, the basic hybrid language is quite a simple modal language. For
example, its satisÔ¨Åability problem is known to be no more complex than the satis-
Ô¨Åability problem for the basic modal language:
Theorem 7.21 The satisÔ¨Åability problem for the basic hybrid logic is PSPACE-
complete.
But in spite of its simplicity the basic hybrid language is surprisingly strong when
it comes to frame deÔ¨Ånability. For a start, many properties deÔ¨Ånable in the basic
modal language can be deÔ¨Åned using pure formulas:
(reÔ¨Çexivity)
i ‚Üí 3i,7.3 Hybrid Logic
437
(symmetry)
i ‚Üí 23i,
(transitivity) 33i ‚Üí 3i,
(density)
3i ‚Üí 33i,
(determinism) 3i ‚Üí 2i.
Moreover, pure formulas also enable us to deÔ¨Åne many properties not deÔ¨Ånable in
the basic modal language, as the reader can easily verify:
(irreÔ¨Çexivity)
(asymmetry)
(antisymmetry)
(intransitivity)
(universality)
(trichotomy)
(at most 2 states)
i ‚Üí ¬¨3i,
i ‚Üí ¬¨33i,
i ‚Üí 2(3i ‚Üí i),
33i ‚Üí ¬¨3i,
3i,
@j 3i ‚à® @j i ‚à® @i 3j,
@i (¬¨j ‚àß ¬¨k) ‚Üí @j k.
All the frame properties deÔ¨Åned above are Ô¨Årst-order. This is no coincidence: all
pure formulas deÔ¨Åne Ô¨Årst-order frame conditions. This is easy to prove: there is a
natural way of extending the standard translation to cover nominals and satisfaction
operators which explains why (see Exercise 7.3.1).
But not only do pure formulas deÔ¨Åne Ô¨Årst-order properties, when used as axioms
they are automatically complete with respect to the class of frames they deÔ¨Åne.
More precisely, there is a proof system called Kh + RULES such that for any set of
pure formulas Œ†:
If P is the normal hybrid logic (which we will shortly deÔ¨Åne) obtained by
adding the formulas in Œ† as axioms to Kh + RULES , then P is complete with
respect to the class of frames deÔ¨Åned by P.
The rest of the section is devoted to proving this, but before diving into the tech-
nicalities it is worth noting that the result hinges on a rather simple observation.
Let us say that a model (W, R, V ) is named if every state in the model is the de-
notation of some nominal (that is, for all w ‚àà W there is some nominal i such that
V (i) = {w}). Furthermore, if œÜ is a pure formula, we say that œà is a pure instance
of œÜ if œà is obtained from œÜ by uniformly substituting nominals for nominals. Then
we have:
Lemma 7.22 Let M = (F, V ) be a named model and œÜ a pure formula. Suppose
that for all pure instances œà of œÜ, M  œà. Then F  œÜ.
Proof. Exercise 7.3.3.
That is, for named models and pure formulas the gap between truth in a model and
validity in a frame is non-existent. So if we had a way of building named models,7 Extended Modal Logic
438
we would not need to appeal to relatively complex syntactic criteria (such as being a
Sahlqvist formula) to obtain general completeness results: any pure formula would
give rise to a strongly complete logic for the class of frames it deÔ¨Åned. In essence,
the work that follows can be summed as follows: we are going to isolate the logic
Kh + RULES and show that we can build named models from its MCSs and prove an
Existence Lemma. Once this is done, a wide range of frame completeness results
will be immediate by an appeal to Lemma 7.22.
Pure extensions of Kh + RULES
Let us Ô¨Årst say what a normal hybrid logic is:
DeÔ¨Ånition 7.23 A set of formulas Œõ in the basic hybrid language is a normal hy-
brid logic if it contains all tautologies, 2(p ‚Üí q) ‚Üí (2p ‚Üí 2q), 3p ‚Üî ¬¨2¬¨p,
the axioms listed below, and it is closed under the following rules of proof: modus
ponens, generalization, @i -generalization (if œÜ is provable then so is @i œÜ, for any
nominal i) and sorted substitution (if œÜ ‚àà Œõ, and Œ∏ results from œÜ by uniformly re-
placing proposition letters by arbitrary formulas, and nominals by nominals, then
Œ∏ ‚àà Œõ). We call the smallest normal hybrid logic Kh .
The motivation for the sorted substitution rule should be clear: while propositional
variables are placeholder for arbitrary information, nominals are names, and sub-
stitution must respect the distinction.
The axioms needed to complete our deÔ¨Ånition of Kh fall into three groups. The
Ô¨Årst identiÔ¨Åes the basic logic of satisfaction operators:
(K@ )
@i (p ‚Üí q) ‚Üí (@i p ‚Üí @i q),
(self-dual)
@i p ‚Üî ¬¨@i ¬¨p,
(introduction) i ‚àß p ‚Üí @i p.
As satisfaction operators are normal modal operators, the inclusion of K@ should
come as no surprise. As for self-dual, note that self-dual modalities are those whose
transition relation is a function: given the jump-to-the-named-state interpretation of
satisfaction operators, this is exactly the axiom we would expect. Introduction tells
us how to place information under the scope of satisfaction operators. Actually,
it also tells us how to get hold of such information, for if we replace p by ¬¨p,
contrapose, and make use of self-dual, we obtain (i ‚àß @i p) ‚Üí p; we call this the
elimination formula.
The second group is a modal theory of naming (or to put it another way, a modal
theory of state equality):
(ref)
(sym)
@i i,
@i j ‚Üî @j i,7.3 Hybrid Logic
439
(nom) @i j ‚àß @j p ‚Üí @i p,
(agree) @j @i p ‚Üî @i p.
Note that the transitivity of naming follows from the nom axiom; for example,
substituting the nominal k for the propositional variable p yields @i j‚àß@j k ‚Üí @i k.
The Ô¨Ånal axiom pins down the interaction between @ and 3:
(back) 3@i p ‚Üí @i p.
Note that 3i ‚àß @i p ‚Üí 3p is another valid @-3 interaction principle; it is called
bridge and we will use it when we prove the Existence Lemma. However bridge is
provable in Kh as the reader is asked to show in Exercise 7.3.4.
The soundness of these axioms is clear ‚Äì but what about completeness? Let
us say that a Kh -MCS is named if and only if it contains a nominal, and call any
nominal belonging to a Kh -MCS a name for that MCS. Now, Kh is strong enough to
prove a lemma which is fundamental to our later work: hidden inside any Kh -MCS
are a collection of named MCSs with a number of desirable properties:
Lemma 7.24 Let Œì be a Kh -MCS. For every nominal i, let Œîi be {œÜ | @i œÜ ‚àà Œì }.
Then:
(i) For every nominal i, Œîi is a Kh -MCS that contains i.
(ii) For all nominals i and j, if i ‚àà Œîj , then Œîj = Œîi .
(iii) For all nominals i and j, @i œÜ ‚àà Œîj iff @i œÜ ‚àà Œì .
(iv) If k is a name for Œì , then Œì = Œîk .
Proof. (i) First, for every nominal i we have the ref axiom @i i, hence i ‚àà Œîi .
Next, Œîi is consistent. For assume for the sake of a contradiction that it is not.
Then there are Œ¥1 , ..., Œ¥n ‚àà Œîi such that  ¬¨(Œ¥1 ‚àß ¬∑ ¬∑ ¬∑ ‚àß Œ¥n ). By @i -necessitation,
 @i ¬¨(Œ¥1 ‚àß ¬∑ ¬∑ ¬∑ ‚àß Œ¥n ), hence @i ¬¨(Œ¥1 ‚àß ¬∑ ¬∑ ¬∑ ‚àß Œ¥n ) is in Œì , and thus by self-dual
¬¨@i (Œ¥1 ‚àß ¬∑ ¬∑ ¬∑ ‚àß Œ¥n ) is in Œì too. On the other hand, as Œ¥1 , ..., Œ¥n ‚àà Œîi , we have
@i Œ¥ 1 , ..., @i Œ¥ n ‚àà Œì . As @i is a normal modality, @i (Œ¥1 ‚àß ¬∑ ¬∑ ¬∑ ‚àß Œ¥n ) ‚àà Œì as well,
contradicting the consistency of Œì . So Œîi is consistent.
Is Œîi maximal? Assume it is not. Then there is a formula œá such that neither
œá nor ¬¨œá is in Œîi . But then both ¬¨@i œá and ¬¨@i ¬¨œá belong to Œì , and this is
impossible: if ¬¨@i œá ‚àà Œì , then by self-duality @i ¬¨œá ‚àà Œì as well. We conclude
that Œîi is a Kh -MCS named by i.
(ii) Suppose i ‚àà Œîj ; we will show that Œîj = Œîi . As i ‚àà Œîj , @j i ‚àà Œì .
Hence, by sym, @i j ‚àà Œì too. But now the result is more-or-less immediate. First,
Œîj ‚äÜ Œîi . For if œÜ ‚àà Œîj , then @j œÜ ‚àà Œì . Hence, as @i j ‚àà Œì , it follows by nom
that @i œÜ ‚àà Œì , and hence that œÜ ‚àà Œîi as required. A similar nom-based argument
shows that Œîi ‚äÜ Œîj .
(iii) By deÔ¨Ånition @i œÜ ‚àà Œîj iff @j @i œÜ ‚àà Œì . By agree, @j @i œÜ ‚àà Œì iff7 Extended Modal Logic
440
@i œÜ ‚àà Œì . (We call this the @-agreement property; it plays an important role
in the completeness proof.)
(iv) Suppose Œì is named by k. Let œÜ ‚àà Œì . Then as k ‚àà Œì , by introduction
@k œÜ ‚àà Œì , and hence œÜ ‚àà Œîk . Conversely, if œÜ ‚àà Œîk , then @k œÜ ‚àà Œì . Hence, as
k ‚àà Œì , by elimination we have œÜ ‚àà Œì .
In what follows, if Œì is a Kh -MCS and i is a nominal, then we will call {œÜ | @i œÜ ‚àà
Œì } a named set yielded by Œì .
We have reached an important crossroad. It is now reasonably straightforward to
prove that Kh is the minimal hybrid logic. We would do so as follows. Given a Kh -
consistent set of sentences Œ£, use the ordinary Lindenbaum‚Äôs Lemma to expand
it to a Kh -MCS Œ£ + , and build a model by taking the submodel of the ordinary
canonical model generated by Œ£+ ‚à™ {Œîi | Œîi is a named set yielded by Œ£+ }.
The reader is asked to do this in Exercise 7.3.5.
But we have a more ambitious goal in mind: we do not want to build just any
model, we want a named model. This will enable us to apply Lemma 7.22 and
prove the completeness of pure axiomatic extensions. However we face two prob-
lems. The Ô¨Årst is this. Given a Kh -consistent set of formula, we can certainly
expand it to an MCS using Lindenbaum‚Äôs Lemma ‚Äì but nothing guarantees that
this MCS will be named. The second problem is much deeper. Suppose we over-
came the Ô¨Årst problem and learned how to expand any consistent set of sentences
Œ£ to a named MCS Œ£ + . Now, as we want to build a named model, this pretty much
dictates that only the named MCSs yielded by Œ£+ should be used in the model con-
struction. And now for the tough part: nothing we have seen so far guarantees that
there are enough MCSs here to support an Existence Lemma. Incidentally, note that
the completeness-via-generation method sketched in the previous paragraph does
not face this problem: generation automatically gives us all successor MCSs, so we
can make use of the ordinary modal Existence Lemma. Unfortunately, not all these
successor MCSs need be named, so the generation method will not help with the
stronger result we have in mind.
But these difÔ¨Åculties are similar to those we faced when discussing rules for
the undeÔ¨Ånable, and this suggests a solution. In Section 4.7 we simulated names
using tense operators, and used the forwards-and-backwards interplay of F and P
to create a coherent network of named MCSs which supported a suitable Existence
Lemma. Moreover, simulated names were used to deÔ¨Åne the D-rule mentioned
in Section 7.1. But nominals are genuine names, and satisfaction operators are
an excellent way of enforcing coherence ‚Äì surely it must be possible to deÔ¨Åne
analogous proof rules for the basic hybrid language? Indeed it is:
(NAME )
j‚ÜíŒ∏
Œ∏
(PASTE )
 @i 3j ‚àß @j œÜ ‚Üí Œ∏
 @i 3œÜ ‚Üí Œ∏7.3 Hybrid Logic
441
In both rules, j is a nominal distinct from i that does not occur in œÜ or Œ∏. The
NAME rule is going to solve our Ô¨Årst problem, the PASTE rule our second. These
rules are clearly close cousins of the IRR rule and the D-rule, but let us defer further
discussion till the end of the section, and put them to work right away.
Let Kh + RULES be the logic obtained by adding the NAME and PASTE rules to
Kh . We say that a Kh + RULES -MCS Œì is pasted iff @i 3œÜ ‚àà Œì implies that for
some nominal j, @i 3j ‚àß @j œÜ ‚àà Œì . And now for the key observation: our new
rules guarantee we can extend any Kh + RULES -consistent set of sentences to a
named and pasted Kh + RULES -MCS, provided we enrich the language with new
nominals:
Lemma 7.25 (Extended Lindenbaum Lemma) Let Œ©  be a (countably) inÔ¨Ånite
collection of nominals disjoint from Œ©, and let L be the language obtained by
adding these new nominals to L. Then every Kh + RULES -consistent set of formu-
las in language L can be extended to a named and pasted Kh + RULES -MCS in
language L .
Proof. Enumerate Œ© . Given a consistent set of L-formulas Œ£, deÔ¨Åne Œ£k to be
Œ£ ‚à™ {k}, where k is the Ô¨Årst new nominal in our enumeration. Œ£k is consistent.
For suppose not. Then for some conjunction of formulas Œ∏ from Œ£,  k ‚Üí ¬¨Œ∏.
But as k is a new nominal, it does not occur in Œ∏; hence, by the NAME rule,  ¬¨Œ∏.
But this contradicts the consistency of Œ£, so Œ£k must be consistent after all.
We now paste. Enumerate all the formulas of L , deÔ¨Åne Œ£ 0 to be Œ£k , and sup-
pose we have deÔ¨Åned Œ£m , where m ‚â• 0. Let œÜm+1 be the (m + 1)-th formula
in our enumeration of L . We deÔ¨Åne Œ£ m+1 as follows. If Œ£m+1 ‚à™ {œÜm+1 } is
inconsistent, then Œ£m+1 = Œ£ m . Otherwise:
(i) Œ£ m+1 = Œ£ m ‚à™ {œÜm+1 } if œÜm+1 is not of the form @i 3œÜ. (Here i can be
any nominal.)
(ii) Œ£ m+1 = Œ£ m ‚à™ {œÜm+1 } ‚à™ {@i 3j ‚àß @j œÜ}, if œÜm+1 is of the form @i 3œÜ.
(Here j is the Ô¨Årst nominal in the new nominal enumeration that does not
occur in Œ£m or @i 3œÜ.)
Let Œ£ + = n‚â•0 Œ£ n . Clearly this set is named (by k), maximal, and pasted.
Furthermore, it is consistent, for the only non-trivial aspects of the expansion is
that deÔ¨Åned by the second item, and the consistency of this step is precisely what
the PASTE rule guarantees. Note the similarity of this argument to the standard
completeness proof for Ô¨Årst-order logic: in essence, PASTE gives us the deductive
power required to use nominals as Henkin constants.
And now we can deÔ¨Åne the models we need. We are basically going to use the
named sets examined in Lemma 7.24, but with one small but crucial change: in-442
7 Extended Modal Logic
stead of starting with an arbitrary Kh -MCS, we will insist on using the named sets
yielded by a named and pasted Kh + RULES -MCS.
DeÔ¨Ånition 7.26 Let Œì be a named and pasted Kh + RULES -MCS. The named
model yielded by Œì , is MŒì = (W Œì , RŒì , V Œì ). Here W Œì is the set of all named sets
yielded by Œì , R is the restriction to W Œì of the usual canonical relation between
MCSs (so RŒì uv iff for all formulas œÜ, œÜ ‚àà v implies 3œÜ ‚àà u) and V Œì is the usual
canonical valuation (so for any atom a, V Œì (a) = {w ‚àà W Œì | a ‚àà w}).
Note that MŒì really is a model: by items (i) and (ii) of Lemma 7.24, V Œì assigns
every nominal a singleton subset of WŒì . And, because we insisted that Œì be
named and pasted, we can prove the Existence Lemma we require:
Lemma 7.27 (Existence Lemma) Let Œì be a named and pasted Kh + RULES -
MCS, and let M = (W, R, V ) be the named model yielded by Œì . Suppose u ‚àà W
and 3œÜ ‚àà u. Then there is a v ‚àà W such that Ruv and œÜ ‚àà v.
Proof. As u ‚àà W , for some nominal i we have that u = Œîi . Hence as 3œÜ ‚àà u,
@i 3œÜ ‚àà Œì . But Œì is pasted so for some nominal j, @i 3j ‚àß @j œÜ ‚àà Œì , and so
3j ‚àà Œîi and œÜ ‚àà Œîj . If we could show that RŒîi Œîj , then Œîj would be a suitable
choice of v. So suppose œà ‚àà Œîj . This means that @j œà ‚àà Œì . By @-agreement
(item (iii) of Lemma 7.24) @j œà ‚àà Œîi . But 3j ‚àà Œîi . Hence, by bridge, 3œà ‚àà Œîi
as required.
In short, we have successfully blended the Ô¨Årst-order idea of Henkin constants with
the modal idea of canonical models, and it is plain sailing all the way to the desired
completeness result.
Lemma 7.28 (Truth Lemma) Let M = (W, R, V ) be the named model yielded
by a named and pasted Kh + RULES -MCS Œì , and let u ‚àà W . Then, for all formulas
œÜ, œÜ ‚àà u iff M, u  œÜ.
Proof. Induction on the structure of œÜ. The atomic, boolean, and modal cases are
obvious (we use the Existence Lemma just proved for the modalities). What about
the satisfaction operators? Suppose M, u  @i œà. This happens iff M, Œîi  œà (for
by items (i) and (ii) of Lemma 7.24, Œîi is the only MCS containing i, and hence,
by the the atomic case of the present lemma, the only state in M where i is true) iff
œà ‚àà Œîi (inductive hypothesis) iff @i œà ‚àà Œîi (using the fact that i ‚àà Œîi together
with introduction for the left to right direction and elimination for the right to left
direction) iff @i œà ‚àà u (@-agreement).
Theorem 7.29 (Completeness) Every Kh + RULES -consistent set of formulas in
language L is satisÔ¨Åable in a countable named model. Moreover, if Œ† is a set7.3 Hybrid Logic
443
of pure formulas (in L), and P is the normal hybrid logic obtained by adding all
the formulas in Œ† as extra axioms to Kh + RULES , then every P-consistent set
of sentences is satisÔ¨Åable in a countable named model based on a frame which
validates every formula in Œ†.
Proof. For the Ô¨Årst claim, given a Kh + RULES -consistent set of formulas Œ£, use
the Extended Lindenbaum Lemma to expand it to a named and pasted set Œ£+ in
a countable language L . Let M = (W, R, V ) be the named model yielded by
Œ£ + . By item (iv) of Lemma 7.24, because Œ£+ is named, Œ£ + ‚àà W . By the Truth
Lemma, M, Œ£ +  Œ£. The model is countable because each state is named by
some L nominal, and there are only countably many of these.
For the ‚Äòmoreover‚Äô claim, given a P-consistent set of formulas Œû, use the Ex-
tended Lindenbaum Lemma to expand it to a named pasted P-MCS Œû+ . The named
model MŒû that Œû + gives rise to will satisfy Œû at Œû+ ; but in addition, as ev-
ery formula in Œ† belongs to every P-MCS, we have that MŒû  Œ†. Hence, by
Lemma 7.22, the frame underlying MŒû validates Œ†.
Example 7.30 We know that i ‚Üí ¬¨3i deÔ¨Ånes irreÔ¨Çexivity and 33i ‚Üí 3i de-
Ô¨Ånes transitivity, hence adding these formulas as axioms to Kh + RULES yields a
logic (let us call it I4) which is complete with respect to the class of strict preorders.
Hence 33p ‚Üí 3p, the ordinary modal transitivity axiom, must be I4-provable.
Furthermore, as i ‚Üí ¬¨33i is valid on any asymmetric frame, and i ‚Üí 2(3i ‚Üí i)
is valid on any antisymmetric frame, these must be I4-provable too. The reader is
asked to supply I4-proofs in Exercise 7.3.6.
The PASTE rule has played a pivotal role in our work; is there anything we can
say about it apart from ‚ÄòHey, it works!‚Äô? There is. As we will now see, PASTE is
actually a lightly-disguised sequent rule.
A sequent is an expression of the form Œì ‚àí‚Üí Œò, where Œì and Œò are multisets of
formulas (that is, Œì and Œò may contain multiple occurrences of the same formula).
Note that the sequent arrow ‚àí‚Üí is longer than the material implication arrow ‚Üí.
Sequents can be read as follows: whenever all the formulas in Œì are true at some
state in a model, at least one formula in Œò is true at that state too. A sequent rule
takes a sequent as input, and returns another sequent as output.
Now, here is PASTE as we stated it above:
 @i 3j ‚àß @j œÜ ‚Üí Œ∏
.
 @i 3œÜ ‚Üí Œ∏
Let us get rid of the  symbols and replace the implications by sequent arrows:
@i 3j ‚àß @j œÜ ‚àí‚Üí Œ∏
.
@i 3œÜ ‚àí‚Üí Œ∏444
7 Extended Modal Logic
Splitting the formula in the top line into two simpler formulas yields:
@i 3j, @j œÜ ‚àí‚Üí Œ∏
.
@i 3œÜ ‚àí‚Üí Œ∏
This rule works in arbitrary deductive contexts, so let us add a left-hand multiset
Œì , and turn Œ∏ into a right-hand multiset Œò, thus obtaining:
@i 3j, @j œÜ, Œì ‚àí‚Üí Œò
.
@i 3œÜ, Œì ‚àí‚Üí Œò
But this is just a sequent rule, and a useful one at that. Let us read it from bottom
to top: to prove Œò given the information @i 3œÜ and Œì (that is, the bottom line),
introduce a brand new nominal j and try to prove Œò from @i 3j, @j œÜ and Œì (that
is, the top line). That is, we should search for a proof by decomposing the formula
@i 3œÜ into a near-atomic formula @i 3j and simpler formula @j œÜ. In fact, this
decomposition is the key idea needed to deÔ¨Åne sequent calculi, tableaux, and natu-
ral deduction systems for hybrid logics, and several systems which work this way
have been developed (see the Notes for details). In effect, such systems discard Kh
from Kh + RULES (after all, why bother keeping the clumsy Hilbert-style part?)
and strengthen the RULES component so it can assume full deductive responsibility.
To conclude, a general remark. As should now be clear (especially if you have
already done Exercises 7.3.1, 7.3.2, and 7.3.3), the basic hybrid language is a gen-
uine hybrid between Ô¨Årst-order and modal logic: it makes available a number of
key Ô¨Årst-order capabilities (such as names for states and state-equality assertions)
in a decidable (indeed, PSPACE-complete) propositional modal logic. But now
that we are used to viewing names as formulas, it is easy to go even further. For
example, instead of thinking of nominals as names, we could think of them as
variables over states and bind them with quantiÔ¨Åers. For example, we could allow
ourselves to form expressions such as
‚àÉx (x ‚àß 3‚àÉy (y ‚àß œÜ ‚àß @x 2(3y ‚Üí œà))).
This expression captures the effect of the until operator: it says U (œÜ, œà). Note that
in this example the ‚àÉ quantiÔ¨Åer is only used to bind nominals to the current state.
This is such an important operation that a special notation, ‚Üì, has been introduced
for it. Using this notation the deÔ¨Ånition of U (œÜ, œà) can be written as
‚Üìx (x ‚àß 3‚Üìy (y ‚àß œÜ ‚àß @x 2(3y ‚Üí œà))).
It turns out that when the basic hybrid language is enriched only with ‚Üì (that is,
not with the full power of ‚àÉ) then the resulting language picks out exactly the frag-
ment of the Ô¨Årst-order correspondence language that is invariant under generated
submodels. See the Notes for more details.7.3 Hybrid Logic
445
Exercises for Section 7.3
7.3.1 Extend the standard translation to the basic hybrid language by adding clauses for
nominals and satisfaction operators. Use your translation to show that all classes of frames
deÔ¨Åned by pure formulas are Ô¨Årst-order deÔ¨Ånable. (Hint: translate nominals to free Ô¨Årst-
order variables.)
7.3.2 For any n ‚â• 1, let R n xy be the Ô¨Årst-order formula ‚àÉz 1 ¬∑ ¬∑ ¬∑ ‚àÉzn (Rxz1 ‚àß Rz1 z2 ‚àß
¬∑ ¬∑ ¬∑ ‚àß Rzn y). Let œà be a Ô¨Årst-order formula that is a boolean combination of formulas of
the form R n xy, Rxy, and x = y. Show that the class of frames deÔ¨Åned by the universal
closure of œà is deÔ¨Ånable in the basic hybrid language. (Hint: look at the way we deÔ¨Åned
trichotomy.)
7.3.3 Prove Lemma 7.22. That is, if M = (F, V ) is a named model and œÜ is a pure formula
and for all pure instances œà of œÜ we have that M  œà, then F  œÜ.
7.3.4 Show that 3i ‚àß @ i p ‚Üí 3p, the bridge formula, is provable in K h . (Hint: prove the
contraposed form 3i ‚àß 2p ‚Üí @ i p with the help of 3q ‚àß 2p ‚Üí 3(q ‚àß p), introduction,
and back.)
7.3.5 Prove that K h is the minimal hybrid logic by Ô¨Çeshing out the completeness-via-
generation argument sketched in the text.
7.3.6 Find I4-proofs of 33p ‚Üí 3p, i ‚Üí ¬¨33i, and i ‚Üí 2(3i ‚Üí i). (The logic I4 was
introduced in Example 7.30.)
7.3.7 The PASTE rule makes crucial use of @-operators. Prove an analog of Theorem 7.29
for the @-free sublanguage of the basic hybrid language. (Hint: you need to simulate the
satisfaction operators using the modalities. So for all n, m ‚â• 0, add the axiom 3 n (i‚àßp) ‚Üí
2m (i ‚Üí p). Furthermore, let 3 i œÜ be shorthand for 3(i ‚àß œÜ), and add all rules of the form
 3 k ¬∑ ¬∑ ¬∑ 3i 3j œÜ ‚Üí Œ∏
.
 3k ¬∑ ¬∑ ¬∑ 3i 3œÜ ‚Üí Œ∏
Here j is a nominal distinct from k, ¬∑ ¬∑ ¬∑ , i that does not occur in œÜ or Œ∏.)
7.3.8 Let I4D be the normal hybrid logic obtained by adding the axiom 3(i ‚à® ¬¨i) to
I4. Clearly I4D lacks the Ô¨Ånite frame property. Show that it possesses the Ô¨Ånite model
property (and hence that Theorem 3.28 fails for hybrid languages). Exploit this by proving
the decidability of I4D using a Ô¨Åltration argument.
7.3.9 Add the global diamond E to the basic hybrid language. Use a Ô¨Åltration argument
to show that the satisÔ¨Åability problem for the resulting language is decidable. What is
its complexity? (Note that @ i œÜ can be deÔ¨Åned to be E(i ‚àß œÜ), so you do not have to
deal explicitly with the satisfaction operators.) Show that a class of frames is deÔ¨Ånable
in this language if and only if it is deÔ¨Ånable in the basic modal language enriched with
the D-operator. (Here ‚ÄòdeÔ¨Ånable‚Äô means deÔ¨Ånable by an arbitrary formula, not just a pure
formula.)446
7 Extended Modal Logic
7.4 The Guarded Fragment
In Chapter 2 we saw that modal languages can be viewed as fragments of Ô¨Årst-
order logic, and in Chapter 6 we discovered that these fragments have some nice
computational properties. It thus seems natural to try and see how far we can
generalize these properties to larger fragments of Ô¨Årst-order logic. This will be the
main aim of this section: we will deÔ¨Åne and discuss two extensions of the modal
fragment with reasonably nice computational behavior.
In order to isolate such fragments, what properties of the modal fragment of
Ô¨Årst-order logic should we concentrate on? In particular, what makes modal logic
decidable? If we conÔ¨Åne ourselves to the basic modal language, is it perhaps the
fact that the standard translation can be carried out entirely within the two variable
fragment of Ô¨Årst-order logic (which has a decidable satisÔ¨Åability problem)? This
argument immediately breaks down if we consider languages with modal operators
of higher arity: while giving rise to decidable logics as well, these languages have
standard translations that really need more than two variables. But as soon as we
are considering n-variable fragments of Ô¨Årst-order logic with n > 2, we face an
undecidable satisÔ¨Åability problem.
Rather, it seems to be the fact that the modal fragment of Ô¨Årst-order logic allows
quantiÔ¨Åcation only in a very restricted form, as is obvious from the modal clause
in the deÔ¨Ånition of the standard translation function:
ST x (3œÜ) = ‚àÉy (Rxy ‚àß ST y (œÜ)).
(7.3)
It is this restricted form of quantiÔ¨Åcation which ensures that modal logic is the
bisimulation invariant fragment of Ô¨Årst-order logic, and bisimulation invariance of
modal truth was critical in the Ô¨Årst method of proving the Ô¨Ånite model property for
the basic modal language (see Section 2.3). Recall that the starting point of this
method was the observation that modal logic has the tree model property (meaning
that every satisÔ¨Åable modal formula is satisÔ¨Åable on a tree model), and that bisimu-
lation invariance is pivotal in proving this result. In short, there seems to be a direct
line from the restricted quantiÔ¨Åer pattern in (7.3), via bisimulation invariance and
the tree model property, to the Ô¨Ånite model property and decidability.
This provides our Ô¨Årst search direction: look for Ô¨Årst-order fragments charac-
terized by restricted quantiÔ¨Åcation. It turns out that one can easily relax many
constraints applying to the (basic) modal fragment. For example, we do not have
to conÔ¨Åne ourselves to formulas using two variables only, to formulas having pre-
cisely one free variable, or to formulas with predicates of arity at most two. Relax-
ing these constraints naturally leads to the so-called guarded fragment of Ô¨Årst-order
logic; the idea here is that quantiÔ¨Åers may appear only in the following form:
‚àÉy (G(x, y) ‚àß œà(x, y))
(7.4)
in which G(x, y) is an atomic formula that we will call the guard of the quantiÔ¨Å-7.4 The Guarded Fragment
447
cation (or, of the formula). The crucial ingredient that we keep from (7.3) is that
all free variables of œà are also free in the guard G(x, y). And indeed, it can be
shown that the guarded fragment has various nice properties, such as a decidable
satisÔ¨Åability problem and the Ô¨Ånite model property.
However, there are some very natural modal-like languages, or alternative but
intuitive interpretations for standard modal languages, that correspond to a decid-
able fragment of Ô¨Årst-order logic as well, but are not covered by this deÔ¨Ånition. For
example, consider the language with the since and until operators: it is straightfor-
ward to turn the truth deÔ¨Ånitions for these operators into a standard translation to
Ô¨Årst-order logic. The interesting clauses are
ST x (U (œÜ, œà)) = ‚àÉy (Rxy ‚àß ST y (œÜ) ‚àß ‚àÄz ((Rxz ‚àß Rzy) ‚Üí ST z (œà))),
(‚àó)
and a similar one for the since operator. We can prove that this kind of clause
takes us outside the guarded fragment of Ô¨Årst-order logic: the problem concerns
the ‚Äòbetweenness conjunct‚Äô ‚àÄz ((Rxz ‚àß Rzy) ‚Üí ST z (œà)) which has a ‚Äòcompos-
ite‚Äô guard, (Rxz ‚àß Rzy). Nevertheless, the language with since and until has a
decidable satisÔ¨Åability problem; apparently, some composite guards are admissible
as well.
Examples such as (‚àó) lead to extensions of the guarded fragment to fragments
in which one is more liberal in the precise conditions imposed on the guard. One
can be a bit more liberal here because in the ‚Äòdirect line‚Äô mentioned earlier there
are some steps that could be skipped on the way. In particular, if we are interested
in decidability rather than the Ô¨Ånite model property, we could just as well settle
for fragments of Ô¨Årst-order logic to which we may apply the mosaic method of
Section 6.4. Recall that the mosaic method is a way of proving decidability by
‚Äòdeconstructing‚Äô a model into a Ô¨Ånite number of Ô¨Ånite pieces, and then using such
Ô¨Ånite toolboxes for constructing models again, models that usually hang together
quite loosely (in a sense to be made precise later). This provides the second di-
rection in our quest: try to Ô¨Ånd fragments of Ô¨Årst-order logic to which the mosaic
method applies, leading to a loose model property. Implementing this idea one
naturally Ô¨Ånds quantiÔ¨Åer restrictions of the form
‚àÉy (œÄ(x, y) ‚àß œà(x, y))
(7.5)
in which there are constraints on the presence of variables in certain subformulas
of the guard œÄ. For such fragments one may Ô¨Ånd a direct line from the restricted
quantiÔ¨Åer pattern in (7.5), via an appropriate notion of bisimulation invariance and
the loose model property, to some Ô¨Ånite mosaic property and decidability.
The particular extension that we discuss in this section is that of the packed
fragment; it Ô¨Åts very nicely in the mosaic approach. On a Ô¨Årst reading of the
section the reader may choose to skip the parts referring to this packed fragment,
and concentrate on the guarded fragment.448
7 Extended Modal Logic
The guarded and the packed fragment
We need some preliminaries. The Ô¨Årst-order language that we will be working
in is purely relational, with equality; the language contains neither constants nor
function symbols. For a sequence of variables x = x1 , . . . , xn , we frequently
write ‚àÉx œÜ, which, as usual, has the same meaning as ‚àÉx1 . . . ‚àÉxn œÜ. However,
in this section we view ‚àÉx not as an abbreviation, but as a primitive operator. In
particular this means that the subformulas of ‚àÉx œÜ are just ‚àÉx œÜ itself, together with
the subformulas of œÜ. As usual, by writing œÜ(x) we indicate that the free variables
of œÜ are among x1 , . . . , xn .
DeÔ¨Ånition 7.31 We say that a formula œÜ packs a set of variables {x1 , . . . , xk } if
(i) Free(œÜ) = {x1 , . . . , xk } and (ii) œÜ is a conjunction of formulas of the form
xi = xj or R(xi1 , . . . , xin ) or ‚àÉxj1 . . . ‚àÉxjm R(xi1 , . . . , xin ) such that (iii) for
every xi = xj , there is a conjunct in œÜ in which xi and xj both occur free.
The packed fragment PF is deÔ¨Åned as the smallest set of Ô¨Årst order formulas
which contains all atomic formulas and is closed under the boolean connectives
and under packed quantiÔ¨Åcation. That is, whenever œà is a packed formula, œÄ packs
Free(œÄ), and Free(œà) ‚äÜ Free(œÄ), then ‚àÉx (œÄ ‚àß œà) is packed as well; œÄ is called
the guard of this formula. The guarded fragment GF is the subfragment of PF in
which we only allow guarded quantiÔ¨Åcation as displayed in (7.4); that is, packed
quantiÔ¨Åcation in which the guard œÄ is an atomic formula.
PF n and GF n denote the restrictions to n variables and at most n-ary predicate
symbols of PF and GF , respectively.
Examples of guarded formulas are
(i) the standard translation of any modal formula (in any language),
(ii) the standard translation of any formula in the basic temporal language,
(iii) formulas like ‚àÄxy (Rxy ‚Üí Ryx), ‚àÉxy (Rxy ‚àß Ryx ‚àß (Rxx ‚à® Ryy)), . . . .
For an example of a packed formula which is not guarded, consider ‚àÉxyz ((Rxy ‚àß
Rxz ‚àßRyz)‚àß¬¨Cxyz). For another example, Ô¨Årst consider the standard translation
‚àÉy (Rxy ‚àß P y ‚àß ‚àÄz ((Rxz ‚àß Rzy) ‚Üí Qz)) of the formula U (p, q). This formula is
not packed itself, because the guard of the subformula ‚àÄz ((Rxz ‚àß Rzy) ‚Üí Qz))
has no conjunct in which the variables x and y occur together. But of course, the
formula is equivalent to
‚àÉx (Rxy ‚àß P y ‚àß ‚àÄz ((Rxz ‚àß Rzy ‚àß Rxy) ‚Üí Qz))
which is packed. It is not hard to convert this example into a proof showing that
every formula in the since and until language is equivalent to a packed formula.
Second, note that the notion of packedness only places meaningful restrictions
on pairs of distinct variables: since the formula x = x packs the set of variables7.4 The Guarded Fragment
449
{x}, the formula ‚àÉx (x = x ‚àß œà(x)), (that is, with a single quantiÔ¨Åcation over the
variable x) is a packed formula, at least, provided that œà(x) is packed. Since the
given formula is equivalent to ‚àÉx œà(x) this shows that packedness allows a fairly
mild form of ordinary quantiÔ¨Åcation, namely over formulas with one free variable
only. A nice corollary of this is that we may perform the standard translation of the
global diamond E within the two variable guarded fragment:
ST x (EœÜ) = ST y (EœÜ) = ‚àÉx (ST x (œÜ)) ‚â° ‚àÉx (x = x ‚àß ST x (œÜ)).
Finally, not all formulas are packed, or equivalent to a packed formula. For exam-
ple, the transitivity formula ‚àÄyz ((Rxy ‚àß Ryz) ‚Üí Rxz) is not packed, and neither
is the standard translation of the difference operator: ‚àÉy (x = y ‚àß P y).
Nice properties
Having deÔ¨Åned the packed and the guarded fragment of Ô¨Årst-order logic, let us
see now what we can prove about these fragments. To start with, for each of the
two fragments we can Ô¨Ånd a suitable notion of bisimulation which characterizes
the fragment in the same way as the ordinary bisimulation characterizes the modal
fragment of Ô¨Årst-order logic. Unfortunately we do not have the space to go into
detail here. Nevertheless, we will show that both fragments have what we call the
loose model property: in Theorem 7.33 we will show that every satisÔ¨Åable packed
formula can be satisÔ¨Åed on a loose model. What, then, is a loose model?
DeÔ¨Ånition 7.32 Let A = (A, I) be a Ô¨Årst-order structure. A tuple (a1 , . . . , an ) of
objects in A is called live in A if either a1 = ¬∑ ¬∑ ¬∑ = an or (a1 , . . . , an ) ‚àà I(P )
for some predicate symbol P . A subset X of A is called guarded if there is some
live tuple (a1 , . . . , an ) such that X ‚äÜ {a1 , . . . , an }. In particular, singleton sets
are always guarded; note also that guarded sets are always Ô¨Ånite. X is packed or
pairwise guarded if it is Ô¨Ånite and each of its two-element subsets is guarded.
We say that A is a loose model of degree k ‚àà N if there is some acyclic connected
graph G = (G, E) and a function f mapping nodes of G to subsets of A of size
not exceeding k such that for every live tuple sÃÑ from A, the set L(s) = {g ‚àà G |
si ‚àà f (g) for all si }, is a non-empty and connected subset of G.
In words, we call a model A = (A, I) loose if we can associate a connected graph
G = (G, E) with it in the following way. Each node t of the graph corresponds
to a small subset f (t) of the model; a good way of thinking about this is that t
‚Äòdescribes‚Äô f (t). One then requires that the graph ‚Äòcovers‚Äô the entire model in the
sense that any a ‚àà A belongs to one of these sets (this follows from the fact that for
any a ‚àà A, the ‚Äòtuple‚Äô a is live). The fact that each set L(a) is connected whenever
a is live, implies that various nodes of the graph will not give contradictory descrip-
tions of the model. Finally, the looseness of the model stems from the acyclicity of450
7 Extended Modal Logic
G and the connectedness of the sets L(a); for, this ensures that in walking through
the graph we may describe different parts of the model, but we never have to worry
about returning to the same part once we have left it. Summarizing, we may see
the graph as a loose, coherent collection of descriptions of local submodels of the
model. Loose models are the ones for which we can Ô¨Ånd such a graph.
The following result states that the packed fragment of Ô¨Årst-order logic has the
loose model property.
Theorem 7.33 Every satisÔ¨Åable packed formula can be satisÔ¨Åed on a loose model
(of degree at most the number of ‚àÉx subformulas of Œæ).
But the big question is of course whether following this looseness principle we
have indeed arrived at a decidable fragment of Ô¨Årst-order logic. The next theorem
states that we have.
Theorem 7.34 The satisÔ¨Åability problems for the guarded and the packed frag-
ment are decidable; both problems are DEXPTIME-complete (complete for doubly
exponential time). However, for a Ô¨Åxed natural number n, the satisÔ¨Åability problem
for formulas in the packed fragment PFn is decidable in EXPTIME.
And Ô¨Ånally, what about the Ô¨Ånite model property? Will every satisÔ¨Åable packed
formula have a Ô¨Ånite model? Here as well, the packed fragment displays very nice
behavior. Unfortunately, we do not have the space for a proof of the Ô¨Ånite model
property for the packed fragment ‚Äì sufÔ¨Åce it to say that it involves some quite
advanced techniques from Ô¨Ånite model theory. For some further information the
reader is referred to the Notes at the end of the section.
Mosaics
The remainder of the section is devoted to proving the Theorems 7.33 and 7.34.
The main idea behind the proof is to use the mosaic method that we met in Chap-
ter 6. Roughly speaking, this method is based on the idea of deconstructing models
into a Ô¨Ånite collection of Ô¨Ånite submodels, and, conversely, of building up new,
‚Äòloose‚Äô models from such parts. We will see that the packed fragment is in a sense
tailored towards making this idea work.
The proof is structured as follows. We start by formally deÔ¨Åning mosaics and
some related concepts. After that we state the main result concerning the mosaic
method, namely the Mosaic Theorem stating that a packed formula is satisÔ¨Åable if
and only if there is a so-called linked set of mosaics for it, of bounded size. This
equivalence enables us to deÔ¨Åne our decision algorithm and establish the com-
plexity upper bounds mentioned in Theorem 7.34. We then continue to prove the7.4 The Guarded Fragment
451
Mosaic Theorem. In doing so we obtain the loose model property for the packed
fragment as a spin-off.
For a formal deÔ¨Ånition of the concept of a mosaic we Ô¨Årst need some syntactic
preliminaries. Given a Ô¨Årst-order formula Œæ, we let Var (Œæ) and Free(Œæ) denote
the sets of variables and free variables occurring in Œæ, respectively. Let V be a
set of variables. A V -substitution is any partial map œÉ : V ‚Üí V . The result of
performing the substitution œÉ on the formula œà is denoted by œàœÉ . (We can and
may assume that such substitutions can be carried out without increasing the total
number of variables involved; more precisely, we assume that if Var (œà) ‚äÜ V then
Var (œà œÉ ) ‚äÜ V .)
As usual, we will employ a notion of closure to delineate a Ô¨Ånite set of relevant
formulas, that is formulas that for some reason critically inÔ¨Çuence the truth of a
given formula Œæ. Let the single negation ‚àºœÜ of a formula œÜ denote the formula œà
if œÜ is of the form ¬¨œà; otherwise, ‚àºœÜ is the formula ¬¨œÜ; we say that a set Œ£ of
formulas is closed under single negations if ‚àºœÜ ‚àà Œ£ whenever œÜ ‚àà Œ£.
DeÔ¨Ånition 7.35 Let Œ£ be a set of packed formulas in the set V of variables.
We call Œ£ V -closed if it is closed under subformulas, single negations and V -
substitutions (that is, if œà belongs to Œ£, then so does œàœÉ for every V -substitution
œÉ). With Clg (Œæ) we denote the smallest Var (Œæ)-closed set of formulas containing
Œæ.
For the remainder of this section, we Ô¨Åx a packed formula Œæ ‚Äì all deÔ¨Ånitions to
come should be understood as being relativized to Œæ. The number of variables oc-
curring in Œæ (free or bound) is denoted by k; that is, k is the size of Var (Œæ). It
can easily be veriÔ¨Åed that the sets of guarded and packed formulas are both closed
under taking subformulas; hence, the set Clg (Œæ) consists of guarded (packed, re-
spectively) formulas. An easy calculation shows that the cardinality of Clg (Œæ) is
bounded by kk ¬∑ (2|Œæ|).
The following notion is the counterpart of the atoms that we have met in earlier
decidability proofs (see Lemma 6.29, for instance). All three deÔ¨Åning conditions
are fairly obvious.
DeÔ¨Ånition 7.36 Let X ‚äÜ Var (Œæ) be a set of variables. An X-type is a set Œì ‚äÜ
Clg (Œæ) with free variables in X satisfying, for all formulas œÜ ‚àß œà, ‚àºœÜ, œÜ in Clg (Œæ)
with free variables in X, the conditions (i) œÜ ‚àß œà ‚àà Œì iff œÜ ‚àà Œì and œà ‚àà Œì ,
(ii) œÜ ‚àà Œì iff ‚àºœÜ ‚àà Œì and (iii) if œÜ, xi = xj ‚àà Œì then œÜœÉ ‚àà Œì for any substitution
œÉ mapping xi to xj and/or xj to xi , while leaving all other variables Ô¨Åxed.
The next deÔ¨Ånition introduces our key tool in proving the decidability of the packed
fragment: mosaics and linked sets of them. Basically, a mosaic consists of a subset
X of Var (Œæ) together with a set Œì encoding the relevant information on some452
7 Extended Modal Logic
small part of a model. Here ‚Äòsmall‚Äô means that its size is bounded by the number of
objects that can be named using variables in X, and ‚Äòrelevant‚Äô refers to all formulas
in Clg (Œæ) whose free variables are in X. It turns out that a Ô¨Ånite set of such mosaics
contains sufÔ¨Åcient information to construct a model for Œæ provided that the set links
the mosaics together in a nice way. Here is a more formal deÔ¨Ånition.
DeÔ¨Ånition 7.37 A mosaic is a pair (X, Œì ) such that X ‚äÜ Var (Œæ) and Œì ‚äÜ Clg (Œæ).
A mosaic is coherent if it satisÔ¨Åes the following conditions:
(C1) Œì is an X-type,
(C2) if œà(x, z) and œÄ(x, z) are in Œì , then so is ‚àÉy (œÄ(x, y) ‚àß œà(x, y)),
(provided that the latter formula belongs to Clg (Œæ)).
A link between two mosaics (X, Œì ) and (X , Œì  ) is a renaming (that is, an injec-
tive substitution) œÉ with dom œÉ ‚äÜ X and range œÉ ‚äÜ X which satisÔ¨Åes, for all
formulas œÜ ‚àà Clg (Œæ): œÜ ‚àà Œì iff œÜœÉ ‚àà Œì  .
A requirement of a mosaic is a formula of the form ‚àÉy (œÄ(x, y) ‚àß œà(x, y)) be-
longing to Œì . A mosaic (X , Œì  ) fulÔ¨Ålls the requirement ‚àÉy (œÄ(x, y) ‚àß œà(x, y))
of a mosaic (X, Œì ) via the link œÉ if for some variables u, v in X we have that
œÉ(x) = u and œÄ(u, v) and œà(u, v) belong to Œì  . A set S of mosaics is linked if
every requirement of a mosaic in S is fulÔ¨Ålled via a link to some mosaic in S. S is
a linked set of mosaics for Œæ if it is linked and Œæ ‚àà Œì for some (X, Œì ) in S.
Note that a mosaic (X, Œì ) may fulÔ¨Åll its own requirements, either via the identity
map or via some other map from X to X.
The key result concerning mosaics is the following Mosaic Theorem:
Theorem 7.38 (Mosaic Theorem) Let Œæ be a packed formula. Then Œæ is satisÔ¨Å-
able if and only if there is a linked set of mosaics for Œæ.
Proof. The hard, right to left, direction of the theorem is treated in Lemma 7.39
below; here we only prove the other direction.
Suppose that Œæ is satisÔ¨Åed in the model A = (A, I). In a straightforward way
we can ‚Äòcut out‚Äô from A a linked set of mosaics for Œæ. Consider the set of partial
assignments of elements in A to variables in Var (Œæ). For each such Œ±, let (XŒ± , ŒìŒ± )
be the mosaic given by XŒ± = dom Œ± and
ŒìŒ± = {œÜ ‚àà Clg (Œæ) | A |= œÜ[Œ±]}.
We leave it to the reader to verify that this collection forms a linked set of mosaics
for Œæ.
When establishing the hard direction of this proposition we will in fact prove some-
thing stronger: starting from a linked set of mosaics for a formula Œæ we will show,
via a step-by-step argument, that there is a loose or tree-like model for Œæ. First,7.4 The Guarded Fragment
453
however, we want to show that the Mosaic Theorem is the key towards proving
the decidability of the packed fragment, and also for Ô¨Ånding an upper bound for its
complexity.
The decision algorithm and its complexity
The mosaic theorem tells us that any packed formula Œæ is satisÔ¨Åable if and only if
there is a linked set of mosaics for Œæ. Thus an algorithm answering the question
whether a linked set of mosaics exists for Œæ, also decides whether Œæ is satisÔ¨Åable.
By providing such an algorithm we establish the upper complexity bound for the
satisÔ¨Åability problem of the packed fragment.
Recall that k denotes the number of variables occurring in Œæ. The following
observations are fairly straightforward consequences of our deÔ¨Ånitions:
k
(i) up to isomorphism there are at most 2k ¬∑ 22|Œæ|¬∑k mosaics. Using the O
k log k
notation, this is at most 2O(|Œæ|)¬∑2
,
(ii) given sets X, Œì with |X| ‚â§ k and Œì ‚äÜ Clg (Œæ) it is decidable in time
polynomial in kk and |Œæ| whether (X, Œì ) is a coherent mosaic,
(iii) given a set X of coherent mosaics and a requirement œÜ(x) it is decidable in
time polynomial in |X| and |œÜ(x)| whether X fulÔ¨Ålls the requirement œÜ(x).
Using methods similar to the elimination of Hintikka sets that we saw in the de-
cidability proof for propositional dynamic logic (see Section 6.8), we now give an
algorithm which decides the existence of a linked set of mosaics for Œæ. Let S0 be
the set of all coherent mosaics. By the observations above, S0 contains at most
k log k
2O(|Œæ|)¬∑2
elements and can be constructed in time polynomial in |S0 |. We now
inductively construct a sequence of sets of mosaics S0 ‚äá S1 ‚äá S2 ‚äá S3 ¬∑ ¬∑ ¬∑. If
every requirement of a mosaic Œº in a set Si is fulÔ¨Ålled we call Œº happy. If every
mosaic in Si is happy then return ‚Äòthere is a linked set of mosaics for Œæ‚Äô if Si con-
tains a mosaic (X, Œì ) with Œæ ‚àà Œì , and return ‚Äòthere is no linked set of mosaics for
Œæ‚Äô otherwise. If, on the other hand, Si contains unhappy mosaics, let Si+1 consist
of all happy mosaics in Si and continue the construction. Since our sets decrease in
size at every step, the construction must halt after at most |S0 | many stages. By the
observations above, computing which states in Si are happy can be done in time
polynomial in Œæ and |Si |. Thus the entire computation can be performed in time
polynomial in |S0 |. Clearly the algorithm is correct.
Hence, if we consider a formula Œæ in a packed fragment with a Ô¨Åxed number of
variables, |S0 | is exponential in |Œæ|. In general, however, the number of variables
occurring in a formula depends on the formula‚Äôs length and, hence, |S0 | is dou-
bly exponential in |Œæ|. Thus, pending the correctness of Lemma 7.39 below, this
establishes the complexity upper bounds in Theorem 7.34.7 Extended Modal Logic
454
Loose models
Finally, we show the hard direction of the Mosaic Theorem; as a spin-off we estab-
lish the ‚Äòloose model property‚Äô mentioned in Theorem 7.33.
Lemma 7.39 Let Œæ be a packed formula. If there is a linked set of mosaics for Œæ,
then Œæ is satisÔ¨Åable in a loose model of degree |Var (Œæ)|.
Proof. Assume that S is a linked set of mosaics for Œæ. Using a step-by-step con-
struction, we will build a loose model for Œæ, together with an acyclic graph asso-
ciated with the model. At each stage of the construction we will be dealing with
some kind of approximation of the Ô¨Ånal model and tree; these approximations will
be called networks and are slightly involved structures.
A network is a quintuple (A, G, Œº, Œ±, œÉ) such that A = (A, I) is a model for the
Ô¨Årst-order language; G = (G, E) is a connected, acyclic graph; Œº : G ‚Üí S is a
map associating a mosaic Œºt = (Xt , Œìt ) in S with each node t of the graph; Œ± is
a map associating an assignment Œ±t : Xt ‚Üí A with each node t of the graph; and
Ô¨Ånally, œÉ is a map associating with each edge (t, t ) of the graph a link œÉtt from Œºt
to Œºt (we will usually simplify our notation by writing œÉ instead of œÉtt ).
The idea is that each mosaic Œºt is meant to give a complete description of the
relevant requirements that we impose on a small part of the model-to-be. Which
part? This is given by the assignment Œ±t . And the word ‚Äòrelevant‚Äô refers to the
fact that we are only interested in the formulas inÔ¨Çuencing the truth of Œæ; that is,
the formulas in Clg (Œæ). The links between neighboring mosaics are there to ensure
that distinct mosaics agree on the part of the model that they both have access to.
Now obviously, if we want all of this to work properly we have to impose some
conditions on networks. In order to formulate these, we need some auxiliary no-
tation. For a subset Q ‚äÜ A, let L(Q) denote the set of nodes in G that have
‚Äòaccess‚Äô to Q; formally, we deÔ¨Åne L(Q) = {t ‚àà G | Q ‚äÜ range(Œ±t )}. For a
tuple a = (a1 , . . . , an ) of elements in A we set L(a) = L({a1 , . . . , an }). Now
a network is called coherent if it satisÔ¨Åes the following conditions (all to be read
universally quantiÔ¨Åed):
(C1)
(C2)
(C3)
(C4)
(C5)
P x ‚àà Œìt iff A |= P x[Œ±t ],
xi = xj ‚àà Œìt iff Œ±t (xi ) = Œ±t (xj ),
L(Q) is non-empty for every guarded set Q ‚äÜ A,
L(Q) is connected for every guarded set Q ‚äÜ A,
if Ett then œÉtt (x) = x iff Œ±t (x) = Œ±t (x ).
A few words of explanation about these conditions: (C1) and (C2) ensure that every
mosaic is a complete description of the atomic formulas holding in the part of the
model it refers to. Condition (C3) states that no live tuple of the model remains
unseen from the graph, while the conditions (C4) and (C5) are the crucial ones7.4 The Guarded Fragment
455
making that remote parts of the graph cannot contain contradictory information
about the model ‚Äì how this works precisely will become clear further on. Note that
condition (C5) has two directions: the left-to-right direction states that neighboring
mosaics have common access to part of the model, while the other direction ensures
that they agree on their requirements concerning this common part.
The motivation for using these networks is that in the end we want any formula
œÜ(x) ‚àà Clg (Œæ) to hold in A under the assignment Œ±t if and only if œÜ(x) belongs
to Œìt . Coherence on its own is not sufÔ¨Åcient to make this happen. A defect of
a network consists of a formula ‚àÉy (œÄ(x, y) ‚àß œà(x, y)) which is a requirement of
the mosaic Œºt for some node t while there is no neighboring node t such that Œºt
fulÔ¨Ålls ‚àÉy (œÄ(x, y) ‚àß œà(x, y)) via the link œÉtt . A coherent network N is perfect if
it has no defects. We say that N is a network for Œæ if for some t ‚àà G, Œºt = (Xt , Œìt )
is such that Œæ ‚àà Œìt .
Claim 1 If N = (A, G, Œº, Œ±, œÉ) is a perfect network for Œæ, then
(i) A is a loose model of degree |Var (Œæ)|, and
(ii) for all formulas œÜ(x) ‚àà Clg (Œæ) and all nodes t of G: œÜ ‚àà Œìt iff A |= œÜ[Œ±t ].
Proof of Claim. For part (i) of the claim, let N = (A, G, Œº, Œ±, œÉ) be the perfect
network for Œæ. Let A = (A, I). As the function f mapping nodes of G to subsets
of A, simply take the map that assigns the range of Œ±t to the node t. Since the
domain of each map Œ±t is always a subset of Var (Œæ), it follows immediately that
f (t) will always be a set of size at most |Var (Œæ)|. Now take an arbitrary live tuple
s in A; it follows from (C3) and (C4) that L(s) is a non-empty and connected part
of the graph G. Thus A is a loose model of degree |Var (Œæ)|.
We prove part (ii) of the claim by induction on the complexity of œÜ. For atomic
formulas the claim follows by conditions (C1) and (C2), and the boolean case of
the induction step is straightforward (since Œìt is an X‚Äìtype) and left to the reader.
We concentrate on the case that œÜ(x) is of the form ‚àÉy (œÄ(x, y) ‚àß œà(x, y)).
First assume that œÜ(x) ‚àà Œìt . Since N is perfect there is a node t in G and
variables u, v in Xt such that Ett , œÄ(u, v) and œà(u, v) belong to Œìt , while the
link œÉ from Œºt to Œºt maps x to u. By the induction hypothesis we Ô¨Ånd that
A |= œÄ(u, v) ‚àß œà(u, v)[Œ±t ].
(7.6)
But from condition (C5) it follows that Œ±t (x) = Œ±t (u), whence (7.6) implies that
A |= ‚àÉy (œÄ(x, y) ‚àß œà(x, y))[Œ±t ],
which is what we were after. Here and in the sequel, if x = (x1 , . . . , xn ), then
Œ±(x) abbreviates (Œ±(x1 ), . . . , Œ±(xn )).
Now suppose, in order to prove the converse direction, that A |= œÜ(x)[Œ±t ]. Let a456
7 Extended Modal Logic
denote Œ±t (x), then there are b in A such that A |= œÄ(x, y)[ab] and A |= œà(x, y)[ab].
Our Ô¨Årst aims are to prove that
L(ab) = ‚àÖ,(7.7)
L(Q) is connected for every Q ‚äÜ {a, b}.(7.8)
and
Note that if we are working in the guarded fragment, then œÄ(x, y) is an atomic
formula, whence it follows from A |= œÄ(x, y)[ab] that ab is live. Thus {a, b} is
guarded, and hence (7.7) is immediate by condition (C3). In fact, every Q ‚äÜ {a, b}
is guarded in this case, so (7.8) is immediate by condition (C4).
In the more general case of the packed fragment we have to work a bit harder.
First, observe that it does follow from A |= œÄ(x, y)[ab] and the conditions on
œÄ(x, y) in the deÔ¨Ånition of packed quantiÔ¨Åcation, that {c, d} is guarded, and thus,
L(c, d) = ‚àÖ, for every pair (c, d) of points taken from ab. It follows from (C4)
that {L(c) | c taken from ab} is a collection of non-empty, connected, pairwise
overlapping subgraphs of the acyclic graph G. It is fairly straightforward to prove,
for instance, by induction on the size of the graph G, that any such collection must
have a non-empty intersection. From this, (7.7) and (7.8) are almost immediate.
Thus, we may assume the existence of a node t in G such that {a, b} ‚äÜ range Œ±t .
Let u and v in Xt be the variables such that Œ±t (u) = a and Œ±t (v) = b. The
induction hypothesis implies that œÄ(u, v) and œà(u, v) belong to Œìt , whence œÜ(u) ‚àà
Œìt by coherence of Œºt . Since both t and t belong to L(a), it follows from (7.8)
that there is a path from t to t within L(a), say t = s0 Es1 E . . . Esn = t. Let œÉi
be the link between the mosaics of si and si+1 , and deÔ¨Åne œÅ to be the composition
of these maps. It follows by an easy inductive argument on the length of the path
that œÅ is a link between Œºt and Œºt such that œÅ(u) = x. Hence, by deÔ¨Ånition of a
link we have that œÜ(x) ‚àà Œìt .
By Claim 1, in order to prove Lemma 7.39 it sufÔ¨Åces to construct a perfect network
for Œæ. This construction uses a step-by-step argument; to start the construction we
need some coherent network for Œæ.
Claim 2 There is a coherent network for Œæ.
Proof of Claim. By our assumption on Œæ there is a coherent mosaic Œº = (X, Œì )
such that Œæ ‚àà Œì . Without loss of generality we may assume that X is the set
{x1 , . . . , xn } (otherwise, take an isomorphic copy of Œº in which X does have this
form). Let a1 , . . . , an be a list of objects such that for all i and j we have that
ai = aj if and only if the formula xi = xj belongs to Œì . DeÔ¨Åne A = {a1 , . . . , an }
and put the tuple (ai1 , . . . , aik ) in the interpretation I(P ) of the k-ary predicate
symbol P precisely if P xi1 . . . xin ‚àà Œì . Let A be the resulting model (A, I) and7.4 The Guarded Fragment
457
deÔ¨Åne G as the trivial graph with one node 0 and no edges. Let Œº(0) be the mosaic
Œº; Œ±0 : X ‚Üí A is given by Œ±(xi ) = ai ; and Ô¨Ånally, œÉ00 is the identity map from
X to X.
We leave it to the reader to verify that the quintuple (A, G, Œº, Œ±, œÉ) is a coherent
network for Œæ.
The crucial step of this construction will be to show that any defect of a coherent
network can be repaired.
Claim 3 For any coherent network N = (A, G, Œº, Œ±, œÉ) and any defect of N there
is a coherent network N+ extending N and lacking this defect.
Proof of Claim. Suppose that œÜ(x) is a defect of N because it is a requirement of
the mosaic Œºt and not fulÔ¨Ålled by any neighboring mosaic Œºt . We will deÔ¨Åne an
extension N+ of N in which this defect is repaired.
Since S is a linked set of mosaics and Œºt belongs to S, Œºt is linked to a mosaic
(X  , Œì  ) ‚àà S in which the requirement is fulÔ¨Ålled via some link œÅ. Let Y be
the set of variables in X that do not belong to the range of œÅ; suppose that Y =
{y1 , . . . , yk } (with all yi being distinct). For the sake of a smooth presentation,
assume that Œì  contains the formulas ¬¨x = y for all variables x ‚àà X  and y ‚àà Y
(this is not without loss of generality ‚Äì we leave the general case as an exercise to
the reader). Take a set {c1 , . . . , ck } of fresh objects (that is, no ci is an element
of the domain A of A), and let Œ≥ be the assignment with domain X deÔ¨Åned as
follows:
Œ±t (x) if x = œÅ(x),
Œ≥(x ) =
ci
if x = yi ,
and let t be an object not belonging to G. Now deÔ¨Åne the network N+ = (A+ ,
G+ , Œº+ , Œ±+ , œÉ + ) as follows:
A+ = A ‚à™ {c1 , . . . , ck },
I + (P ) = I(P ) ‚à™ {d | for some x, d = Œ≥(x) and P x ‚àà Œì  },
G+ = G ‚à™ {t },
E + = E ‚à™ {(t, t )},
while Œº+ , Œ±+ and œÉ+ are given as the obvious extensions of Œº, Œ± and œÉ, namely
+



by putting Œº+
t = (X , Œì ), Œ±t = Œ≥ and œÉtt = œÅ.
+
Since the interpretation I agrees with I on ‚Äòold‚Äô tuples it is a straightforward
exercise to verify that the new network N+ satisÔ¨Åes the conditions (C1)‚Äì(C3) and
(C5).
In order to check that condition (C4) holds, take some guarded subset Q from
A+ ; we will show that L+ (Q) is a connected subgraph of G+ . It is rather easy7 Extended Modal Logic
458
to see that L+ (Q) is identical to either L(Q) or L(Q) ‚à™ {t }; hence by the con-
nectedness of L(Q) it sufÔ¨Åces to prove, on the assumptions that t ‚àà L+ (Q) and
L(Q) = ‚àÖ, that t ‚àà L(Q). Hence, suppose that t ‚àà L+ (Q); that is, each a ‚àà Q
is in the range of Œ≥. But if L(Q) = ‚àÖ, each such point a must be old; hence, by
deÔ¨Ånition of Œ≥, each a ‚àà Q must belong to range Œ±t . This gives that t ‚àà L(Q), as
required.
As in our earlier step-by-step proofs, the previous two claims show that using some
standard combinatorics we can construct a chain of networks such that their limit
is a perfect network. This completes the proof of Lemma 7.39.
Exercises for Section 7.4
7.4.1 In the loosely guarded fragment the following quantiÔ¨Åcation patterns are allowed:
‚àÉx (œÄ(x, y) ‚àß œà(x, y)) is a loosely guarded formula if œà(x, y) is loosely guarded, œÄ(x, y)
is a conjunction as in the packed fragment, and any pair z, z  of distinct variables from xy
occurs free in some conjunct of the guard œÄ, unless z and z  are both from y. For example,
‚àÉx ((Ryx ‚àß Rxy  ) ‚àß ¬¨Cxyy  ) is loosely guarded, but not packed since there is no conjunct
having both y and y  free.
Show that for every loosely guarded sentence Œæ there exists an equivalent packed sen-
tence Œæ  in the same language.
7.4.2 DeÔ¨Åne the universal packed fragment as the fragment of Ô¨Årst-order logic that is gen-
erated from atoms, negated atoms, conjunction, disjunction, ordinary existential quantiÔ¨Å-
cation, and packed universal quantiÔ¨Åcation. (With the latter we mean that ‚àÄx (œÄ ‚Üí œà) is
in the fragment if œà is universally packed, œÄ packs its own free variables, and Free(œà) ‚äÜ
Free(œÄ).)
Show that satisÔ¨Åability is decidable for the universal packed fragment.
7.4.3 Fix a natural number n, and suppose that we are working in an n-bounded Ô¨Årst-order
signature; that is, all predicate symbols have arity at most n. Prove that in such a signature,
every guarded sentence is equivalent to a guarded sentence using at most n variables. Does
this hold for packed sentences as well? What are the consequences for the complexity of
the respective satisÔ¨Åability problems?
7.4.4 Let Œæ be a packed formula, and suppose that Œæ is satisÔ¨Åable. Prove that Œæ is satisÔ¨Åable
in a loose model with an associated graph G of which the out-degree is bounded by some
recursive function on Œæ. In particular, this out-degree should be Ô¨Ånite. (The out-degree of
a node k of a graph (G, E) is deÔ¨Åned as the number of its neighbors, or, formally, as the
size of the set {k  ‚àà G | kEk  }; the out-degree of a graph is deÔ¨Åned as the supremum of
the out-degrees of the individual nodes.)
7.5 Multi-Dimensional Modal Logic
In Chapter 2 we backed up our claim that logical formalisms do not live in isola-
tion by developing the correspondence theory of modal logic: we studied modal
languages as fragments of Ô¨Årst-order languages. In this section we will turn the7.5 Multi-Dimensional Modal Logic
459
looking glass around and examine Ô¨Årst-order logic as if it were a modal formalism.
The basic observations enabling this perspective are that we may view assignments
(the functions that give Ô¨Årst-order variables their value in a Ô¨Årst-order structure) as
states of a modal model, and that this makes standard Ô¨Årst-order quantiÔ¨Åers behave
just like modal diamonds and boxes. First-order logic thus forms an example of
a multi-dimensional modal system. Multi-dimensional modal logic is a branch of
modal logic dealing with special relational structures in which the states, rather
than being abstract entities, have some inner structure. More speciÔ¨Åcally, these
states are tuples or sequences over some base set, in our case, the domain of the
Ô¨Årst-order structure. Furthermore, the accessibility relations between these states
are (partly) determined by this inner structure of the states.
Reverse correspondence theory
To simplify our presentation, in this section we will not treat modal versions of
Ô¨Årst-order logic in general, but restrict our attention to certain Ô¨Ånite variable frag-
ments. A precise deÔ¨Ånition of these fragments will be given later on (see DeÔ¨Åni-
tion 7.40). For the time being, we Ô¨Åx a natural number n ‚â• 2 and invite the reader
to think of a Ô¨Årst-order language with equality, but without constants or function
symbols, in which all predicates are n-adic. Consider the basic declarative state-
ment in Ô¨Årst-order logic concerning the truth of a formula in a model under an
assignment s:
M |= œÜ [s].
(7.9)
The basic observation underlying our approach, is that we can read (7.9) from a
modal perspective as: ‚Äòthe formula œÜ is true in M at state s.‚Äô But since we have
only n variables at our disposal, say v0 , . . . , vn‚àí1 , we can identify assignments
with maps: n (= {0, . . . , n ‚àí 1}) ‚Üí U , or equivalently, with n-tuples over the
domain U of the structure M ‚Äì we will denote the set of such n-tuples by Un .
But then we Ô¨Ånd ourselves in the setting of multi-dimensional modal logic: the
universe of our modal models will be of the form Un for some base set U . Now
recall that the truth deÔ¨Ånition of the quantiÔ¨Åers reads as follows:
M |= ‚àÉvi œÜ[s] iff there is an u ‚àà U such that M |= œÜ [siu ],
where siu is the assignment deÔ¨Åned by siu (k) = u if k = i and siu (k) = s(k) other-
wise. We can replace the above truth deÔ¨Ånition with the more ‚Äòmodal‚Äô equivalent,
M |= ‚àÉvi œÜ[s] iff there is an assignment s with s ‚â°i s and M |= œÜ [s ],
where ‚â°i is given by
s ‚â°i s iff for all j = i, sj = sj .
(7.10)460
7 Extended Modal Logic
In other words: existential quantiÔ¨Åcation behaves like a modal diamond, having ‚â°i
as its accessibility relation.
Since the semantics of the boolean connectives in the predicate calculus is the
same as in modal logic, this shows that the inductive clauses in the truth deÔ¨Ånition
of Ô¨Årst-order logic neatly Ô¨Åt a modal mould. So let us now concentrate on the
atomic formulas. To start with, we observe that equality formulas do not cause any
problem: the formula vi = vj , with truth deÔ¨Ånition
M |= vi = vj [s] iff s ‚àà Id ij ,
can be seen as a modal constant. Here Idij is deÔ¨Åned by
s ‚àà Id ij iff si = sj .
(7.11)
The case of the other atomic formulas is more involved, however. Since we con-
Ô¨Åned ourselves to the calculus of n-adic relations and do not have constants or func-
tion symbols, our atomic predicate formulas are of the form P vœÉ(0) . . . vœÉ(n‚àí1) .
Here œÉ is an n-transformation, that is, a map: n ‚Üí n. In the model theory of Ô¨Årst-
order logic the predicate symbol P will be interpreted as a subset of Un ; but this is
precisely how modal valuations treat propositional variables in models where the
universe is of the form U n ! Therefore, we can identify the set of propositional vari-
ables of the modal formalism with the set of predicate symbols of our Ô¨Årst-order
language. In this way, we obtain a modal reading of (7.9) for the case where œÜ is the
atomic formula P v0 . . . vn‚àí1 : M |= P v0 . . . vn‚àí1 [s] iff s belongs to the interpreta-
tion of P . However, as a consequence of this approach our set-up will not enjoy a
one-to-one correspondence between atomic Ô¨Årst-order formulas and atomic modal
ones: the atomic formula P vœÉ(0) . . . vœÉ(n‚àí1) will correspond to the modal atom p
only if œÉ is the identity function on n. For the cases where œÉ is not the identity map
we still have to Ô¨Ånd some kind of solution. There are many options here.
Since we are working in a Ô¨Årst-order language with equality, atomic formulas
with multiple occurrences of a variable can be rewritten as formulas with only
‚Äòunproblematic‚Äô atomic subformulas, for instance
P v1 v0 v0 ‚Üî ‚àÉv2 (v2 = v0 ‚àß P v1 v2 v2 )
‚Üî ‚àÉv2 (v2 = v0 ‚àß ‚àÉv0 (v0 = v1 ‚àß P v0 v2 v2 ))
‚Üî ‚àÉv2 (v2 = v0 ‚àß ‚àÉv0 (v0 = v1 ‚àß ‚àÉv1 (v1 = v2 ‚àß P v0 v1 v2 ))).
This leaves the case of what to do with atoms of the form P vœÉ(0) . . . vœÉ(n‚àí1) , where
œÉ is a permutation of n, or in other words, atomic formulas where variables have
been substituted simultaneously. The previous trick does not work here: for ex-
ample, to write an equivalent of the formula P v1 v0 v2 one needs extra variables as
buffers, for instance, when replacing P v1 v0 v2 by
‚àÉv3 ‚àÉv4 (v3 = v0 ‚àß v4 = v1 ‚àß ‚àÉv0 ‚àÉv1 (v0 = v4 ‚àß v1 = v3 ‚àß P v0 v1 v2 )).7.5 Multi-Dimensional Modal Logic
461
One might consider a solution where a predicate P is translated into various modal
propositional variables pœÉ , one for every permutation œÉ of n, but this is not very
elegant. One might also forget about simultaneous substitutions and conÔ¨Åne one-
self to a fragment of n-variable logic where all atomic predicate formulas are of
the form P v0 . . . vn‚àí1 ‚Äì this fragment of restricted Ô¨Årst-order logic is deÔ¨Åned be-
low. A third solution is to take substitution seriously, so to speak, by adding special
‚Äòsubstitution operators‚Äô to the language. The key observation is that for any trans-
formation œÉ ‚àà nn , we have that
M |= P vœÉ(0) . . . vœÉ(n‚àí1) [s] iff M |= P v0 . . . vn‚àí1 [s ‚ó¶ œÉ],
(7.12)
where s ‚ó¶ œÉ is the composition of œÉ and s (recall that s is a map: n ‚Üí U ). So, if
we deÔ¨Åne the relation 1œÉ ‚äÜ U n √ó U n by
s 1œÉ t iff t = s ‚ó¶ œÉ,
(7.13)
we have rephrased (7.12) in terms of an accessibility relation (in fact, a function):
M |= P vœÉ(0) . . . vœÉ(n‚àí1) [s] iff, for some t with s 1œÉ t, M |= P v0 . . . vn‚àí1 [t]. So
if we add an operator œÉ to the modal language for every n-transformation œÉ in
nn , with 1œÉ as its intended accessibility relation, we have got the desired modal
equivalent for any atomic formula P vœÉ(0) . . . vœÉ(n‚àí1) ‚Äì in the form œÉ p. (As a
special case, for the formula P v0 . . . vn‚àí1 one can take the identity map on n.)
DeÔ¨Ånition 7.40 Let n be an arbitrary but Ô¨Åxed natural number. The alphabet of
Ln and of Lrn consists of a set of variables {vi | i < n}, a countable set of n-adic
relation symbols (P0 , P1 , . . .), equality (=), the boolean connectives ¬¨, ‚à® and the
quantiÔ¨Åers ‚àÉvi . The collection of formulas is deÔ¨Åned as usual in Ô¨Årst-order logic,
with the restriction that the atomic formulas of Lrn are of the form vi = vj or
Pl (v0 . . . vn‚àí1 ); for Ln we allow all atomic formulas (but note that all predicates
are of arity n).
A Ô¨Årst-order structure for Ln (Lrn ) is a pair M = (U, V ) such that U is a set
called the domain of the structure and V is an interpretation function mapping
every P to a subset of U n . The notion of a formula œÜ being true in a Ô¨Årst-order
structure M under an assignment s is deÔ¨Åned as usual. For instance, given our
notation we have, for any atomic formula:
M |= P (v0 . . . vn‚àí1 ) [s] if s ‚àà V (P ),
M |= P (vœÉ(0) . . . vœÉ(n‚àí1) ) [s] if s ‚ó¶ œÉ (= (sœÉ(0) . . . sœÉ(n‚àí1) )) ‚àà V (P ).
An Ln -formula œÜ is true in M (notation: M |= œÜ), if M |= œÜ [s] for all s ‚àà Un ;
it is valid (notation: |=fo œÜ), if it is true in every Ô¨Årst-order structure of Ln . The
same deÔ¨Ånition applies to Lrn .
From now on, we will concentrate on the modal versions of Lrn and Ln , which are
given in the following deÔ¨Ånition:7 Extended Modal Logic
462
DeÔ¨Ånition 7.41 Let n be an arbitrary but Ô¨Åxed natural number. MLRn (short for:
modal language of relations) is the modal similarity type having constants ŒπŒ¥ij and
diamonds 3i , œÉ (for all i, j < n, œÉ ‚àà nn ). CMLn , the similarity type of cylindric
modal logic, is the fragment of MLRn -formulas in which no substitution operator
œÉ occurs.
A Ô¨Årst-order structure M = (U, V ) can be seen as a modal model based on the
universe U n , and formulas of these modal similarity types are interpreted in such a
structure in the obvious way; for instance, we have
M, s  ŒπŒ¥ij
M, s  œÉ œÜ
iff
iff
(iff
M, s  3i œÜ iff
si = sj ,
M, s ‚ó¶ œÉ  œÜ
there is a t with s 1œÉ t and M, t  œÜ),
there is a t with s ‚â°i t and M, t  œÜ.
If an MLRn -formula œÜ holds throughout any Ô¨Årst-order structure, we say that it is
Ô¨Årst-order valid, notation: Cn  œÜ (this notation will be clariÔ¨Åed further on).
The modal disguise of Ln in MLRn and of Lrn in CML is so thin, that we give the
translations mapping Ô¨Årst-order formulas to modal ones without further comments.
DeÔ¨Ånition 7.42 Let (¬∑)t be the following translation from Ln to MLR n :
(P vœÉ(0) . . . vœÉ(n‚àí1) )t =
œÉ p,
t(vi = vj )= ŒπŒ¥ij ,
t= ¬¨œÜt ,
(¬¨œÜ)
(œÜ ‚à® œà)t = œÜt ‚à® œà t ,
(‚àÉvi œÜ)t = 3i œÜt .
This translation allows us to see Lrn and CMLn as syntactic variants: (¬∑)t is easily
seen to be an isomorphism between the formula algebras of Lrn and CMLn . Note
that in the case of Ln versus MLRn , we face a different situation: where in MLR
the simultaneous substitution of two variables for each other is a primitive operator,
in Ô¨Årst-order logic it can only be deÔ¨Åned by induction. Nevertheless, we could
easily deÔ¨Åne a translation mapping MLRn -formulas to equivalent Lrn -formulas. In
any case, the following proposition shows that we really have developed a reverse
correspondence theory; we leave the proof as an exercise to the reader.
Proposition 7.43 Let œÜ be a formula in Ln , then
(i) for any Ô¨Årst-order structure M, and any n-tuple/assignment s, we have that
M |= œÜ[s] if and only if M, s  œÜt ;
(ii) as a corollary, we have that |=fo œÜ iff Cn  œÜt .7.5 Multi-Dimensional Modal Logic
463
Let us now put the modal machinery to work and see whether we can Ô¨Ånd out
something new about Ô¨Årst-order logic.
Degrees of validity
Perhaps the most interesting aspect of this modal perspective on Ô¨Årst-order logic is
that it allows us to generalize the semantics of Ô¨Årst-order logic, and thus offers a
wider perspective on the standard Tarskian semantics. The basic idea is fairly ob-
vious: now that we are talking about modal languages, it is clear that the Ô¨Årst-order
structures of DeÔ¨Ånition 7.41 are very speciÔ¨Åc modal models for these languages.
We may abstract from the Ô¨Årst-order background of these models, and consider
modal models in which the universe is an arbitrary set and the accessibility rela-
tions are arbitrary relations (of the appropriate arity).
DeÔ¨Ånition 7.44 An MLRn -frame is a tuple (W, Ti , Eij , FœÉ )i,j<n,œÉ‚àànn such that
every Eij is a subset of the universe W , and such that every Ti and every FœÉ is a
binary relation on W . An MLRn -model is a pair M = (F, V ) with F an MLRn -
frame and V a valuation, that is, a map assigning subsets of W to propositional
variables. CMLn -models and frames are deÔ¨Åned likewise.
For such models, truth of a formula at a state is deÔ¨Åned via the usual modal induc-
tion, for instance:
M, w  œÉ œÜ iff there is a v with FœÉ wv and M, v  œÜ.
In this very general semantics, states (that is, elements of the universe) are no
longer real assignments, but, rather, abstractions thereof. First-order logic now re-
ally has become a poly-modal logic, with quantiÔ¨Åcation and substitution diamonds.
It is interesting and instructive to see how familiar laws of the predicate calculus
behave in this new set-up. For example, the axiom schema œÜ ‚Üí ‚àÉvi œÜ will be valid
only in n-frames where Ti is a reÔ¨Çexive relation (this follows from the fact that the
modal formula p ‚Üí 3i p corresponds to the frame condition ‚àÄx Ti xx). Likewise,
the axiom schemes ‚àÉvi ‚àÉvi œÜ ‚Üí ‚àÉvi œÜ and œÜ ‚Üí ‚àÄvi ‚àÉvi œÜ will be valid only in
frames where the relation Ti is transitive and symmetric, respectively.
Later on we will see more of such correspondences; the point to be made here
is that the abstract perspective on the semantics of Ô¨Årst-order logic imposes a cer-
tain ‚Äòdegree of validity‚Äô on well-known theorems of the predicate calculus. Some
theorems are valid in all abstract assignment frames, like distribution:
‚àÄvi (œÜ ‚Üí œà) ‚Üí (‚àÄvi œÜ ‚Üí ‚àÄvi œà),
which is nothing but the modal K-axiom. Other theorems of the predicate cal-
culus, like the ones mentioned above, are only valid in some classes of frames.464
7 Extended Modal Logic
Narrowing down the class of frames means increasing the set of valid formu-
las, and vice versa. In particular, we now have the option to look at classes of
frames that are only slightly more general than the standard Ô¨Årst-order structures,
but have much nicer computational properties. This new perspective on Ô¨Årst-order
logic, which was inspired by the literature on algebraic logic, provides us with
enormous freedom to play with the semantics for Ô¨Årst-order logic. In particu-
lar, consider the fact that Ô¨Årst-order structures can be seen as frames of the form
(U n , ‚â°i , Idij , 1œÉ )i,j<n,œÉ‚àànn where all assignments s ‚àà U n are available. But why
not study a semantics where states are still real assignments on the base set U , but
not all such assignments are available?
There are at least two good reasons to make such a move. First, it turns out that
the logic of such generalized assignment frames has much nicer meta-properties
than the logic of the cubes such as decidability, see for instance Theorem 7.46.
These logics will provide less laws than the usual predicate calculus, but their sup-
ply of theorems may be sufÔ¨Åcient for particular applications. Note for instance,
that the schemes œÜ ‚Üí ‚àÉvi œÜ, ‚àÉvi ‚àÉvi œÜ ‚Üí ‚àÉvi œÜ and œÜ ‚Üí ‚àÄvi ‚àÉvi œÜ are still valid in
every generalized assignment frame, since ‚â°i W is always an equivalence relation.
In some situations it may even be useful not to have all familiar validities. Con-
sider for instance the schema
‚àÉvi ‚àÉvj œÜ ‚Üí ‚àÉvj ‚àÉvi œÜ.
(7.14)
It follows from correspondence theory that (7.14) is valid in a frame F iff (7.15)
below holds in F.
‚àÄxz (‚àÉy (Ti xy ‚àß Tj yz) ‚Üí ‚àÉu (Tj xu ‚àß Ti uz)).
(7.15)
The point is this. The schema (7.14) prevents us from making the dependency
of variables explicit in the language (that is, whether vj is dependent of vi or the
other way around), while these dependencies play an important role in some proof-
theoretical approaches. So, the second motivation for generalizing the semantics
of Ô¨Årst-order logic is that it gives us a Ô¨Åner sieve on the notion of equivalence
between Ô¨Årst-order formulas. Note for instance that (7.14) is not valid in frames
with assignment ‚Äòholes‚Äô: take n = 2. In a square (that is, 2-cubic) frame we have
(a, b) ‚â°0 (a , b) ‚â°1 (a , b ), but if (a, b ) is not an available tuple, then there is no
s such that (a, b) ‚â°1 s ‚â°0 (a , b ) ‚Äì hence this frame will not satisfy (7.15). So,
the schema (7.14) will not be valid in this frame.
In this new paradigm, a whole landscape of frame classes and corresponding
logics arises. In the most general approach, any subset of Un may serve as the uni-
verse of a multi-dimensional frame, but it seems natural to impose restrictions on
the set of available assignments. Unfortunately, for reasons of space limitations we
cannot go into further detail here, conÔ¨Åning ourselves to the following deÔ¨Ånition.7.5 Multi-Dimensional Modal Logic
465
DeÔ¨Ånition 7.45 Let U be some set, and W a set of n-tuples over U , that is, W ‚äÜ
U n . The cube over U or full assignment frame over U is deÔ¨Åned as the frame
Cn (U ) = (U n , ‚â°i , Idij , 1œÉ )i,j<n,œÉ‚àànn .
The W -relativized cube over U or W -assignment frame on U is deÔ¨Åned as the
frame
CW
n (U ) = (W, ‚â°i W , Idij ‚à© W, 1œÉ W )i,j<n,œÉ‚àànn .
Cn and Rn are the classes of cubes and relativized cubes, respectively.
Observe that this deÔ¨Ånition clariÔ¨Åes our earlier notation ‚ÄòCn  œÜ‚Äô for the fact that
the modal formula œÜ is ‚ÄòÔ¨Årst-order valid‚Äô.
Decidability
As we already mentioned, one of the reasons for developing the abstract and gen-
eralized assignment semantics is to ‚Äòtame‚Äô Ô¨Årst-order logic by looking for core
versions with nicer computational behavior. This idea is substantiated by the fol-
lowing theorem.
Theorem 7.46 It is decidable in exponential time whether a given MLRn -formula
is satisÔ¨Åable in a given relativized cube. As a corollary, the problem whether a
given Ô¨Årst-order formula in Ln can be satisÔ¨Åed in a general assignment frame is
also decidable in exponential time.
Proof. This theorem can be proved directly by using the mosaic method that we
encountered in Section 6.4 ‚Äì in fact, the mosaic method was developed for this
particular proof! However, space limitations prevent us from giving the mosaic
argument here. Therefore, we prove the theorem by a reduction of the Rn satisÔ¨Å-
ability problem to the satisÔ¨Åability problem of the n-variable guarded fragment of
Section 7.4.
This reduction is quite interesting in itself: the key idea is that we Ô¨Ånd a syn-
tactic counterpart to the semantic notion of restricting the set of available assign-
ments. There is a very simple way of doing so, namely by introducing a special
n-adic predicate G that will be interpreted as the collection of available assign-
ments. One can then translate modal formulas (or Ln -formulas) into Ô¨Årst-order
ones, with the proviso that this translation is syntactically relativized to G. The
formula Gv0 . . . vn‚àí1 acts as a guard of the translated formula, and, indeed, it will
easily be seen that the range of this translation falls inside the guarded fragment.
Now for the technical details. Given a collection Œ¶ of propositional variables,
assume that with each p ‚àà Œ¶ we have an associated n-adic predicate symbol P .
Also, Ô¨Åx a new n-adic predicate symbol G; let Œ¶+ denote the expanded signature7 Extended Modal Logic
466
{P | p ‚àà Œ¶} ‚à™ {G}. Consider the following translation (¬∑)‚Ä¢ mapping MLRn -
formulas to Ô¨Årst-order formulas:
p‚Ä¢ = P v0 . . . vn‚àí1 ,
‚Ä¢
ŒπŒ¥ij
‚Ä¢
(¬¨œÜ)
= vi = vj ,
= Gv0 . . . vn‚àí1 ‚àß ¬¨œÜ‚Ä¢ ,
(œÜ ‚àß œà)‚Ä¢ = œÜ‚Ä¢ ‚àß œà ‚Ä¢ ,
(œÉ œÜ)‚Ä¢ = (Gv0 . . . vn‚àí1 ‚àß œÜ‚Ä¢ )œÉ ,
(3i œÜ)‚Ä¢ = ‚àÉvi (Gv0 . . . vn‚àí1 ‚àß œÜ‚Ä¢ ).
Here, for a given transformation œÉ, (¬∑)œÉ denotes the corresponding syntactic sub-
stitution operation on Ô¨Årst-order formulas.
Claim 1 For any MLRn -formula œÜ we have that Rn  œÜ if and only if the formula
Gv0 . . . vn‚àí1 ‚Üí œÜ‚Ä¢ is a Ô¨Årst-order validity.
Proof of Claim. In order to prove this claim, we need a correspondence between
modal models and Ô¨Årst-order models for the new language. Given a relativized
assignment model M = (CW
n (U ), V ), deÔ¨Åne the corresponding Ô¨Årst-order model
‚Ä¢
M as the structure (U, I) where I(P ) = V (p) for every propositional variable p,
and I(G) = W . Conversely, given a Ô¨Årst-order structure A = (A, I) for the ex-
I(G)
panded Ô¨Årst-order signature Œ¶, let A‚Ä¢ be the relativized cube model (Cn (A), V ),
where the valuation V is given by V (p) = I(P ).
For any relativized assignment model M, and any available assignment s, we
have
M, s  œÜ iff M‚Ä¢ |= œÜ‚Ä¢ [s].
(7.16)
This sufÔ¨Åces to prove Claim 1, because of the following. First suppose that the
modal formula œÜ is satisÔ¨Åable in some relativized cube model M, say at state s.
Since s is an available tuple, it follows from (7.16) that œÜ‚Ä¢ is satisÔ¨Åable in the Ô¨Årst-
order structure M‚Ä¢ under the assignment s; but also, since s is available we have
M‚Ä¢ |= Gv0 . . . vn‚àí1 [s]. This shows that œÜ‚Ä¢ ‚àß Gv0 . . . vn‚àí1 is satisÔ¨Åable.
Conversely, if the latter formula is satisÔ¨Åable, there is some Ô¨Årst-order structure
A for the language Œ¶+ , and some assignment s such that A |= œÜ‚Ä¢ ‚àßGv0 . . . vn‚àí1 [s].
It is not difÔ¨Åcult to see that (A‚Ä¢ )‚Ä¢ = A. Since A |= Gv0 . . . vn‚àí1 [s], it follows by
deÔ¨Ånition that s is an available assignment of A‚Ä¢ . But then we may apply (7.16)
which yields that A‚Ä¢ , s  œÜ; in particular, œÜ is satisÔ¨Åable in Rn . The proof of (7.16)
proceeds by a standard induction, which we leave to the reader.
Finally, we leave it to the reader to verify that the range of (¬∑)‚Ä¢ indeed falls entirely
inside the n-variable guarded fragment Fn . From Claim 1 and this observation the
theorem is immediate.7.5 Multi-Dimensional Modal Logic
467
Axiomatization
To Ô¨Ånish off the section we will sketch how to prove completeness for the class of
cube models. For simplicity we conÔ¨Åne ourselves to the similarity type of cylindric
modal logic ‚Äì but observe that this completeness result will immediately transfer
to the restricted n-variable fragment Lrn .
Multi-dimensional modal logic is an area with a very interesting completeness
theory. For instance, if one only admits the standard modal derivation rules (modus
ponens, necessitation and uniform substitution), then Ô¨Ånite axiomatizations are few
and far between. For instance, concerning the CMLn -theory of the class Cn , it
is known that if Œ£ is a set of CMLn -formulas axiomatizing Cn , then for each
natural number m, Œ£ contains inÔ¨Ånitely many formulas that contain all diamonds
3i , at least one diagonal constant ŒπŒ¥ij and at least m propositional variables . . . .
However, if we allow special derivation rules, in the style of Section 4.7, then a
nice Ô¨Ånite axiomatization can be obtained, as we will see now. A key role in our
axiomatization and in our proof will be played by a deÔ¨Åned operator Dn p which
acts as the difference operator on the class of cube frames, see Section 7.1. For its
deÔ¨Ånition we need some auxiliary operators:
= 3i (ŒπŒ¥ij ‚àß œÜ)
(i = j),
= 30 . . . 3i‚àí1 3i+1 . . . 3n‚àí1 œÜ,

n
Dn œÜ =
j =i ji 3i (¬¨ŒπŒ¥ij ‚àß Ei œÜ).
ij œÜ
Eni œÜ
The deÔ¨Ånition of Dn may look fairly complex, but it is directly based on the obser-
vation that two n-tuples s and t are distinct if and only for some coordinate i, si is
distinct from ti .
Proposition 7.47 Dn acts as the difference operator on the class of cubes.
Proof. Let M = (Cn (U ), V ) be a cube model. We will show that
M, s  Dn p iff M, t |= p for some t such that s = t.
(7.17)
For the sake of a clear exposition we assume that n = 3, so that we may write
s = (s0 , s1 , s2 ).
For the left to right direction of (7.17), suppose that M, s  Dn p. Without loss
of generality we may assume that s  10 30 (¬¨ŒπŒ¥01 ‚àß En0 p). By deÔ¨Ånition of 10
it follows that (s0 , s0 , s2 )  30 (¬¨ŒπŒ¥01 ‚àß En0 p). This in its turn implies that there is
some s0 such that (s0 , s0 , s2 )  ¬¨ŒπŒ¥01 and (s0 , s0 , s2 )  En0 p. It is easily seen that
the meaning of En0 is given by
M, u  Eni œà iff M, v |= œà for some v such that ui = vi ,
so (s0 , s0 , s2 )  En0 p means that there is some n-tuple t such that t  p and
s0 = t0 . But it follows from (s0 , s0 , s2 )  ¬¨ŒπŒ¥01 that s0 = s0 , so that we Ô¨Ånd that7 Extended Modal Logic
468
t0 = s0 . But then, indeed, t is distinct from s. We leave it to the reader to prove
the right to left direction of (7.17).
However, the connection between Dn and the class of cubes is far tighter than this
proposition suggests. In fact, the cubes are the only frames on which Dn acts as
the difference operator, at least, against the right background of the class HCFn of
hypercylindric frames.
DeÔ¨Ånition 7.48 A CMLn -frame is called hypercylindric if the following formulas
are valid on it:
(CM1 i )
(CM2 i )
(CM3 i )
(CM4 ij )
(CM5 i )
(CM6 ij )
(CM7 ijk )
(CM8 ij )
p ‚Üí 3i p,
p ‚Üí 2i 3i p,
3i 3i p ‚Üí 3i p,
3i 3j p ‚Üí 3j 3i p,
ŒπŒ¥ii ,
3i (ŒπŒ¥ij ‚àß p) ‚Üí 2i (ŒπŒ¥ij ‚Üí p)) (i = j),
ŒπŒ¥ij ‚Üî 3k (ŒπŒ¥ik ‚àß ŒπŒ¥kj ) (k ‚àà {i, j}),
(ŒπŒ¥ij ‚àß 3i (¬¨p ‚àß 3j p)) ‚Üí 3j (¬¨ŒπŒ¥ij ‚àß 3i p)
(i = j).
All these axioms are Sahlqvist formulas and thus express Ô¨Årst-order properties of
frames. Clearly, the axioms CM1 ‚Äì3 together say that each Ti is an equivalence
relation. CM6 ij then means that in every Ti -equivalence class there is at most one
element on the diagonal Eij (i = j). One can combine this fact with the (Ô¨Årst-
order translations of) CM5 j and CM7 jji to show that every Ti -equivalence class
contains exactly one representative on the Eij -diagonal. Apart from this effect, the
contribution of CM7 is rather technical. Finally, the meaning of CM4 and CM8
is best made clear by Figure 7.2, where the straight lines represent the antecedent
of the Ô¨Årst-order correspondents, and the dotted lines, the relations holding of the
‚Äòold‚Äô states and the ‚Äònew‚Äô ones given by the consequent.
q
z
Ti
Tj
q
y
q
u
q
q
x
Ti
q
Tj , =
Tj
Ti
z
q
u ‚àà Eij
Tj
Ti
q
y
x ‚àà Eij
Eij
Fig. 7.2. The meaning of CM4 ij (left) and CM8 ij (right)7.5 Multi-Dimensional Modal Logic
469
The key theorem in our completeness proof is the following.
Theorem 7.49 For any frame F in HCFn , Dn acts as the difference operator on F
iff F is a cube.
Proof. We have already proved the left to right direction of this equivalence in
Proposition 7.47. The proof of the other direction is technically rather involved
and falls outside the scope of this book.
In fact, with Theorem 7.49 we have all the material in our hands to prove the
desired completeness result.
DeÔ¨Ånition 7.50 Consider the following modal derivation system Œ©n . Its axioms
are (besides the ones of the minimal modal logic for the similarity type CMLn ),
the formulas CM1 ‚Äì8 ; as its derivation rules we take, besides the standard ones,
also the Dn -rule:
 (p ‚àß ¬¨Dn p) ‚Üí Œ∏
.
Œ∏
As usual, Œ©n will also denote the logic generated by this derivation system.
Theorem 7.51 Œ©n is sound and strongly complete with respect to the class Cn .
Proof. It follows immediately from Theorem 7.6 and Theorem 7.49 that we obtain
a complete axiomatization for Cn if we extend Œ©n with the Dn -versions of the
axioms symmetry, pseudo-transitivity and D-inclusion. However, as its turns out,
these axioms are valid on the class of hypercylindric frames, so they are already
derivable in Œ©n (even without the use of the Dn -rule). From this, the theorem is
immediate.
Exercises for Section 7.5
7.5.1 Let n and m be natural numbers such that n < m, and consider a CML n -formula œÜ.
First, observe that œÜ is also a CML m -formula. Prove that C n  œÜ iff Cm  œÜ. Conclude
that our deÔ¨Ånition of an MLR n -formula being Ô¨Årst-order valid, is unambiguous.
7.5.2 Prove that the formula 3 0 ¬∑ ¬∑ ¬∑ 3n‚àí1 p acts as the global modality on the class of
hypercylindric frames. That is, show that for any model M based on such a frame we have
that
M, s  30 ¬∑ ¬∑ ¬∑ 3n‚àí1 p iff M, t  p for some t in M.
Which of the axioms CM1 ‚ÄìCM8 are actually needed for this?
r
7.5.3 Let L‚àí
n denote the equality-free fragment of L n ; that is, all atomic formulas are of
the form P v0 . . . vn‚àí1 . In an obvious way we can deÔ¨Åne relativized assignment frames for
this language. Prove that the satisÔ¨Åability problem for L ‚àí
n in this class of frames can be
solved in PSPACE.470
7 Extended Modal Logic
7.5.4 Prove that every hypercylindric CML 2 -frame is the bounded morphic image of a
square frame (that is, a 2-cube). Use this fact to Ô¨Ånd a complete axiomatization for the
class C2 that only uses the standard modal derivation rules.
7.5.5 Let CFn be the class of cylindric frames, that is, those CML n -frames that satisfy the
axioms CM1 ‚ÄìCM7 . The class of n-dimensional cylindric algebras is deÔ¨Åned as CA n =
SPCmCFn . The classes HCFn and HCAn are deÔ¨Åned similarly, now using all axioms
CM1 ‚ÄìCM8 .
(a) Prove that CA n and HCAn are canonical, that is, closed under taking canonical
embedding algebras.
(b) Prove that CA n and HCAn are varieties.
7.5.6 A full n-dimensional cylindric set algebra is an algebra of the form
(P(U n ), ‚à™, ‚àí, ‚àÖ, Ci , Id ij )i,j<n .
Here the i-th cylindriÔ¨Åcation is deÔ¨Åned as the map C i : P(U n ) ‚Üí P(U n ) given by
Ci (X) = {s ‚àà U n | t ‚àà X for some t in X with s ‚â° i t }.
If we close the class of these algebras under products and subalgebras, we arrive at the
variety RCAn of representable n-dimensional cylindric algebras.
(a) Prove that every representable n-dimensional cylindric algebra is a boolean algebra
with operators.
(b) Prove that RCAn is contained in the classes CAn and HCAn of the previous exer-
cise.
(c) Prove that RCAn is canonical. (Hint: use Theorem 7.49 to show that the class C n
of n-dimensional cubes is Ô¨Årst-order deÔ¨Ånable in the frame language of CML n .)
7.6 A Lindstr√∂m Theorem for Modal Logic
Throughout this book we have seen many examples of modal languages, espe-
cially in the present chapter. To get a clear picture of the emerging spectrum, these
languages may be classiÔ¨Åed according to their expressive power or their semantic
properties. But what ‚Äì if any ‚Äì is the special status of the familiar modal languages
deÔ¨Åned in Chapter 1. If we focus on characteristic semantic properties, then clearly
their invariance under bisimulations must be a key feature. But what else is needed
to single out the (standard) modal languages?
The answer to this question is a modal analog of a classic result in Ô¨Årst-order
model theory: Lindstr√∂m‚Äôs Theorem. It states that, given a suitable explication
of what ‚Äòclassical logic‚Äô is, Ô¨Årst-order logic is the strongest logic to possess the
Compactness and L√∂wenheim-Skolem properties. To prove an analogous charac-
terization result for modal logic we need to agree on a number of things:
‚Ä¢ What will be the distinguishing property of the logic that we want to characterize
(on top of its invariance for bisimulations)? To answer this question we will
exploit the notion of degree introduced in DeÔ¨Ånition 2.28.7.6 A Lindstr√∂m Theorem for Modal Logic
471
‚Ä¢ What is a suitable notion of an abstract modal logic? To answer this question we
will introduce some bookkeeping properties from the formulation of the original
Lindstr√∂m Theorem for Ô¨Årst-order logic, and add a further property having to do
with invariance under bisimulations.
Our plan for this section is to discuss each of the above items, one after the other,
and to conclude with a Lindstr√∂m Theorem for modal logic.
Background material
Throughout this section models for modal languages are pointed models of the
form (M, w), where M is a relational structure and w is an element of M (its
distinguished point) at which evaluation takes place. Our main reasons for adopting
this convention are the following. First, the basic semantic unit in modal logic
simply is a structure together with a distinguished node at which evaluation takes
place. Second, some of the results below admit smoother formulations when we
adopt the local perspective of pointed models.
Bisimulations between pointed models (M, w) and (N, v) are required to link
the distinguished points w and v.
DeÔ¨Ånition 7.52 (In-degree) Let œÑ be a modal similarity type, and let M be a
œÑ -model. The in-degree of a state u in M is the number of times u occurs as a
non-Ô¨Årst argument in a relation: Rw . . . u . . .. More formally, it is deÔ¨Åned as
|{w
 ‚àà M<œâ | for some R and i > 1, u = wi and RMw1 . . . wi . . . wn ) }|,
where Mœâ is the collection of all Ô¨Ånite sequences of elements in M.
In addition to the in-degree of an element of a model, we will also need to use the
notion of height as deÔ¨Åned in DeÔ¨Ånition 2.32.
Below we will need models with nice properties, such as a low in-degree or Ô¨Ånite
height for each of its elements. To get such models, we use the notion of forcing.
Fix a similarity type œÑ . A property P of models is ‚ÜîœÑ -enforceable, or enforce-
able, iff for every pointed œÑ -model (M, w), there is a pointed œÑ -model (N, v) with
(M, w) ‚ÜîœÑ (N, v) and (N, v) has P. For example, the property ‚Äòevery element
has Ô¨Ånite height‚Äô is enforceable. To see this, let (M, w) be a pointed œÑ -model; we
may assume that M is generated by w. Let (N, w) be the submodel of M whose
domain consists of all elements of Ô¨Ånite height. Then (M, w) ‚ÜîœÑ (N, w).
Proposition 7.53 The following properties of models are enforceable:
(i) tree-likeness, and
(ii) the conjunction of ‚Äòhaving a root with in-degree 0‚Äô and ‚Äòevery element (ex-
cept the root) has in-degree at most 1‚Äô.472
7 Extended Modal Logic
Proof. Item (ii) follows from item (i). A proof of item (i) for similarity types
only involving diamonds is given in Proposition 2.15; for the general case, consult
Exercise 2.1.7.
We will characterize modal logic (in the sense of DeÔ¨Ånitions 1.12 and 1.23) by
showing that it is the only modal logic satisfying a modal counterpart of the original
Lindstr√∂m conditions: having a notion of Ô¨Ånite degree which gives a Ô¨Åxed upper
bound on the height of the elements that need to be considered to verify a formula;
recall DeÔ¨Ånition 2.28 for the deÔ¨Ånition.
To wrap up our discussion of background material needed for our Lindstr√∂m
Theorem, let us brieÔ¨Çy recall some basic facts related to degrees and height. Here
is the Ô¨Årst of these facts; recall that ((M, w) n, w) denotes the submodel of M
that is generated from w and that only has states of height at most n.
Proposition 7.54 Let œÜ be a modal formula with deg(œÜ) ‚â§ n. Then (M, w)  œÜ
iff ((M, w) n, w)  œÜ.
Next, recall from Proposition 2.29 that, up to logical equivalence, there are only
Ô¨Ånitely many non-equivalent modal formulas with a Ô¨Åxed Ô¨Ånite degree over a Ô¨Ånite
similarity type.
We say that (M, w) and (N, v) are n-equivalent if w and v satisfy the same
modal formulas of degree at most n.
Proposition 7.55 Let œÑ be a Ô¨Ånite similarity type. Let (M, w), (N, v) be two
rooted models such that the roots have in-degree 0, every element different from
the root has in-degree at most 1, and all nodes have height at most n.
If (M, w) and (N, v) are (n + 1)-equivalent, then (M, w) ‚Üî (N, v).
Proof. DeÔ¨Åne Z ‚äÜ A √ó B by xZy iff:
height(x) = height(y) = m and (M, x) and (N, y) are (n ‚àí m)-equivalent.
We claim that Z : (M, w) ‚Üî (N, v). To prove this, we only show the forth
condition. Assume xZy and RMxx1 . . . xk , where height(x) = height(y) = m.
Then n ‚àí m ‚â• 1. Let  be the modal operator whose semantics is based on R.
As œÑ is Ô¨Ånite, there are only Ô¨Ånitely many non-equivalent formulas of degree at
most n ‚àí m ‚àí 1. Let œài be the conjunction of all non-equivalent modal formu-
las of at most this degree that are satisÔ¨Åed at xi (1 ‚â§ i ‚â§ k). Then (M, x) 
(œà1 , . . . , œàk ), and (œà1 , . . . , œàk ) has degree n ‚àí m. Hence, as xZy, (N, y) 
(œà1 , . . . , œàk ). So there are y1 , . . . , yk in N such that RNyy1 . . . yk and (N, yi ) 
œài (1 ‚â§ i ‚â§ k).
Now, as all states have in-degree at most 1, height(xi ) = height(yi ) = m + 1,
and (M, xi ) and (N, yi ) (1 ‚â§ i ‚â§ k) are (n ‚àí (m + 1))-equivalent. Hence,
(M, xi ) ‚ÜîœÑ (N, yi ). This proves the forth condition.7.6 A Lindstr√∂m Theorem for Modal Logic
473
Abstract modal logic
The original Lindstr√∂m Theorem for Ô¨Årst-order logic starts from a deÔ¨Ånition of an
abstract classical logic as a pair (L, |=L ) consisting of a set of formulas L and a
satisfaction relation |=L between L-structures and L-formulas that satisÔ¨Åes three
bookkeeping conditions, an Isomorphism property, and a Relativization property
which allows one to consider deÔ¨Ånable submodels. Then, an abstract logic extend-
ing Ô¨Årst-order logic coincides with Ô¨Årst-order logic if and only if it satisÔ¨Åes the
Compactness and L√∂wenheim-Skolem properties. We will now set up our modal
analog of Lindstr√∂m‚Äôs Theorem along similar lines.
The deÔ¨Ånition runs along the same lines as the deÔ¨Ånition of an abstract classical
logic. An abstract modal logic is characterized by three properties: two bookkeep-
ing properties, and a Bisimilarity property to replace the Isomorphism property.
DeÔ¨Ånition 7.56 (Abstract Modal Logic) By an abstract modal logic we mean
a pair (L, L ) with the following properties (here L is the set of formulas, and
L is its satisfaction relation, that is, a relation between (pointed) models and L-
formulas):
(i) Occurrence property. For each œÜ in L there is an associated Ô¨Ånite language
L(œÑœÜ ). The relation (M, w) L œÜ is a relation between L-formulas œÜ and struc-
tures (M, w) for languages L containing L(œÑœÜ ). That is, if œÜ is in L, and M is
an L-model, then the statement (M, w) L œÜ is either true or false if L contains
L(œÑœÜ ), and undeÔ¨Åned otherwise.
(ii) Expansion property. The relation (M, w) L œÜ depends only on the reduct of
M to L(œÑœÜ ). That is, if (M, w) L œÜ and (N, w) is an expansion of (M, w) to a
larger language, then (N, v) L œÜ.
(iii) Bisimilarity property. The relation (M, w) L œÜ is preserved under bisimu-
lations: if (M, w) ‚ÜîœÑ (N, v) and (M, w) L œÜ, then (N, v) L œÜ.
If we compare the above deÔ¨Ånition to the list of properties deÔ¨Åning an abstract
classical logic, we see that it is the Bisimilarity property that determines the modal
character of an abstract modal logic.
Obviously, ordinary modal formulas provide an example of an abstract modal
logic, but so does propositional dynamic logic. In contrast, the language of basic
temporal logic provides an example of a logic that is not an abstract modal logic,
as formulas from basic temporal logic are not preserved under bisimulations.
Next, we need to say what we mean by ‚Äò(L, L ) extends basic modal logic‚Äô and
by closure under negation.7 Extended Modal Logic
474
DeÔ¨Ånition 7.57 We say that (L, L ) extends modal logic if for every basic modal
formula there exists an equivalent L-formula, that is, if for each basic modal for-
mula œÜ there exists an L-formula œà such that for any model (M, w) we have
(M, w)  œÜ iff (M, w) L œà.
Also, (L, L ) is closed under negation if for all L-formulas œÜ there exists an
L-formula ¬¨œÜ such that for all models (M, w), (M, w)  œÜ iff (M, w)  ¬¨œÜ.
Of course, propositional dynamic logic is an example of an abstract modal logic
that extends (basic) modal logic.
Logics in the sense of DeÔ¨Ånition 7.56 deal with the same class of pointed mod-
els as (basic) modal logic, and only the formulas and satisfaction relation may be
different. This implies, for example, that intuitionistic logic or the hybrid logics
considered in Section 7.3 are not abstract modal logics: their models need to sat-
isfy special constraints. The original Lindstr√∂m characterization of Ô¨Årst-order logic
suffers from similar limitations (by not allowing œâ-logic as a logic, for example).
As a Ô¨Ånal step in our preparations, we need to say what the notion of degree
means in the setting of an abstract modal logic.
DeÔ¨Ånition 7.58 (Notion of Finite Degree) An abstract modal logic has a notion
of Ô¨Ånite degree if there is a function degL : L ‚Üí œâ such that for all (M, w), all œÜ
in L,
(M, w) L œÜ iff
((M, w) degL (œÜ)), w L œÜ.
If L extends (basic) modal logic, we assume that degL behaves regularly with
respect to standard modal operators and proposition letters. That is, if  is a modal
operator (see DeÔ¨Ånition 1.12), then degL (p) = 0 and degL ((œÜ1 , . . . , œÜn )) =
1 + max{degL (œÜi ) | 1 ‚â§ i ‚â§ n}.
Finally, two models (M, w) and (N, v) for the same language are L-equivalent
if for every œÜ in L, (M, w)  œÜ iff (N, v)  œÜ.
Having a Ô¨Ånite degree is a very restrictive property, which is not implied by the
Ô¨Ånite model property (f.m.p.). To see this, recall that propositional dynamic logic
has the f.m.p.: it has the property that every satisÔ¨Åable formula œÜ is satisÔ¨Åable on a
model of size at most |œÜ|3 , where œÜ is the length of œÜ. However, it does not have a
notion of Ô¨Ånite degree. To see this, consider the model (œâ, Ra , V ), where Ra is the
successor relation and V is an arbitrary valuation, and let œÜ = [a‚àó ]a; clearly
(œâ, Ra , V ), 0  œÜ. But for no n ‚àà œâ does the restriction (œâ, Ra , V ) n satisfy œÜ
at 0. It follows that PDL does not have a notion of Ô¨Ånite degree.
Characterizing modal logic
We are almost ready now to prove our characterization result. The following lemma
is instrumental.7.6 A Lindstr√∂m Theorem for Modal Logic
475
Lemma 7.59 Let (L, L ) be an abstract modal logic which is closed under nega-
tion. Assume L has a notion of Ô¨Ånite degree degL . Let œÜ be an L-formula with
degL (œÜ) = n. Then, for any two models (M, w), (N, v) such that (M, w) and
(N, v) are n-equivalent, we have that (M, w) L œÜ implies (N, v) L œÜ.
Proof. Assume that the conclusion of the lemma does not hold. Let (M, w), (N, v)
be such that (M, w) and (N, v) are n-equivalent, but (M, w) L œÜ and (N, v) L
¬¨œÜ.
By the Occurrence and Expansion properties we may assume that L = L(œÑœÜ ),
where L(œÑœÜ ) is the Ô¨Ånite language in which œÜ lives.
By Proposition 7.53 we can assume that (M, w) and (N, v) are rooted such that
the roots have in-degree 0, while all other nodes have in-degree at most 1. Then
((M, w) n, w) and ((N, v) n, v) are n-equivalent, and ((M, w) n, w) L œÜ
but ((N, v) n, v) L ¬¨œÜ. In addition ((M, w) n, w) and ((N, v) n, v)
both have in-degree 1 and roots of in-degree 0. By Proposition 7.55 it follows that
((M, w) n, w) and ((N, v) n, v) are bisimilar ‚Äì but now we have a contra-
diction with the Bisimilarity property as ((M, w) n, w) and ((N, v) n, v) are
bisimilar but do not agree on œÜ.
Theorem 7.60 Let (L, L ) extend modal logic. If (L, L ) has a notion of Ô¨Ånite
degree, then it is equivalent to the modal language as deÔ¨Åned in DeÔ¨Ånition 1.12.
Proof. We must show that every L-formula œÜ is L-equivalent to a basic modal
formula œà, that is, for all (M, w), (M, w) L œÜ iff (M, w) L œà. As before,
by the Occurrence and Expansion properties we may restrict ourselves to a Ô¨Ånite
language. Moreover, œÜ has a basic modal equivalent iff it has such an equivalent
with the same degree; so we have to locate the equivalent we are after among the
basic modal formulas whose degree equals the L-degree of œÜ.
Assume n = degL (œÜ). By Proposition 2.29 there are only Ô¨Ånitely many (non-
equivalent) basic modal formulas whose degree equals n; assume that they are all
contained in Œìn . It sufÔ¨Åces to show the following:
if (M, w) and (N, v) agree on all formulas in Œìn , then they agree on œÜ.
(7.18)
For then, œÜ will be equivalent to a boolean combination of formulas in Œìn . To see
this, reason as follows. The relation ‚ÄòsatisÔ¨Åes the same formulas in Œìn ‚Äô is an equiv-
alence relation on the class of all models; as Œìn is Ô¨Ånite, there can only be Ô¨Ånitely
many equivalence classes. Choose representatives (M1 , w1 ), . . . , (Mm , wm ), and
for each i, with 1 ‚â§ i ‚â§ m, let œài be the conjunction of all formulas in Œìn that are

satisÔ¨Åed by (Mi , wi ). Then œÜ is equivalent to {œài | (Mi , wi ) L œÜ}.
Now to conclude the proof of the theorem we need only observe that condition
(7.18) is exactly the content of Lemma 7.59.476
7 Extended Modal Logic
To conclude this section a few remarks are in order. First, the property of having a
notion of Ô¨Ånite degree can be characterized algebraically in terms of preservation
under ultraproducts over the natural numbers; Theorem 7.60 can then be reformu-
lated accordingly.
Second, in the proof of the Lindstr√∂m Theorem the basic modal formula œà that is
found as the equivalent of the abstract modal formula œÜ is in the same vocabulary
as œÜ. This means, for example, that the only abstract modal logic over a binary
relation that has a notion of Ô¨Ånite degree is the standard modal logic with a single
modal operator 3.
Here, we have only covered the modal logics as deÔ¨Åned in DeÔ¨Ånition 1.12; in
some cases extensions beyond this pattern can easily be obtained. As a Ô¨Årst exam-
ple, consider the basic temporal language with operators F and P , where x  F p
(x  P p) iff for some y, Rxy and y  œÜ (Ryx and y  œÜ). Consider temporal
bisimulations in which one not only looks forward along the binary relation, but
also backward, and adopt the notion of height accordingly. Given the obvious def-
inition of an abstract temporal logic, standard temporal logic is the only temporal
logic over a single binary relation that has a notion of Ô¨Ånite degree.
7.7 Summary of Chapter 7
 Logical Modalities: Logical modalities receive a Ô¨Åxed interpretation in every
model. Simple examples are the past tense operator P , the global diamond E,
and the difference operator D. As well as enhancing expressivity, some of them
(notably P and D) make it possible to prove general completeness theorems
using additional rules of proof.
 Algebra of Diamonds: Some modal languages offer not just a single logical
modality but an entire algebra of diamonds. Good examples are PDL and BML.
 Since and Until: The since and until operators are interesting in applied logic
because they enable us to specify guarantee properties. They are mathematically
interesting because they are expressively complete over Dedekind complete to-
tal orders.
 Completeness-via-Completeness: While deductive completeness of since/until
logic can be proved using standard modal techniques, for Dedekind complete
total order there is an interesting alternative: taking a detour via expressive
completeness.
 Hybrid Logic: The basic hybrid language lets us refer to states using nominals,
atomic symbols true at exactly one state in every model. Some stronger hybrid
languages allow us to bind nominals.
 Hybrid Proof Theory: We can deÔ¨Åne a rule of proof called PASTE in the basic
hybrid language. This rule is essentially a sequent rule lightly disguised. WithNotes to Chapter 7
477
its help, a frame completeness result covering all pure formulas can be proved
fairly straightforwardly.
 Guarded Fragment: As the standard translation shows, modalities are essen-
tially macros which permit restricted forms of quantiÔ¨Åcation. Abstracting from
this insight leads to the guarded fragment, a decidable fragment of Ô¨Årst-order
logic with the Ô¨Ånal model property.
 Packed Fragment: By taking this observation even further, and noting that the
mosaic method sufÔ¨Åces to prove decidability, it is possible to isolate an even
larger decidable fragment of Ô¨Årst-order logic: the packed fragment. This frag-
ment also has the Ô¨Ånite model property.
 Multi-Dimensional Modal Logic: Multi-dimensional modal logic is essentially
modal logic in which evaluation is performed at a sequence of states, rather than
at a single state. By viewing variable assignments as sequences of states, it is
possible to view Ô¨Årst-order logic itself as a multi-dimensional modal logic.
 Lindstr√∂m‚Äôs Theorem: Given a suitable (bisimulation centered) explication of
what an abstract modal logic is, our Lindstr√∂m Theorem for modal logic says
that the general modal languages deÔ¨Åned in DeÔ¨Ånition 1.12 are the strongest
ones to have a notion of Ô¨Ånite degree.
 Extended Modal Logic: In many ways, this chapter is badly named. Among
other things, we have just seen that not only is it possible to introduce global-
ity, more complex quantiÔ¨Åer alternations in satisfaction deÔ¨Ånitions, names for
states, and evaluation at sequences of states, but we can do so without losing
the properties that made modal logic attractive in the Ô¨Årst place. So forget the
‚Äòextended‚Äô. As we said in the Preface: it is all just modal logic!
Notes
A really serious guide to extended modal logic would have to cover the (vast)
literature on temporal logics, Ô¨Åxed point logics, and variants of PDL discussed in
the theoretical computer science literature, plus formalisms such as feature and
description logic, and much else besides. We do not have space to do all that, and
the following Notes stick to the six topics discussed in the text. Nonetheless, with
the help of the following remarks (coupled with a little judicious reference chasing)
the reader should be able to form a coherent map of territory.
Logical Modalities. It is hard to precise about when the idea of adding Ô¨Åxed in-
terpretation operators to modal languages came to be seen as standard. Certainly
the writings of Johan van Benthem (for example, his book on temporal logic, his
‚Äòmanual‚Äô on intensional logic, and his inÔ¨Çuential survey of correspondence theory)
played an important role. So did the new applications of modal logic, particularly
in computer science (once you have seen PDL it is hard to believe that the basic478
7 Extended Modal Logic
modal language is the be-all and end-all of modal logic). At any rate, by the end
of the 1980s the idea that modal languages are abstract tools for talking about re-
lational structures ‚Äì tools that it was not only legitimate, but actually interesting
to extend ‚Äì was well established in both Amsterdam and Bulgaria. Nowadays this
view is taken for granted by many (perhaps most) modal logicians, and given this
perspective the use of logical modalities is as natural as breathing.
Of course, many of the operators we now call ‚Äòlogical‚Äô have been around a lot
longer than that. In a way, the global modality has always been there (after all its
just a plain old S5 operator). But when did it Ô¨Årst emerge as an additional operator?
We are not sure. Prior used it on a number of occasions (see, for example, [365,
Appendix B4]), though sometimes Prior‚Äôs global modality is actually the master
modality [‚àó] discussed in Section 6.5 (that is, sometimes Prior views globality as
the reÔ¨Çexive transitive closure of the underlying relation).
But it seems fair to say that it was the Bulgarian-school who Ô¨Årst exploited it
systematically: it is the Swiss Army knife underlying their investigation of BML,
and their work on hybrid logic. Goranko and Passy [192] is a systematic study of
the global modality as an additional operator, and is the source of Theorem 7.1, the
Goldblatt-Thomason theorem for ML(3, E). The operator has also been studied
from an algebraic angle, being closely connected to the notion of a discriminator
variety; these classes display nice algebraic behavior and have been intensively
investigated in universal algebra. For, in the context of boolean algebra with oper-
ators, having the global modality is equivalent to having a so-called discriminator
term; this is why in algebraic circles this modality is sometimes dubbed a ‚Äòunary
discriminator term‚Äô; see Jipsen [247] for some information. The basic complexity
results for the global modality were proved in Spaan‚Äôs thesis [419]. Incidentally,
the global modality is usually referred to as the ‚Äòuniversal‚Äô modality in the litera-
ture. However the word ‚Äòuniversal‚Äô suggests that we are working with a box, so we
prefer the term ‚Äòglobal‚Äô, which is appropriate for both boxes and diamonds.
The history of the difference operator is harder to untangle. It is probably due
to von Wright [465] (who viewed it as a ‚Äòlogic of elsewhere‚Äô) and Segerberg gave
an axiomatization in a festschrift for von Wright (see [406]). Segerberg‚Äôs axiom-
atization, together with a more detailed completeness proof, was later published
in [408]. But Segerberg treats D as an isolated modality. The use of D as an ad-
ditional modality seems to have been proposed independently by Koymans [271]
and Sain [397]. The difference operator is also discussed in Goranko [189]. For a
systematic investigation of D as an additional, logical modality, see de Rijke [378].
The D-Sahlqvist theorem in the text is due to Venema [444]. Theorem 7.8 is an
unpublished result due to Szabolcs Mikul√°s.
B ML is a Bulgarian school invention. The system is Ô¨Årst described in Gargov,
Passy and Tinchev [166] (as part of a wide ranging discussion of extended modal
logic) and Gargov and Passy [165] concentrates on BML and gives proofs of the keyNotes to Chapter 7
479
completeness and decidability results. See also the results on modal deÔ¨Ånability in
Goranko [189]. All these papers view modal languages as general tools for talking
about structures, very much in the spirit of the present book. The window operator
has an interesting independent history: van Benthem [38] used it as part of a logic
of permissions and obligations, Goldblatt [176] used it to deÔ¨Åne negation in quan-
tum logic, Humberstone [236] used it in a discussion of inaccessible worlds, while
Gargov, Passy and Tinchev [166] view it as a ‚Äòlogic of sufÔ¨Åciency‚Äô that balances
the usual ‚Äòlogic of necessity‚Äô provided by 2. Complexity-theoretic aspects of BML
have been studied and surveyed by Lutz and Sattler [303], while resolution-based
decision procedures for extensions of BML and related languages are explored by
Hustadt and Schmidt [238].
As we pointed out in the text, both BML and PDL are examples of modal lan-
guages equipped with highly structured collections of modal operators. The dy-
namic modal logic of de Rijke [384] is a further example, and many description
logics allow for the construction of complex roles (that is, accessibility relations)
by means of some or all of the booleans, converse, and sometimes even transitive
closure and least Ô¨Åxed point constructors; see Donini et al. [115].
The algebraic counterparts of modal languages with structured collections of
modal operators can best be phrased in terms of multi-sorted algebras, where the
(algebraic counterparts of the) modal operators provide the links between the sorts.
Kleene algebras [272] and Peirce algebras [382, 385] are two important examples.
The former provide an algebraic semantics for PDL and consist of a boolean algebra
and a regular algebra together with systematic links between them that are used
to interpret the diamonds. The latter provide an algebraic semantics of dynamic
modal logic and consist of a boolean and a relation algebra together with various
links between them to interpret the modalities in the language.
Since and Until. The invention of since/until logic was a major breakthrough in
the study of modal logic. Hans Kamp tells the story this way. In a semester-long
course Arthur Prior gave on tense logic at UCLA in the fall of 1965, when Kamp
had just started his PhD, Prior stressed that the P and F operators were strictly
topological, and asked whether it was possible to develop some notion of met-
ric time within the framework of tense logic. Now, a Ô¨Årst requirement on such
an enterprise is that it can express what it is for some proposition q to have been
true since the last time some periodically true proposition p was true. Trying to
Ô¨Ånd a genuinely topological tense logic in which these kinds of relations could be
expressed lead Kamp to the deÔ¨Ånitions of since and until. As the technical inter-
est of the new operators became clear, the original motivation seems to have been
shelved (Kamp, personal communication, remarks that ‚ÄòThe question of how to
embed a logic of metric temporal notions within a topological tense logic unfortu-
nately never got properly off the ground.‚Äô). Kamp Ô¨Årst showed that P and F cannot480
7 Extended Modal Logic
express since and until, and eventually succeeded in proving Theorem 7.12(i), the
expressive completeness of the since and until operators over Dedekind complete
total orders (see his thesis [258]). At that time, deductive completeness was the
dominant interest in modal logic. Kamp‚Äôs result showed that the neglected topic of
modal expressivity deserved further attention, and can be regarded as a precursor
to the study of correspondence theory that emerged in the 1970s.
The next step was taken by Dov Gabbay. Kamp‚Äôs result was clearly important,
but his direct proof was complex, and although Jonathan Stavi [422] succeeded in
providing a direct proof of Theorem 7.12(ii), it was not obvious how to proceed.
Matters were greatly simpliÔ¨Åed when Gabbay introduced the notion of separability
(see [148, 150]). Roughly speaking, a language is separable over a class of models
if every formula is equivalent to a boolean combination of atomic formulas, formu-
las that only talk about the past, and formulas that only talk about the future. This
idea drastically simpliÔ¨Åes the proofs of Theorem 7.12(i) and Theorem 7.12(ii), and
opens the way to more general investigations. Nowadays a variety of techniques are
used for proving expressive completeness results for modal (and other) languages;
game-based approaches (see Immerman and Kozen [240]) have proved particularly
useful. The best introduction to expressive completeness is the encyclopedic Gab-
bay, Hodkinson, and Reynolds [156]; both separability and game-based proofs are
discussed, as well as many other results on since/until logic.
But what really made the until operator so popular is the simple observation
made in the text: it offers precisely what is needed to express guarantee properties
(this was Ô¨Årst noted in Gabbay, Pnueli, Shelah, and Stavi [160]). Nowadays, until
may well be the single best known modal operator (at least in computer science)
and it occurs both in its original form, and in a number of variant forms in the
study of linear and branching time temporal logics (see Clarke and Emerson [94],
Goldblatt [177]).
Good discussions of step-by-step completeness proofs for since and until can
be found in Burgess [78] and Xu [466]. The classiÔ¨Åcation of properties of Ô¨Çows
of time (in terms of safety, liveness, and guarantees) referred to in Section 7.2
can be found in Manna and Pnueli‚Äôs textbook [312] on using temporal logic for
specifying concurrent and reactive systems. Theorem 7.19 is due to Venema [443];
the strategy of using expressive completeness to obtain axiomatic completeness
results goes back at least to Gabbay and Hodkinson [155].
One Ô¨Ånal remark: in spite of the fact that its satisfaction deÔ¨Ånition makes use of a
more complex patterns of quantiÔ¨Åcation, the since and until operators are genuinely
modal. In particular, the notion of bisimulation can be adapted to these operators:
the only complication is that, instead of the simple ‚Äòcomplete the square‚Äô idea il-
lustrated in Figure 2.3 (65), bisimulations now need to match relational steps plus
intermediate intervals in suitable ways. Kurtonina and de Rijke [288] contain a
solution to this issue as well as a survey of earlier proposals.Notes to Chapter 7
481
Hybrid Logic. Arthur Prior introduced and made systematic use of hybrid logic;
see Prior [365] (in particular, Chapter 5 and Appendix B.3), several of the papers
in Prior [366], and the posthumously published Prior and Fine [367]. Prior‚Äôs sys-
tems typically allowed explicit quantiÔ¨Åcation over states using ‚àÄ and ‚àÉ, and con-
tained the global modality. Technical aspects of such languages were explored in
Bull [73], an important paper, which among other things notes that pure formulas
give rise to easy frame completeness results. In the mid 1980s Passy and Tinchev
independently reinvented the idea of ‚Äònames as formulas‚Äô. Their earliest paper
[356] added nominals and the global modality to a rich version of PDL; in [357]
they considered ‚àÄ and ‚àÉ (again in the setting of PDL); and [358], their beautiful
essay on hybrid languages, remains one of the key papers on hybrid logic.
The subsequent history of hybrid logic revolves around attempts to Ô¨Ånd well-
behaved sublanguages of such strong systems. The most obvious way to do this is
the one explored in the text: treat nominals as names, rather than variables open
to binding, and keep the underlying modal language relatively weak. Early papers
which explore this option include Gargov and Goranko [164] (the basic modal
language enriched with nominals and the global modality) and Blackburn [54] (the
basic tense language enriched with nominals alone). The basic hybrid language
discussed in the text can be viewed as an interesting compromise between simply
adding nominals to the basic modal language (which makes the axiomatics messier,
as Exercise 7.3.7 shows) and adding both nominals and the global modality (which
raises the complexity to EXPTIME-complete). A proof of Theorem 7.21 (that the
basic hybrid language has a PSPACE-complete satisÔ¨Åability problem) can be found
in Areces, Blackburn and Marx [14]. For a more detailed look at the complexity
of hybrid logic, see [13] by the same authors. Theorem 7.29 is a modiÔ¨Åcation of
results proved in Blackburn and Tzakova [63]. It simpliÔ¨Åes a similar result proved
in Gargov and Goranko [164] with the aid of the global modality.
But the idea of binding variables to states turns out to be important. Binding
admits a rich expressivity hierarchy. For a start, even if binding with ‚àÄ and ‚àÉ
is allowed, when there are no satisfaction operators in the language, the result-
ing language does not have full Ô¨Årst-order expressivity; see Blackburn and Selig-
man [59]. Moreover, as we mentioned in the text, the ‚Üì binder simply binds vari-
ables to the current state; in effect, it lets us create a name for the here-and-now (see
Goranko [190], Blackburn and Seligman [59, 60], Blackburn and Tzakova [63]). If
we enrich the basic hybrid language with the ‚Üì binder we obtain a hybrid language
which corresponds to precisely the fragment of the Ô¨Årst-order correspondence lan-
guage which is invariant under generated submodels. This is proved in Areces,
Blackburn and Marx [14] by isolating notions of bisimulation suitable for various
hybrid languages and proving a characterization theorem. The paper also links
these notions of bisimulation to restricted forms of Ehrenfeucht-Fraƒ±Ãàss√© games.
Hybrid logic provides a natural setting for modal proof theory. Seligman [411]482
7 Extended Modal Logic
is the pioneering paper here, and Seligman [412] discusses satisfaction operator
based natural deduction and sequent systems. Blackburn [56] deÔ¨Ånes satisfaction
operator driven tableaux and sequent systems and uses Hintikka sets to prove an
analog of Theorem 7.29. Tzakova [439] combines the use of nominals with the
preÔ¨Åx systems of Fitting [137]. Demri [107] deÔ¨Ånes a sequent calculus for the
basic tense language enriched with nominals, and Demri and Gor√© [108] introduce
a display calculus for the basic tense language enriched with nominals and D.
Hybrid logics turn up naturally in a number of applications. The AVMs used
in computational linguistics (recall Example 1.17) can be viewed as modal log-
ics: path re-entrancy tags are treated as nominals (see, for example, Blackburn and
Spaan [61]). And while it has long been known that description logics are nota-
tional variants of modal logics, this relation only holds at the level of concepts.
So-called A-Box (or assertional) reasoning ‚Äì that is, reasoning about how concepts
apply to particular individuals ‚Äì corresponds to a restricted use of satisfaction op-
erators, while the ‚Äòone-of‚Äô operators used in some versions of description logic
are essentially disjunctions of nominals; see Blackburn and Tzakova [62], Are-
ces and de Rijke [15], and Areces‚Äôs PhD thesis [12]. Nominals also turn up in
the Polish tradition of modal logics for information systems and rough-set theory:
see Konikowska [269, 270]. They also provide a natural model of tense and other
forms of temporal reference in natural language (see Blackburn [55]).
A Ô¨Ånal remark. The basic hybrid language shows that sorting is interesting
in the setting of modal logic ‚Äì so why not introduce further sorts? In fact, this
step was already taken in Bull [73] who introduced a third sort of atomic sym-
bol: path nominals, true at precisely the points belonging to some path through the
model. For more information on hybrid logic, see the Hybrid Logic home page at
www.hylo.net. For a recent ‚Äòmanifesto‚Äô on hybrid logic that touches on most
of the themes just mentioned, see Blackburn [57].
The Guarded Fragment. The guarded fragment was introduced by Andr√©ka, van
Benthem and N√©meti in 1994. The roots of the decidability proof date back to
1986, when N√©meti [340] showed that the equational theory of the class of so-
called relativized cylindric set algebras is decidable. The Ô¨Årst-order counterpart of
this result is that a certain subfragment of the guarded fragment is decidable.
The importance of this result for Ô¨Årst-order logic was realized in 1994 when
Andr√©ka, van Benthem and N√©meti introduced the guarded fragment and showed
that many nice properties of the basic modal system K generalize to it. In par-
ticular, the authors established a characterization in terms of guarded bisimula-
tions, decidability and a kind of tree model property. The journal version of their
paper is [9]. Some time later van Benthem was able to generalize some of the
results, introducing the loosely guarded fragment in [49]. The slightly more gen-
eral packed fragment was introduced in Marx [317] in order to give a semanticNotes to Chapter 7
483
characterization in terms of packed bisimulations. (An example of a packed sen-
tence which is not equivalent to a loosely guarded sentence in the same signature
is ‚àÉxyz (‚àÉwCxyw ‚àß ‚àÉw Cxzw ‚àß ‚àÉw Czyw ‚àß ¬¨Cxyz).)
The mosaic based decision algorithms of Andr√©ka, van Benthem and N√©meti
were essentially optimal: a result established by Gr√§del [194]. In this paper, Gr√§del
also deÔ¨Ånes and establishes the loose model property for the loosely guarded frag-
ment. Our deÔ¨Ånition of a loose model is based on the deÔ¨Ånition of a tree model
given there. Gr√§del and Walukiewicz [197] showed that the same bounds obtain
when the guarded fragment is expanded with least and greatest Ô¨Åxed point oper-
ators. Marx, Mikul√°s and Schlobach [319] deÔ¨Åned a PSPACE-complete guarded
fragment (both locality principles) with the Ô¨Ånite tree model property.
The Ô¨Ånite model property for the guarded fragment, and several subfragments of
the packed fragment, was established in an algebraic setting by Andr√©ka, Hodkin-
son and N√©meti [7]. Gr√§del [194] provides a direct proof for the guarded fragment.
The remaining open question for the full packed fragment was solved afÔ¨Årmatively
by Hodkinson [231]. All these results are based on variants of a result due to Her-
wig [222]. The use of Herwig‚Äôs Theorem to establish the Ô¨Ånite model property and
to eliminate the need for step-by-step constructions is due to Hirsch et al. [227].
Multi-Dimensional Modal Logic. The idea of evaluating modal languages at se-
quences of points, rather than at the points simpliciter, is extremely natural, so it
is no surprise that over the years modal logicians with very diverse interests have
devised multi-dimensional systems.
It seems that logicians interested in natural language were Ô¨Årst off the mark.
Natural language utterances are so context dependent, that evaluating at sequences
of points (each coordinate modelling a different aspect of context) proved a useful
idea. Evaluation at pairs of points is built into Montague‚Äôs [336] general framework
for natural language semantics. Kamp‚Äôs [259] classic analysis of the word ‚Äònow‚Äô
uses a second coordinate to keep track of utterance time. Vlach [452] provided an
analysis of the word ‚Äòthen‚Äô, and in a series of papers, √Öqvist and co-workers [11]
developed rich multi-dimensional modal logics for analyzing temporal phenomena
in natural language. Before long, such systems were subjected to rigorous logical
investigation: see, for example, Segerberg‚Äôs elegant decidability and completeness
result in [405], and Gabbay‚Äôs work on expressiveness and other topics (much of
which reappeared in later work by Gabbay, Hodkinson and Reynolds [156]).
Somewhat later, a rich source of inspiration came from logic itself. Some work
here, such as the sorted modal logic PREDBOX of Kuhn [286], Ô¨Åtted in the tradition
of Quine-style Ô¨Årst-order logic without variables, but most of it was linked, one
way or another, with the algebraic logic framework of the Tarskian school (see the
Notes of Chapter 5). This certainly applies to the multi-dimensional logics that we
presented in Section 7.5. Venema [445], from which our Theorem 7.51 originates,484
7 Extended Modal Logic
made the connection between modal logic and cylindric algebras. Subsequent re-
search drew on existing ideas on relativized cylindric algebras (see N√©meti [340])
to use the modal framework to ‚Äòtame‚Äô Ô¨Årst-order logic and its Ô¨Ånite variable frag-
ments (see our discussion of the abstract and relativized assignment frames in
the text; more information on this program can be found in van Benthem [48]
or Mikul√°s [329]). This line of work is closely related to arrow logic, which is
a multi-dimensional modal logic in its own right (see Marx et al. [318] for more
information) and in fact this strand of work ultimately lead to the isolation of the
guarded fragment. All of these (and more) multi-dimensional modal logics are cov-
ered in the monograph Marx and Venema [320]; readers interested in complexity
results should consult Marx [316].
Computer scientists have different motivations for studying multi-dimensional
modal logics. In order to build formal models of an application domain, they need
to take account of various features simultaneously. Of the wealth of literature on
this topic we will just mention Fagin et al. [125], which concentrates on the com-
bination of temporal and epistemic logics in the context of distributed systems.
Such applications have led logicians to study various ways of constructing complex
logics from relatively simple ones. A particularly interesting and mathematically
non-trivial branch of multi-dimensional modal logics arises if one studies a modal
language with various modal operators over a semantics in which the frames are
cartesian products of frames for the individual operators. This area of so-called
product logics, which has an early predecessor in Shehtman [413], has recently
become very active; a monograph Gabbay et al. [159] is on its way.
Finally, multi-dimensional modal logic remains one of the most philosophically
important branches of modal logic. Important references include Kaplan [264,
265], Stalnaker [421], and Chalmers [90].
The Lindstr√∂m Theorem for Modal Logic. Theorem 7.60, a Lindstr√∂m-type
characterization of the modal languages deÔ¨Åned in DeÔ¨Ånitions 1.9 and 1.12 is due
to de Rijke [381]; the result was obtained as part of a general program to come up
with modal counterparts of model-theoretic results in Ô¨Årst-order logic [380]. The
original Ô¨Årst-order version of Lindstr√∂m‚Äôs Theorem was Ô¨Årst presented in Lind-
str√∂m [302]. The original result states that, given a suitable explication of a ‚Äòclas-
sical logic‚Äô, Ô¨Årst-order logic is the strongest logic to possess the Compactness and
L√∂wenheim-Skolem properties; it formed an important source of inspiration for
the area of model-theoretic logics [26]. DeÔ¨Ånitions of the abstract notion of a logic
can be found in Chang and Keisler [91] and in Barwise [25]. A very accessible pre-
sentation of Lindstr√∂m‚Äôs Theorem for Ô¨Årst-order logic can be found in Doets [111,
Chapter 4].Appendix A
A Logical Toolkit
In this appendix we review basic Ô¨Årst-order logic, deÔ¨Åne some model-theoretic
concepts, introduce the ultraproduct construction, and brieÔ¨Çy discuss second-order
and inÔ¨Ånitary logic. But it is not a self-contained introduction to Ô¨Årst-order (or any
other) logic: we assume the reader has had some prior exposure to formal logic and
is comfortable with the basic ideas. If a signiÔ¨Åcant portion of what follows is un-
familiar, you should consult an introduction to mathematical logic (Enderton [122]
and Hodges [228] are good choices).
There are many sources for further information about model theory: Doets [111]
is an approachable introductory text, Hodges [229] gives an encyclopedic view of
the Ô¨Åeld, and Bell and Slomson [33] is a detailed guide to the ultraproduct construc-
tion. But the single most important source is probably Chang and Keisler [91]; our
presentation of ultraproducts is largely based on theirs. For second-order logic, see
Doets and van Benthem [112], Chapter 4 of Enderton [122], and Fitting [139]. For
inÔ¨Ånitary logic, see Keisler [267].
Languages, Models, and Satisfaction
A language of Ô¨Årst-order logic is built from terms and formulas. Terms t are built
from variables x, constants c, and function symbols f as follows:
t ::= x | c | f (t1 , . . . , tn ).
The atomic formulas Œ≤ are expressions of the form:
Œ≤ ::= t1 = t2 | R(t1 , . . . , tn ).
Here R is an n-ary relation symbol, and the ti are terms of the language.
Arbitrary Ô¨Årst-order formulas Œ± are built from atomic formulas Œ≤ using boolean
operators and quantiÔ¨Åers as follows:
Œ± ::= Œ≤ | ¬¨Œ± | Œ± ‚à® Œ± | ‚àÉx Œ±.
485486
A A Logical Toolkit
We deÔ¨Åne ‚àÄx Œ± to be ¬¨‚àÉx ¬¨Œ±. Other boolean connectives (in particular, ‚àß, ‚Üí, ‚Üî,
‚ä•, ) can be deÔ¨Åned in the standard way, as can the notions of free and bound
variables of a formula. A Ô¨Årst-order sentence is a formula without free variables.
Models for a Ô¨Årst-order language L1 are tuples A = (A, R, . . . , f, . . . , c, . . .).
Here A is a non-empty set (the domain, or universe), each R is a relation on the
domain (a subset of An , for some n), each f is a function on the domain (a mapping
from An to A, for some n) and each c is an element of the domain (the elements
of A singled out in this way are often called distinguished elements). Models are
essentially relational structures (see DeÔ¨Ånition 1.1), for n-place functions are (n +
1)-ary relations, and distinguished elements can be viewed as 0-ary functions.
The models used to interpret a language must ‚Äòmatch‚Äô it in certain obvious re-
spects. First, the model must supply enough relations to interpret all the relation
symbols of the language, enough functions to interpret all the function symbols of
the language, and enough distinguished elements to interpret all the constants of the
language. Furthermore, relations of arity n must be used to interpret n-ary relation
symbols, and n-ary functions must be used to interpret n-ary function symbols. We
will usually employ the same notation for a relation symbol and the actual relation
interpreting this symbol, and likewise for function symbols and constants.
We need a mechanism to interpret free variables. Given a model A = (A, R,
. . . , f , . . . , c, . . .), an assignment on A is a function g that assigns an element of A
to each variable of the language. Thus, given a model and an assignment we can
interpret arbitrary terms through the obvious inductive deÔ¨Ånition: constants denote
the corresponding distinguished elements, variables are interpreted using the as-
signment, and terms f (t1 , . . . , tn ) are interpreted by applying the interpretation of
f to the interpretations of t1 , . . . , tn . We often call the interpretation of a term its
value; tA[g] denotes the value of term t in model A under assignment g.
The satisfaction deÔ¨Ånition is a 3-place relation |= between a model, formula,
and assignment: A |= Œ±[g] means that formula Œ± is satisÔ¨Åed in model A under
assignment g. But before deÔ¨Åning this relation, a notational point. Rather than
using g, g , and so on to name arbitrary assignments, it is more common to use
a notation that speciÔ¨Åes which element has been assigned to which free variable.
Thus if Œ±(x1 , . . . , xn ) is a formula in which x1 , . . . , xn occur free, A is a model,
and a1 , . . . , an are elements of A, then A |= Œ±[a1 , . . . , an ] means that we are
evaluating with respect to an assignment that assigns ai to xi (for 1 ‚â§ i ‚â§ n).
Sometimes this notation is convenient when deÔ¨Åning the value of terms: in our
discussion of ultraproducts we use expressions such as tA[a1 , . . . , an ] to denote the
value of term t in model A under an assignment that sends xi to ai , for 1 ‚â§ i ‚â§ n.
The satisfaction relation is deÔ¨Åned by induction on the structure of formulas.
The atomic cases are as follows: A |= R(t1 , . . . , tn )[a1 , . . . , an ] iff the values of
the terms t1 , . . . , tn are R-related in the model A; and A |= t1 = t2 [a1 , . . . , an ]
iff the values of terms t1 and t2 in A are equal. The boolean cases are deÔ¨ÅnedA Logical Toolkit
487
in the obvious way by A |= ¬¨Œ±[a1 , . . . , an ] iff A |= Œ±[a1 , . . . , an ]; and A |=
Œ± ‚à® Œ± [a1 , . . . , an ] iff either A |= Œ±[a1 , . . . , an ] or A |= Œ± [a1 , . . . , an ]. The case
of the quantiÔ¨Åer is deÔ¨Åned as follows:
A |= ‚àÉx Œ±[a1 , . . . , an ] iff there exists a in A such that
A |= Œ±[a1 , . . . , an , x ‚Üí a],
where [a1 , . . . , an , x ‚Üí a] is the assignment that differs from [a1 , . . . , an ], if at
all, only in that the variable x is assigned the value a. Clearly, we have that A |=
‚àÄx Œ±[a1 , . . . , an ] iff for all a in A, A |= Œ±[a1 , . . . , an , x ‚Üí a].
If A |= Œ±[a1 , . . . , an ] then we say that the sequence a1 , . . . , an satisÔ¨Åes Œ± in A.
It is easy to see that if a sentence is satisÔ¨Åed in a model under one assignment,
then it is satisÔ¨Åed under all assignments; accordingly, if a sentence Œ± is satisÔ¨Åed in
a model A under some assignment, then we write A |= Œ± and say that Œ± is true in
A, or that A is a model for Œ±. Two models A and B are elementarily equivalent
(notation: A ‚â° B), if every sentence true in A is true in B, and vice versa.
DeÔ¨Ånition A.1 (Validity and Semantic Consequence) A formula Œ± is valid if for
every model A and every assignment, A |= Œ±[a1 , . . . , an ].
Given a set of formulas Œ† (the premises) and a formula Œ≥ (the conclusion), we
say that Œ≥ is a semantic consequence of Œ† (notation: Œ† |= Œ≥), if for every model
A and every assignment
A |= Œ†[a1 , a2 , . . .] implies A |= Œ≥[a1 , a2 , . . .].
That is, satisÔ¨Åability of the premises (with respect to some assignment) guarantees
satisÔ¨Åability of the conclusion (with respect to the same assignment).
Basic Properties of First-Order Logic
First-order logic is undecidable: it is impossible to write a computer program that,
given an arbitrary Ô¨Årst-order formula as input, will stop after Ô¨Ånitely many steps
and (correctly) tell us whether the formula is valid or not. On the other hand,
Ô¨Årst-order validity is recursively enumerable. That is, it is possible to write a com-
puter program that successively generates all valid formulas. (The relationship
between decidability, undecidability, and recursive enumerability is discussed in
Appendix C.)
The usual way of showing that the collection of Ô¨Årst-order validities is recur-
sively enumerable is to devise a (sound and complete) proof system for it. Many
such systems are known (axiom systems, sequent systems, natural deduction sys-
tems) and though very different, they have one fundamental thing in common: they488
A A Logical Toolkit
are purely syntactic. Proofs are essentially simple Ô¨Ånite data structures (for exam-
ple, lists or trees of formulas). Such a data structure is a proof of a formula if the
symbols it contains fulÔ¨Åll certain (usually quite simple) syntactic criteria.
Let us write  Œ± to indicate that Œ± is provable in a standard proof system. We
would like  Œ± to hold if and only if |= Œ±, for if we could do this we would have
reduced a complex semantic notion (|= Œ± means satisÔ¨Åed in all models under all
assignments, and there are lots of models and assignments) to a relatively simple
syntactic one (patterns of symbols in Ô¨Ånite data structures). It is not obvious that
this can be done, but it can. Indeed, something better is the case. If we write Œ†  Œ≥
to indicate that the conclusion Œ≥ follows syntactically from the premises Œ† (this
concept can be deÔ¨Åned for any standard proof system) then we have:
Theorem A.2 (Soundness and Completeness) Let Œ† be a set of Ô¨Årst-order for-
mulas, and Œ± a Ô¨Årst-order formula. Then Œ†  Œ± iff Œ† |= Œ±. When Œ† = ‚àÖ we
have as a special case that  Œ± iff |= Œ±.
Proof. Completeness is the right to left implication: this assures us that the proof
system captures all semantically correct inferences. Detailed proofs can be found
in Chang and Keisler [91] and Enderton [122]. Hodges [228] has a good discussion
of completeness proof strategies.
The left to right direction assures that the proof system does not produce seman-
tic nonsense; this is called soundness. It is far easier to prove than completeness
(typically, a fairly simple inductive argument sufÔ¨Åces) and proofs for various types
of proof system can be found in any standard text on mathematical logic.
So Ô¨Årst-order semantic consequence, and Ô¨Årst-order validity, can be reduced to
syntactic criteria on simple data structures. Thus Ô¨Årst-order validities can be re-
cursively enumerated: we merely write a program that systematically generates all
Ô¨Ånite data structures of the appropriate kind, and checks whether they fulÔ¨Åll the
criteria demanded of proofs.
The Completeness Theorem is one of the fundamental theorems of Ô¨Årst-order
logic, but it plays a relatively modest role in this book. More important for us are
the two theorems that follow:
Theorem A.3 (Compactness) Let Œ£ be a set of Ô¨Årst-order formulas. If each Ô¨Ånite
subset of Œ£ has a model, then Œ£ itself has a model.
Theorem A.4 (L√∂wenheim-Skolem Theorem) Let Œ£ be a set of Ô¨Årst-order for-
mulas. If Œ£ has a model, then it has a countable model.
We will make use of both these results (actually, we will generally use a stronger
version of the L√∂wenheim-Skolem Theorem which is discussed below).A Logical Toolkit
489
Both the Compactness and L√∂wenheim-Skolem Theorems are purely model the-
oretic: they make no reference to provability in some proof system. The Com-
pleteness, Compactness and L√∂wenheim-Skolem Theorems together characterize
Ô¨Årst-order logic.
This completes our survey of the basics of Ô¨Årst-order logic. If much of it was
unfamiliar, we suggest you consult Enderton [122] or Hodges [228].
Basic Model-Theoretic Concepts
Now for some basic model-theoretic concepts. First we need to know when two
models are isomorphic.
DeÔ¨Ånition A.5 (Isomorphism) Two models A and A for the same Ô¨Årst-order lan-
guage are isomorphic if there is a bijective function f mapping A onto A such
that
(i) For each n-place relation R of A and the corresponding relation R of A ,
R(a1 , . . . , an ) iff R (f a1 , . . . , f an ).
(ii) For each m-place function F of A and the corresponding function F of A ,
f (F (a1 , . . . , an )) = F  (f a1 , . . . , f an ).
(iii) For each distinguished element c of A and the corresponding distinguished
element c of A , f (c) = c .
A function f that satisÔ¨Åes these requirements is called an isomorphism between A
and A . The notation f : A ‚àº
= A means that f is an isomorphism between A and

A.
In essence, isomorphic models are mathematically identical. Thus the following
proposition (which can be proved by induction on the structure of formulas) is
unsurprising:
Proposition A.6 Let f be an isomorphism between A and B. Then for all formu-
las Œ±(x1 , . . . , xn ) and n-tuples a1 , . . . , an ‚àà A, we have
A |= Œ±[a1 , . . . , an ] iff B |= Œ±[f a1 , . . . , f an ].
We are often confronted with situations in which a model we are interested in is
part of a larger one, or when we need to extend a given model to a bigger one. We
now deÔ¨Åne the basic model-theoretic notions useful in such cases.
DeÔ¨Ånition A.7 (Submodels and extensions) A model A is called a submodel of
A (notation: A ‚äÜ A), if A ‚äÜ A and490
A A Logical Toolkit
(i) Each n-place relation R of A is the restriction to A of the corresponding
relation R of A.
(ii) Each n-place function f  of A is the restriction to A of the corresponding
function f of A.
(iii) Each distinguished element of A is the corresponding distinguished ele-
ment of A.
If A is a submodel of A, then we say that A is an extension of A .
That A ‚äÜ A is no guarantee that A and A satisfy the same formulas ‚Äì and in
general, that is what we care about. This prompts the following deÔ¨Ånition:
DeÔ¨Ånition A.8 (Elementary Extension) B is said to be an elementary extension
of A, (notation: A B), if
(i) B is an extension of A.
(ii) For any Ô¨Årst-order formula Œ±(x1 , . . . , xn ) and any sequence a1 , . . . , an of
elements in A, a1 , . . . , an satisÔ¨Åes Œ± in A iff it satisÔ¨Åes Œ± in B.
When B is an elementary extension of A we also say that A is an elementary
submodel of B.
A mapping f : A ‚Üí B is called an elementary embedding of A into B, (nota-
tion: f : A B), if for all formulas Œ±(x1 , . . . , xn ) and n-tuples a1 , . . . , an ‚àà A,
we have
A |= Œ±[a1 , . . . , an ] iff B |= Œ±[f a1 , . . . , f an ].
That is, an elementary embedding of A into B is an isomorphism of A onto an
elementary submodel of B.
When working with some model, it is often useful to move from the original lan-
guage to a richer language in which every element on the model has a name:
DeÔ¨Ånition A.9 (Expansion) Let L be a Ô¨Årst-order language, and A a model for L.
We expand L to a new language LA = L ‚à™ {ca | a ‚àà A} by adding a new constant
symbol ca for each element a ‚àà A (if a = b, then ca and cb are different symbols).
We expand A to the model AA = (A, a)a‚ààA for LA by stipulating that each ele-
ment a of A is a distinguished element. Each new constant ca of LA is interpreted
by the distinguished element a. If X is a subset of A, then LX is the language
L ‚à™ {ca | a ‚àà X}, and AX = (A, a)a‚ààX is the obvious expansion of A to a model
for LX ; that is, all the elements of X become distinguished elements.
Proposition A.10 B is an elementary extension of A iff A ‚äÜ B and
(A, a)a‚ààA ‚â° (B, a)a‚ààA .A Logical Toolkit
491
We can now state the version of the L√∂wenheim-Skolem Theorem that will be most
useful to us:
Theorem A.11 Let A be a model of cardinality Œ±, and let the |L| ‚â§ Œ≤ ‚â§ Œ±,
where |L| is the number of non-logical symbols in the language. Then A has an
elementary submodel of cardinality Œ≤. Furthermore, given any set X ‚äÜ A of
cardinality ‚â§ Œ≤, A has an elementary submodel of cardinality Œ≤ which contains
X.
Actually, in two respects this result is more general than we need. First, we nearly
always work with languages with at most countably many non-logical symbols.
Secondly, we will always be interested in forming countable submodels (that is,
we are interested in the case when Œ≤ is ‚Ñµ0 ). But the other two generalizations will
be useful. First this form of the theorem guarantees that we can Ô¨Ånd not merely
a submodel, but an elementary submodel. Second, we can select any (sufÔ¨Åciently
small) subset of the original model we Ô¨Ånd interesting, and Ô¨Ånd an elementary
submodel containing it.
Ultraproducts
This ultraproduct construction is an important tool for building new models out of
old. Roughly speaking, it tells us how we can multiply together a collection of
models to form a new model with the following property: any formula satisÔ¨Åed in
most of the original models is satisÔ¨Åed in the new model, and vice versa. Math-
ematically, the notion ‚Äòmost of‚Äô is cashed out with the aid of ultraÔ¨Ålters. Readers
that are not familiar with this notion are advised to have a look at some of the
exercises in Section 2.5.
DeÔ¨Ånition A.12 (Filters and UltraÔ¨Ålters) Let W be a non-empty set. A Ô¨Ålter F
over W is a set F ‚äÜ P(W ) such that
(i) W ‚àà F .
(ii) If X, Y ‚àà F , then X ‚à© Y ‚àà F .
(iii) If X ‚àà F and X ‚äÜ Z ‚äÜ W , then Z ‚àà F .
Obviously P(W ) is itself a Ô¨Ålter. A Ô¨Ålter is called proper if it is distinct from
P(W ). An ultraÔ¨Ålter over W is a proper Ô¨Ålter U such that for all X ‚àà P(W ),
X ‚àà U if and only if (W \ X) ‚àà
/ U.
A non-trivial example of a Ô¨Ålter is the collection of all co-Ô¨Ånite subsets of an inÔ¨Ånite
set. (A subset of an inÔ¨Ånite set is co-Ô¨Ånite if its complement is Ô¨Ånite.) A large
supply of Ô¨Ålters is provided by the following deÔ¨Ånition.A A Logical Toolkit
492
DeÔ¨Ånition A.13 Let W be a non-empty set, and let E be a subset of P(W ). By
the Ô¨Ålter generated by E we mean the intersection F of the collection of all Ô¨Ålters
over W which include E:

F = {G | E ‚äÜ G and G is a Ô¨Ålter over W }.
E has the Ô¨Ånite intersection property if the intersection of any Ô¨Ånite number of
elements of E is non-empty.
We have deÔ¨Åned ultraÔ¨Ålters as a special kind of Ô¨Ålters, satisfying an additional
property. An alternative deÔ¨Ånition states that ultraÔ¨Ålters are maximal proper Ô¨Ålters;
that is, a Ô¨Ålter is an ultraÔ¨Ålter if and only if it is proper but has no proper extensions.
In many cases where we need to prove the existence of an ultraÔ¨Ålter containing a
certain collection of sets, we apply the UltraÔ¨Ålter Theorem.
Fact A.14 (UltraÔ¨Ålter Theorem) Fix a non-empty set W . Any proper Ô¨Ålter over
W can be extended to an ultraÔ¨Ålter over W . As a corollary, any subset of P(W )
with the Ô¨Ånite intersection property can be extended to an ultraÔ¨Ålter over W .
A special role is often played by the so-called principal ultraÔ¨Ålters.
DeÔ¨Ånition A.15 Let W be a non-empty set. Given an element w ‚àà W , the prin-
cipal ultraÔ¨Ålter œÄw generated by w is the Ô¨Ålter generated by the singleton set {w}.
An equivalent deÔ¨Ånition would be to put œÄw = {X ‚äÜ W | w ‚àà X}.
Are such sets really ultraÔ¨Ålters? Yes ‚Äì see Exercise 2.5.2.
We are ready to introduce the ultraproduct construction. We Ô¨Årst apply the con-
struction to sets, and then to models. Suppose that U is an ultraÔ¨Ålter over a non-

empty set I, and that for each i ‚àà I, Ai is a non-empty set. Let C = i‚ààI Ai
be the cartesian product of those sets. That is: C is the set of all functions f with
domain I such that for each i ‚àà I, f (i) ‚àà Ai . For two functions f , g ‚àà C we say
that f and g are U -equivalent (notation f ‚àºU g) if {i ‚àà I | f (i) = g(i)} ‚àà U .
Proposition A.16 The relation ‚àºU is an equivalence relation on the set C.
DeÔ¨Ånition A.17 Let fU be the equivalence class of f modulo ‚àºU , that is: fU =
{g ‚àà C | g ‚àºU f }. The ultraproduct of the sets Ai modulo U is the set of all

equivalence classes of ‚àºU . It is denoted by U Ai . So

U Ai = {fU | f ‚àà

i‚ààI Ai }.
Let us now apply the same idea to models:
DeÔ¨Ånition A.18 Fix a Ô¨Årst-order language L1 , and let Ai (i ‚àà I) be L1 -models.

The ultraproduct U Ai of Ai modulo U is the model described as follows:A Logical Toolkit

493

(i) The universe AU of U Ai is the set U Ai , where Ai is the universe of
Ai .
(ii) Let R be an n-place relation symbol, and Ri its interpretation in the model

Ai . The relation RU in U Ai is given by
RU fU1 . . . fUn iff {i ‚àà I | Ri f 1 (i) . . . f n (i)} ‚àà U.
(iii) Let F be an n-place function symbol, and Fi its interpretation in Ai . The

function FU in U Ai is given by
FU (fU1 , . . . , fUn ) = {(i, Fi (f 1 (i), . . . , f n (i))) | i ‚àà I}U .
(iv) Let c be a constant, and ai its interpretation in Ai . Then c is interpreted by

the element c ‚àà U Ai where c = {(i, ai ) | i ‚àà I}U .
In the case where all the structures are the same, say, Ai = A for all i, we speak of

the ultrapower of A modulo U , notation: U A.
To show that the above deÔ¨Ånition is coherent, we should check that the above
clauses depend only on the equivalence classes fU1 , . . . , fUn+1 . We leave this to
the reader and go straight to the fundamental result.
Theorem A.19 (≈Åo≈õ‚Äôs Theorem) Let U be an ultraÔ¨Ålter over a non-empty set I.
For each i ‚àà I, let Ai be a model.

(i) For every term t(x1 , . . . , xn ) and all elements fU1 , . . . , fUn of B = U Ai
we have
tB[x1 ‚Üí fU1 , . . . , xn ‚Üí fUn ] = {(i, tAi [f 1 (i), . . . , f n (i)]) | i ‚àà I}U .
(ii) Given any Ô¨Årst-order formula Œ±(x1 , . . . , xn ) in L1œÑ and fU1 , . . . , fUn in

U Ai we have

1
n
U Ai |= Œ±[fU , . . . , fU ] iff
(A.1)
{i ‚àà I | Ai |= Œ±[f 1 (i), . . . , f n (i)]} ‚àà U.
Proof. We leave item (i) to the reader. To prove item (ii) we argue by induction
on Œ±. The atomic case holds by deÔ¨Ånition. Suppose that Œ± ‚â° ¬¨Œ≤(x1 , . . . , xn ) and
(A.1) holds for Œ≤(x1 , . . . , xn ). Then


1
n
1
n
U Ai |= Œ±[fU . . . fU ] iff not
U Ai |= Œ≤[fU , . . . , fU ]
iff {i ‚àà I | Ai |= Œ≤[fU1 , . . . , fUn ]} ‚àà
/U
iff {i ‚àà I | Ai |= Œ≤[f 1 (i), . . . , f n (i)]} ‚àà U
iff {i ‚àà I | Ai |= Œ±[f 1 (i), . . . , f n (i)]} ‚àà U.
Here, the second equivalence follows from the inductive hypothesis, and the third
from the fact that U is an ultraÔ¨Ålter.494
A A Logical Toolkit
Next we have to prove that if Œ≤ and Œ≥ satisfy (A.1), then so does Œ≤ ‚àß Œ≥. This
uses the fact that Ô¨Ålters are closed under intersections and supersets.
Finally, suppose that Œ±(x1 , . . . , xn ) ‚â° ‚àÉx0 Œ≤(x0 , x1 , . . . , xn ) and that (A.1)
holds for Œ≤. Then the following are equivalent:


1
n
0
0 1
n
U Ai |= Œ±[fU , . . . , fU ] iff for some fU ,
U Ai |= Œ≤[fU fU , . . . , fU ]
iff for some fU0 , {i ‚àà I | Ai |= Œ≤[f 0 (i)f 1 (i), . . . , f n (i)]} ‚àà U. (A.2)
As Ai |= Œ≤[f 0 (i), . . . , f n (i)] implies Ai |= Œ±[f 1 (i), . . . , f n (i)], (A.2) implies
{i ‚àà I | Ai |= Œ±[f 1 (i), . . . , f n (i)]} ‚àà U.

(A.3)
Conversely, if (A.3) holds, then we can easily select a function f0 in i‚ààI Ai ,
where Ai is the universe of Ai , such that (A.2) holds. So (A.2) is equivalent to
(A.3).

Corollary A.20 Let U A be an ultrapower of A. Then, for all Ô¨Årst-order sen-

tences Œ±, A |= Œ± iff U A |= Œ±.
There is a natural embedding of a model A in each of its ultrapowers. DeÔ¨Åne the

diagonal mapping d of A into U A to be the function
a ‚Üí (fa )U , where fa (i) = a, for all i ‚àà I.

Corollary A.21 Let U A be an ultrapower of A. Then the diagonal mapping of

A into U A is an elementary embedding.
Proof. Let Œ±(x1 , . . . , xn ) be a Ô¨Årst-order formula, and a1 , . . . , an elements of A.
By Theorem A.19 we have

U A |= Œ±[d(a1 ), . . . , d(an )] iff {i ‚àà I | A |= Œ±[a1 , . . . , an ]} ‚àà U
iff A |= Œ±[a1 , . . . , an ].
The preceding results will be useful in our modal investigations. But ultraproducts
can also be employed to characterize the expressive power of Ô¨Årst-order languages,
and we will use this characterization on several occasions. First, we need to be
precise about what it means to deÔ¨Åne a class of models in a Ô¨Årst-order language.
DeÔ¨Ånition A.22 A class K of models for a Ô¨Åxed Ô¨Årst-order language L1 is deÔ¨Åned
by a set Œî of L1 -sentences if every model for the language is in K iff it is a model
for Œî. A class of models is elementary if it is deÔ¨Åned by some set of Ô¨Årst-order
sentences.
Theorem A.23 A class of models K is deÔ¨Ånable by means of a set of Ô¨Årst-order
sentences iff it is closed under isomorphisms and ultraproducts, while its comple-
ment is closed under ultrapowers.A Logical Toolkit
495
Proof. See [91, Theorem 6.1.16]; a weaker version of the result states that K is
elementary iff it is closed under ultraproducts and elementary equivalence [91,
Theorem 4.1.12].
In Lemma 2.73 we made use of the following result: Let L be a countable Ô¨Årst-
order language, U a countably incomplete ultraÔ¨Ålter over a non-empty set I, and

M an L-model. The ultrapower U M is countably saturated. A proof of this
result can be found in [91, Theorem 6.1.1].
Extensions of First-Order Logic
We now brieÔ¨Çy review two important extensions of Ô¨Årst-order logic: second-order
logic and inÔ¨Ånitary logic.
In second-order logic quantiÔ¨Åcation is allowed not only over individuals, as in
Ô¨Årst-order logic, but also over sets of individuals. That is, we can write expressions
like
(well-orderedness) ‚àÄX (‚àÉy Xy ‚Üí ‚àÉy (Xy ‚àß ¬¨‚àÉz Xz ‚àß z < y))
(induction)
‚àÄX (X0 ‚àß ‚àÄn (Xn ‚Üí X(n + 1)) ‚Üí ‚àÄn Xn)
Here the expression ‚àÄX is a second-order quantiÔ¨Åer, and X is a variable over sets
of individuals. Second-order formulas are interpreted on the same models as Ô¨Årst-
order formulas are, and second-order quantiÔ¨Åers have the obvious meaning (for
example, ‚àÄX means ‚Äòfor all subsets‚Äô).
The two formulas just given are relatively simple second-order formulas. For
a start, the only second-order quantiÔ¨Åers used are quantiÔ¨Åers over unary relations
(that is, subsets), thus these formulas are what is known as monadic second-order
formulas. Moreover, only universal quantiÔ¨Åers are used (indeed, in both examples
only one such quantiÔ¨Åer is used) and these stand right at the start of the formula,
thus these formulas are examples of universal second-order formulas. In Chap-
ter 3 we show that, when interpreted over frames, modal formulas are equivalent
to universal second-order formulas.
As these examples make clear, second-order logic (indeed, even the universal
monadic fragment of second-order logic) is far more expressive than Ô¨Årst-order
logic: neither well-orderedness nor induction is deÔ¨Ånable in Ô¨Årst-order logic. But
this increased expressive power comes at a price: many familiar results from Ô¨Årst-
order logic break down. For example, the validities of second-order logic are not
recursively enumerable, and the Compactness and L√∂wenheim-Skolem theorems
(A.3 and A.4) do not hold for second-order logic. However there is a method due
to Henkin [217] for ‚Äòtaming‚Äô second-order logic. By working with a special class
of non-standard models (usually called generalized models or Henkin models), it
is possible to obtain a Ô¨Årst-order perspective on a useful fragment of second-order496
A A Logical Toolkit
logic, and to prove a natural completeness theorem for this fragment. Good dis-
cussions of the method can be found in Doets and van Benthem [112], Chapter 4
of Enderton [122], and Fitting [139]. The modal analog of the method ‚Äì the use of
general frames ‚Äì is discussed in detail in the text.
In inÔ¨Ånitary logic, we are allowed to form inÔ¨Ånitely long formulas. The inÔ¨Ånitary
logic Lœâ1 œâ , for example, allows countably inÔ¨Ånite conjunctions and disjunctions
in addition to the usual Ô¨Årst-order repertoire. At Ô¨Årst glance, the idea of inÔ¨Ånitely
long formulas may seem bizarre ‚Äì but in fact the the logic is a natural setting
for formalizing many computational issues. For example, ‚Äòrepeat the program Œ±
Ô¨Ånitely many times‚Äô means the same as the inÔ¨Ånite disjunction
skip, or do Œ± once, or do Œ± twice, or do Œ± three times, or . . . .
And likewise, the following inÔ¨Ånitary formula expresses that S is the reÔ¨Çexive,
transitive closure of R:

‚àÄxy (Sxy ‚Üî i‚â•1 Ri xy),
where R0 xy := (x = y) and Rn+1 xy := ‚àÉz (Rxz ‚àß Rn zy). As we discuss in
Chapter 2, when interpreted on models, propositional dynamic logic is a fragment
of Lœâ1 œâ .Appendix B
An Algebraic Toolkit
In this appendix we review some basic (universal) algebraic notions used in Chap-
ter 5. The Ô¨Årst part deals with algebras and operations on (classes of) algebras,
the second part is about algebraic model theory, and in the third part we discuss
equational logic. Birkhoff‚Äôs fundamental theorems are stated without proof.
For an introduction to universal algebra, see Burris and Sankappanavar [81] or
Gr√§tzer [198]; McKenzie, McNulty and Taylor [321] provide more comprehensive
reading. Basic track readers may like the algebraic accounts of propositional logic
given in Chapter 3 of Bell and Machover [32] and Chapters 1 and 2 of Bell and
Slomson [33]. Many readers will Ô¨Ånd Davey and Priestly [105] useful supplemen-
tary reading.
Universal Algebra
An algebra is a set together with a collection of functions over the set; these func-
tions are usually called operations. Algebras come in various similarity types,
determined by the number and arity of the operations.
DeÔ¨Ånition B.1 (Similarity Type) An algebraic similarity type is an ordered pair
F = (F, œÅ) where F is a non-empty set and œÅ is a function F ‚Üí N. Elements
of F are called function symbols; the function œÅ assigns to each operator f ‚àà F a
Ô¨Ånite arity or rank, indicating the number of arguments that f can be applied to.
Function symbols of rank zero are called constants. We will usually be sloppy in
our notation and terminology and write f ‚àà F instead of f ‚àà F .
Given a similarity type, it is obvious what an algebra of this type should be.
DeÔ¨Ånition B.2 (Algebras) Let A be some set, and n a natural number; an n-ary
operation on A is a function from An to A.
Let F be an algebraic similarity type. An algebra of type F is a pair A =
(A, I) where A is a non-empty set called the carrier of the algebra, and I is an
497498
B An Algebraic Toolkit
interpretation, a function assigning, for every n, an n-ary operation fA on A to
each function symbol f of rank n. We often use the notation A = (A, fA)f ‚ààF for
such an algebra. When no confusion is likely to arise, we omit the subscripts on
the operations.
We now deÔ¨Åne the standard constructions for forming new algebras from old. First
we deÔ¨Åne the natural notion of structure preserving maps between algebras.
DeÔ¨Ånition B.3 (Homomorphisms) Let A = (A, fA)f ‚ààF and B = (B, fB)f ‚ààF
be two algebras of the same similarity type. A map Œ∑ : A ‚Üí B is a homomorphism
if for all f ‚àà F , and all a1 , . . . , an ‚àà A (where n is the rank of f ):
Œ∑(fA(a1 , . . . , an )) = fB(Œ∑a1 , . . . , Œ∑an ).
(B.1)
(Here Œ∑ai is shorthand Œ∑(ai ).) The special case for constants c is
Œ∑(cA) = cB.
The kernel of a homomorphism f : A ‚Üí B is the relation ker f = {(a, a ) ‚àà A2 |
f (a) = f (a )}. We say that B is a homomorphic image of A (notation: A
B),
if there is a surjective homomorphism from A onto B. Given a class C of algebras,
HC is the class of homomorphic images of algebras in C.
DeÔ¨Ånition B.4 (Isomorphisms) A bijective homomorphism is called an isomor-
phism. We say that two algebras are isomorphic if there is an isomorphism between
them. Usually we do not distinguish isomorphic algebras, but if we do, we write
IC for the class of isomorphic copies of algebras in C.
The second way of making new algebras from old is to Ô¨Ånd a small algebra inside
a larger one.
DeÔ¨Ånition B.5 (Subalgebras) Let A be an algebra, and B a subset of the carrier
A. If B is closed under every operation fA, then we call B = (B, fA B )f ‚ààF a
subalgebra of A. We say that C is embeddable in A (notation: C  A), if C is
isomorphic to a subalgebra of A; the isomorphism is called an embedding. Given
a class C of algebras, SC denotes the class of isomorphic copies of subalgebras of
algebras in C.
A third way of forming new algebras is to make a big algebra out of a collection of
small ones.
DeÔ¨Ånition B.6 (Products) Let (Aj )j‚ààJ be a family of algebras. We deÔ¨Åne the

product j‚ààJ Aj of this family as the algebra A = (A, fA)f ‚ààF where A is theAn Algebraic Toolkit
499

cartesian product j‚ààJ Aj of the carriers Aj , and the operation fA is deÔ¨Åned co-

ordinatewise; that is, for elements a1 , . . . , an ‚àà j‚ààJ Aj , fA(a1 , . . . , an ) is the

element of j‚ààJ Aj given by:
fA(a1 , . . . , an )(j) = fAj (a1 (j), . . . , an (j)).

When all the algebras Aj are the same, say A, then we call j‚ààJ A a power of

A, and write AJ rather than j‚ààJ A. Given a class C of algebras, PC denotes the
class of isomorphic copies of products of algebras in C.
Suppose you are working with a class of algebras from which you cannot obtain
new algebras by the three operations deÔ¨Åned above. Intuitively, such a class is
‚Äòcomplete‚Äô, for it is closed under the natural algebra-forming operations. Such
classes play an important role in universal algebra. They are called varieties:
DeÔ¨Ånition B.7 (Varieties) A class of algebras is called a variety if it is closed
under taking subalgebras, homomorphic images, and products. Given a class C
of algebras, VC denotes the variety generated by C; that is, the smallest variety
containing C.
A well-known result in universal algebra states that VC = HSPC. That is, in order
to obtain the variety generated by C, you can start by taking products of algebras
in C, then go on to take subalgebras, and Ô¨Ånish off by forming homomorphic im-
ages. You do not need to do anything else: subsequent applications of any of these
operations will not produce anything new.
Homomorphisms and Congruences
Homomorphisms on an algebra A are closely related to special equivalence rela-
tions on the carrier of A.
DeÔ¨Ånition B.8 (Congruences) Let A be an algebra for the similarity type F. An
equivalence relation ‚àº on A (that is, a reÔ¨Çexive, symmetric and transitive relation)
is a congruence if it satisÔ¨Åes, for all f ‚àà F
if a1 ‚àº b1 & . . . & an ‚àº bn , then fA(a1 , . . . , an ) ‚àº fA(b1 , . . . , bn ),
(B.2)
where n is the rank of f .
The standard examples of congruences are the ‚Äòmodulo‚Äô relations on the integers.
Consider the algebra Z = (Z, +, ‚àó, 0, 1) of the integers under addition and multi-
plication, and, for a positive integer n, let the relation ‚â°n be deÔ¨Åned by z ‚â°n z 
if n divides z ‚àí z . We leave it to the reader to verify that these relations are all
congruences.500
B An Algebraic Toolkit
The importance of congruences is that they are precisely the kind of equivalence
relations that allow a natural algebraic structure to be deÔ¨Åned on the collection of
equivalence classes.
DeÔ¨Ånition B.9 (Quotient Algebras) Let A be an F-algebra, and ‚àº a congruence
on A. The quotient algebra of A by ‚àº is the algebra A/‚àº whose carrier is the set
A/‚àº = {[a] | a ‚àà A}
of equivalence classes of A under ‚àº, and whose operations are deÔ¨Åned by
fA/‚àº ([a1 ], . . . , [an ]) = [fA(a1 , . . . , an )].
(This is well-deÔ¨Åned by (B.2).) The function ŒΩ taking an element a ‚àà A to its
equivalence class [a] is called the natural map associated with the congruence.
As an example, taking the quotient of Z under the relation ‚â°n makes the algebra
Zn of arithmetic modulo n.
The close connection between homomorphisms and congruences is given by the
following proposition (the proof of which we leave to the reader).
Proposition B.10 (Homomorphisms and Congruences) Let A be an F-algebra.
Then
(i) If f : A ‚Üí B is a homomorphism, its kernel is a congruence on A.
(ii) Conversely, if ‚àº is a congruence on A, its associated natural map is a
surjective homomorphism from A onto A/‚àº.
Algebraic Model Theory
Universal algebra can be seen as a branch of model theory in which one is only
interested in structures where all relations are functions. The standard language
for talking about such structures is equational, where an equation is a statement
asserting that two terms denote the same element.
DeÔ¨Ånition B.11 (Terms and Equations) Given an algebraic similarity type F and
a set X of elements called variables, we deÔ¨Åne the set TerF (X) of F-terms over
X inductively: it is the smallest set T containing all constants and all variables in
X such that f (t1 , . . . , tn ) is in T whenever t1 , . . . , tn are in T and f is a function
symbol of rank n.
An equation is a pair of terms (s, t); the notation s ‚âà t is usually used.
Having deÔ¨Åned the algebraic language, we now consider the way it is interpreted
in algebras. Obviously terms refer to elements of algebras, but in order to calculate
the meaning of a term we need to know what the variables in the term stand for.
This information is provided by an assignment.An Algebraic Toolkit
501
DeÔ¨Ånition B.12 (Algebraic Semantics) Let F be an algebraic similarity type, X a
set of variables, and A an F-algebra. An assignment on A is a function Œ∏ : X ‚Üí A
associating an element of A with each variable in X. Given such an assignment Œ∏,
we can calculate the meaning Œ∏ÃÉ(t) of a term t in Ter F (X) as follows:
Œ∏ÃÉ(x) = Œ∏(x),
Œ∏ÃÉ(c) = cA,
Œ∏ÃÉ(f (t1 , . . . , tn )) = fA(Œ∏ÃÉ(t1 ), . . . , Œ∏ÃÉ(tn )).
The last equality bears an obvious resemblance to the condition (B.1) deÔ¨Åning
homomorphisms. In fact, we can turn the meaning function into a genuine homo-
morphism by imposing a natural algebraic structure on the set TerF (X) of terms:
DeÔ¨Ånition B.13 (Term Algebras) Let F be an algebraic similarity type, and X
a set of variables. The term algebra of F over X is the algebra TerF (X) =
(Ter F (X), I) where every function symbol f is interpreted as the operation I(f )
on Ter F (X) given by
I(f )(t1 , . . . , tn ) = f (t1 , . . . , tn ).
(B.3)
In other words, the carrier of the term algebra over F is the set of F-terms over the
set of variables X, and the operation I(f ) or fTer F (X) maps an n-tuple t1 , . . . , tn
of terms to the term f (t1 , . . . , tn ). Note the double role of f in (B.3): on the right-
hand side, f denotes a ‚Äòstatic‚Äô part of the syntactic term f (t1 , . . . , tn ), while on
the left-hand side I(f ) denotes a ‚Äòdynamic‚Äô interpretation of f as an operation on
terms.
The perspective on F-terms as constituting an F-algebra is extremely useful.
For example, we can view the operation of substituting terms for variables in terms
as an endomorphism on the term algebra, that is, a homomorphism from an algebra
to itself.
DeÔ¨Ånition B.14 Let F be a similarity type, and X a set of variables. A substitution
is a map œÉ : X ‚Üí Ter F (X) mapping variables to terms. Such a substitution can
be extended to a map œÉÃÉ : Ter F (X) ‚Üí Ter F (X) by the following inductive
deÔ¨Ånition:
œÉÃÉ(x) := œÉ(x),
œÉÃÉ(f (t1 , . . . , tn )) := f (œÉÃÉ(t1 ), . . . , œÉÃÉ(tn )).
We sometimes use the word ‚Äòsubstitution‚Äô for a function mapping terms to terms
that satisÔ¨Åes the second of the conditions above (that is, we sometimes call œÉÃÉ a
substitution).502
B An Algebraic Toolkit
Proposition B.15 Let œÉ : Ter F (X) ‚Üí Ter F (X) be a substitution. Then œÉ :
TerF (X) ‚Üí TerF (X) is a homomorphism.
Moreover, the meaning function associated with an assignment Œ∏ is now a homo-
morphism:
Proposition B.16 Given any assignment Œ∏ of variables X to elements of an alge-
bra A, the corresponding meaning function Œ∏ÃÉ is a homomorphism from TerF (X)
to A.
The standard way of making statements about algebras is to compare the meaning
of two terms under the same valuation ‚Äì that is, to use equations.
DeÔ¨Ånition B.17 (Truth and Validity) An equation s ‚âà t is true or holds in an
algebra A (notation: A |= s ‚âà t), if for all assignments Œ∏, Œ∏ÃÉ(s) = Œ∏ÃÉ(t).
A set E of equations holds in an algebra A (notation: A |= E), if each equation
in E holds in A. If A |= s ‚âà t or A |= E we will also say that A is a model for
s ‚âà t, or for E, respectively.
An equation s ‚âà t is a semantic consequence of a set E of equations (notation:
E |= s ‚âà t), if every model for E is a model for s ‚âà t.
Algebraists are often interested in speciÔ¨Åc classes of algebras such as groups and
boolean algebras. Such classes are usually deÔ¨Åned by sets of equations.
DeÔ¨Ånition B.18 (Equational Class) A class C of algebras is equationally deÔ¨Ån-
able, or an equational class, if there is a set E of equations such that C contains
precisely the models for E.
The following theorem, due to Birkhoff, is one of the most fundamental results of
universal algebra:
Theorem B.19 (Birkhoff) A class of algebras is equationally deÔ¨Ånable if and only
if it is a variety.
Unfortunately, we do not have the space to prove this theorem here. The reader
is advised to try proving the easy direction (that is, to show that any equationally
deÔ¨Ånable class is closed under taking homomorphic images, subalgebras and direct
products) for him- or herself.
Equational Logic
Equational logic arises when we formalize the rules that enable us to deduce new
equations from old. Although we do not make direct use of equational logic in the
text, it will be helpful if the reader is acquainted with it. Here is a fairly standard
system.An Algebraic Toolkit
503
DeÔ¨Ånition B.20 (Equational Logic) Let F be an algebraic similarity type, and E
a set of equations. The set of equations that are derivable from E is inductively
deÔ¨Åned by the following schema:
The equations in E are derivable from E; they are called axioms.
Every equation t ‚âà t is derivable from E.
If t1 ‚âà t2 is derivable from E, then so is t2 ‚âà t1 .
If the equations t1 ‚âà t2 and t2 ‚âà t3 are derivable from E, then so is
t1 ‚âà t3 .
(congruence) Suppose that all equations t1 ‚âà u1 , . . . , tn ‚âà un are derivable from
E, and that f is a function symbol of rank n. Then the equation
f (t1 , . . . , tn ) ‚âà f (u1 , . . . , un ) is derivable from E as well. This
schema is sometimes called replacement.
(substitution) If t1 ‚âà t2 is derivable from E, then so is the equation œÉt1 ‚âà œÉt2 ,
for every substitution œÉ.
(axioms)
(reÔ¨Çexivity)
(symmetry)
(transitivity)
The notation E  t1 ‚âà t2 means that the equation t1 ‚âà t2 is derivable from E.
A derivation is a list of equations such that every element is either an axiom, or
has the form t ‚âà t, or can be obtained from earlier elements of the list using the
symmetry, transitivity, congruence/replacement, or substitution rules.
A fundamental completeness result, also due to Birkhoff, links this deductive ap-
paratus to the semantic consequence relation deÔ¨Åned earlier.
Theorem B.21 Let E be a set of equations for the algebraic similarity type F.
Then for all equations s ‚âà t, E |= s ‚âà t iff E  s ‚âà t.Appendix C
A Computational Toolkit
In this appendix we introduce the basic ideas of computability theory (the study
of which problems are, and which problems are not, computationally solvable),
and provide some background information on complexity theory (the study of the
computational resources required to solve problems).
For detailed discussions of computability, see Rogers [391] or Odifreddi [343].
For accessible introductions to the subject, see Boolos and Jeffrey [70], or Cut-
land [103]. But the single most useful source is probably the (second edition of)
Lewis and Papadimitriou [301]; this introduces computability theory, and then goes
on to treat computational complexity. For more on computational complexity, try
Garey and Johnson [163] and Papadimitriou [352]. Garey and Johnson‚Äôs book is a
source for information on NP-complete problems, but it discusses the basic ideas
of computational complexity lucidly, and gives background information on other
complexity classes. Papadimitriou‚Äôs book is a well-written introduction to compu-
tational complexity covering far more than is needed to understand Chapter 6; if
you want to go deeper into computational complexity, it is a good place to start.
Computability and Uncomputability
To prove theorems about computability ‚Äì and in particular to prove that some prob-
lem is not computable ‚Äì we need a robust mathematical model of computability.
One of the most widely used models is the Turing machine. A Turing machine
is a device which manipulates symbols written on a tape. The symbols are taken
from some alphabet Ô¨Åxed in advance (often the alphabet simply consists of the two
symbols 0 and 1). The tape is subdivided into squares, and only one symbol can be
written on each square (squares containing no symbols are called blank). The tape
is used to receive input, to present output, and acts as working memory. The tape
is assumed to be inÔ¨Ånitely long in both directions (so no Ô¨Ånite upper bound on the
amount of working memory is assumed).
Turing machines scan the squares of such tapes and act on the information they
504A Computational Toolkit
505
see; they can only scan one square at a time. A Turing machine has a Ô¨Ånite number
of internal states, and a Ô¨Ånite number of rules which tell it what to do when it is
in a certain state scanning a certain symbol. Turing machines can perform three
basic actions: (1) move to the square immediately to the left of the square they are
currently scanning, (2) move to the square immediately to the right of the square
they are currently scanning, or (3) write a symbol (from the alphabet) on the square
currently being scanned (thereby overwriting any symbol already written on that
square). In addition to specifying which of these three actions will be performed,
the rules also specify which internal state the Turing machine is to move into on
completing the action. A Turing machine halts when (and if) it enters a special
halting state. For some simple (and not so simple) examples of computations on
Turing machines, see Chapter 4 of Lewis and Papadimitriou [301] and Chapters 1‚Äì
3 of Boolos and Jeffrey [70].
The ideas just sketched can be made precise as follows:
DeÔ¨Ånition C.1 (Turing Machines) A Turing machine is a 5-tuple (S, s, H, Œ£, Œ¥)
where S is a Ô¨Ånite set of states, s ‚àà S is the initial state, H ‚äÜ S is the set of
halting states, Œ£ (the alphabet) is a Ô¨Ånite set of symbols, and Œ¥ is a function from
(S \ H) √ó Œ£ to S √ó (Œ£ ‚à™ {left, right}).
For example, the rule if you are in state 57 scanning the symbol 1, move one square
to the left and go into state 14 amounts to saying that Œ¥(57, 1) = (14, left). The
rule if you are in state 30 scanning the symbol %, write the symbol 5 and go into
state 12 means that Œ¥(30, %) = (12, 5). Since Œ¥ is a function, the action of such
a machine is deterministic: when the machine is put in the initial state scanning
some tape, what it does (if it does anything) is Ô¨Åxed.
Let f be a function, and suppose we have Ô¨Åxed some convention about how
the elements of the domain and range of the function are to be represented. (For
example, if f is a function from the natural numbers to the natural numbers, we
might decide to use binary notation ‚Äì that is, base 2 notation ‚Äì to represent the
numbers). Then f is computable (or recursive) if there is a Turing machine that
when given (the representation of) an item x in the domain of f will halt after
Ô¨Ånitely many steps, leaving on an otherwise blank tape (the representation of) f (x).
We can use Turing machines to provide yes/no answers to problems. Many
logical problems ‚Äì for example, is some formula œÜ satisÔ¨Åable or not ‚Äì are of this
type. Suppose we have Ô¨Åxed the alphabet of a Turing machine, and have decided
how we are going to represent the problems we are interested in (in Section 6.1,
we discuss how to encode modal formulas and models as strings of 0s and 1s).
Given our encoding conventions, some strings over the alphabet represent problem
instances for which the answer is yes, while others represent problem instances for
which the answer is no. A problem is computable (or recursive, or decidable) if506
C A Computational Toolkit
there is a Turing machine which when given (the representation of) any instance
of the problem, halts after Ô¨Ånitely many steps leaving the (representation of) the
correct answer on an otherwise blank tape.
Turing machines essentially provide answers to set membership problems: a
yes answer means that the input belongs to a set of interest (for example, the set
of satisÔ¨Åable formulas) while a no means it does not. Thus it is common to talk
of computable (or recursive, or decidable) sets. Another important notion is that
of a recursively enumerable set. A set is recursively enumerable (r.e.) if there is
a Turing machine which successively writes, on an otherwise blank tape, all and
only the members of the set. If the set is inÔ¨Ånite, this listing process will never
Ô¨Ånish ‚Äì but after some Ô¨Ånite time, any given element of an r.e. set will eventually
be listed.
All recursive sets are r.e., but there are r.e. sets that are not recursive. The
best known example is the set of valid Ô¨Årst-order formulas (in a sufÔ¨Åciently rich
language). This set is not recursive, but (as we mentioned in Appendix A) it is
recursively enumerable. Details for the following result may be found in Lewis
and Papadimitriou [301, pp. 198‚Äì200, 267‚Äì273])
Proposition C.2 A set is recursive iff both it and its complement are recursively
enumerable
Thus, from a computational perspective, the set of Ô¨Årst-order formulas that are
not valid is more complex than the set of valid formulas ‚Äì the non-valid formulas
cannot even be recursively enumerated.
It is common practice to identify problems with the set of those strings of sym-
bols that provide the answer yes to the problem. For once an alphabet has been
Ô¨Åxed, each subset of the set of all Ô¨Ånite strings over the alphabet can be regarded
as the encoding of the problem. This abstract perspective is a convenient way of
stating abstract computability and complexity results, and we adopt it later in this
appendix; but in the text, when we apply these ideas to modal logic, we try to keep
our statement of problems fairly concrete.
Because of its simplicity, the Turing machine model is widely used in theoretical
computer science, particularly in complexity theory. But it is not a toy model
of computation: experience has shown that it is remarkably robust and general.
For example, we can allow Turing machines to have special read-only input tapes,
special write-only output tapes, and allow them to access several working tapes
independently ‚Äì but none of these variations allows new functions to be computed
or new problems solved. Moreover, we can move away from the Turing machine
model in many different ways: for example, we can use Random Access Memory
machines which model more directly the workings of a physical computer. Such
variations make no difference: if a function is computable (or a problem decidable)A Computational Toolkit
507
in one of these alternative models then it is also computable (decidable) on some
Turing machine.
Another important variation is the use of non-deterministic Turing machines.
The action of such a machine is not Ô¨Åxed by the symbol it is scanning and the state
it is in: for any such combination, it may have a (Ô¨Ånite) range of options. (Formally,
we drop the requirement that the Œ¥ of DeÔ¨Ånition C.1 be a function and let it be an
arbitrary relation.) We think of such a machine as following all the options allowed
by Œ¥ simultaneously, and say that such a machine solves a problem if at least one
such computation path halts leaving the correct answer on an otherwise blank tape.
The beauty of non-determinism is that it factors out search. Many problems re-
quire us to Ô¨Ånd a candidate solution and then see if it works, and if not, to look for
another candidate, and so on. This process may be the major computational over-
head. Non-deterministic machines abstract away from this: if there is a solution,
a non-deterministic machine can Ô¨Ånd it far more efÔ¨Åciently (we will see a classic
example of this when we discuss complexity theory). But as far as computability
is concerned, non-determinism adds nothing: if a function (or problem) is com-
putable using a non-deterministic Turing machine, it is also computable using a
deterministic Turing machine, for we can (laboriously) work through all possible
choices.
Such observations give rise to Church‚Äôs thesis.
Thesis C.3 (Church‚Äôs Thesis) A function is computable (a problem decidable)
precisely when it can be computed (solved) using a Turing machine.
On the face of it, Church‚Äôs Thesis just stipulates that the notion of computation
deÔ¨Åned by Turing machines is so robust that it makes sense to think of it as pinning
down what we mean by computation. But its import is far wider: in essence it is
an acknowledgment of the fact that all the general Ô¨Ånitary models of computation
that have been proposed (and there are probably several hundreds of these) have
turned out to be equivalent. That is, Church‚Äôs Thesis afÔ¨Årms that we do have a
robust model of computation.
You may view Church‚Äôs Thesis as saying that computable functions and prob-
lems are those which can be calculated/solved by writing a program in your favorite
programming language when no limitations are placed on memory or execution
time. In fact, in Chapter 6 we rarely talk explicitly of Turing machines: rather, we
prove that problems are decidable by analyzing them till it becomes clear that any
competent programmer could write a program that carries out the task.
The most important beneÔ¨Åt of having a robust deÔ¨Ånition of computability is that
it gives us a way of proving that some function or problem is undecidable. And
many ‚Äì indeed most ‚Äì functions and problems are undecidable. For let M be a
set of natural numbers. Is each such M decidable? A simple cardinality argument508
C A Computational Toolkit
shows that the answer is no. Every Turing machine is a Ô¨Ånite function over a
Ô¨Ånite set of states and a Ô¨Ånite alphabet. It follows that there are only countably
many Turing machines ‚Äì but there are uncountably many M , so they cannot all be
computable. It is not difÔ¨Åcult to construct concrete examples of functions which
no Turing machine can compute (see Lewis and Papadimitriou [301, Chapter 5],
and Boolos and Jeffrey [70, Chapters 4, 5]).
But again, to prove undecidability it is not necessary to appeal to the deÔ¨Ånition
of a Turing machine. It is usually easier to show problems are undecidable via
reductions:
DeÔ¨Ånition C.4 Let Œ£ be an alphabet and let L1 , L2 ‚äÜ Œ£ ‚àó be problems (note that
we are adopting the abstract view of problems here). A reduction from L1 to L2 is
a computable function f : Œ£‚àó ‚Üí Œ£ ‚àó such that s ‚àà L1 iff f (s) ‚àà L2 ; here, Œ£ ‚àó is
simply the set of all Ô¨Ånite strings over Œ£.
Proposition C.5 Let L1 , L2 ‚äÜ Œ£ ‚àó be problems, and f be a reduction from L1 to
L2 . If L1 is undecidable, then so is L2 .
Proof. Easily established using a proof by contradiction, and the reader may like
to try. You can Ô¨Ånd a detailed account on pages 254‚Äì258 of the second edition of
Lewis and Papadimitriou [301].
Nowadays a vast range of problems are known to be undecidable, and we can try
to prove undecidability results by reduction from any one of these problems. We
follow this strategy in Chapter 6.
One Ô¨Ånal remark: not all undecidable problems are alike. There is a precise
sense in which some are worse than others. The key idea is to equip Turing ma-
chines with oracles. A Turing machine equipped with an oracle is allowed to tem-
porarily halt in the middle of some computation, consult the oracle, and proceed
with its computation taking the oracle‚Äôs answer into account.
Oracles provide answers to undecidable problems (an oracle that provided an-
swers to decidable problems would offer nothing new: it could always be replaced
by a Turing machine). They are a mathematical abstraction which allow us to
remove the limitation to Ô¨Ånitary computation inherent in Church‚Äôs thesis. It is
common to specify what oracles can do in logical terms ‚Äì for example, we might
imagine we have a Turing machine hooked to an oracle that is able to determine
whether an arbitrary second-order sentence has a model or not. It turns out that
undecidable problems are not all the same: when we measure their difÔ¨Åculty with
respect to the oracles required to solve them, there is a whole hierarchy of difÔ¨Å-
culty. A problem that is not merely undecidable, but requires the help of some
such oracle to solve it, is called highly undecidable. In Section 6.5 we show that
a certain modal satisÔ¨Åability problem is highly undecidable, and in fact, Œ£11 -hard.A Computational Toolkit
509
Roughly speaking, this means that the problem is as difÔ¨Åcult as deciding whether
a prenex formula in the second-order language of arithmetic, that begins with a
block of existential quantiÔ¨Åers, is satisÔ¨Åable on the natural numbers. Such formulas
have immense expressive power, and Œ£11 problems are highly complex (certainly
not recursively enumerable). Incidentally, ‚Äòordinary‚Äô undecidable problems are of-
ten said to be Œ†10 -hard, and we use this terminology in Section 6.5 too. Roughly
speaking, this means that such problems are ‚Äòonly‚Äô as difÔ¨Åcult as deciding whether
a prenex formula (with what is known as a recursive matrix) in the Ô¨Årst-order lan-
guage of arithmetic, and with a quantiÔ¨Åer preÔ¨Åx consisting of universal quantiÔ¨Åers
only, is satisÔ¨Åable on the natural numbers. Although such problems are undecid-
able, they are recursively enumerable. For more on highly undecidable problems,
see Harel [208]. For precise deÔ¨Ånitions and further discussion of the classes Œ£11
and Œ†10 , see Odifreddi [343].
Complexity Theory
Complexity theory studies the computational resources required to solve (decid-
able) problems. The two main resources studied are time (the number of com-
putation steps required) and space (the amount of memory required). Both time
required and space required are measured as functions of the length of the input.
Ideally, complexity theory would give us a precise bound on the resources re-
quired to solve any problem that interested us. But this goal is far too ambitious.
Instead, complexity theory classiÔ¨Åes problems into various classes. In this book
we mention the classes
P ‚äÜ NP ‚äÜ PSPACE ‚äÜ EXPTIME ‚äÜ NEXPTIME
(C.1)
and we devote a lot of attention to NP, PSPACE, and EXPTIME.
Before deÔ¨Åning these classes, some general remarks. It is currently unknown
whether the inclusions in (C.1) are strict or not. It is widely conjectured that they
are, but nobody has been able to prove (or disprove) any of these strict inclusions.
All we know for sure is that P = EXPTIME.
Second, although a problem that belongs to any of these classes is decidable, P
(the class at the bottom of this putative hierarchy) is widely taken to be the class of
problems that are tractable, or efÔ¨Åciently solvable.
DeÔ¨Ånition C.6 A deterministic Turing machine is polynomially time bounded if
there is a polynomial p(n) such that the machine always halts after at most p(n)
steps, where n is the length of the input. A problem is solvable in polynomial time
(a function f is solvable in polynomial time) if there is a polynomially bounded
Turing machine that solves it (that computes it). The class of all problems solvable
in polynomial time is called P. A problem is called tractable if it belongs to P.510
C A Computational Toolkit
One word of warning. When we solve a problem on a Turing machine, we choose
a way of representing the problem (that is, encoding it in the symbols used by that
machine). Needless to say, there are sensible ways of representing problems, and
highly inefÔ¨Åcient ways of doing so. If a sufÔ¨Åciently bad representation is chosen,
this can give a completely misleading impression of the resources required to solve
the problem. For example, a really bad representation could ensure that a problem
solvable in polynomial time takes exponential time to compute.
Fortunately, for the complexity classes considered in this book, there is little to
worry about. The main pitfall to be avoided concerns the representation of num-
bers: unary representations should be avoided as they are exponentially longer than
binary (or higher base) representations. In the text, we assume we are working with
binary representations of numbers. We discuss the representation of modal logical
problems in Section 6.1.
Identifying tractable problems with those in P is not unproblematic, but it has
proved useful. For a start, if a problem is solvable in polynomial time, then typ-
ically the polynomial is of low degree. Moreover, if a problem is not solvable in
polynomial time, then (some instances of it) will be very hard to solve indeed. For
example, if a problem requires resources exponential in the length of the input (for
example, 2n , where n is the length of the input), then no algorithm is going to solve
all instances of the problem efÔ¨Åciently: on some input, even for quite small values
of n, the computation will not halt within the expected lifetime of the universe.
Hardness and completeness
In order to deÔ¨Åne the complexity classes of interest, we need some additional con-
cepts. We have already met the idea of reducing one problem to another (see Def-
inition C.4). To make further progress, we need the notion of tractably reducing
one problem to another. As we have identiÔ¨Åed ‚Äòtractable‚Äô with ‚Äòcomputable in
polynomial time‚Äô, the following notion is what we require.
DeÔ¨Ånition C.7 (Polytime Reduction) Let L1 , L2 ‚äÜ Œ£ ‚àó be problems. A polyno-
mial time computable function f : Œ£‚àó ‚Üí Œ£ ‚àó is called a polynomial time reduction
(or: a polytime reduction) from L1 to L2 if for each s ‚àà Œ£‚àó we have that s ‚àà L1
iff f (s) ‚àà L2 .
A polytime reduction from L1 to L2 is essentially a tractable way of compiling
problem L1 down to problem L2 . It follows that if L2 is solvable in polynomial
time (that is, if L2 is tractable), then so is L1 : to test whether a string x is in L1 ,
simply compute f (x) (this compilation step is polynomial time computable) and
then test whether f (x) ‚àà L2 (which by assumption is polynomial time solvable).
As x ‚àà L1 iff f (x) ‚àà L2 , and as the composition of two polynomials is a poly-
nomial, we have efÔ¨Åciently computed an answer to our original problem. On theA Computational Toolkit
511
other hand, if L1 is not solvable in polynomial time, then neither is L2 , as the
reader should verify. Summing up: if there is a polytime reduction from L1 to L2 ,
then L2 is at least as hard as L1 , and this observation leads us to the following
fundamental deÔ¨Ånition:
DeÔ¨Ånition C.8 (Hardness and Completeness) Let C be a class of problems. A
problem L is C-hard (with respect to polynomial time reductions) if every problem
in C is polynomial time reducible to L; L is C-complete if it is C-hard and moreover
L ‚àà C. That is, the C-complete problems are the hardest problems in C.
The class P
This fundamental class does not play a direct role in the book, for it is widely be-
lieved that the problem of deciding whether a formula of classical propositional
logic is satisÔ¨Åable is not in P. (No proof of this is known ‚Äì it is one of the best-
known open problems in theoretical computer science.) As the modal logics dis-
cussed in this book contain classical propositional logic as a subpart, their satisÔ¨Åa-
bility problems probably do not lie in P either.
The class NP
There are many naturally occurring problems which do not seem to belong to P but
which can be solved efÔ¨Åciently using a non-deterministic Turing machine.
DeÔ¨Ånition C.9 A non-deterministic Turing machine is polynomially time bounded
if there is a polynomial p(n) such that no computation of the machine continues
for more than p(n) steps where n is the length of the input. NP is the class of all
problems decided by a polynomially bounded non-deterministic machine.
The problems that seem not to be in P but which are in NP typically involve search.
The classic example is the satisÔ¨Åability problem for propositional logic: given a
propositional formula œÜ, is there an assignment of truth values (0 and 1) to its
proposition letters that makes the formula evaluate to 1? No deterministic poly-
nomial time algorithm for propositional satisÔ¨Åability is known, and it is widely
believed that none exists.
But it is easy to design an NP algorithm to solve propositional satisÔ¨Åability.
When it is given as input the formula œÜ, the Ô¨Årst step of the algorithm is to non-
deterministically try out all possible combinations of truth values on the proposi-
tional variables in œÜ. If there is a solution, this is returned; if not, an arbitrary truth
value assignment is returned instead. Either way, after one (non-deterministic) step
we are given an assignment. We can then deterministically compute in polynomial
time whether this assignment satisÔ¨Åes œÜ or not (all we have to do is perform one512
C A Computational Toolkit
operation for each logical connective in œÜ). If œÜ evaluates to true, œÜ is satisÔ¨Åable.
On the other hand, if œÜ evaluates to false, it must be unsatisÔ¨Åable, for the non-
deterministic step would have returned a satisfying assignment had one existed.
Does this mean that propositional satisÔ¨Åability is really an easy problem to
solve? Unfortunately, no. The only known way of implementing non-determinism
is to simulate it on a deterministic Turing machine. All known simulations require
exponential time to perform, and it is widely believed (though not proved) that no
efÔ¨Åcient simulation exists. Non-deterministic Turing machines are probably not a
realistic model of efÔ¨Åcient computation.
But non-determinism has proved to be a very useful way of thinking about prob-
lems consisting of a search for a solution, followed by a veriÔ¨Åcation step that can be
conducted in deterministic polynomial time. An extraordinary range of interesting
problems have this general proÔ¨Åle (see Garey and Johnson [163] for an extensive
list), and by reducing the search to a single non-deterministic step, we see that such
problems belong to NP.
Now for a more demanding question: are there any NP-hard problems? The
celebrated Cook-Levine Theorem tells us that there are.
Theorem C.10 (Cook-Levine Theorem) The propositional satisÔ¨Åability problem
is NP-complete.
Proof. We have just given an informal argument showing that the propositional
satisÔ¨Åability problem is in NP. As for NP-hardness, we need to show (in accordance
with DeÔ¨Ånition C.8) that any problem in NP whatsoever can be polytime reduced
to the propositional satisÔ¨Åability problem. It may seem that we do not have enough
information to prove something this general ‚Äì but amazingly, we do. An elegant
proof is given by Lewis and Papadimitriou [301, pp. 309‚Äì317].
Once we have shown that one problem is NP-complete, it becomes much easier to
show that other problems are NP-complete. Given a problem L which we suspect
to be NP-complete, all we have to do is (i) show that it is in NP, and (ii) show
that some problem known to be NP-hard is polynomial time reducible to L. In this
book, showing point (ii) is trivial: all the logics we are interested in extend classical
propositional logic, so NP-hardness is immediate by the Cook-Levine Theorem.
The classes NP and coNP (that is, the class of problems whose complements
are in NP) seem to have very different complexity proÔ¨Åles. A classic problem in
coNP is the validity problem for propositional calculus ‚Äì the problem of deciding
whether all assignments of truth values satisfy a propositional formula. The va-
lidity problem is widely believed not to be in P. However, (unlike the satisÔ¨Åability
problem) it does not seem to belong to NP either: because we need to consider all
possible truth assignments, non-determinism does not seem to help us solve it. ButA Computational Toolkit
513
we face another open problem here: although it is standardly conjectured that NP
= coNP, no-one has been able to prove or disprove it.
The class PSPACE
PSPACE is the complexity class of most relevance to modal logic. It is deÔ¨Åned in
terms of deterministic Turing machines.
DeÔ¨Ånition C.11 A deterministic Turing machine is polynomially space bounded
if there is a polynomial p(n) such that no computation of the machine scans more
than p(n) tape squares, where n is the length of the input. PSPACE is the class
of all problems that are decided by a polynomially space bounded deterministic
Turing machine.
Proposition C.12 NP ‚äÜ PSPACE.
Proof. This is a special case of a more general result: see Papadimitriou [352,
Theorem 7.4(b)].
What is the intuition behind this theorem? As we have remarked, a determinis-
tic Turing machine can simulate a non-deterministic Turing machine, though it is
widely believed that the simulation will in general run exponentially slower than
the non-deterministic machine. Proposition C.12 tells us for any problem in NP, it
is always possible to carry out the simulation in such a way that there is no blow-
up in space requirements. Roughly speaking, we work systematically through the
search space, with the search for each item taking only polynomial space. When it
is time to search for the next item, we reuse the same squares. There is a bookkeep-
ing overhead (we need to keep track of where we are in the search space) but (with
careful management) this can be done using a relatively small number of squares.
So while the simulation may take a long time, we do not need much memory.
It is widely conjectured that NP ‚äÇ PSPACE (that is, it is believed that there are
problems in PSPACE that are not in NP) and indeed that coNP ‚äÇ PSPACE too.
We will now describe an important problem in PSPACE that seems to belong to
neither NP nor coNP; we make use of this problem in Chapter 6.
The set of prenex quantiÔ¨Åed boolean formulas (QBFs) consists of expressions of
the form
Q1 p1 . . . Qm pm Œ∏(p1 , . . . , pm ),
where each Qi is either ‚àÄ or ‚àÉ, and Œ∏(p1 , . . . , pm ) is a formula of propositional
calculus. The quantiÔ¨Åers range over the truth values 1 (true) and 0 (false), and a
quantiÔ¨Åed boolean formula without free variables is true if and only if it evaluates
to 1; the QBF-truth problem is to determine whether such a formula is true or not.514
C A Computational Toolkit
This problem contains both the satisÔ¨Åability and validity problems for propositional
logic as special cases (let the quantiÔ¨Åers be all existential, or all universal, respec-
tively). But the general problem of deciding the truth of QBF formulas seems to be
harder than either of these. Nonetheless there is a certain modularity to deciding
QBF-truth. We try out one sequence of truth value assignments: checking whether
it works takes polynomial space. We record what we have done, and reuse the
same space to check the next assignment sequence. In this way we check through
all possible assignments, and each check is performed in the same working space.
So it may take an awfully long time to solve the problem ‚Äì but we do not have to
use much memory. And in fact we have the following result.
Theorem C.13 The QBF-truth problem is PSPACE-complete.
Proof. See Papadimitriou [352, Theorem 19.1].
PSPACE is deÔ¨Åned in terms of deterministic Turing machines. NPSPACE, the
class of problems computable by non-deterministic polynomial space bounded Tur-
ing machines, is deÔ¨Åned by rephrasing the deÔ¨Ånition in terms of non-deterministic
Turing machines. Intriguingly, NPSPACE contains nothing new:
Theorem C.14 (Savitch‚Äôs Theorem) PSPACE = NPSPACE.
Proof. See Papadimitriou [352, Theorem 7.5].
So if we want to show that a problem is in PSPACE, we can do so by showing that
it is in NPSPACE, and we take advantage of this in the text.
Finally, PSPACE = coPSPACE. Why? Well, any deterministic Turing machine
that decides a problem L in PSPACE can be converted to a machine that decides L
simply by Ô¨Çipping yess to nos and vice versa. This invariance under complemen-
tation has nothing much to do with PSPACE: for any time or space class C deÔ¨Åned
in terms of deterministic Turing machines, C = coC, as the ‚Äòswitch the outputs‚Äô
argument shows. (Note that this argument does not work with non-deterministic
machines.)
The class EXPTIME
EXPTIME is deÔ¨Åned in terms of deterministic Turing machines:
DeÔ¨Ånition C.15 A deterministic Turing machine is exponentially time bounded if
there is a polynomial p(n) such that the machine always halts after at most 2p(n)
steps, where n is the length of the input.
A problem is solvable in exponential time if there is an exponentially time
bounded Turing machine that solves it. The class of all problems solvable in expo-
nential time is called EXPTIME.A Computational Toolkit
515
Incidentally, the use of 2 in this deÔ¨Ånition is arbitrary. If we can show that a Turing
machine is time bounded by a function of the form cp(n) , where c > 2, then we
can show that it is exponentially time bounded in the sense just deÔ¨Åned: simply
choose k such that 2k > c. Then the Turing machine is time bounded by 2k¬∑p(n) ,
for cp(n) < (2k )p(n) = 2k¬∑p(n) .
EXPTIME-hard problems are intractable. Some problems in EXPTIME are
provably outside P (see Lewis and Papadimitriou [301, Theorem 6.1.2]), hence
any EXPTIME-hard problem is at least as hard as such intractable problems.
The class NEXPTIME
NEXPTIME is the class of problems solvable using an exponentially bounded non-
deterministic Turing machine. Like NP algorithms, NEXPTIME algorithms have
a ‚Äòguess and check‚Äô proÔ¨Åle. The crucial difference is that guessed information may
be exponentially large in the size of the input, thus the deterministic checking that
follows may take exponentially many steps in the size of the input.
We have not mentioned NEXPTIME much in Chapter 6, but it is implicitly
present: when modal logics are proved decidable using the Ô¨Ånite model property, a
NEXPTIME algorithm is usually being employed.
O notation
In the text we try to do as little combinatorial analysis as possible, and we are
often content simply to say that some procedure or other runs in polynomial, or
exponential, time. But sometimes we state more precise bounds, and when we do,
we use O notation. Basically, O notation is a way of stating bounds that ignores
multiplicative constants and low order terms. For example, instead of saying that
an algorithm runs in time 3n2 + 2n + 7 (where n is the size of the input) we would
say that it runs in time O(n2 ) (read this as: ‚Äòof the order n2 ‚Äô). Roughly speaking,
this means that for all sufÔ¨Åciently large n, the fact that we square the length of the
input dominates all the other contributions. More precisely:
DeÔ¨Ånition C.16 Let f and g be functions from the natural numbers to the natural
numbers. We say that f = O(g) if there are positive constants c and k such that
for all n ‚â• k, f (n) ‚â§ c ¬∑ g(n).
Thus 3n2 + 2n + 7 = O(n2 ), as 3n2 + 2n + 7 ‚â§ 6n2 for all n ‚â• 2.Appendix D
A Guide to the Literature
Here we list and brieÔ¨Çy describe a number of textbooks, survey articles, and more
specialized books which the reader may Ô¨Ånd useful. We have not aimed for com-
prehensive coverage. Rather, we have commented on the sources the reader is most
likely to run into, provided pointers to topics not discussed in this book (in partic-
ular, modal proof theory and theorem proving, and Ô¨Årst-order modal logic) and
drawn attention to some interesting emerging themes.
This is a good place to mention the Advances in Modal Logic initiative, which
attempts to bring together scholars working in various areas of modal logic and its
applications. You can Ô¨Ånd out more at: http://www.aiml.net. The collec-
tion Advances in Modal Logic, Volume 1, edited by Kracht et al. [281], contains
a selection of papers from the Ô¨Årst conference hosted by the initiative. Selections
from later workshops have also been published; see Advances in Modal Logic, Vol-
ume 2, edited by Zakharyaschev et al. [469]; Advances in Modal Logic, Volume 3,
edited by Wolter et al. [461]; and Advances in Modal Logic, Volume 4, edited by
Balbiani et al. [18].
Textbooks on Modal Logic
To start, here is an annotated list of textbooks on modal logic.
‚ó¶ A Manual of Intensional Logic, van Benthem [44]. What is modal logic? What
is not! This inspiring little book takes the reader on a whirlwind tour of the
many faces of modal logic. The book is deceptively easy to read; alert readers
will soon cotton onto the fact that the author indicates unexplored territory on
practically every page.
‚ó¶ The Logic of Provability, Boolos [69]. Clear, up-to-date, introduction to prov-
ability logic.
‚ó¶ Modal Logic, Chagrov and Zakharyaschev [88]. A recent advanced textbook
on modal logics in the basic modal language and their connections with super-
516A Guide to the Literature
517
intuitionistic logics. Concentrates on the Ô¨Åne structure of the lattice of normal
modal logics, using methods not covered by our book, to prove general results
on various properties of logics.
‚ó¶ Modal Logic. An Introduction, Chellas [92]. A readable introductory text which
focuses on completeness-via-canonicity and decidability-via-Ô¨Åltration for the
basic modal language. Also introduces neighborhood (or Montague-Scott) se-
mantics, a tool for analyzing non-normal modal logics (Chellas calls neighbor-
hood models minimal models).
‚ó¶ Proof Methods for Modal and Intuitionistic Logic, Fitting [137]. This beautiful
book explores in detail a number of proof methods (tableaux, sequent systems,
natural deduction) for modal logic; we have no hesitation in recommending this
classic work as a great source for Ô¨Ånding out more about modal proof theory.
‚ó¶ Types, Tableaus, and Goedel‚Äôs God, Fitting [139]. An introduction to higher-
order modal logic that ends by formalizing Goedel‚Äôs ontological argument for
the existence of God! Quite apart from anything else, it is one of the best intro-
ductions to ordinary (non-modal) higher-order logic around. Tableaux-based.
‚ó¶ First-Order Modal Logic, Fitting and Mendelsohn [140]. An excellent intro-
duction to Ô¨Årst-order modal logic. Addresses both technical and philosophical
aspects of quantiÔ¨Åcation and equality. Provides both Hilbert-style and tableaux-
based proof systems.
‚ó¶ Modal Logics and Philosophy, Girle [172]. Readable introduction to modal
logic, including Ô¨Årst-order modal logic. Discusses temporal, dynamic, epis-
temic, and deontic interpretations, as well as the logic of necessity and possi-
bility.
‚ó¶ Logics of Time and Computation, Goldblatt [177]. Clearly written intermediate
level text which focuses on completeness results for the basic modal and tempo-
ral languages, and a variety of extended modal languages, including until-based
temporal languages, PDL, and Ô¨Årst-order PDL. A useful book to have around.
‚ó¶ Mathematics of Modality, Goldblatt [178]. This book brings together a number
of the author‚Äôs papers on modal logics. In particular, it contains his seminal PhD
thesis which can be hard to obtain in its article version [184, 185].
‚ó¶ Dynamic Logic, Harel, Kozen and Tiuryn [212]. A detailed, well written, intro-
duction to propositional dynamic logic, and many of its extensions, including
Ô¨Årst-order dynamic logic. A good choice for readers wanting to Ô¨Ånd out more
about this important branch of modal logic.
‚ó¶ A Companion to Modal Logic, Hughes and Cresswell [234]. This was the Ô¨Årst
textbook to move beyond the staples of the classical period (relational seman-
tics, canonical models, Ô¨Åltrations) and discuss distinctively modern topics (no-
tably frame incompleteness). Short, accessible, and clear, it is still a valuable
introductory text, though it has since been superseded by the next entry.518
D A Guide to the Literature
‚ó¶ A New Introduction to Modal Logic, Hughes and Cresswell [235]. An admirably
clear and wide ranging introductory text. Although many topics (such as the
standard translation) are not discussed, it manages to at least mention many mod-
ern themes such as frame deÔ¨Ånability and extended modal languages. Contains
a good discussion of Ô¨Årst-order modal logic.
‚ó¶ Tools and Techniques in Modal Logic, Kracht [279]. Advanced book on math-
ematical aspects of modal logic, taking a polymodal perspective. Contains an
in-depth study of correspondence and completeness, duality theory, the lattice
of modal logics, and transfer results from monomodal to polymodal logics.
‚ó¶ The ‚ÄòLemmon Notes‚Äô: An Introduction to Modal Logic, Lemmon and Scott
[296]. All that exists of an unÔ¨Ånished monograph on modal logic (Lemmon‚Äôs
death in 1966 prevented its completion). The original source for work on Ô¨Åltra-
tions and canonical models, for many years it was the deÔ¨Ånitive introduction to
modal logic. Although out of date, its quality still shines through.
‚ó¶ Epistemic Logic for AI and Computer Science, Meyer and van der Hoek [328].
An introductory text on epistemic logic. Covers the basic modal approach, as
well as more advanced models and default reasoning.
‚ó¶ A Short Introduction to Modal Logic, Mints [330]. This little book is a short
introduction to Gentzen-style proof systems for S5, S4 and T. A useful starting
point in modal proof theory.
‚ó¶ First Steps in Modal Logic, Popkorn [361]. If you Ô¨Ånd the present book too
difÔ¨Åcult and feel the need to consult something simpler, we suggest you try
Popkorn‚Äôs text. Like the present book it is semantically oriented and takes for
granted that modal logic has more to offer than the basic modal language. It is
clearly written, mathematically precise, and besides the present book, it is the
only textbook we know that discusses bisimulations.
‚ó¶ Self-Reference and Modal Logic, Smory≈Ñski [416]. The classic introduction to
provability logic. Beautifully written. More demanding than the Boolos volume.
‚ó¶ From Modal Logic to Deductive Databases, edited by Thayse [430]. Wide-
ranging introduction to modal logic. Discusses links with natural language, tem-
poral reasoning, various forms of defeasible reasoning, and deductive databases.
Books in Other Languages
Next, here is a list of books in languages other than English, without comments.
‚ó¶ Essai de Logique D√©ontique, Bailhache [17].
‚ó¶ Logicaboek, Batens [30].
‚ó¶ Fondements Logiques du Raisonnement Contextuel. Une Etude sur les Logiques
des Conditionnels, Crocco [101].
‚ó¶ Logica, SigniÔ¨Åcato e Intelligenza ArtiÔ¨Åciale, Frixione [143].A Guide to the Literature
519
‚ó¶ La Logique du Temps, Gardies [161].
‚ó¶ Essai sur les Logiques des Modalit√©s, Gardies [162].
‚ó¶ Logique. Volume 3. M√©thodes pour l‚Äôintelligence artiÔ¨Åcielle, Gochet, Gri-
bomont, and Thayse [174].
‚ó¶ Una Introducci√≥n a la L√≥gica Modal, Jansana [244].
‚ó¶ La Logique D√©ductive, Kalinowski [257].
‚ó¶ Glauben, Wissen und Wahrscheinlichkeit. Systeme der Epistemischen Logik,
Lenzen [298].
‚ó¶ Pour une Logique du Sens, Martin [315].
‚ó¶ Forcing et S√©mantique de Kripke-Joyal, Moens [331].
‚ó¶ Essais sur les Logiques non Chrysipiennes, Moisil [332].
‚ó¶ Klassische und nichtklassische Aussagenlogik, Rautenberg [373].
Survey Articles
Note that virtually all the survey articles listed below are drawn from the following
sources:
‚ó¶ Handbook of Automated Reasoning, edited by Robinson and Voronkov [388].
‚ó¶ Handbook of Logic and Language, edited by van Benthem and ter Meulen [51].
‚ó¶ Handbook of Logic in ArtiÔ¨Åcial Intelligence and Logic Programming, edited by
Gabbay, Hogger, and Robinson [157, 158].
‚ó¶ Handbook of Logic in Computer Science, edited by Abramsky, Gabbay, and
Maibaum [1].
‚ó¶ Handbook of Philosophical Logic, edited by Gabbay and Guenthner [154].
‚ó¶ Handbook of Proof Theory, edited by Buss [83].
‚ó¶ Handbook of Tableau Methods, edited by D‚ÄôAgostino, Gabbay, H√§hnle, and
Posegga [104].
‚ó¶ Handbook of Theoretical Computer Science, edited by van Leeuwen [293].
In fact, these handbooks contain surveys of many other topics in, or related to,
modal logic including: auto-epistemic logic, belief revision, combinations of tense
and modality, computational treatments of time, conditional logic, decision pro-
cedures, deontic logic, description logics, epistemic aspects of databases, general
decidable fragments, higher-order modal logic, logics of programs, non-monotonic
temporal reasoning, philosophical perspectives on Ô¨Årst-order modal logic, prov-
ability logic, reasoning about knowledge, time and change in AI.
‚ó¶ Correspondence Theory, van Benthem [43]. For many years this was the only
easily accessible general reference on correspondence theory, and it is still well
worth reading. Lots of telling examples, and propelled by a clear vision of what
the modal enterprise is all about.520
D A Guide to the Literature
‚ó¶ Temporal Logic, van Benthem [47]. A wide-ranging and thoughtful discussion
of key themes in temporal logic.
‚ó¶ Basic Modal Logic, Bull and Segerberg [75]. An interesting survey, rich in
historical detail, which provides a useful point of entry to a topic barely touched
on in the present book: the Ô¨Åne structure of the lattice of normal modal logics in
the basic modal language.
‚ó¶ Basic Tense Logic, Burgess [79]. An accessible survey, mostly devoted to the ba-
sic temporal language, but touching on until-based logics and multi-dimensional
systems. Contains many useful examples of step-by-step completeness proofs.
‚ó¶ Advanced Modal Logic, Chagrov, Wolter and Zakharyaschev [87]. Takes up the
story where the Bull and Segerberg survey leaves off. Strong on the Ô¨Åne structure
of the lattice of normal modal logics.
‚ó¶ Reasoning in Description Logics, Donini, Lenzerini, Nardi, and Schaerf [115].
Approachable overview article which discusses four types of reasoning impor-
tant in description logic. Both inference techniques and complexity results are
covered.
‚ó¶ Temporal and Modal Logic, Emerson [121]. A detailed introduction to temporal
logic from the perspective of theoretical computer science. Somewhat dated, but
still a good introduction.
‚ó¶ Basic Modal Logic, Fitting [138]. An extremely clear introductory survey. Starts
with a good discussion of the basic modal language (including Hilbert systems,
natural deduction, tableaux methods, the standard translation, and alternative
semantics), and then goes on to examine Ô¨Årst-order modal logic.
‚ó¶ Varieties of Complex Algebras and Algebraic Polymodal Logic, Goldblatt [186,
181]. Both of these provide an introduction to the study of varieties of BAOs,
emphasizing their connections with modal logics, and focusing on structural
properties (such as canonicity) that are related to natural properties of modal
logical systems.
‚ó¶ Tableau Methods for Modal and Temporal Logics, Gor√© [193]. Detailed survey
of tableaux based proof methods for temporal languages.
‚ó¶ Dynamic Logic, Harel [209]. If you want to learn more about PDL, this is a
good place to look, though it is more densely written than Harel, Kozen and
Tiuryn [212]. Discusses a wide range of variants and extensions of PDL.
‚ó¶ The Logic of Provability, Japaridze and de Jongh [245]. A thorough overview of
provability logic, covering propositional provability logic, interpretability logic
and related areas, as well as predicate provability logic.
‚ó¶ A Survey of Boolean Algebras with Operators, J√≥nsson [253]. Gives an algebraic
introduction to the theory of boolean algebras with operators. The papers by
Goldblatt and this one by J√≥nsson are highly recommended to readers who want
more on the algebraic side of modal logic than our Chapter 5 offers.A Guide to the Literature
521
‚ó¶ Logics of Programs, Kozen and Tiuryn [274]. Essentially (though not entirely)
an introduction to PDL. Useful, but Harel, Kozen and Tiuryn [212] is probably a
better choice.
‚ó¶ Resolution Decision Procedures, Leitsch, Ferm√ºller and Tammet [294]. An ex-
tensive survey of resolution-based decision procedures for fragments of Ô¨Årst-
order logic. Covers procedures for modal and guarded fragments and fragments
corresponding to description logics.
‚ó¶ Encoding Non-Classical Logics in Classical Logic, Ohlbach, de Rijke, Non-
nengart, and Gabbay [345]. A computationally oriented overview of translation
methods for mapping modal and modal-like languages into Ô¨Årst-order logic. Dis-
cusses various Ô¨Çavors of the standard (relational) translation and the functional
translation, from the point of view of both expressive power and decidability.
‚ó¶ Feature Logics, Rounds [394]. Authoritative survey of feature logic. Devotes a
lot of attention to the modal aspects of feature logic.
‚ó¶ Modal and Temporal Logics, Stirling [424]. An extremely useful, technically
oriented article which will appeal to many readers of this volume. Starting with
many of the same tools introduced in this book (transition systems, bisimula-
tions, correspondence theory, unraveling), it goes on to discuss many other top-
ics such as modal Œº-calculi and links with automata theory.
‚ó¶ An Overview of Interpretability Logic, Visser [451]. An elegant overview of
interpretability logic, an extension of provability logic which deals with inter-
pretations between formal theories.
‚ó¶ Canonical Formulas for Modal and Superintuitionistic Logics: A Short Outline,
Zakharyaschev [467]. Canonical formulas are an important frame-theoretic ap-
proach to the classiÔ¨Åcation of modal formulas. This is an accessible survey, by
the inventor of the method, with plenty of motivations, examples and deÔ¨Ånitions.
Other Books
‚ó¶ Vicious Circles, Barwise and Moss [27]. An introduction to non-well-founded
set theory, a set theory where bisimulation rather than extensionality is the key
concept. The authors advocate using inÔ¨Ånitary modal logic to study such struc-
tures, and the area is becoming a research area in its own right.
‚ó¶ Modal Logic and Classical Logic, van Benthem [42]. This book (a reworking of
the author‚Äôs PhD thesis) is the primary source on what is now called correspon-
dence theory. Although most of the book is devoted to frame deÔ¨Ånability, this
is also where bisimulations (under the name p-relations) were introduced and
shown to capture modal expressivity over models. It may be hard to get hold of,
but it is well worth making the effort.
‚ó¶ Logic of Time, van Benthem [45]. Explores temporal logic model-theoretically;
modal logic is just one strand in the story. The book makes many interesting522
D A Guide to the Literature
technical contributions (notably in the study of interval structures) but its real
importance is methodological: it is by far the most convincing demonstration
we know of the light model-theoretic methods can throw on difÔ¨Åcult conceptual
issues.
‚ó¶ Reasoning about Knowledge, Fagin, Halpern, Moses and Vardi [125]. Looks set
to be the key reference on epistemic logic for quite some time to come. Treats a
wide range of topics from a modern semantically-oriented perspective. Clearly
written. Highly recommended.
‚ó¶ Labelled Deductive Systems, Gabbay [151]. This is not a book on modal logic,
but an introduction to a proof theoretical methodology. But modal logics provide
many of the nicest examples of the labeling method in action, and if you are
interested in modal proof theory you need to know about this.
‚ó¶ Temporal Logics. Mathematical Foundations and Computational Aspects. Vol-
ume 1, Gabbay, Hodkinson and Reynolds [156]. The Ô¨Årst of three projected
volumes, this book discusses basic completeness and incompleteness, the tem-
poral logics of special structures (such as R), multi-dimensional temporal logic,
Ô¨Åxed-point logic and propositional quantiÔ¨Åcation, and much else besides. Con-
tains a detailed discussion of expressive completeness.
‚ó¶ Cylindric Algebras, Parts I & II, by Henkin, Monk and Tarski [218]. The deÔ¨Åni-
tive work on cylindric algebras, it also contains a wealth of results on other
branches of algebraic logic and on boolean algebras with operators in general.
‚ó¶ Relation Algebras by Games, by Hodkinson and Hirsch [226]. Still in manu-
script form at the time of writing, this work promises to become a standard
reference on relation algebras. Strong on the connections between relation alge-
bras and model theory and a convincing argument for the application of games
in algebraic logic.
‚ó¶ The Temporal Logic of Reactive and Concurrent Systems. Volume 1: SpeciÔ¨Åca-
tion, Manna and Pnueli [312]. Textbook aimed at computer scientists interested
in specifying reactive systems. All the necessary temporal logic is introduced
and explained in the course of the book.
‚ó¶ The Temporal VeriÔ¨Åcation of Reactive Systems. Volume 2: Safety, Manna and
Pnueli [313]. Follow up to the previous volume, emphasizing safety issues.
‚ó¶ Multidimensional Modal Logic, Marx and Venema [320]. The key reference
for work in multi-dimensional modal logic. Discusses two-dimensional modal
logics, arrow logics, modal logics of intervals, modal logics of relations, and the
problem of deÔ¨Åning ‚Äòconcrete‚Äô semantics (in the sense of Henkin) for arbitrary
modal languages.
‚ó¶ Temporal Logic, √òhrstrom and Hasle [347]. Introduction to temporal logic from
a historical perspective. A good way of getting to grips with Prior‚Äôs work.
‚ó¶ Past, Present and Future, Prior [365]. Arthur Prior seems to be one of those
authors more often cited than read. This is pity: if you push on past his use ofA Guide to the Literature
523
Polish notation you will discover a fascinating writer with a surprisingly up to
date range of concerns.
‚ó¶ Set Theory and the Continuum Problem, Smullyan and Fitting [418]. So why is
this one here? Because in Part III of the book the authors show how Cohen-style
forcing arguments can be formulated using Ô¨Årst-order S4. Roughly speaking,
they prove independence results using sophisticated step-by-step arguments.
‚ó¶ Proof Theory of Modal Logic, Wansing [454]. A collection of papers devoted to
proof-theoretical aspects of modal logic, covering many Ô¨Çavors of proof theory:
sequents, resolution, tableaux, display calculi, and translation-based approaches.
‚ó¶ Displaying Modal Logic, Wansing [455]. A proof-theoretical monograph that
shows in detail how to deÔ¨Åne display calculi for modal logics.
‚ó¶ Modal Logic: The Lewis Modal Systems, Zeman [474]. Provides sequent proof
systems for the Lewis systems and some others. Written by a student of Arthur
Prior, it draws on some of Prior‚Äôs unpublished classroom material. Clearly writ-
ten. Uses Polish notation.
The Œ©-bibliography
Finally, a fairly comprehensive bibliography of books and articles on modal (and
various non-classical) logics is provided by Volume II of the Œ©-bibliography of
mathematical logic. The references in this volume, edited by Rautenberg [375],
stop somewhere in the 1980s; nevertheless, this work can be the starting point of a
fascinating quest for treasures in the earlier literature of modal logic.Bibliography
[1]
[2]
[3]
[4]
[5]
[6]
[7]
[8]
[9]
[10]
[11]
[12]
[13]
[14]
[15]
S. Abramsky, D.M. Gabbay, and T.S.E. Maibaum, editors. Handbook of Logic in
Computer Science, volume 2. Clarendon Press, 1992.
P. Aczel. Non-Well-Founded Sets. CSLI Publications, 1988.
M. Aiello and J. van Benthem. A modal walk through space. Journal of Applied
Non-Classical Logics, 12:319‚Äì364, 2002.
C.E. Alchourr√≥n, P. G√§rdenfors, and D. Makinson. On the logic of theory change:
partial meet contraction and revision functions. Journal of Symbolic Logic, 50:510‚Äì
530, 1985.
A. Andr√©ka, A. Kurucz, I. N√©meti, and I. Sain. Applying algebraic logic to logic. In
M. Nivat and M. Wirsing, editors, Algebraic Methodology and Software Technology,
pages 201‚Äì221. Springer, 1994.
H. Andr√©ka. Complexity of equations valid in algebras of relations. Annals of Pure
and Applied Logic, 89:149‚Äì229, 1997.
H. Andr√©ka, I.M. Hodkinson, and I. N√©meti. Finite algebras of relations are repre-
sentable on Ô¨Ånite sets. Journal of Symbolic Logic, 64:243‚Äì267, 1999.
H. Andr√©ka, J.D. Monk, and I. N√©meti, editors. Algebraic Logic. (Proceedings of
the 1988 Budapest Conference), volume 54 of Colloquia Mathematica Societatis
J√°nos Bolyai. North-Holland Publishing Company, 1991.
H. Andr√©ka, J. van Benthem, and I. N√©meti. Modal languages and bounded frag-
ments of predicate logic. Journal of Philosophical Logic, 27:217‚Äì274, 1998.
I.H. Anellis and N. Houser. Nineteenth century roots of algebraic logic and universal
algebra. In Andr√©ka et al. [8], pages 1‚Äì36.
L. √Öqvist, F. Guenthner, and C. Rohrer. DeÔ¨Ånability in ITL of some subordinate
temporal conjunctions in English. In F. Guenthner and C. Rohrer, editors, Studies
in Formal Semantics, pages 201‚Äì221. North Holland, 1978.
C. Areces. Logic Engineering: The Case of Description and Hybrid Logics. PhD
thesis, ILLC, University of Amsterdam, 2000.
C. Areces, P. Blackburn, and M. Marx. The computational complexity of hybrid
temporal logics. Logic Journal of the IGPL, 8(5):653‚Äì679, 2000.
C. Areces, P. Blackburn, and M. Marx. Hybrid logics: Characterization, interpola-
tion and complexity. Journal of Symbolic Logic, 66:977‚Äì1010, 2001.
C. Areces and M. de Rijke. Description and/or hybrid logic. In Workshop Proceed-
ings AiML-2000, pages 1‚Äì14. Institut f√ºr Informatik, Universit√§t Leipzig, 2000.
524Bibliography
[16]
[17]
[18]
[19]
[20]
[21]
[22]
[23]
[24]
[25]
[26]
[27]
[28]
[29]
[30]
[31]
[32]
[33]
[34]
[35]
[36]
[37]
[38]
[39]
[40]
525
F. Baader and K. Schulz, editors. Frontiers of Combining Systems 1. Kluwer Aca-
demic Publishers, 1996.
P. Bailhache. Essai de Logique D √©ontique. Mathesis, 1991.
P. Balbiani, N.-Y. Suzuki, F. Wolter, and M. Zakharyaschev, editors. Advances in
Modal Logic, Volume 4. King‚Äôs College London Publications, 2003.
Ph. Balbiani, L. Fari√±as del Cerro, T. Tinchev, and D. Vakarelov. Modal logics for
incidence geometries. Journal of Logic and Computation, 7:59‚Äì78, 1997.
A. Baltag. STS: A Structural Theory of Sets. PhD thesis, Indiana University, Bloom-
ington, Indiana, 1998.
A. Baltag. A logic for suspicious players: epistemic actions and belief updates
in games. Bulletin of Economic Research, to appear, 2000. Paper presented at
the Fourth Conference on Logic and the Foundations of the Theory of Games and
Decisions.
A. Baltag. STS: a structural theory of sets. In Zakharyaschev et al. [469].
B. Banieqbal, H. Barringer, and A. Pnueli, editors. Proc. Colloquium on Temporal
Logic in SpeciÔ¨Åcation, volume 398 of LNCS. Springer, 1989.
H. Barendregt. The Lambda Calculus: Its Syntax and Semantics. North-Holland
Publishing Company, 1984.
J. Barwise. Model-theoretic logics: background and aims. In Barwise and Feferman
[26], pages 3‚Äì23.
J. Barwise and S. Feferman, editors. Model-Theoretic Logics. Springer, 1985.
J. Barwise and L. Moss. Vicious Circles, volume 60 of Lecture Notes. CSLI Publi-
cations, 1996.
J. Barwise and L.S. Moss. Modal correspondence for models. Journal of Philo-
sophical Logic, 27:275‚Äì294, 1998.
D. Basin and N. Klarlund. Automata based symbolic reasoning in hardware veriÔ¨Å-
cation. Journal of Formal Methods in Systems Design, 13:255‚Äì288, 1998.
D. Batens. Logicaboek. Garant Leven, Apeldoorn, 1991.
P. Battigalli and G. Bonanno. Recent results on belief, knowledge and the founda-
tions of game theory. Research in Economics, 53:149‚Äì225, 1999.
J.L. Bell and M. Machover. A Course in Mathematical Logic. North-Holland Pub-
lishing Company, 1977.
J.L. Bell and A.B. Slomson. Models and Ultraproducts. North-Holland Publishing
Company, 1969.
B. Bennet, C. Dixon, M. Fisher, E. Franconi, I. Horrocks, U. Hustadt, and
M. de Rijke. Combinations of modal logic. Journal of AI Reviews, 17:1‚Äì20, 2002.
J. van Benthem. A note on modal formulas and relational properties. Journal of
Symbolic Logic, 40:85‚Äì88, 1975.
J. van Benthem. Modal Correspondence Theory. PhD thesis, Mathematisch Insti-
tuut & Instituut voor Grondslagenonderzoek, University of Amsterdam, 1976.
J. van Benthem. Two simple incomplete modal logics. Theoria, 44:25‚Äì37, 1978.
J. van Benthem. Minimal deontic logics. Bulletin of the Section of Logic, 8:36‚Äì42,
1979.
J. van Benthem. Syntactical aspects of modal incompleteness theorems. Theoria,
45:63‚Äì77, 1979.
J. van Benthem. Canonical modal logics and ultraÔ¨Ålter extensions. Journal of Sym-
bolic Logic, 44:1‚Äì8, 1980.526
[41]
[42]
[43]
[44]
[45]
[46]
[47]
[48]
[49]
[50]
[51]
[52]
[53]
[54]
[55]
[56]
[57]
[58]
[59]
[60]
[61]
[62]
[63]
[64]
Bibliography
J. van Benthem. Some kinds of modal completeness. Studia Logica, 39:125‚Äì141,
1980.
J. van Benthem. Modal Logic and Classical Logic. Bibliopolis, 1983.
J. van Benthem. Correspondence theory. In Gabbay and Guenthner [154], pages
167‚Äì247.
J. van Benthem. A Manual of Intensional Logic, volume 1 of Lecture Notes. CSLI
Publications, 1985.
J. van Benthem. The Logic of Time. Kluwer Academic Publishers, second edition,
1991.
J. van Benthem. Modal frame classes revisited. Fundamenta Informaticae, 18:307‚Äì
317, 1993.
J. van Benthem. Temporal logic. In Gabbay et al. [158], pages 241‚Äì351.
J. van Benthem. Exploring Logical Dynamics. Studies in Logic, Language and
Information. CSLI Publications, 1996.
J. van Benthem. Dynamic bits and pieces. Technical Report LP-97-01, Institute for
Language, Logic and Computation, 1997.
J. van Benthem and W. Meyer Viol. Logical semantics of programming. Unpub-
lished lecture notes. University of Amsterdam, 1993.
J. van Benthem and A. ter Meulen, editors. Handbook of Logic and Language.
Elsevier Science, 1997.
R. Berger. The undecidability of the domino problem. Technical Report 66, Mem.
Amer. Math. Soc., 1966.
G. Birkhoff. On the structure of abstract algebras. Proceedings of the Cambridge
Philosophical Society, 29:441‚Äì464, 1935.
P. Blackburn. Nominal tense logic. Notre Dame Journal of Formal Logic, 34:56‚Äì83,
1993.
P. Blackburn. Tense, temporal reference, and tense logic. Journal of Semantics,
11:83‚Äì101, 1994.
P. Blackburn. Internalizing labelled deduction. Journal of Logic and Computation,
10:137‚Äì168, 2000.
P. Blackburn. Representation, reasoning, and relational structures: a hybrid logic
manifesto. Logic Journal of the IGPL, 8:339‚Äì365, 2000.
P. Blackburn, C. Gardent, and W. Meyer-Viol. Talking about trees. In Proceedings
of the 6th Conference of the European Chapter of the Association for Computational
Linguistics, pages 21‚Äì29, 1993.
P. Blackburn and J. Seligman. Hybrid languages. Journal of Logic, Language and
Information, 4:251‚Äì272, 1995.
P. Blackburn and J. Seligman. What are hybrid languages? In Kracht et al. [281],
pages 41‚Äì62.
P. Blackburn and E. Spaan. A modal perspective on the computational complexity of
attribute value grammar. Journal of Logic, Language and Information, 2:129‚Äì169,
1993.
P. Blackburn and M. Tzakova. Hybridizing concept languages. Annals of Mathe-
matics and ArtiÔ¨Åcial Intelligence, 24:23‚Äì49, 1998.
P. Blackburn and M. Tzakova. Hybrid languages and temporal logic. Logic Journal
of the IGPL, 7(1):27‚Äì54, 1999.
W.J. Blok. An axiomatization of the modal theory of the veiled recession frame.Bibliography
[65]
[66]
[67]
[68]
[69]
[70]
[71]
[72]
[73]
[74]
[75]
[76]
[77]
[78]
[79]
[80]
[81]
[82]
[83]
[84]
[85]
[86]
[87]
[88]
[89]
527
Technical report, Department of Mathematics, University of Amsterdam, 1977.
W.J. Blok. On the degree of incompleteness in modal logic and the covering rela-
tions in the lattice of modal logics. Technical Report 78‚Äì07, Department of Mathe-
matics, University of Amsterdam, 1978.
W.J. Blok. The lattice of modal algebras: An algebraic investigation. Journal of
Symbolic Logic, 45:221‚Äì236, 1980.
W.J. Blok and D. Pigozzi. Algebraizable logics. Memoirs of the American Mathe-
matical Society, 77, 396, 1989.
G. Boolos. The Unprovability of Consistency. Cambridge University Press, 1979.
G. Boolos. The Logic of Provability. Cambridge University Press, 1993.
G. Boolos and R. Jeffrey. Computability and Logic. Cambridge University Press,
1989.
E. B√∂rger, E. Gr√§del, and Y. Gurevich. The Classical Decision Problem. Springer,
1997.
J.R. B√ºchi. On a decision method in restricted second order arithmetic. In Pro-
ceedings International Congress on Logic, Methodology and Philosophy of Science
1960. Stanford University Press, 1962.
R. Bull. An approach to tense logic. Theoria, 36:282‚Äì300, 1970.
R.A. Bull. That all normal extensions of S4.3 have the Ô¨Ånite model property.
Zeitschrift f√ºr mathemathische Logik und Grundlagen der Mathematik, 12:314‚Äì344,
1966.
R.A. Bull and K. Segerberg. Basic modal logic. In Gabbay and Guenthner [154],
pages 1‚Äì88.
P. Buneman, S. Davidson, M. Fernandez, and D. Suciu. Adding structure to un-
structered data. In Proceedings ICDT‚Äô97, 1997.
J. Burgess. Decidability for branching time. Studia logica, 39:203‚Äì218, 1980.
J. Burgess. Axioms for tense logic I: ‚Äòsince‚Äô and ‚Äòuntil‚Äô. Notre Dame Journal of
Formal Logic, 23:375‚Äì383, 1982.
J.P. Burgess. Basic tense logic. In Gabbay and Guenthner [154], pages 89‚Äì133.
J.P. Burgess and Y. Gurevich. The decision problem for linear temporal logic. Notre
Dame Journal of Formal Logic, 26:115‚Äì128, 1985.
S. Burris and H.P. Sankappanavar. A Course in Universal Algebra. Graduate Texts
in Mathematics. Springer, 1981.
R. Burstall. Program proving as hand simulation with a little induction. In Informa-
tion Processing ‚Äô74, pages 308‚Äì312. North-Holland Publishing Company, 1974.
S.R. Buss, editor. Handbook of Proof Theory. Elsevier Science, 1998.
D. Calvanese, G. De Giacomo, and M. Lenzerini. Modeling and querying semi-
structured data. Networking and Information Systems, pages 253‚Äì273, 1999.
R. Carnap. Modalities and quantiÔ¨Åcation. Journal of Symbolic Logic, 11:33‚Äì64,
1946.
R. Carnap. Meaning and Necessity. University of Chicago Press, 1947.
A. Chagrov, F. Wolter, and M. Zakharyaschev. Advanced modal logic. In Handbook
of Philosophical Logic, volume 3, pages 83‚Äì266. Kluwer Academic Publishers, sec-
ond edition, 2001.
A. Chagrov and M. Zakharyaschev. Modal Logic, volume 35 of Oxford Logic
Guides. Oxford University Press, 1997.
L.A. Chagrova. An undecidable problem in correspondence theory. Journal of528
Bibliography
Symbolic Logic, 56:1261‚Äì1272, 1991.
D. Chalmers. The Conscious Mind. Oxford University Press, 1996.
C.C. Chang and H.J. Keisler. Model Theory. North-Holland Publishing Company,
Amsterdam, 1973.
[92] B.F. Chellas. Modal Logic, an Introduction. Cambridge University Press, 1980.
[93] B. Chlebus. Domino-tiling games. Journal of Computer and System Sciences,
32:374‚Äì392, 1986.
[94] E.M. Clarke and E.A. Emerson. Design and synthesis of synchronisation skeletons
using branching time temporal logic. In D. Kozen, editor, Logics of Programs, pages
52‚Äì71. Springer, 1981.
[95] E.M. Clarke, O. Grumberg, and D.A. Peled. Model Checking. The MIT Press, 1999.
[96] E.M. Clarke and B.-H. Schlingloff. Model checking. In Robinson and Voronkov
[388].
[97] B.J. Copeland, editor. Logic and Reality. Essays on the Legacy of Arthur Prior.
Clarendon Press, 1996.
[98] W. Craig. On axiomatizability within a system. Journal of Symbolic Logic, 18:30‚Äì
32, 1953.
[99] M.J. Cresswell. A Henkin completeness theorem for T. Notre Dame Journal of
Formal Logic, 8:186‚Äì90, 1967.
[100] M.J. Cresswell. An incomplete decidable modal logic. Journal of Symbolic Logic,
49:520‚Äì527, 1984.
[101] G. Crocco. Fondements Logiques du Raisonnement Contextuel. Une Etude sur les
Logiques des Conditionnels. Padova Unipress, 1996.
[102] L. Csirmaz, D.M. Gabbay, and M. de Rijke, editors. Logic Colloquium ‚Äô92, num-
ber 1 in Studies in Logic, Language and Information. CSLI Publications, 1995.
[103] N. Cutland. Computability. An Introduction to Recursive Function Theory. Cam-
bridge University Press, 1980.
[104] M. D‚ÄôAgostino, D.M. Gabbay, R. H√§hnle, and J. Posegga, editors. Handbook of
Tableau Methods. Kluwer Academic Publishers, 1999.
[105] B.A. Davey and H.A. Priestly. Introduction to Lattices and Order. Cambridge
University Press, 1990.
[106] G. De Giacomo. Decidability of Class-Based Knowledge Representation For-
malisms. PhD thesis, Universit√† di Roma ‚ÄúLa Sapienza‚Äù, 1995.
[107] S. Demri. Sequent calculi for nominal tense logics: a step towards mechanization?
In Murray [339], pages 140‚Äì154.
[108] S. Demri and R. Gor√©. Cut-free display calculi for nominal tense logics. In Murray
[339], pages 155‚Äì170.
[109] H. van Ditmarsch. Knowledge Games. PhD thesis, Department of Mathematics and
Computer Science, Rijksuniversiteit Groningen, 2000.
[110] H.C. Doets. Completeness and DeÔ¨Ånability: Applications of the Ehrenfeucht Game
in Intensional and Second-Order Logic. PhD thesis, Department of Mathematics
and Computer Science, University of Amsterdam, 1987.
[111] K. Doets. Basic Model Theory. Studies in Logic, Language and Information. CSLI
Publications, 1996.
[112] K. Doets and J. van Benthem. Higher-order logic. In Gabbay and Guenthner [153],
pages 275‚Äì329.
[113] J. Doner. Tree acceptors and some of their applications. Journal of Computer and
[90]
[91]Bibliography
529
System Sciences, 4:406‚Äì451, 1970.
[114] F.M. Donini, M. Lenzerini, D. Nardi, and W. Nutt. The complexity of concept
languages. Information and Computation, 134:1‚Äì58, 1997.
[115] F.M. Donini, M. Lenzerini, D. Nardi, and A. Schaerf. Reasoning in description
logics. In G. Brewka, editor, Principles of Knowledge Representation, Studies in
Logic, Language and Information, pages 191‚Äì236. CSLI Publications, 1996.
[116] J. Dugundji. Note on a property of matrices for Lewis and Langford‚Äôs calculi of
propositions. Journal of Symbolic Logic, 5:150‚Äì151, 1940.
[117] M.A.E. Dummett and E.J. Lemmon. Modal logics between S4 and S5. Zeitschrift
f√ºr mathemathische Logik und Grundlagen der Mathematik, 5:250‚Äì264, 1959.
[118] H.-D. Ebbinghaus and J. Flum. Finite Model Theory. Perspectives in Mathematical
Logic. Springer, 1995.
[119] A. Ehrenfeucht. An application of games to the completeness problem for formal-
ized theories. Fundamenta Mathematicae, 49:129‚Äì141, 1961.
[120] P. van Emde Boas. The convenience of tilings. Technical Report CT-96-01, ILLC,
University of Amsterdam, 1996.
[121] E.A. Emerson. Temporal and modal logics. In van Leeuwen [293], pages 995‚Äì1072.
[122] H.B. Enderton. A Mathematical Introduction to Logic. Academic Press, New York,
1972.
[123] L.L. Esakia. Topological Kripke models. Soviet Mathematics Doklady, 15:147‚Äì151,
1974.
[124] L.L. Esakia and V.Yu. Meskhi. Five critical systems. Theoria, 40:52‚Äì60, 1977.
[125] R. Fagin, J.Y. Halpern, Y. Moses, and M.Y. Vardi. Reasoning About Knowledge.
The MIT Press, 1995.
[126] T. Fernando. A modal logic for non-deterministic discourse processing. Journal of
Logic, Language and Information, 8:455‚Äì468, 1999.
[127] K. Fine. Propositional quantiÔ¨Åers in modal logic. Theoria, 36:331‚Äì346, 1970.
[128] K. Fine. The logics containing S4.3. Zeitschrift f √ºr mathemathische Logik und
Grundlagen der Mathematik, 17:371‚Äì376, 1971.
[129] K. Fine. An incomplete logic containing S4. Theoria, 40:23‚Äì29, 1974.
[130] K. Fine. Logics extending K4. Part I. Journal of Symbolic Logic, 39:31‚Äì42, 1974.
[131] K. Fine. Normal forms in modal logic. Notre Dame Journal of Formal Logic,
16:229‚Äì234, 1975.
[132] K. Fine. Some connections between elementary and modal logic. In Kanger [263].
[133] K. Fine. Modal logics containing K4. Part II. Journal of Symbolic Logic, 50:619‚Äì
651, 1985.
[134] M. Finger. Handling database updates in two-dimensional temporal logic. Journal
of Applied Non-Classical Logics, 2:201‚Äì224, 1992.
[135] M.J. Fischer and R.E. Ladner. Propositional dynamic logic of regular programs.
Journal of Computer and System Sciences, 18:194‚Äì211, 1979.
[136] F. Fitch. A correlation between modal reduction principles and properties of rela-
tions. Journal of Philosophical Logic, 2:97‚Äì101, 1973.
[137] M. Fitting. Proof Methods for Modal and Intuitionistic Logic. Reidel, 1983.
[138] M. Fitting. Basic modal logic. In Gabbay et al. [157], pages 368‚Äì449.
[139] M. Fitting. Types, Tableaus, and Goedel‚Äôs God. Kluwer Academic Publishers, 2002.
[140] M. Fitting and R.L. Mendelsohn. First-Order Modal Logic. Kluwer Academic
Publishers, 1998.530
Bibliography
[141] R. Fraƒ±Ãàss√©. Sur quelques classiÔ¨Åcations des syst√®mes de relations. Publ. Sci. Univ.
Alger., 1:35‚Äì182, 1954.
[142] N. Friedman and J.Y. Halpern. Modeling belief in dynamic systems, part i: Foun-
dations. ArtiÔ¨Åcial Intelligence, 95:257‚Äì316, 1997.
[143] M. Frixione. Logica, SigniÔ¨Åcato e Intelligenza ArtiÔ¨Åciale. FrancoAngeli, Milano,
1994.
[144] A. Fuhrmann. On the modal logic of theory change. In A. Fuhrmann and M. Mor-
reau, editors, LNAI, volume 465, pages 259‚Äì281. Springer, 1990.
[145] D.M. Gabbay. Decidability results in non-classical logics. Annals of Mathematical
Logic, 10:237‚Äì285, 1971.
[146] D.M. Gabbay. On decidable, Ô¨Ånitely axiomatizable modal and tense logics without
the Ô¨Ånite model property I. Israel Journal of Mathematics, 10:478‚Äì495, 1971.
[147] D.M. Gabbay. On decidable, Ô¨Ånitely axiomatizable modal and tense logics without
the Ô¨Ånite model property II. Israel Journal of Mathematics, 10:496‚Äì503, 1971.
[148] D.M. Gabbay. The separation property of tense logics. Unpublished manuscript,
September 1979.
[149] D.M. Gabbay. An irreÔ¨Çexivity lemma with applications to axiomatizations of con-
ditions on linear frames. In U. M√∂nnich, editor, Aspects of Philosophical Logic,
pages 67‚Äì89. Reidel, 1981.
[150] D.M. Gabbay. The declarative past and imperative future: executable temporal logic
for interactive systems. In Banieqbal et al. [23], pages 431‚Äì448.
[151] D.M. Gabbay. Labelled Deductive Systems. Clarendon Press, Oxford, 1996.
[152] D.M. Gabbay and M. de Rijke, editors. Frontiers of Combining Systems 2. Research
Studies Press, 2000.
[153] D.M. Gabbay and F. Guenthner, editors. Handbook of Philosophical Logic, vol-
ume 1. Reidel, 1983.
[154] D.M. Gabbay and F. Guenthner, editors. Handbook of Philosophical Logic, vol-
ume 2. Reidel, 1984.
[155] D.M. Gabbay and I.M. Hodkinson. An axiomatization of the temporal logic with
Since and Until over the real numbers. Journal of Logic and Computation, 1:229‚Äì
259, 1991.
[156] D.M. Gabbay, I.M. Hodkinson, and M. Reynolds. Temporal Logic: Mathematical
Foundations and Computational Aspects. Oxford University Press, 1994.
[157] D.M. Gabbay, C.J. Hogger, and J.A. Robinson, editors. Handbook of Logic in Ar-
tiÔ¨Åcial Intelligence and Logic Programming, volume 1. Oxford University Press,
1993.
[158] D.M. Gabbay, C.J. Hogger, and J.A. Robinson, editors. Handbook of Logic in Ar-
tiÔ¨Åcial Intelligence and Logic Programming, volume 4. Oxford University Press,
1994.
[159] D.M. Gabbay, A. Kurucz, F. Wolter, and M. Zakharyaschev. Many-Dimensional
Modal Logics: Theory and Applications, volume 146 of Studies in Logic and the
Foundations of Mathematics. Elsevier, 2003.
[160] D.M. Gabbay, A. Pnueli, S. Shelah, and J. Stavi. On the temporal analysis of fair-
ness. In Proc. 7th ACM Symposium on Principles of Programming Languages,
pages 163‚Äì173, 1980.
[161] J. Gardies. La Logique du Temps. Presses Universitaires de France, Paris, 1975.
[162] J. Gardies. Essai sur les Logiques des Modalit √©s. Presses Universitaires de France,Bibliography
531
Paris, 1979.
[163] M.R. Garey and D.S. Johnson. Computers and Intractibility. A Guide to the Theory
of NP-Completeness. W.H. Freeman, 1979.
[164] G. Gargov and V. Goranko. Modal logic with names. Journal of Philosophical
Logic, 22:607‚Äì636, 1993.
[165] G. Gargov and S. Passy. A note on Boolean modal logic. In P.P. Petkov, editor,
Mathematical Logic. Proceedings of the 1988 Heyting Summerschool, pages 311‚Äì
321. Plenum Press, 1990.
[166] G. Gargov, S. Passy, and T. Tinchev. Modal environment for Boolean speculations.
In D. Skordev, editor, Mathematical Logic and its Applications, pages 253‚Äì263.
Plenum Press, 1987.
[167] F. Gecseg and M. Steinby. Tree languages. In Rozenberg and Salomaa [395], pages
1‚Äì68.
[168] M. Gehrke and J. Harding. Bounded lattice expansions. Journal of Algebra,
238:345‚Äì371, 2001.
[169] M. Gehrke and B. J√≥nsson. Bounded distributive lattices with operators. Mathemat-
ica Japonica, 40:207‚Äì215, 1994.
[170] J. Gerbrandy and W. Groeneveld. Reasoning about information change. Journal of
Logic, Language and Information, 6:147‚Äì169, 1997.
[171] S. Ghilardi and G. Meloni. Constructive canonicity in non-classical logics. Annals
of Pure and Applied Logic, 86:1‚Äì32, 1997.
[172] R. Girle. Modal Logics and Philosophy. Acumen, 2000.
[173] R. van Glabbeek. The linear time-branching time spectrum II; the semantics of
sequential processes with silent moves. In Proceedings CONCUR ‚Äô93, volume 715
of LNCS, pages 66‚Äì81. Springer, 1993.
[174] P. Gochet, P. Gribomont, and A. Thayse. Logique. Volume 3. M √©thodes pour
l‚Äôintelligence artiÔ¨Åcielle. Hermes, 2000.
[175] K. G√∂del. Eine Interpretation des intuitionistischen Aussagenkalk√ºlus. In Ergeb-
nisse eines mathematischen Kolloquiums 4, pages 34‚Äì40, 1933.
[176] R. Goldblatt. Semantic analysis of orthologic. Journal of Philosophical Logic,
3:19‚Äì35, 1974.
[177] R. Goldblatt. Logics of Time and Computation, volume 7 of Lecture Notes. CSLI
Publications, 1987.
[178] R. Goldblatt. Mathematics of Modality, volume 43 of Lecture Notes. CSLI Publi-
cations, 1993.
[179] R. Goldblatt. Saturation and the Hennessy-Milner property. In Ponse et al. [360].
[180] R. Goldblatt. Elementary generation and canonicity for varieties of boolean algebras
with operators. Algebra Universalis, 34:551‚Äì607, 1995.
[181] R. Goldblatt. Algebraic polymodal logic: a survey. Logic Journal of the IGPL,
8:393‚Äì450, 2000.
[182] R. Goldblatt. Mathematical modal logic: a view of its evolution, 2000. To appear.
Draft available at http://www.vuw.ac.nz/Àúrob.
[183] R.I. Goldblatt. First-order deÔ¨Ånability in modal logic. Journal of Symbolic Logic,
40:35‚Äì40, 1975.
[184] R.I. Goldblatt. Metamathematics of modal logic I. Reports on Mathematical Logic,
6:41‚Äì78, 1976.
[185] R.I. Goldblatt. Metamathematics of modal logic II. Reports on Mathematical Logic,532
Bibliography
7:21‚Äì52, 1976.
[186] R.I. Goldblatt. Varieties of complex algebras. Annals of Pure and Applied Logic,
38:173‚Äì241, 1989.
[187] R.I. Goldblatt. The McKinsey axiom is not canonical. Journal of Symbolic Logic,
56:554‚Äì562, 1991.
[188] R.I. Goldblatt and S.K. Thomason. Axiomatic classes in propositional modal logic.
In J. Crossley, editor, Algebra and Logic, pages 163‚Äì173. Springer, 1974.
[189] V. Goranko. Modal deÔ¨Ånability in enriched languages. Notre Dame Journal of
Formal Logic, 31:81‚Äì105, 1990.
[190] V. Goranko. Hierarchies of modal and temporal logics with reference pointers.
Journal of Logic, Language and Information, 5:1‚Äì24, 1996.
[191] V. Goranko and B. Kapron. The modal logic of the countable random frame. Archive
for Mathematical Logic, 42:221‚Äì243, 2003.
[192] V. Goranko and S. Passy. Using the universal modality: Gains and questions. Jour-
nal of Logic and Computation, 2:5‚Äì30, 1992.
[193] R. Gor√©. Tableau methods for modal and temporal logics. In D‚ÄôAgostino et al.
[104].
[194] E. Gr√§del. On the restraining power of guards. Journal of Symbolic Logic, 64:1719‚Äì
1742, 1999.
[195] E. Gr√§del, P. Kolaitis, and M.Y. Vardi. On the decision problem for two-variable
Ô¨Årst-order logic. Bulletin of Symbolic Logic, 3:53‚Äì69, 1997.
[196] E. Gr√§del, M. Otto, and E. Rosen. Two-variable logic with counting is decidable. In
Proceedings 12th IEEE Symposium on Logic in Computer Science LICS‚Äô97, 1997.
[197] E. Gr√§del and I. Walukiewicz. Guarded Ô¨Åxed point logic. In Proceedings 14th IEEE
Symposium on Logic in Computer Science LICS‚Äô99, 1999.
[198] G. Gr√§tzer. Universal Algebra. Springer, 1979.
[199] A.J. Grove, J.Y. Halpern, and D. Koller. Asymptotic conditional probabilities: the
non-unary case. Journal of Symbolic Logic, 61:250‚Äì275, 1996.
[200] A.J. Grove, J.Y. Halpern, and D. Koller. Asymptotic conditional probabilities: the
unary case. SIAM Journal on Computing, 25:1‚Äì51, 1996.
[201] Y. Gurevich and S. Shelah. The decision problem for branching time logic. Journal
of Symbolic Logic, 50:669‚Äì681, 1985.
[202] P. R. Halmos. Algebraic Logic. Chelsea Publishing Company, 1962.
[203] J.Y. Halpern. The effect of bounding the number of primitive propositions and the
depth of nesting on the complexity of modal logic. ArtiÔ¨Åcial Intelligence, 75:361‚Äì
372, 1995.
[204] J.Y. Halpern and B.M. Kapron. Zero-one laws for modal logic. Annals of Pure and
Applied Logic, 69:157‚Äì193, 1994.
[205] J.Y. Halpern and Y.O. Moses. A guide to the completeness and complexity for
modal logics of knowledge and belief. ArtiÔ¨Åcial Intelligence, 54:319‚Äì379, 1992.
[206] J.Y. Halpern and M.Y. Vardi. The complexity of reasoning about knowledge and
time, I: Lower bounds. Journal of Computer and System Sciences, 38:195‚Äì237,
1989.
[207] J.Y. Halpern and M.Y. Vardi. Model checking vs. theorem proving: a manifesto.
In J.A. Allen, R. Fikes, and E. Sandewall, editors, Principles of Knowledge Rep-
resentation and Reasoning: Proc. Second International Conference (KR‚Äô91), pages
325‚Äì334. Morgan Kaufmann, 1991.Bibliography
533
[208] D. Harel. Recurring dominoes: making the highly undecidable highly understand-
able. In Proc. of the Conference on Foundations of Computing Theory, volume 158
of LNCS, pages 177‚Äì194. Springer, 1983.
[209] D. Harel. Dynamic logic. In Gabbay and Guenthner [154], pages 497‚Äì604.
[210] D. Harel. Recurring dominoes: making the highly undecidable highly understand-
able. Annals of Discrete Mathematics, 24:51‚Äì72, 1985.
[211] D. Harel. Effective transformations on inÔ¨Ånite trees, with applications to high un-
decidability. Journal of the ACM, 33:224‚Äì248, 1986.
[212] D. Harel, D. Kozen, and J. Tiuryn. Dynamic Logic. The MIT Press, 2000.
[213] R. Harrop. On the existence of Ô¨Ånite models and decision procedures for proposi-
tional calculi. Proceedings of the Cambridge Philosophical Society, 54:1‚Äì13, 1958.
[214] T. Hayashi. Finite automata on inÔ¨Ånite objects. Math. Res. Kyushu University,
15:13‚Äì66, 1985.
[215] E. Hemaspaandra. The price of universality. Notre Dame Journal of Formal Logic,
37:174‚Äì203, 1996.
[216] L. Henkin. Logical systems containing only a Ô¨Ånite number of symbols. S√©miniare
de Math√©matique Sup√©rieures 21, Les Presses de l‚ÄôUniversit√© de Montr√©al,
Montr√©al, 1967.
[217] L. Henkin. Completeness in the theory of types. Journal of Symbolic Logic, 15:81‚Äì
91, 1950.
[218] L. Henkin, J.D. Monk, and A. Tarski. Cylindric Algebras. Part 1. Part 2. North-
Holland Publishing Company, Amsterdam, 1971, 1985.
[219] M. Hennessy and R. Milner. Algebraic laws for indeterminism and concurrency.
Journal of the ACM, 32:137‚Äì162, 1985.
[220] J.G. Henriksen, J. Jensen, M. J√∏rgensen, N. Klarlund, R. Paige, T. Rauhe, and
A. Sandhol. MONA: Monadic second-order logic in practice. In Proceedings
TACAS‚Äô95, LNCS, pages 479‚Äì506. Springer, 1995.
[221] M. Henzinger, T. Henzinger, and P. Kopke. Computing simulations on Ô¨Ånite and in-
Ô¨Ånite graphs. In Proceedings 20th Symposium on Foundations of Computer Science,
pages 453‚Äì462, 1995.
[222] B. Herwig. Extending partial isomorphisms on Ô¨Ånite structures. Combinatorica,
15:365‚Äì371, 1995.
[223] J. Hindley and J. Seldin. Introduction to Combinators and the Lambda Calculus.
London Mathematical Society Student Texts vol. 1. Cambridge University Press,
1986.
[224] J. Hintikka. Knowledge and Belief. Cornell University Press, 1962.
[225] R. Hirsch and I.M. Hodkinson. Step by step ‚Äî building representations in algebraic
logic. Journal of Symbolic Logic, 62:225‚Äì279, 1997.
[226] R. Hirsch and I.M. Hodkinson. Relation Algebras by Games. Number 147 in Studies
in Logic. Elsevier, Amsterdam, 2002.
[227] R. Hirsch, I.M. Hodkinson, M. Marx, Sz. Mikul√°s, and M. Reynolds. Mosaics and
step-by-step. Remarks on ‚ÄòA modal logic of relations‚Äô. In Or≈Çowska [349], pages
158‚Äì167.
[228] W. Hodges. Elementary predicate logic. In Gabbay and Guenthner [153], pages
1‚Äì131.
[229] W. Hodges. Model Theory. Cambridge University Press, 1993.
[230] I.M. Hodkinson. Atom structures of cylindric algebras and relation algebras. Annals534
Bibliography
of Pure and Applied Logic, 89:117‚Äì148, 1997.
[231] I.M. Hodkinson. Loosely guarded fragment has Ô¨Ånite model property. Studia Log-
ica, 70:205‚Äì240, 2002.
[232] M. Hollenberg. Safety for bisimulation in general modal logic. In Proceedings 10th
Amsterdam Colloquium, 1996.
[233] M.J. Hollenberg. Hennessy-Milner classes and process algebra. In Ponse et al.
[360].
[234] G. Hughes and M.J. Cresswell. A Companion to Modal Logic. Methuen, 1984.
[235] G. Hughes and M.J. Cresswell. A New Introduction to Modal Logic. Routledge,
1996.
[236] I. Humberstone. Inaccessible worlds. Notre Dame Journal of Formal Logic, 24:346‚Äì
352, 1983.
[237] U. Hustadt. Resolution-Based Decision Procedures for Subclasses of First-Order
Logic. PhD thesis, Universit√§t des Saarlandes, Saarbr√ºcken, Germany, 1999.
[238] U. Hustadt and R. A. Schmidt. Issues of decidability for description logics in the
framework of resolution. In R. Caferra and G. Salzer, editors, First-order Theorem
Proving‚ÄîFTP‚Äô98, pages 152‚Äì161. Technical Report E1852-GS-981, Technische
Universit√§t Wien, 1998.
[239] M.R.A. Huth and M.D. Ryan. Logic in Computer Science. Cambridge University
Press, 2000.
[240] N. Immerman and D. Kozen. DeÔ¨Ånability with bounded number of bound variables.
In Proceedings 4th IEEE Symposium on Logic in Computer Science LICS‚Äô87. Com-
puter Society Press, 1987.
[241] B. Jacobs. The temporal logic of coalgebras via Galois algebras. Mathematical
Structure in Computer Science, 12:875‚Äì903, 2002.
[242] B. Jacobs and J. Rutten. A tutorial on (co)algebras and (co)induction. Bulletin of
the European Association for Theoretical Computer Science, 62:222‚Äì259, 1997.
[243] D. Janin and I. Walukiewicz. On the expressive completeness of the propositional
Œº-calculus w.r.t. monadic second-order logic. In Proceedings CONCUR ‚Äô96, 1996.
[244] R. Jansana. Una Introducci √≥n a la L√≥gica Modal. Editorial Tecnos, Madrid, 1990.
[245] G. Japaridze and D. de Jongh. The logic of provability. In Buss [83], pages 475‚Äì546.
[246] He Jifeng. Process simulation and reÔ¨Ånement. Formal Aspects of Computing,
1:229‚Äì241, 1989.
[247] P. Jipsen. Discriminator varieties of boolean algebras with residuated operators. In
C. Rauszer, editor, Algebraic Methods in Logic and Computer Science, volume 28
of Banach Center Publications, pages 239‚Äì252. Polish Academy of Sciences, 1993.
[248] P.J. Johnstone. Stone Spaces, volume 3 of Cambridge Studies in Advanced Mathe-
matics. Cambridge University Press, Cambridge, 1982.
[249] D. de Jongh and A. Troelstra. On the connection between partially ordered sets and
some pseudo-boolean algebras. Indigationes Mathematicae, 28:317‚Äì329, 1966.
[250] D. de Jongh and F. Veltman. Intensional logic, 1986. Course notes.
[251] B. J√≥nsson. Varieties of relation algebras. Algebra Universalis, 15:273‚Äì298, 1982.
[252] B. J√≥nsson. The theory of binary relations. In Andr√©ka et al. [8], pages 241‚Äì292.
[253] B. J√≥nsson. A survey of boolean algebras with operators. In Algebras and Orders,
pages 239‚Äì286. Kluwer Academic Publishers, 1993.
[254] B. J√≥nsson. On the canonicity of Sahlqvist identities. Studia Logica, 4:473‚Äì491,
1994.Bibliography
535
[255] B. J√≥nsson and A. Tarski. Boolean algebras with operators, Part I. American Journal
of Mathematics, 73:891‚Äì939, 1952.
[256] B. J√≥nsson and A. Tarski. Boolean algebras with operators, Part II. American
Journal of Mathematics, 74:127‚Äì162, 1952.
[257] G. Kalinowski. La Logique D √©ductive. Presses Universitaires de France, 1996.
[258] H. Kamp. Tense Logic and the Theory of Linear Order. PhD thesis, University of
California, Los Angeles, 1968.
[259] H. Kamp. Formal properties of ‚ÄòNow‚Äô. Theoria, 37:227‚Äì273, 1971.
[260] M. Kaneko and T. Nagashima. Game logic and its applications. Studia Logica,
57:325‚Äì354, 1998.
[261] S. Kanger. The morning star paradox. Theoria, pages 1‚Äì11, 1957.
[262] S. Kanger. Provability in Logic. Almqvist & Wiksell, 1957.
[263] S. Kanger, editor. Proceedings of the Third Scandinavian Logic Symposium. Upp-
sala 1973. North-Holland Publishing Company, 1975.
[264] D. Kaplan. Dthat. In P. Cole, editor, Syntax and Semantics Volume 9, pages 221‚Äì
253. Academic Press, 1978.
[265] D. Kaplan. On the logic of demonstratives. Journal of Philosophical Logic, 8:81‚Äì
98, 1978.
[266] R. Kasper and W. Rounds. The logic of uniÔ¨Åcation in grammar. Linguistics and
Philosophy, 13:33‚Äì58, 1990.
[267] H.J. Keisler. Model Theory for InÔ¨Ånitary Logic. North-Holland Publishing Com-
pany, 1971.
[268] H. Kirchner and C. Ringeissen, editors. Frontiers of Combining Systems 3. Springer,
2000.
[269] B. Konikowska. A formal language for reasoning about indiscernibility. Bulletin of
the Polish Academy of Sciences, 35:239‚Äì249, 1987.
[270] B. Konikowska. A logic for reasoning about relative similarity. Studia Logica,
58:185‚Äì226, 1997.
[271] R. Koymans. Specifying Message Passing and Time-Critical Systems with Temporal
Logic, volume 651 of LNCS. Springer, 1992.
[272] D. Kozen. A completeness theorem for Kleene algebras and the algebra of reg-
ular events. In Proceedings 6th IEEE Symposium on Logic in Computer Science
LICS‚Äô91, pages 214‚Äì225, 1991.
[273] D. Kozen and R. Parikh. An elementary proof of the completeness of PDL. Theo-
retical Computer Science, 14:113‚Äì118, 1981.
[274] D. Kozen and J. Tiuryn. Logics of programs. In van Leeuwen [293], pages 789‚Äì840.
[275] M. Kracht. Even more about the lattice of tense logics. Archive of Mathematical
Logic, 31:243‚Äì357, 1992.
[276] M. Kracht. How completeness and correspondence theory got married. In de Rijke
[379], pages 175‚Äì214.
[277] M. Kracht. Splittings and the Ô¨Ånite model property. Journal of Symbolic Logic,
58:139‚Äì157, 1993.
[278] M. Kracht. Lattices of modal logics and their groups of automorphisms. Journal of
Pure and Applied Logic, 100:99‚Äì139, 1999.
[279] M. Kracht. Tools and Techniques in Modal Logic. Number 142 in Studies in Logic.
Elsevier, Amsterdam, 1999.
[280] M. Kracht. Logic and syntax ‚Äî a personal perspective. In Zakharyaschev et al.536
Bibliography
[469], pages 355‚Äì384.
[281] M. Kracht, M. de Rijke, H. Wansing, and M. Zakharyaschev, editors. Advances in
Modal Logic, Volume 1, volume 87 of Lecture Notes. CSLI Publications, 1998.
[282] M. Kracht and F. Wolter. Simulation and transfer results in modal logic: A survey.
Studia Logica, 59:149‚Äì177, 1997.
[283] S. Kripke. A completeness theorem in modal logic. Journal of Symbolic Logic,
24:1‚Äì14, 1959.
[284] S. Kripke. Semantic analysis of modal logic I, normal propositional calculi.
Zeitschrift f√ºr mathemathische Logik und Grundlagen der Mathematik, 9:67‚Äì96,
1963.
[285] S. Kripke. Semantical considerations on modal logic. Acta Philosophica Fennica,
16:83‚Äì94, 1963.
[286] S. Kuhn. QuantiÔ¨Åers as diamonds. Studia Logica, 39:173‚Äì195, 1980.
[287] N. Kurtonina. Frames and Labels. PhD thesis, OTS, Utrecht University, 1996.
[288] N. Kurtonina and M. de Rijke. Bisimulations for temporal logic. Journal of Logic,
Language and Information, 6:403‚Äì425, 1997.
[289] N. Kurtonina and M. de Rijke. Expressiveness of concept expressions in Ô¨Årst-order
description logics. ArtiÔ¨Åcial Intelligence, 107:303‚Äì333, 1999.
[290] A. Kurz. A co-variety-theorem for modal logic. In Zakharyaschev et al. [469].
[291] A.H. Lachlan. A note on Thomason‚Äôs reÔ¨Åned structures for tense logics. Theoria,
40:117‚Äì120, 1970.
[292] R. Ladner. The computational complexity of provability in systems of modal logic.
SIAM Journal on Computing, 6:467‚Äì480, 1977.
[293] J. van Leeuwen, editor. Handbook of Theoretical Computer Science, volume B:
Formal Models and Semantics. Elsevier, 1990.
[294] A. Leitsch, C. Ferm√ºller, and T. Tammet. Resolution decision procedures. In Robin-
son and Voronkov [388].
[295] E.J. Lemmon. Algebraic semantics for modal logics, Parts I & II. Journal of Sym-
bolic Logic, pages 46‚Äì65 & 191‚Äì218, 1966.
[296] E.J. Lemmon and D.S. Scott. The ‚ÄòLemmon Notes‚Äô: An Introduction to Modal Logic.
Blackwell, 1977.
[297] O. Lemon and I. Pratt. On the incompleteness of modal logics of space: advancing
complete modal logics of space. In Kracht et al. [281].
[298] W. Lenzen. Glauben, Wissen und Wahrscheinlichkeit. Systeme der Epistemischen
Logik. Springer, 1980.
[299] C.I. Lewis. A Survey of Symbolic Logic. University of California Press, 1918.
[300] C.I. Lewis and C.H. Langford. Symbolic Logic. Dover, 1932.
[301] H.R. Lewis and C.H. Papadimitriou. Elements of the Theory of Computation.
Prentice-Hall, 1981.
[302] P. Lindstr√∂m. On extensions of elementary logic. Theoria, 35:1‚Äì11, 1969.
[303] C. Lutz and U. Sattler. The complexity of reasoning with boolean modal logics. In
Workshop Proceedings AiML-2000, pages 175‚Äì184. Institut f√ºr Informatik, Univer-
sit√§t Leipzig, 2000.
[304] R.C. Lyndon. The representation of relation algebras. Annals of Mathematics,
51:707‚Äì729, 1950.
[305] H. MacColl. Symbolic Logic and its Applications. Longmans, Green, and Co.,
London, 1906.Bibliography
537
[306] R. Maddux. Introductory course on relation algebras, Ô¨Ånite-dimensional cylindric
algebras, and their interconnections. In Andr√©ka et al. [8], pages 361‚Äì392.
[307] D.C. Makinson. On some completeness theorems in modal logic. Zeitschrift f √ºr
mathemathische Logik und Grundlagen der Mathematik, 12:379‚Äì84, 1966.
[308] D.C. Makinson. A generalization of the concept of relational model. Theoria, pages
331‚Äì335, 1970.
[309] D.C. Makinson. Some embedding theorems for modal logic. Notre Dame Journal
of Formal Logic, pages 252‚Äì254, 1971.
[310] L. Maksimova. Interpolation theorems in modal logic and amalgable varieties of
topological boolean algebras. Algebra and Logic, 18:348‚Äì370, 1979.
[311] L.L. Maksimova. Pretabular extensions of Lewis S4. Algebra and Logic, 14:16‚Äì33,
1975.
[312] Z. Manna and A. Pnueli. The Temporal Logic of Reactive and Concurrent Systems.
Vol. 1 SpeciÔ¨Åcation. Springer, 1992.
[313] Z. Manna and A. Pnueli. Temporal VeriÔ¨Åcation of Reactive Systems: Safety.
Springer, 1995.
[314] M. Manzano. Extensions of First Order Logic, volume 19 of Tracts in Theoretical
Computer Science. Cambridge University Press, 1996.
[315] R. Martin. Pour une Logique du Sens. Presses Universitaires de France Paris, 1983.
[316] M. Marx. Complexity of modal logics of relations. Technical Report ML‚Äì97‚Äì02,
Institute for Language, Logic and Computation, May 1997.
[317] M. Marx. Tolerance logic. Journal of Logic, Language and Information, 10:353‚Äì
373, 2001.
[318] M. Marx, L. P√≥los, and M. Masuch, editors. Arrow Logic and Multi-Modal Logic.
Studies in Logic, Language and Information. CSLI Publications, 1996.
[319] M. Marx, S. Schlobach, and Sz. Mikul√°s. Labelled deduction for the guarded frag-
ment. In D. Basin et al., editor, Labelled Deduction, Applied Logic Series, pages
193‚Äì214. Kluwer Academic Publishers, 2000.
[320] M. Marx and Y. Venema. Multidimensional Modal Logic, volume 4 of Applied
Logic Series. Kluwer Academic Publishers, 1997.
[321] R. McKenzie, G. McNulty, and W. Taylor. Algebras, Lattices, Varieties, volume I.
Wadsworth & Brooks/Cole, 1987.
[322] J.C.C. McKinsey. A solution to the decision problems for the Lewis systems S2 and
S4 with an application to topology. Journal of Symbolic Logic, 6:117‚Äì134, 1941.
[323] J.C.C. McKinsey. On the syntactical construction of systems of modal logic. Jour-
nal of Symbolic Logic, 10:83‚Äì96, 1945.
[324] J.C.C. McKinsey and A. Tarski. The algebra of topology. Annals of Mathematics,
pages 141‚Äì191, 1944.
[325] J.C.C. McKinsey and A. Tarski. Some theorems about the sentential calculi of Lewis
and Heyting. Journal of Symbolic Logic, 13:1‚Äì15, 1948.
[326] K. McMillan. Symbolic Model Checking. Kluwer Academic Publishers, 1993.
[327] C. Meredith and A. Prior. Interpretations of different modal logics in the ‚Äòproperty
calculus‚Äô, 1956. Mimeographed manuscript. Philosophy Department, Canterbury
University College.
[328] J.J.-Ch. Meyer and W. van der Hoek. Epistemic Logic for AI and Computer Science.
Cambridge University Press, 1995.
[329] Sz. Mikul√°s. Taming Logics. PhD thesis, Institute for Language, Logic and Com-538
Bibliography
putation, University of Amsterdam, 1995. ILLC Dissertation Series 95-12.
[330] G. Mints. A Short Introduction to Modal Logic, volume 30 of Lecture Notes. CSLI
Publications, 1992.
[331] J.L. Moens. Forcing et S √©mantique de Kripke-Joyal. Cabay, 1982.
[332] G. Moisil. Essais sur les Logiques non Chrysipiennes. Editions de l‚ÄôAcad√©mie de
la R√©publique Socialiste de Roumanie, 1972.
[333] F. Moller and A. Rabinovich. On the expressive power of CTL ‚àó . In Proceedings
14th IEEE Symposium on Logic in Computer Science LICS‚Äô99, 1999.
[334] J.D. Monk. On representable relation algebras. Michigan Mathematical Journal,
11:207‚Äì210, 1964.
[335] R. Montague. Logical necessity, physical necessity, ethics, and quantiÔ¨Åers. Inquiry,
4:259‚Äì269, 1960.
[336] R. Montague. Universal grammar. Theoria, 36:373‚Äì398, 1970.
[337] M. Mortimer. On languages with two variables. Zeitschrift f √ºr mathemathische
Logik und Grundlagen der Mathematik, 21:135‚Äì140, 1975.
[338] D.E. Muller, A. Saoudi, and P.E. Schupp. Weak alternating automata give a simple
explanation of why most temporal and dynamic logics are decidable in exponential
time. In Proceedings 3rd IEEE Symposium on Logic in Computer Science LICS‚Äô88,
pages 422‚Äì427, 1988.
[339] N. Murray, editor. Conference on Tableaux Calculi and Related Methods
(TABLEAUX), Saratoga Springs, USA, volume 1617 of LNAI. Springer, 1999.
[340] I. N√©meti. Free algebras and decidability in algebraic logic, 1986. Thesis for D.Sc.
(a post-habilitation degree) with Math. Inst. Hungar. Ac. Sci. Budapest. In Hungar-
ian, the English version is [342].
[341] I. N√©meti. Algebraizations of quantiÔ¨Åer logics: an overview. Studia Logica, 50:485‚Äì
569, 1991.
[342] I. N√©meti. Decidability of weakened versions of Ô¨Årst-order logic. In Csirmaz et al.
[102], pages 177‚Äì242.
[343] P. Odifreddi. Classical Recursion Theory. North-Holland Publishing Company,
1989.
[344] H.J. Ohlbach, D.M. Gabbay, and D. Plaisted. Killer transformations. In Wansing
[454].
[345] H.J. Ohlbach, A. Nonnengart, M. de Rijke, and D.M. Gabbay. Encoding non-
classical logics in classical logic. In Robinson and Voronkov [388].
[346] H.J. Ohlbach and R.A. Schmidt. Functional translation and second-order frame
properties of modal logics. Journal of Logic and Computation, 7:581‚Äì603, 1997.
[347] P. √òhrstrom and P Hasle. Temporal Logic. Kluwer Academic Publishers, 1995.
[348] H. Ono and A. Nakamura. On the size of refutation Kripke models for some linear
modal and tense logics. Studia Logica, 39:325‚Äì333, 1980.
[349] E. Or≈Çowska, editor. Logic at Work: Essays Dedicated to the Memory of Elena
Rasiowa. Studies in Fuzziness and Soft Computing. Springer, 1999.
[350] M.J. Osborne and A. Rubinstein. A Course in Game Theory. The MIT Press, 1994.
[351] M. Otto. Bounded Variable Logics and Counting ‚Äî A Study in Finite Models, vol-
ume 9 of Lecture Notes in Logic. Springer, 1997.
[352] C.H. Papadimitriou. Computational Complexity. Addison-Wesley, 1994.
[353] R. Parikh. The completeness of propositional dynamic logic. In Mathematical Foun-
dations of Computer Science 1978, volume 51 of LNCS, pages 403‚Äì415. Springer,Bibliography
539
1978.
[354] D. Park. Concurrency and automata on inÔ¨Ånite sequences. In Proceedings 5th GI
Conference, pages 167‚Äì183. Springer, 1981.
[355] W.T. Parry. The postulates for strict implication. Mind, 43:78‚Äì80, 1934.
[356] S. Passy and T. Tinchev. PDL with data constants. Information Processing Letters,
20:35‚Äì41, 1985.
[357] S. Passy and T. Tinchev. QuantiÔ¨Åers in combinatory PDL: completeness, deÔ¨Ånabil-
ity, incompleteness. In Fundamentals of Computation Theory FCT 85, volume 199
of LNCS, pages 512‚Äì519. Springer, 1985.
[358] S. Passy and T. Tinchev. An essay in combinatory dynamic logic. Information and
Computation, 93:263‚Äì332, 1991.
[359] A. Pnueli. The temporal logic of programs. In Proc. 18th Symp. Foundations of
Computer Science, pages 46‚Äì57, 1977.
[360] A. Ponse, M. de Rijke, and Y. Venema, editors. Modal Logic and Process Algebra:
A Bisimulation Perspective, volume 53 of Lecture Notes. CSLI Publications, 1995.
[361] S. Popkorn. First Steps in Modal Logic. Cambridge University Press, 1992.
[362] V.R. Pratt. Semantical considerations on Floyd-Hoare logic. In Proc. 17th IEEE
Symposium on Computer Science, pages 109‚Äì121, 1976.
[363] V.R. Pratt. Models of program logics. In Proc. 20th IEEE Symp. Foundations of
Computer Science, pages 115‚Äì222, 1979.
[364] A.N. Prior. Time and Modality. Oxford University Press, 1957.
[365] A.N. Prior. Past, Present and Future. Oxford University Press, 1967.
[366] A.N. Prior. Papers on Time and Tense. Oxford University Press, New edition, 2003.
Edited by Hasle, √òhrstrom, Bra√ºner, and Copeland.
[367] A.N. Prior and K. Fine. Worlds, Times and Selves. University of Massachusetts
Press, 1977.
[368] M.O. Rabin. Decidability of second-order theories and automata on inÔ¨Ånite trees.
Transactions of the American Mathematical Society, 141:1‚Äì35, 1969.
[369] S. Rahman. Hugh MacColl: Eine bibliographische Erschlie√üung seiner Hauptwerke
und Notizen zu ihrer Rezeptionsgeschichte. History and Philosophy of Logic,
18:165‚Äì183, 1997.
[370] H. Rasiowa and R. Sikorski. The Mathematics of Metamathematics. Polish Scien-
tiÔ¨Åc Publishers, 1963.
[371] H. Rasiowa and R. Sikorski. An Algebraic Approach to Non-Classical Logics. North
Holland, 1974.
[372] W. Rautenberg. Der Verband der normalen verzweigten Modallogiken. Mathema-
tische Zeitschrift, 156:123‚Äì140, 1977.
[373] W. Rautenberg. Klassische und nichtklassische Aussagenlogik. Vieweg & Sohn,
1979.
[374] W. Rautenberg. Splitting lattices of logics. Archiv f √ºr Mathematische Logik,
20:155‚Äì159, 1980.
[375] W. Rautenberg, editor. Non-Classical Logics. Œ©-bibliography of Mathematical
Logic, Volume II. Springer, 1987.
[376] M. Reape. A feature value logic. In C. Rupp, M. Rosner, and R. Johnson, editors,
Constraints, Language and Computation, Synthese Language Library, pages 77‚Äì
110. Academic Press, 1994.
[377] M. Reynolds. A decidable logic of parallelism. Notre Dame Journal of Formal540
Bibliography
Logic, 38:419‚Äì436, 1997.
[378] M. de Rijke. The modal logic of inequality. Journal of Symbolic Logic, 57:566‚Äì584,
1992.
[379] M. de Rijke, editor. Diamonds and Defaults. Synthese Library vol. 229. Kluwer
Academic Publishers, 1993.
[380] M de. Rijke. Extending Modal Logic. PhD thesis, ILLC, University of Amsterdam,
1993.
[381] M. de Rijke. A Lindstr√∂m theorem for modal logic. In Ponse et al. [360], pages
217‚Äì230.
[382] M. de Rijke. The logic of Peirce algebras. Journal of Logic, Language and Infor-
mation, 4:227‚Äì250, 1995.
[383] M. de Rijke, editor. Advances in Intensional Logic. Number 7 in Applied Logic
Series. Kluwer Academic Publishers, 1997.
[384] M. de Rijke. A system of dynamic modal logic. Journal of Philosophical Logic,
27:109‚Äì142, 1998.
[385] M. de Rijke. A modal characterization of Peirce algebras. In Or≈Çowska [349], pages
109‚Äì123.
[386] M. de Rijke and H. Sturm. Global deÔ¨Ånability in basic modal logic. In H. Wansing,
editor, Essays on Non-Classical Logic. King‚Äôs College University Press, 2000.
[387] M. de Rijke and Y. Venema. Sahlqvist‚Äôs theorem for Boolean algebras with opera-
tors. Studia Logica, 95:61‚Äì78, 1995.
[388] A. Robinson and A. Voronkov, editors. Handbook of Automated Reasoning. Elsevier
Science Publishers, to appear.
[389] R.M. Robinson. Undecidability and nonperiodicity for tilings of the plane. Inven-
tiones Mathematicae, 12:177‚Äì209, 1971.
[390] P.H. Rodenburg. Intuitionistic Correspondence Theory. PhD thesis, University of
Amsterdam, 1986.
[391] H. Rogers. Theory of Recursive Functions and Effective Computability. McGraw
Hill, 1967.
[392] E. Rosen. Modal logic over Ô¨Ånite structures. Journal of Logic, Language and
Information, 6:427‚Äì439, 1997.
[393] M. R√∂√üiger. Coalgebras and modal logic. Electronic Notes in Computer Science,
33:299‚Äì320, 2000.
[394] W.C. Rounds. Feature logics. In van Benthem and ter Meulen [51].
[395] G. Rozenberg and A. Salomaa, editors. Handbook of Formal Languages, volume 3:
Beyond Words. Springer, 1997.
[396] H. Sahlqvist. Completeness and correspondence in the Ô¨Årst and second order se-
mantics for modal logic. In Kanger [263], pages 110‚Äì143.
[397] I. Sain. Is ‚Äòsome-other-time‚Äô sometimes better than ‚Äòsometime‚Äô for proving partial
correctness of programs? Studia Logica, 47:279‚Äì301, 1988.
[398] G. Sambin and V. Vaccaro. Topology and duality in modal logic. Annals of Pure
and Applied Logic, 37:249‚Äì296, 1988.
[399] G. Sambin and V. Vaccaro. A topological proof of Sahlqvist‚Äôs theorem. Journal of
Symbolic Logic, 54:992‚Äì999, 1989.
[400] K. Schild. A correspondence theory for terminological logics. In Proc. 12th IJCAI,
pages 466‚Äì471, 1990.
[401] D. Scott. A decision method for validity of sentences in two variables. Journal ofBibliography
541
Symbolic Logic, 27:377, 1962.
[402] K. Segerberg. Decidability of S4.1. Theoria, 34:7‚Äì20, 1968.
[403] K. Segerberg. Modal logics with linear alternative relations. Theoria, 36:301‚Äì322,
1970.
[404] K. Segerberg. An Essay in Classical Modal Logic. FilosoÔ¨Åska Studier 13. University
of Uppsala, 1971.
[405] K. Segerberg. Two-dimensional modal logics. Journal of Philosophical Logic,
2:77‚Äì96, 1973.
[406] K. Segerberg. ‚ÄòSomewhere else‚Äô and ‚ÄòSome other time‚Äô. In Wright and Wrong,
pages 61‚Äì64, 1976.
[407] K. Segerberg. A completeness theorem in the modal logic of programs. Notices of
the American Mathematical Society, 24:A‚Äì552, 1977.
[408] K. Segerberg. A note on the logic of elsewhere. Theoria, 46:183‚Äì187, 1980.
[409] K. Segerberg. A completeness theorem in the modal logic of programs. In
T. Traczyk, editor, Universal Algebra and Applications, volume 9 of Banach Centre
Publications, pages 31‚Äì46. PWN‚ÄìPolish ScientiÔ¨Åc Publishers, 1982.
[410] K. Segerberg. Proposal for a theory of belief revision along the lines of Lindstr√∂m
and Rabinowicz. Fundamenta Informaticae, 32:183‚Äì191, 1997.
[411] J. Seligman. A cut-free sequent calculus for elementary situated reasoning. Techni-
cal Report HCRC-RP 22, HCRC, Edinburgh, 1991.
[412] J. Seligman. The logic of correct description. In de Rijke [383], pages 107‚Äì135.
[413] V. Shehtman. Two-dimensional modal logics. Mathematical Notices of USSR
Academy of Sciences, 23:417‚Äì424, 1978.
[414] H. Simmons. The monotonous elimination of predicate variables. Journal of Logic
and Computation, 4, 1994.
[415] A.P. Sistla and E.M. Clarke. The complexity of linear temporal logic. Journal of
the ACM, 32:733‚Äì749, 1985.
[416] C. Smory≈Ñski. Self-Reference and Modal Logic. Springer, New York, 1985.
[417] R. Smullyan and M Fitting. Set Theory and the Continuum Problem. Clarendon
Press, 1996.
[418] R.M. Smullyan and M. Fitting. Set Theory and the Continuum Problem. Oxford
University Press, 1997.
[419] E. Spaan. Complexity of Modal Logics. PhD thesis, ILLC, University of Amsterdam,
1993.
[420] E. Spaan. The complexity of propositional tense logics. In de Rijke [379], pages
239‚Äì252.
[421] B. Stalnaker. Assertion. In P. Cole, editor, Syntax and Semantics Volume 9, pages
316‚Äì322. Academic Press, 1978.
[422] J. Stavi. Functional completeness over the rationals. Unpublished manuscript. Bar-
Ilan University, Ramat-Gan, Israel, 1979.
[423] V. Stebletsova. Algebras, Relations and Geometries. PhD thesis, Zeno (The Leiden-
Utrecht Research Institute of Philosophy), Utrecht, 2000.
[424] C. Stirling. Modal and temporal logics. In Abramsky et al. [1], pages 477‚Äì563.
[425] M.H. Stone. The theory of representations for boolean algebras. Transactions of the
American Mathematical Society, 40:37‚Äì111, 1936.
[426] H. Sturm. Modale Fragmente von L œâœâ und Lœâ1 œâ . PhD thesis, CIS, University of
Munich, 1997.542
Bibliography
[427] A. Tarski. On the calculus of relations. Journal of Symbolic Logic, 6:73‚Äì89, 1941.
[428] A. Tarski and S. Givant. A Formalization of Set Theory without Variables, vol-
ume 41. AMS Colloquium Publications, Providence, Rhode Island, 1987.
[429] J.W. Thatcher and J.B. Wright. Generalized Ô¨Ånite automata theory with an appli-
cation to a decision problem of second-order logic. Mathematical Systems Theory,
2:57‚Äì81, 1968.
[430] A. Thayse, editor. From Modal Logic to Deductive Databases. Wiley, 1989.
[431] W. Thomas. Automata on inÔ¨Ånite objects. In van Leeuwen [293], pages 135‚Äì191.
[432] W. Thomas. Languages, automata and logic. In Rozenberg and Salomaa [395],
pages 389‚Äì456.
[433] S.K. Thomason. Semantic analysis of tense logics. Journal of Symbolic Logic,
37:150‚Äì158, 1972.
[434] S.K. Thomason. An incompleteness theorem in modal logic. Theoria, 40:150‚Äì158,
1974.
[435] S.K. Thomason. Categories of frames for modal logics. Journal of Symbolic Logic,
40:439‚Äì442, 1975.
[436] S.K. Thomason. Reduction of second-order logic to modal logic. Zeitschrift f √ºr
mathemathische Logik und Grundlagen der Mathematik, 21:107‚Äì114, 1975.
[437] S.K. Thomason. Reduction of tense logic to modal logic II. Theoria, 41:154‚Äì169,
1975.
[438] D. Toman and D. Niwi≈Ñski. First-order queries over temporal databases inexpress-
ible in temporal logic. Manuscript, 1997.
[439] M. Tzakova. Tableaux calculi for hybrid logics. In Murray [339], pages 278‚Äì292.
[440] A. Urquhart. Decidability and the Ô¨Ånite model property. Journal of Philosophical
Logic, 10:367‚Äì370, 1981.
[441] M.Y. Vardi. Why is modal logic so robustly decidable? In DIMACS Series in
Discrete Mathematics and Theoretical Computer Science 31, pages 149‚Äì184. AMS,
1997.
[442] M.Y. Vardi and P. Wolper. Automata-theoretic techniques for modal logics of pro-
grams. Journal of Computer and System Sciences, 32:183‚Äì221, 1986.
[443] Y. Venema. Completeness via completeness: Since and Until. In de Rijke [379],
pages 279‚Äì286.
[444] Y. Venema. Derivation rules as anti-axioms in modal logic. Journal of Symbolic
Logic, 58:1003‚Äì1034, 1993.
[445] Y. Venema. Cylindric modal logic. Journal of Symbolic Logic, 60:591‚Äì623, 1995.
[446] Y. Venema. Atom structures and Sahlqvist equations. Algebra Universalis, 38:185‚Äì
199, 1997.
[447] Y. Venema. Modal deÔ¨Ånability, purely modal. In J. Gerbrandy, M. Marx,
M. de Rijke, and Y. Venema, editors, JFAK. Essays Dedicated to Johan van Benthem
on the Occasion of his 50th Birthday. Vossiuspers AUP, Amsterdam, 1999.
[448] Y. Venema. Points, lines and diamonds: a two-sorted modal logic for projective
geometry. Journal of Logic and Computation, 9:601‚Äì621, 1999.
[449] Y. Venema. Canonical pseudo-correspondence. In Zakharyaschev et al. [469], pages
439‚Äì448.
[450] A. Visser. Modal logic and bisimulation. Tutorial for the workshop ‚ÄòThree days of
bisimulation‚Äô, Amsterdam, 1994.
[451] A. Visser. An overview of interpretability logic. In Kracht et al. [281], pages 307‚ÄìBibliography
543
359.
[452] H. Vlach. ‚ÄòNow‚Äô and ‚ÄòThen‚Äô. PhD thesis, University of California, Los Angeles,
1973.
[453] H. Wang. Proving theorems by pattern recognition II. Bell Systs. Tech. J, 40:1‚Äì41,
1961.
[454] H. Wansing, editor. Proof Theory of Modal Logic. Kluwer Academic Publishers,
1996.
[455] H. Wansing. Displaying Modal Logic. Kluwer Academic Publishers, 1998.
[456] P. Wolper. Temporal logic can be more expressive. Information and Control, 56:72‚Äì
93, 1983.
[457] F. Wolter. Tense logic without tense operators. Mathematical Logic Quarterly,
42:145‚Äì171, 1996.
[458] F. Wolter. Completeness and decidability of tense logics closely related to logics
containing K4. Journal of Symbolic Logic, 62:131‚Äì158, 1997.
[459] F. Wolter. The structure of lattices of subframe logics. Annals of Pure and Applied
Logic, 86:47‚Äì100, 1997.
[460] F. Wolter. The product of converse PDL and polymodal K. Journal of Logic and
Computation, 10:223‚Äì251, 2000.
[461] F. Wolter, H. Wansing, M. de Rijke, and M. Zakharyaschev, editors. Advances in
Modal Logic, Volume 3. World ScientiÔ¨Åc, 2002.
[462] F. Wolter and M. Zakharyaschev. SatisÔ¨Åability problem in description logics with
modal operators. In Principles of Knowledge Representation and Reasoning: Proc.
Sixth International Conference (KR‚Äô98), pages 512‚Äì523. Morgan Kaufmann, 1998.
[463] M. Wooldridge and N. Jennings. Intelligent agents: theory and practice. Knowledge
Engineering Review, 10:115‚Äì152, 1995.
[464] G.H. von Wright. An Essay in Modal Logic. North-Holland Publishing Company,
1951.
[465] G.H. von Wright. A modal logic of place. In E. Sosa, editor, The Philosophy of
Nicholas Rescher, pages 65‚Äì73. Publications of the Group in Logic and Methodol-
ogy of Science of Real Finland, vol. 3, 1979.
[466] M. Xu. On some U,S-tense logics. Journal of Philosophical Logic, 17:181‚Äì202,
1988.
[467] M. Zakharyaschev. Canonical formulas for modal and superintuitionistic logics: a
short outline. In de Rijke [383], pages 195‚Äì248.
[468] M. Zakharyaschev and A. Alekseev. All Ô¨Ånitely axiomatizable normal extensions
of K4.3 are decidable. Mathematical Logic Quaterly, 41:15‚Äì23, 1995.
[469] M. Zakharyaschev, K. Segerberg, M. de Rijke, and H. Wansing, editors. Advances
in Modal Logic, Volume 2. CSLI Publications, 2000.
[470] M.V. Zakharyaschev. On intermediate logics. Soviet Mathematics Doklady, 27:274‚Äì
277, 1983.
[471] M.V. Zakharyaschev. Normal modal logics containing S4. Soviet Mathematics
Doklady, 28:252‚Äì255, 1984.
[472] M.V. Zakharyaschev. Syntax and semantics of modal logics containing S4. Algebra
and Logic, 27:408‚Äì428, 1988.
[473] M.V. Zakharyaschev. Canonical formulas for K4. Part I: basic results. Journal of
Symbolic Logic, 57:1377‚Äì1402, 1992.
[474] J. Zeman. Modal Logic: The Lewis Modal Systems. Oxford University Press, 1973.List of Notation
Modalities
3, 2, DeÔ¨Ånition 1.9
K, Example 1.10
, DeÔ¨Ånition 1.11
3a , a, DeÔ¨Ånition 1.11
, DeÔ¨Ånition 1.13
2a , [a], DeÔ¨Ånition 1.13
F , P , G, H, Example 1.14
œÄ, [œÄ], Example 1.15
‚ó¶, ‚äó, 1‚Äô, Example 1.16
30 , 31 , 32 , . . . , Example 1.22
E, A, Example 2.4, page 415
[‚àó], page 371
D, D, page 419
[| ¬∑ |], page 424
S, U , page 427
S  , U  , DeÔ¨Ånition 429
@i , page 436
‚Üì, page 444
Id ij , Equation 7.11
œÉ , page 461
ŒπŒ¥ij , DeÔ¨Ånition 7.41
ij , En
i , Dn , page 467
Other syntax
p, q, r, . . . , DeÔ¨Ånition 1.9
œÑ , DeÔ¨Ånition 1.11
œÅ, DeÔ¨Ånition 1.11 and B.1
œÄ1 ‚à™ œÄ2 , œÄ1 ; œÄ2 , œÄ ‚àó , œÄ1 ‚à© œÄ2 , Example 1.15
œÜ?, Example 1.15
(‚àÄyx), (‚àÉyx), page 170
‚àÄr , ‚àÉr , page 170
‚àºœÜ, DeÔ¨Ånition 4.79
Bool , DeÔ¨Ånition 5.1
Ter œÑ (Œ¶), DeÔ¨Ånition 5.18
i, j, k, page 435
Formulas and axioms
K, Dual, DeÔ¨Ånition 1.39
4, Example 3.6, page 207
T, 5, Example 3.6
M, Example 3.11
œÜF,w , page 143
REL, AT, POS, page 157
BOX-AT, page 162
B, D, .3, L, page 192
Ki , Dual , DeÔ¨Ånition 4.13
Dr , Dl , den, page 207
.3r , .3l , page 208
.rr , Dr , Ll , page 212
name(œÜ), page 230
œÜB (m), Table 6.5
fL (Œ≤), Table 6.6
(A1a)‚Äì(A7a), (A1b)‚Äì(A7b), DeÔ¨Ånition 7.13
D, L, W, N, DeÔ¨Ånition 7.13
G(x, y), page 446
(CM1 i )‚Äì(CM8 i ), DeÔ¨Ånition 7.48
Maps and operations on formulas
œÜœÉ , DeÔ¨Ånition 1.18
deg, DeÔ¨Ånition 2.28
ST x , DeÔ¨Ånition 2.45
cœÜ (x), Theorem 3.54
œÜ‚âà , DeÔ¨Ånition 5.26
Free(œÜ), DeÔ¨Ånition 7.31
(¬∑)t , DeÔ¨Ånition 7.42
(¬∑)‚Ä¢ , page 466
Languages
œÑ , DeÔ¨Ånition 1.11
œÑ‚Üí , Example 1.16
ML(œÑ, Œ¶), DeÔ¨Ånition 1.12
PDL , Example 1.15
L1œÑ (Œ¶), DeÔ¨Ånition 2.44
L2œÑ (Œ¶), L2œÑ , page 126
SnS, DeÔ¨Ånition 6.17
KR , page 367
KRA , page 368
KRA [‚àó], page 371
ML(3), page 415
ML(E), ML(3, E), page 415
ML(D), ML(3, D), page 419
MLR n , DeÔ¨Ånition 7.41
L1 , page 486
LX , DeÔ¨Ånition A.9
Lœâ1 œâ , page 496
Sets of formulas
Form(œÑ, Œ¶), DeÔ¨Ånition 1.12
544List of Notation
ŒõF , DeÔ¨Ånition 1.28
FL(Œ£), ¬¨FL(Œ£), DeÔ¨Ånition 4.79
ClŒì , Cl(œÜ), DeÔ¨Ånition 6.23
Dem(H, 3œà), DeÔ¨Ånition 6.43
PF , GF , PF n , GF n , DeÔ¨Ånition 7.31
Ln , rn , DeÔ¨Ånition 7.40
CMLn , DeÔ¨Ånition 7.41
Logics
ŒõF , DeÔ¨Ånition 1.28
K, DeÔ¨Ånition 1.42
ŒõS , ŒõS , Example 4.2
PC, page 190
K4, T, B, KD, S4, S5, K4.3, S4.3, KL, Table 4.1
KœÑ , KœÑ Œì, DeÔ¨Ånition 4.14
Kt , DeÔ¨Ånition 4.33
Kt Q, DeÔ¨Ånition 4.40
ŒõFt , DeÔ¨Ånition 4.32
KvB, Exercise 4.4.2
Kt Tho, Kt ThoM, page 212
Kt Q+ , DeÔ¨Ånition 4.66
PDL, DeÔ¨Ånition 4.78
Kn Alt1 , page 341
Kt N, page 360
Kg , page 417
Ktd Œ£, page 420
ŒõdF , Theorem 7.8
B, BW, BN, page 431
Kh + RULES, page 437 and 441
Kg , DeÔ¨Ånition 7.23
Maps
mR , DeÔ¨Ånition 1.30, 2.55
lR , DeÔ¨Ånition 2.55
d, page 494
Operations on maps
Œ∏ÃÉ, DeÔ¨Ånition B.12, 5.23
Œ∏ + , Œ∑+ , DeÔ¨Ånition 5.50
Relations
C, R, I, Example 1.8
R1 , page 424
Ra , Rb , . . . Example 1.24(i)
R , DeÔ¨Ånition 1.23
RœÄ , DeÔ¨Ånition 1.26
‚Üî, DeÔ¨Ånition 2.16
‚Üîn , DeÔ¨Ånition 2.30
RŒõ , DeÔ¨Ånition 4.18
Œõ
RŒõ
P , RF , DeÔ¨Ånition 4.34
‚â°C , page 269
‚â°Œõ , DeÔ¨Ånition 5.29
Qf , DeÔ¨Ånition 5.40
, page 323
‚àºU , page 492
ker f , DeÔ¨Ånition B.3
sub, DeÔ¨Ånition 4.92
R‚àíŒ± , page 424
‚â°i , Equation 7.10
1œÉ , Equation 7.13
Relations between structures
w  w  , M  M , DeÔ¨Ånition 2.1
545
M  M, DeÔ¨Ånition 2.5
M‚àº
= M , DeÔ¨Ånition 2.8, A.5
M  M , DeÔ¨Ånition 2.10
Z : M, w ‚Üî M , w  and Z : M ‚Üî M ,
DeÔ¨Ånition 2.16
M, w ‚Üî M , w  and w ‚Üî w  , DeÔ¨Ånition 2.16
M ‚Üî M , DeÔ¨Ånition 2.16
w Œ£ w  , DeÔ¨Ånition 2.36
F  F, F  F , DeÔ¨Ånition 3.13
f : A  B and A  B, DeÔ¨Ånition A.8
A ‚â° B, page 487
Operations on relations
R+ , R‚àó , Example 1.6
RÀá, Example 1.25
R0 , R1 , R2 , . . . , Example 1.22(iii)
Rf , DeÔ¨Ånition 2.36
Rs , Rl , page 79
Rt , DeÔ¨Ånition 2.42
Rue , DeÔ¨Ånition 2.57
P ?, Example 2.80(ii)
‚àºR, Example 2.80(iii)
RŒ≤ , R , Convention 3.46
Truth, validity and consequence
M, w  œÜ, DeÔ¨Ånition 1.20
M, w  Œ£, DeÔ¨Ånition 1.20
w  œÜ, page 18
M  œÜ, DeÔ¨Ånition 1.21
F, w  œÜ, DeÔ¨Ånition 1.28
F  œÜ, DeÔ¨Ånition 1.28
F  œÜ, DeÔ¨Ånition 1.28
Œ£ S œÜ, DeÔ¨Ånition 1.35
Œ£ gS œÜ, DeÔ¨Ånition 1.37
(F, V ), s  œÅ, Convention 5.88
tA [g], page 486
tA [a1 , . . . , an ], page 486
A |= Œ±[a1 , . . . , an ], page 486
A |= Œ±[a1 , . . . , an , x ‚Üí a], page 487
Œ† |= Œ≥, page 487
A |= s ‚âà t, A |= E, DeÔ¨Ånition B.17
Structures
(N, <), (Z, <), (Q, <), (R, <), (œâ, <),
Example 1.2
SU , Example 1.8
MŒõ , FŒõ , DeÔ¨Ånition 4.18 and 4.34
2, DeÔ¨Ånition 5.2
Form(Œ¶), DeÔ¨Ånition 5.3
P(A), DeÔ¨Ånition 5.7
LC (Œ¶), DeÔ¨Ånition 5.13
LŒõ (Œ¶), DeÔ¨Ånition 5.31
fcŒõ , Example 5.61
Nn , DeÔ¨Ånition 6.17
Cn (U ), CW
n (U ), DeÔ¨Ånition 7.45
AX , DeÔ¨Ånition A.9
TerF (X), DeÔ¨Ånition B.13
Form(œÑ, Œ¶), DeÔ¨Ånition 5.28
Operations on structures
i Mi , DeÔ¨Ånition 2.2
M k, DeÔ¨Ånition 2.32
MfŒ£ , Mf , DeÔ¨Ånition 2.36546
ueM, ueF, DeÔ¨Ånition 2.57
i Fi , DeÔ¨Ånition 3.13
FX , Fw , DeÔ¨Ånition 3.13
 = (W
 , R,
 V
 ), DeÔ¨Ånition 4.51
M
F+ , DeÔ¨Ånition 5.21
A+ , DeÔ¨Ånition 5.40
EmA+ , DeÔ¨Ånition 5.40
Uf
 284
 A, page
A , U A, DeÔ¨Ånition A.18
U i
J
j‚ààJ Aj , A , DeÔ¨Ånition B.6
A/‚àº, DeÔ¨Ånition B.9
Classes of structures
FrœÜ , FrŒì , DeÔ¨Ånition 3.1
Set, DeÔ¨Ånition 5.7
BA, DeÔ¨Ånition 5.10
Fn
1 , page 341
Cn , Rn , DeÔ¨Ånition 7.45
HCFn , page 468
Operations on classes
K, page 107
Cm, DeÔ¨Ånition 5.21
V, DeÔ¨Ånition 5.55
H, DeÔ¨Ånition B.3
I, DeÔ¨Ånition B.4
S, DeÔ¨Ånition B.5
P, DeÔ¨Ånition B.6
V, DeÔ¨Ånition B.7
Special sets
Œ¶, DeÔ¨Ånition 1.9
Vm , Example 3.7
At(Œ£), DeÔ¨Ånition 4.80
W Œõ , DeÔ¨Ånition 4.18
Tn , DeÔ¨Ånition 6.17
Ter F (X), DeÔ¨Ånition B.11
Operations on sets
P(W ), DeÔ¨Ånition 1.19
W \ X, DeÔ¨Ånition 1.32
Uf (W ), DeÔ¨Ånition 2.57
P ?, Example 2.80(ii)
 page 242
A,
R[c],
Proposition 5.83

A , page 492
 i‚ààI i
A
U i,
U A, DeÔ¨Ånition A.17
Hin(Œ£), DeÔ¨Ånition 6.53
Miscellaneous
K œÜ, DeÔ¨Ånition 1.39
|w|Œ£ , |w|, DeÔ¨Ånition 2.36
Œõ œÜ, DeÔ¨Ånition 4.1
[œÜ], DeÔ¨Ånition 5.13
f , DeÔ¨Ånition 5.19
 Example 5.61
œÜ,
 Œ±, page 488
Œ†  Œ≥, page 488
œÄw , DeÔ¨Ånition A.15
fU , DeÔ¨Ånition A.17
fa , fw , page 494
[a], DeÔ¨Ånition B.9
List of Notation
‚âà, DeÔ¨Ånition B.11
Œ†10 , Œ£11 , page 508
Œ£ ‚àó , DeÔ¨Ånition C.4
O, page 515Index
abstract modal logic, 473
additivity, 275
admissible
set, 29
valuation, 29
algebra, 497
as logic, 262
of truth values, 265
algebraic interpretation of modal logic, 278
algebraic perspective, 39, 45
algebraizing
modal axiomatics, 279
modal semantics, 277
propositional axiomatics, 268
propositional semantics, 263
algorithm
witness, 386
antisymmetry, 3, 217
arrow
frame
square, 8
logic, 7, 16, 26, 30, 60
and the three variable fragment, 91
bisimilarity and squares, 72
bounded morphism, 62
Ô¨Ånite model property, 83
frame for, 8
generated submodel, 57
language of, 14
model for, 23
relativized square, 229
square arrow frame, 8
standard translation, 90
ultraÔ¨Ålter extension, 99
structure, 7
atom, 241, 358
axiom, 33, 192
induction, 132
Segerberg‚Äôs, 132
axiomatic system, see Hilbert system, normal modal
logic
axiomatizable, 342
axiomatization, 195
back condition, 65
basic
hybrid language, 435
modal language, 9
decidability, 340
frame for, 16
model for, 16
temporal language
bisimulation, 70, 72
bounded morphism, 62
completeness-via-canonicity, 204‚Äì209
deÔ¨Ånability of bidirectionality, 26, 137
deÔ¨Ånition of, 11
dense frame, 129
expressiveness, 63
frame for, 21
generated submodel, 57
model for, 21
over (Q, <), 224‚Äì237
standard translation, 89
strong completeness of Kt Q+ , 239
transitive temporal Ô¨Åltration, 83
ultraÔ¨Ålter extension, 99
undeÔ¨Ånability of progressive, 72
basic hybrid language, 435
basic temporal language, 137
bidirectional model and frame, 21
binary tree, 382‚Äì384
Birkhoff‚Äôs Theorem, 502
bisimilar, 65
bisimilarity-somewhere-else, 98, 102
bisimulation, 64‚Äì73
locality and computation, 67
n-, 74
safe for, 112
boolean
algebra, 269
and classical theoremhood, 269
algebra with operators ( BAO ), 275
homomorphism, 296
modal logic, 424‚Äì425
bounded
morphic image, 59
morphism
duals of, 313
547Index
548
for frames, 138
for general frames, 309
for models, 57‚Äì73
box
2, 9
2a , 11
[a], 11
boxed atom, 161
BR, 425
Bull‚Äôs Theorem, 43, 247‚Äì252
bulldozing, 220‚Äì222
canonical
class of algebras, 292
embedding algebra, 288
equation, 292
formula, 203
logic, 203
model, 42
arbitrary similarity type, 200
basic modal language, 197
basic temporal language, 205
over a Ô¨Ånite set of formulas, 243
relation, 198
valuation, 198
Canonical Model Theorem, 199
canonicity
and d-persistence, 319
and Ô¨Årst-order deÔ¨Ånability, 215
failure of, 211
for a property, 204
Cantor‚Äôs Theorem, 225, 229
carrier
of an algebra, 497
Chagrova‚Äôs Theorem, 167
characterization
of frame classes, 125
Church‚Äôs Thesis, 507
Church-Rosser property, 160
classical era, (1959‚Äì1972), 41
closed
formula, 151
subset of general frame, 315
closure
Fischer-Ladner, 241
transitive, 5
under single negations, 241
under subformulas, 77, 241
universal, 445
cluster, 81
and completeness proofs, 220
co-Ô¨Ånite set, 30
coÔ¨Ånality, 213
compact
logic, 212
compactness
over models, 86
Compactness Theorem, 488
complete logic, 212
completely additive formula, 113
completeness
strong, 194
of Kt Q, 228
of Kt Q+ , 236
of Kt , 206
of Kt 4.3, 220, 221
of Kt Q, 209
of K4.3, 210
of K4, 202
of KB, 202
of KD, 202
of K, 199, 219
of S4.3, 210
of S4, 203, 219
of S5, 203
of T, 202
via completeness, 432
weak, 194
via Stone‚Äôs Theorem, 273
completeness-via-canonicity, 202
complex algebra, 277
composition relation, 7
computable, 505
conÔ¨Çuence, see Church-Rosser property
congruence, 499
natural map associated with, 500
connected, 3, 247
coNP, 512
consistency, 191, 194
problem, 334
converse
axioms
canonicity of, 206
of a relation, 22
Cook-Levine Theorem, 512
coPSPACE, 514
correspondence
for models, 85
global, for frames, 126
language, 84
local, for frames, 149
theory, 86
corresponding algebraic similarity type, 275
Craig‚Äôs Lemma, 342
cube
over U , 465
relativized, 465
current state, 18
cylindric modal logic, 462
d-persistence, 318
daughter-of, 6
dead-end, 19
decidability, 338, 505
via Ô¨Ånite models, 338‚Äì346
via interpretations, 347‚Äì356
via quasi-models and mosaics, 356‚Äì364
decidable, 338, 505
Dedekind complete, 429
deducibility, 190
deÔ¨Ånability
of a property, 125
of frame classes, 125
of model classes, 88
of models, 107‚Äì109
deÔ¨Ånable variant, 146Index
deÔ¨Ånably well-ordered, 431
degree, 74
density, 207
canonicity of, 207
deÔ¨Ånability of, 129
descriptive
frames and BAO s, 311
general frame, 306
Detour Lemma, 102
di-persistence, 318
diamond
3, 9
3a , 11
a, 11
saturated, 231
difference operator, 63, 238, 419‚Äì424
discriminator variety, 419
disjoint union
of frames, 138
of general frames, 310
of models, 52‚Äì55
distinguishing model, 146
distribution axiom, see K axiom
domain, 2
downward monotone, 152
Dual axiom, 33, 191, 195
dual operator, 9
duality theory
applications, 299‚Äì303
basic ideas, 294‚Äì299
DUWTO -frame, 207
elementarily equivalent, 487
elementary
class of models, 494
extension, 490
submodel, 490
elimination of Hintikka sets, 402‚Äì405
embedding, 58
endomorphism, 501
epistemic logic, 10, 19
equation, 500
equational
class, 502
logic, 502
equivalence
elementary, 487
expressive, 90
Ô¨Årst-order, 487
modal, 52
euclidean, 128
Existence Lemma
basic modal language, 198
for arbitrary programs in PDL, 245
for basic programs in PDL, 243
exponentially deep models, 393‚Äì395
expressive
power, 43, 45, 73, 97
expressive completeness, 430
EXPTIME, 514
and modal logic, 393‚Äì406
global modality, 422
guarded fragment, 453
hardness via tiling, 395‚Äì402
extension
elementary, 490
ultraÔ¨Ålter, 138
extensions of S4.3
Bull‚Äôs Theorem, 247‚Äì252
Ô¨Ånite axiomatizability, 252‚Äì255
Hemaspaandra‚Äôs Theorem, 380
negative characterization, 255‚Äì256
f.f.p., 335
f.m.p., 73, 336
false in a model, 18
falsiÔ¨Åable, 18
Ô¨Ålter
of a boolean algebra, 284
over a set, 491
Ô¨Åltration, 77‚Äì82
largest, 79
natural map, 78
smallest, 79
transitive, 80
transitive temporal, 83
Filtration Theorem, 79
Ô¨Ånite
character, 335
frame property, 145‚Äì148
general case, 335
intersection property, 492
meet property, 285
model property
for normal modal logics, 145
for similarity types, 73
general case, 336
strong, 339
models
via Ô¨Åltrations, 77‚Äì82
via selections, 74‚Äì77
transitive frame, 143‚Äì144
-variable fragment, 87
Ô¨Ånitely
axiomatizable, 252, 342
based, 335
Ô¨Årst-order logic
assignment, 486
basic properties, 487‚Äì489
compactness, 488
completeness, 488
formula, 485
L√∂wenheim-Skolem Theorem, 488
modal fragment, 100
model, 486
model theory, 489‚Äì495
satisfaction deÔ¨Ånition, 486
sentence, 486
term, 485
ultraproducts, 492
validity and semantic consequence, 487
Fischer-Ladner closure, 241
Ô¨Çat set of lists, 255
formula
algebra
modal logic, 280
549550
propositional logic, 265
as term, 264
completely additive, 113
Ô¨Årst-order, 485
Grzegorczyk, 256
Jankov-Fine, 143
Kracht, 170
L√∂b, 10, 130
McKinsey, 12, 30, 133
modal, 9, 11
monotone, 152
Sahlqvist
general case, 164
very simple, 156
Sahqlvist
simple, 160
uniform, 151
universal second-order, 495
forth condition, 64
fragment
guarded, 446
packed, 446
universal, 458
frame
arbitrary similarity type, 20
arrow logic, 8
basic modal language, 16
basic temporal language, 21
connected, 247
deÔ¨Ånability, 125
relative, 125
DUWTO , 207
general, see general frame
incompleteness, see incompleteness
language
Ô¨Årst-order, 126
second-order, 126
of type œÑ , 20
propositional dynamic logic, 22
square, 229
underlying a model, 17
general frame, 28‚Äì31
algebraic perspective, 303‚Äì318
and second-order logic, 136
compact, 306
descriptive, 306
differentiated, 306
discrete, 306
full, 306
general completeness result, 306
reÔ¨Åned, 306
tight, 306
topological aspects, 314‚Äì317
general ultraÔ¨Ålter frame, 310
generalization, 33, 191
generated
point-, 56
subframe, 138
submodel, 55‚Äì57
global
modality, 54, 367‚Äì371, 415‚Äì419
truth, 18
Index
Goldblatt-Thomason Theorem, 142, 178‚Äì181
algebraic proof, 300‚Äì301
Grzegorczyk formula, 137, 256
guarantee properties, 427
guarded
fragment, 446‚Äì458
quantiÔ¨Åcation, 448
height, 75
Hemaspaandra‚Äôs Theorem, 380
Hennessy-Milner
class, 92
property, 92
Theorem, 69
highly undecidable, 508
Hilbert systems and normal modal logic, 33‚Äì37
Hintikka set, 357
homomorphism, 57
modal, 296
of algebras, 498
hybrid logic, 434‚Äì444
hypercylindric frame, 468
identity arrow, 7
image-Ô¨Ånite, 69
incompleteness, 44, 212
Ô¨Årst-order example, 216
of Kt ThoM, 214
of KvB, 216
ramiÔ¨Åcations of, 214‚Äì216
inconsistent
formula, 191
logic, 190
induction axiom, see Segerberg‚Äôs axiom
inÔ¨Ånitary logic, 496
instant, 2
internal, 18
interpretation
in SnS, 347‚Äì355
invariance, 52
irreÔ¨Çexivity, 2, 217, 229
isomorphism
of algebras, 498
of Ô¨Årst-order models, 489
of modal models, 58
J√≥nsson-Tarski Theorem, 40
and canonicity, 291‚Äì293
statement and proof, 289‚Äì291
Jankov-Fine formula, 143
K axiom, 33, 191, 195
Kracht formula, 170
Kracht‚Äôs Theorem, 171, 210
Kripke semantics, 42
Kruskal‚Äôs Theorem, 253
L√∂b formula, 10, 130
L√∂wenheim-Skolem Theorem, 488
for modal models, 86
labeled transition system, 3
lambda notation, 155
languageIndex
basic modal, 9
modal, 11
left-unboundedness, 207
Lindenbaum‚Äôs Lemma, 197
Lindenbaum-Tarski algebra
modal logic, 281
propositional logic, 271
Lindstr√∂m Theorem for modal logic, 470‚Äì476
linear order, 2
local, 18
frame correspondence, 149
logic
compact, 212
complete, 212
epistemic, 10, 19
equational, 502
inÔ¨Ånitary, 496
modal, 189
normal modal, 191, 195
normal temporal, 205
of a class of frames, 24
provability, 10
second-order, 495
since/until, 426, 434
loose
model, 454‚Äì458
loosely guarded fragment, 458
≈Åo≈õ‚Äôs Theorem, 493
m-saturation, 91‚Äì93
master modality, 371‚Äì373
maximal consistent set, 196
McKinsey formula, 12, 30, 133
MCS , see maximal consistent set
modal
consequence relation, 31‚Äì32
constant, see nullary modality
homomorphism, 296
language of relations, 462
logic, 189
boolean, 424‚Äì425
multi-dimensional, 458
operator
arity, 11
modal logic
abstract, 473
modality
global, 406
master, 371‚Äì373
nullary, 11, 195, 201
substitution, 461
universal, 478
modally equivalent, 52
model
arrow logic, 23
based on a frame, 17
basic modal language, 16
basic temporal language, 21
canonical, 197
Ô¨Ånitely based, 335
Ô¨Årst-order logic, 486
loose, 454‚Äì458
named, 238
551
on a general frame, 29
pointed, 107
propositional dynamic logic, 22
saturated, 100
modern era, (1972‚Äìpresent), 44
modus ponens, 33, 189
monadic
second-order logic, 495
second-order theory of n successor functions, 348
monotone
downward, 152
formula, 152
upward, 152
monotonicity
in boolean algebras, 276
of formulas, 152
morphism, see bounded morphism
mosaics
for packed and guarded fragments, 450‚Äì453
for tense logic of naturals, 360‚Äì363
multi-dimensional modal logic, 458‚Äì470
n-bisimulation, 74
nabla, , 11
named model, 238
natural valuation
on canonical model, 198
necessarily, 10, 19, 127
necessitation, see generalization
negation
single, 241, 356
negative occurrence, 151
network, 224, 232, 454
NEXPTIME, 515
node, 2
nominal, 238, 435
non-branching, 209
to the right, 193
normal modal logic, 33‚Äì37
alternative deÔ¨Ånition, 191
and Ô¨Ånite frames, 145
arbitrary similarity type, 195
basic modal language, 191
basic temporal language, 205
generated by a set of formulas, 192
incomplete, 212
minimal, 192
propositional dynamic logic, 240
normality
algebraic deÔ¨Ånition, 275
NP, 511
and modal logic, 373‚Äì381
NPSPACE, 514
nullary modality, 11, 195, 201
operation, 497
operator
algebraic deÔ¨Ånition, 275
difference, 238
dual, 9
since, 43
until, 43, 72
oracle, 508552
P, 511
packed
fragment, 446‚Äì458
universal, 458
quantiÔ¨Åcation, 448
partial order, 3, 217
PDL, see propositional dynamic logic
permissible, 16
persistence, 318
point, 2
point-generated
frame, 139
model, 56
pointed model, 107, 471
polynomial
space, 513
time, 509
reduction, 510
polysize model property, 339
positive
existential formula, 111
occurrence, 151
possible world, 19
possibly, 10, 19, 127
preservation, 51
problem, 505
as strings of symbols, 506
completeness of, 511
consistency, 334
decidable, 505
EXPTIME, 514
hardness of, 511
non-elementary, 373
NP, 511
P, 511
provability, 334
PSPACE, 513
satisÔ¨Åability, 333
tiling, 366
undecidable, 507
validity, 333
product
of algebras, 498
progressive operator, 72
proof
in K, 33, 35
propositional dynamic logic, 16, 26
and inÔ¨Ånitary logic, 89
as three variable fragment, 89
axiomatization, 240
bisimulation, 71
bounded morphism, 62
compactness failure, 240
decidability of, 343
deÔ¨Ånability of regular frames, 132
EXPTIME algorithm for, 403
EXPTIME hardness of, 397
frame for, 22
generated submodel, 57
language, 12
model for, 22
regular, 13
standard translation, 89‚Äì90
Index
test, 13
with intersection, 13, 367‚Äì373
provability
logic, 10
problem, 334
provable
in K, 33
provable equivalence as a congruence
modal logic, 281
propositional logic, 270
PSPACE, 513
algorithm for K, 384‚Äì389
and modal logic, 381‚Äì393
hybrid logic, 436
Ladner‚Äôs Theorem, 389‚Äì392
QBF, 389, 513
truth problem, 513
validity problem, 389
quantiÔ¨Åcation
guarded, 448
packed, 448
quantiÔ¨Åed boolean formula, 389
quantiÔ¨Åers as modalities, 459‚Äì460
quotient algebra, 500
r-persistence, 318
Rabin‚Äôs Theorem, 350
recursive, 505
recursively
axiomatizable, 342
enumerable, 506
reduction, 508
reÔ¨Çexive
and transitive tree, 7
closure, 3, 8
linear order, 3
total order, 3
transitive closure, 5
reÔ¨Çexivity, 3, 127
refutable, see falsiÔ¨Åable
refuted in a model, see false in a model
regular frames and models, 22
relational
semantics, 41
structure, 2
relativized
cube over U , 465
square, 229
reverse relation, 8
right-unboundedness, 193, 207
root
of tree, 6
rooted, see point-generated
rules
as sequents, 443
for the undeÔ¨Ånable
IRR , 229‚Äì238
S4.3
decidability of extensions, 345
NP-completeness of extensions, 380
safety, 112Index
Sahlqvist
Completeness Theorem, 210
Correspondence Theorem, 165
formula
general case, 164
simple, 160
very simple, 156
Sahlqvist Completeness Theorem
statement and proof, 322‚Äì325
Sahlqvist-van Benthem algorithm, 156‚Äì166
satisfaction operator, 238
satisÔ¨Åability
problem, 333
satisÔ¨Åable, 18
Ô¨Ånitely, 92
satisÔ¨Åed in a model
arbitrary similarity type, 20
basic modal language, 17
nullary modality, 20
saturated model, 100, 101
saturation
diamond, 231
m-, 91‚Äì93
Savitch‚Äôs Theorem, 514
second-order
logic, 495
translation, 135
Segerberg‚Äôs axiom, 13, 132
semantic consequence
global, 32
local, 31
set algebra, 267
similarity type
algebraic, 497
modal, 11
simulation, 110
since operator, 43
since/until logic, 426‚Äì434
situation, 2
SnS, 348
soundness, 193
square
frame, 229
over U , 8
relativized, 229
standard translation, 83‚Äì91
and second-order frame language, 135
until, 429
state, 2
Stavi connectives, 429
step-by-step method, 223‚Äì228
Stone Representation Theorem
full statement and proof, 286
short statement, 273
strict
partial order, 2
total order, 220
strong
completeness, 194
of Kt Q, 228
of Kt Q+ , 236
of Kt , 206
of Kt 4.3, 220, 221
553
of Kt Q, 209
of K4.3, 210
of K4, 202
of KB, 202
of KD, 202
of K, 199, 219
of S4.3, 210
of S4, 203, 219
of S5, 203
of T, 202
Ô¨Ånite model property, 339
homomorphism, 58
subalgebra, 498
subformula closed, 77
submodel, 56
elementary, 490
substitution, 15
modality, 461
successor, 18
syntactic era, (1918‚Äì1959), 38
syntactically driven, 43
temporal, see basic temporal
tense logic, 40, 205
term, 485, 500
algebra, 501
as formula, 435
theorem, 189
tile, 365
tiling
game, 395
problem
N √ó N, 366
N √ó N recurrent, 366
times, 2
total order, 2
tractable, 509
transitive
closure, 5
tree, 7, 9
transitivity, 2
translation
second-order, 135
standard, see standard translation
tree, 6, 347, 348
-like, 6
binary, 382‚Äì384
model, 62
model property, 62
reÔ¨Çexive and transitive, 7
transitive, 7, 9
triangle, , 11
trichotomy, 2, 207
true in a model, see satisÔ¨Åed in a model
truth and validity in algebras, 502
Truth Lemma, 199
Turing machine, 504
exponentially time bounded, 514
non-deterministic, 507
non-deterministic polynomially time bounded, 511
polynomially space bounded, 513
polynomially time bounded, 509
with oracles, 508554
ultraÔ¨Ålter
countably incomplete, 106
extension
of a frame, 138
of a model, 93‚Äì100
temporal language, 99
frame, 287
general, 310
of a boolean algebra, 284
over a set, 491
principal, 492
UltraÔ¨Ålter Theorem, 285, 492
ultrapower, 493
ultraproduct, 492‚Äì493
of modal models, 104‚Äì107
unbounded, 207
undecidability
via tiling, 364‚Äì373
undecidable, 338, 507
unfolding, see unraveling
uniform
formula, 151‚Äì155
substitution, 33, 189
universal
modality, 478
second-order formula, 495
universally true, see global truth
universe, 2
unraveling, 63
in completeness proofs, 218‚Äì220
until operator, 43, 72, 427
unwinding, see unraveling
upward monotone, 152
Index
valid, 24
at a state in a frame, 24
in a frame, 24
in a general frame, 29
on a class of frames, 24
validity
deÔ¨Ånition of, 24, 124
problem, 333
valuation, 17
van Benthem Characterization Theorem, 100‚Äì104
variant
deÔ¨Ånable, 146
variety, 499
weak
completeness, 194
of propositional dynamic logic, 239‚Äì246
of KL, 212
via Stone‚Äôs Theorem, 273
linearity, 207
total order, 207
well-founded, 8
well-order
deÔ¨Ånably, 431
well-ordered, 429
window, 424
witness
algorithm, 386
set, 385
world, 2
